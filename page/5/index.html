<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"zuofw.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="个人网站，学习记录，面试记录和经验总结、互联网中一块属于自己的小窝">
<meta property="og:type" content="website">
<meta property="og:title" content="QingQiu&#39;Blog">
<meta property="og:url" content="https://zuofw.github.io/page/5/index.html">
<meta property="og:site_name" content="QingQiu&#39;Blog">
<meta property="og:description" content="个人网站，学习记录，面试记录和经验总结、互联网中一块属于自己的小窝">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="QingQiu">
<meta property="article:tag" content="博客，学习，成长">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://zuofw.github.io/page/5/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>QingQiu'Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>


<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">QingQiu'Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">清秋的博客</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-fa fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-fa fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-fa fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-fa fa-archive"></i>归档</a>

  </li>
        <li class="menu-item menu-item-github">

    <a href="https://github.com/Zuofw" rel="noopener" target="_blank"><i class="fa fa-fw fa-fab fa-github"></i>Github</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zuofw.github.io/2024/02/27/04/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="QingQiu">
      <meta itemprop="description" content="个人网站，学习记录，面试记录和经验总结、互联网中一块属于自己的小窝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="QingQiu'Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/02/27/04/" class="post-title-link" itemprop="url">python and web or ai</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-02-27 19:23:04" itemprop="dateCreated datePublished" datetime="2024-02-27T19:23:04+08:00">2024-02-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-03-01 20:12:49" itemprop="dateModified" datetime="2024-03-01T20:12:49+08:00">2024-03-01</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>815</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><h2 id="web"><a href="#web" class="headerlink" title="web"></a>web</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python">pip install beautifulsoup4 <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="Scrapy框架"><a href="#Scrapy框架" class="headerlink" title="Scrapy框架"></a>Scrapy框架</h2><p>项目结构:</p>
<pre class="line-numbers language-css" data-language="css"><code class="language-css">scrapy.cfg 配置文件
setting.py 定义爬虫的相关配置信息
items.py 定义待爬页面数据的结构
pipelines.py 定义存储爬到的数据的方式
middlewares.py 定义随机切换ip等逻辑
Spiders 在目录里，存放爬虫代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">scrapy startproject projectName 新建一个项目
1.在items模块中定义待爬取内容的数据结构
2.在spiders文件中
scrapy genspider name xxx.com 新建一个爬虫文件
3.pipelines中定义存储方式
4.settings中加入
ITEM_PIPELINES =</span> <span class="token punctuation">{</span>

    <span class="token string">"cnblogPrj.pipelines.CnblogprjPipeline"</span><span class="token punctuation">:</span> 300<span class="token punctuation">,</span>

<span class="token punctuation">}</span>

# 禁用cookies

COOKIES_ENABLED = False<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-none"><code class="language-none">x = float(input() )

y = float(input())

print("{:.3f} + {:.3f} = {:.3f}".format(x, y, x + y))

print("{:.3f} - {:.3f} = {:.3f}" .format (x, y, x - y))

print("{:.3f} * {:.3f} = {:.3f}" .format (x, y, x * y))

print("{:.3f} / {:.3f} = {:.3f}" .format (x, y, x / &nbsp;y))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zuofw.github.io/2023/10/23/46/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="QingQiu">
      <meta itemprop="description" content="个人网站，学习记录，面试记录和经验总结、互联网中一块属于自己的小窝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="QingQiu'Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/10/23/46/" class="post-title-link" itemprop="url">计网</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-10-23 20:01:46" itemprop="dateCreated datePublished" datetime="2023-10-23T20:01:46+08:00">2023-10-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-10-15 22:28:33" itemprop="dateModified" datetime="2024-10-15T22:28:33+08:00">2024-10-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">计算机基础</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>16k</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="计网"><a href="#计网" class="headerlink" title="计网"></a>计网</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>MTU:网络中一次可以传输的最大数据包的大小<br>MSS:TCP中除去TCP和IP的头部，能够传输的最大的数据量<br>SDU，Service Data Unit，服务数据单元。<br>ISP 是 Internet Service Provider 的缩写，翻译为互联网服务提供商。<br>协议<br>Telnet 客户端登录协议，属于应用层<br>TLD 是 Top-Level Domain 的缩写，翻译为顶级域名<br>GBN (Go-Back-N)  退回<br>SR 选择性重传<br>mask 子网掩码<br>SDN 是指软件定义网络（Software-Defined Networking）<br>OSPF（Open Shortest Path First）是一种开放式的链路状态路由协议，用于计算机网络中的动态路由。<br>Secure sockets layer (SSL)</p>
<p><strong>MSL:报文最大生存时间<br>TTL:经过的路由跳数</strong></p>
<p>序列号：在建立连接时由内核生成的随机数作为其初始值，通过 SYN 报文传给接收端主机，每发送一次数据，就「累加」一次该「数据字节数」的大小。用来解决网络包乱序问题。<br>确认号：指下一次「期望」收到的数据的序列号，发送端收到接收方发来的 ACK 确认报文以后，就可以认为在这个序号以前的数据都已经被正常接收。用来解决丢包的问题。<br><strong>控制位：</strong> 用来标识 TCP 报文是什么类型的报文，比如是 SYN 报文、数据报文、ACK 报文，FIN 报文等。</p>
<h1 id="面试常问"><a href="#面试常问" class="headerlink" title="面试常问"></a>面试常问</h1><ul>
<li>UDP是面向报文的：发送方不会对报文进行拆分，所以一个报文就是一个完整的消息，接收方使用队列来区分不同报文</li>
<li>TCP是面向字节流的：粘包问题：TCP报文会拆分成多个，取决于<strong>发送窗口、拥塞窗口以及当前发送缓冲区的大小等条件</strong>，所以不容易知道一个用户消息的边界<ul>
<li><img src="/2023/10/23/46/TcpHeader.png"></li>
<li>控制位是单独的留出来的几个位置</li>
<li>TCP面向字节流的，发送的是一个个连续的字节，而UDP是面向数据报的，一个UDP数据报就是一个完整的消息</li>
<li>重传机制：1.超时重传，重传时间最好略大于包的往返时间，2.快速重传3.SACK重传，选择性确认&nbsp;TCP 头部「选项」字段里加一个&nbsp;<code>SACK</code>&nbsp;的东西，它<strong>可以将已收到的数据的信息发送给「发送方」</strong>，这样发送方就可以知道哪些数据收到了，哪些数据没收到，知道了这些信息，就可以<strong>只重传丢失的数据</strong>。4.   Duplicate SACK,只告诉对方有哪些数据被重复接受了</li>
<li>滑动窗口：<strong>无需等待确认应答，而可以继续发送数据的最大值</strong></li>
<li><strong>拥塞窗口 cwnd</strong>是发送方维护的一个的状态变量，它会根据<strong>网络的拥塞程度动态变化的</strong>。 网络没出现拥塞，cwnd增加，出现拥塞cwnd减少</li>
</ul>
</li>
<li>HTTP：最常使用的是HTTP/1.1 <ul>
<li>优化 HTTP/1.1<ol>
<li>减少请求次数：1.使用客户端缓存，2.减少重定向次数，3.合并请求，4.延迟发送，只发送一部分内容</li>
<li>减少响应数据大小：使用压缩方式</li>
</ol>
</li>
</ul>
<ol>
<li>Keep-Alive：用于保持长连接，keepalive，TCP中的保活机制,HTTP1.1默认是开启的，在请求头中使用<code>Connection: Keep-Alive</code></li>
<li>强制缓存：服务器直接要求使用浏览器缓存的数据， 协商缓存：服务器会对比缓存过期时间，决定是否过期，返回给浏览器决定是否使用浏览器的缓存</li>
<li>队头阻塞：服务端在处理请求时耗时较长导致后面的请求无法即使发送，解决方式 ：使用管道：客户端可以直接发送多个请求，服务端根据发送顺序来解决，但是管道技术基本 <strong>没人使用</strong></li>
</ol>
<ul>
<li>演进过程：<ol>
<li>1.1 使用长连接改善短链接的性能开销，使用管道进传输，改善了队头阻塞。缺点是：header未压缩，只能压缩body,只能从客户端开始发送请求，没有请求优先级</li>
<li>2 头部压缩，当同时发送多个请求，如果请求头是一样或者相似的就把重复发部分消除，基于HTTPS的，头部全部使用二进制格式取代原来的纯文本，使用Stream,一个Stream可以包含多个Message,Message中可以包含多个Frame,Frame中包含Headers和Body,Stream都跑在同一个TCP上，客户端收到后会根据相同的Stream ID 有序组装成HTTP消息，Stream流用于多路复用TCP<ul>
<li>缺点是：由于TCP的是基于字节流的，必须保证收到的字节数据是完整且恋雪的才能将数据返回给应用层</li>
</ul>
</li>
<li>HTTP/3 使用UDP协议来解决响应的队头阻塞。<ol>
<li>使用基于UDP的QUIC协议，保证类似的可靠传输</li>
<li>QUIC 有自己的一套机制可以保证传输的可靠性的。当某个流发生丢包时，只会阻塞这个流，其他流不会受到影响，因此不存在队头阻塞问题。这与 HTTP/2 不同，HTTP/2 只要某个流中的数据包丢失了，其他流也会因此受影响。</li>
<li>当某个流丢包时，只会阻塞这个流，其他流不会阻塞，不存在队头阻塞问题</li>
<li><a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/2_http/https_rsa.html#tls-%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B">RSA算法</a>不支持前向加密，只要获取浏览器的私钥，即可破解</li>
<li></li>
</ol>
</li>
</ol>
</li>
</ul>
</li>
<li>HTTPS: <ol>
<li>使用混合加密：通信建立前使用非对称加密来交换会话密钥， 通信过程中使用对称加密的会话密钥来进行通信</li>
<li>公钥运算出的结果，只有使用私钥来进行逆运算得到结果。 发送时，发送者使用接收者的公钥，公钥是可知的，解决了密钥交换的问题，接收者使用自己的私钥进行解密。</li>
<li>公钥加密，私钥解密：保证传输过程中内容的加密</li>
<li>私钥加密，公钥解密：保证消息不会被篡改。—&gt;数字签名算法</li>
<li>使用权威机构CA(数字证书认证机构)来保存数字证书：个人信息+公钥+数字签名</li>
</ol>
</li>
<li>TCP<ul>
<li>三次握手的过程<ol>
<li>客户端发送带有SYN(同步序列)SEQ(序列号) = x  标志的数据包，客户端进入SYN_SEND状态</li>
<li>服务端发送带有SYN(SEQ = y) + ACK (ACK = x + 1) 标志的数据包，进入SYN_RECV状态</li>
<li>客户端发送 带有ACK(ACK = y + 1) 标志的数据包，二者进入ESTABLISHED状态</li>
</ol>
<ul>
<li>为什么要第二次传回SYN 用于表明所收到的是对应的客户端发送的信号</li>
</ul>
</li>
<li>四次挥手:<ol>
<li>客户端发送FIN(SEQ = x) ，进入FIN-WAIT-1状态</li>
<li>服务端发送ACK(ACK=x+1) 进入CLOSE-WAIT状态，客户端进入FIN-WAIT-2</li>
<li>服务端发送FIN(SEQ=y) 请求关闭,进入LAST-ACK</li>
<li>客户端发送，ACK(ACK=y+1) ，客户端进入TIME-WAIT，服务端接收后进入CLOSE，客户端等待一段时间之后如果没有收到回复，就关闭客户端。</li>
</ol>
</li>
<li>可不可以把ACK和FIN合并起来变成三次挥手： 不行，因为服务器收到断开请求时，可能还有一些数据没有传输完成，所以先发送ACK表明收到请求，等待所有数据发送完成之后发送FIN断开连接</li>
</ul>
</li>
<li>IP<ul>
<li>DNS:域名解析：</li>
<li>DHCP（动态主机配置协议）是一个网络协议，用于自动分配 IP 地址和其他相关配置信息给网络中的设备。这使得设备可以在加入网络时自动获取网络配置，无需手动设置。</li>
<li>ARP工作原理：广播问询，单播响应<ul>
<li>一个局域网中<ol>
<li>维护一个ARP表 &lt;IP,MAC,TTL&gt;</li>
<li>查询ARP表，如果不存在，则构造一个ARP查询分组，将其广播到局域网中，MAC地址为广播地址，然后希望收到的是IP地址</li>
<li>设备接收后查询是否为自己的IP，如果不是则丢弃，如果是，则构造ARP响应分组，发送给查询主机，并在自己的表中构造一条查询主机的IP-MAC映射表，使用的是单播，不再广播</li>
<li>查询的主机接受后，将其加入ARP表中</li>
</ol>
</li>
<li>不在一个局域网中：通过路由器转发查询</li>
</ul>
</li>
<li>NAT:同一个场景下将私有IP转化为共有IP地址</li>
<li>ICMP：互联网控制报文协议，确认Ip包是否<ul>
<li>ping：基于ICMP协议工作的，使用的ICMP类型中0和8，也就是回送应答和会送请求，根据这个来判断是否到达IP地址，如果路由器中间没有找到对应的接收端IP就会往发送端IP发送ICMP报文，8是源主机向目标主机的发送的请求，0是目标主机的回应</li>
<li>各种本地IP代指的区别：<ol>
<li>localhost 默认就是同于127.0.0.1，但是可以修改，是属于域名</li>
<li>0.0.0.0 IPv4中是无效地址，代指的是广播，监听本地的0.0.0.0时，代表的监听本机上所有的IPv4地址</li>
<li>127.0.0.1是回环地址</li>
</ol>
</li>
</ul>
</li>
<li>IGMP：Internet组管理协议，工作哎主机和最后一跳的路由之间。</li>
<li>为何断网了也能ping通127.0.0.1? 因为会把消息交给本地网卡，本地网卡直接把消息发送到本机接受到的消息链表中并触发软中断，由内核线程来传递给上层应用程序</li>
</ul>
</li>
</ul>
<h2 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h2><p>分类</p>
<h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><h2 id="如何解决粘包问题"><a href="#如何解决粘包问题" class="headerlink" title="如何解决粘包问题"></a>如何解决粘包问题</h2><p>找到消息的边界就能解决这个问题</p>
<ol>
<li>固定长度</li>
<li>特殊字符作为边界</li>
<li>自定义消息结构</li>
</ol>
<h3 id="重传机制"><a href="#重传机制" class="headerlink" title="重传机制"></a>重传机制</h3><p>重传是由序列号和确认应答来控制的</p>
<ol>
<li>超时重传，TCP的超时重传策略是间隔时间每次都设置为先前值的两倍，如果出现两次超时，说明网络环境差，不会重传了</li>
<li>快速重传：当收到三个相同ACK报文时，说明出现了丢包，会重传丢失的报文。</li>
</ol>
<h3 id="滑动窗口-4-2-TCP-重传、滑动窗口、流量控制、拥塞控制-小林coding-xiaolincoding-com"><a href="#滑动窗口-4-2-TCP-重传、滑动窗口、流量控制、拥塞控制-小林coding-xiaolincoding-com" class="headerlink" title="[滑动窗口](4.2 TCP 重传、滑动窗口、流量控制、拥塞控制 | 小林coding (xiaolincoding.com))"></a>[滑动窗口](<a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/3_tcp/tcp_feature.html#%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6">4.2 TCP 重传、滑动窗口、流量控制、拥塞控制 | 小林coding (xiaolincoding.com)</a>)</h3><p>TCP头中有一个Window字段，代表滑动窗口大小。表示接受方告诉对方自己还有多少缓冲区可以接受数据。</p>
<h4 id="发送方窗口"><a href="#发送方窗口" class="headerlink" title="发送方窗口"></a>发送方窗口</h4><p><img src="/2023/10/23/46/%E5%8F%91%E9%80%81%E6%96%B9%E7%AA%97%E5%8F%A3.png"></p>
<h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>HTTP是一个在计算机世界中专门在亮点之间传输文字、图片等超文本的约定与规范</p>
<h3 id="常见的状态码"><a href="#常见的状态码" class="headerlink" title="常见的状态码"></a>常见的状态码</h3><ol>
<li>1xx 是一种中间状态，实际使用较少</li>
<li>2xx 表示服务器成功处理了请求<ul>
<li>200 OK</li>
<li>204 No Content 与200基本相同，但是响应头没有body数据</li>
<li>206 Partial Content表示响应返回的body数据并不是资源的全部。</li>
</ul>
</li>
<li>3xx 重定向<ul>
<li>301 永久重定向</li>
<li>302 Found 临时重定向，注意301和302都会在响应头中使用Location字段知名后续需要跳转的URL，浏览器会自动重定向到新的URL</li>
<li>304  资源未修改，可以使用缓存资源</li>
</ul>
</li>
<li>4xx 客户端发送的报文有误<ul>
<li>400 请求有误，笼统的错误</li>
<li>403 服务器禁止访问资源</li>
<li>404 服务器不存在或未找到</li>
</ul>
</li>
<li>5xx 客户端请求报文正确，但是服务器处理时，内部出现了错误，属于服务端错误码<ul>
<li>500 笼统错误</li>
<li>501 客户端请求功能不支持，敬请期待</li>
<li>502 网关错误</li>
<li>503 服务器繁忙，无法咱是无法响应客户端。</li>
</ul>
</li>
</ol>
<h3 id="HTTP缓存"><a href="#HTTP缓存" class="headerlink" title="HTTP缓存"></a>HTTP缓存</h3><ol>
<li>强制缓存：浏览器判断缓存没过期就强制使用本地缓存。使用的是Cache-Control和Expires，第一个是相对时间，第二个是绝对时间。第一个优先级更高。<ul>
<li>浏览器第一次请求时，会加上这个过期时间</li>
<li>再次请求时，根据请求时间和这个过期时间进行比较，来判断是否过期，并且更新这个时间</li>
</ul>
</li>
<li>协商缓存： 与服务器协商之后，通过协商结果来判断是否使用本地缓存。<img src="/2023/10/23/46/%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98.png"></li>
</ol>
<h2 id="不同版本的HTTP特点"><a href="#不同版本的HTTP特点" class="headerlink" title="不同版本的HTTP特点"></a>不同版本的HTTP特点</h2><p>HTTP: 80<br>HTTPS: 443</p>
<h3 id="HTTP缓存-1"><a href="#HTTP缓存-1" class="headerlink" title="HTTP缓存"></a>HTTP缓存</h3><p>Cache-Control(相对时间)优先级高于Expires(绝对时间)<br>强制缓存是浏览器中的缓存没过期就强制使用缓存，协商缓存是每次与服务器协商是否过期。</p>
<h3 id="HTTP的迭代和对比"><a href="#HTTP的迭代和对比" class="headerlink" title="HTTP的迭代和对比"></a>HTTP的迭代和对比</h3><h4 id="HTTP1-1"><a href="#HTTP1-1" class="headerlink" title="HTTP1.1"></a>HTTP1.1</h4><p><strong>已经实现了长连接和管道网络传输(不需要一问一答，可以连续发送请求)</strong><br>解决了 <strong>请求的队头阻塞</strong>，但是没解决响应的队头阻塞。<br>头部冗长，未压缩，请求只能由客户端开始</p>
<h4 id="优点和缺点"><a href="#优点和缺点" class="headerlink" title="优点和缺点"></a>优点和缺点</h4><p>双刃剑：无状态、明文传输<br>缺点：不安全</p>
<ul>
<li>无状态可以使得浏览器不需要额外记忆HTTP的状态，缺点是处理有关联性的操作时会很麻烦<ul>
<li>解决方式就是使用Cookie</li>
</ul>
</li>
<li>明文传输：方便调试的同时不安全</li>
<li>不安全：1. 明文传输2.不验证通信双方的身份3.不能证明报文的完整性 <ul>
<li>解决方式使用HTTPS</li>
</ul>
</li>
</ul>
<h4 id="性能-长连接"><a href="#性能-长连接" class="headerlink" title="性能(长连接)"></a>性能(长连接)</h4><ol>
<li>相比较于1.0，1.1使用了长连接，一次TCP连接发起多次请求</li>
<li>可以使用管道通信，只要请求发送出去后，不需要等待响应结果即可发送下一个请求<br>解决了请求的队头阻塞，但是没有解决响应的队头阻塞，同时不是默认使用的<blockquote>
<p>队头阻塞是指当一个请求因为某种原因被阻塞，会导致后面排队的所有请求都一同被阻塞<br>进步：</p>
</blockquote>
</li>
<li>长连接</li>
<li>支持管道网络传输<br>缺点：</li>
<li>Header部分未经压缩就发送，延迟大，只能压缩Body部分</li>
<li>会出现队头阻塞：服务端响应慢，导致后续的请求不能及时发送</li>
<li>请求只能从客户端开始</li>
</ol>
<h4 id="HTTP-x2F-2"><a href="#HTTP-x2F-2" class="headerlink" title="HTTP/2"></a>HTTP/2</h4><p>进步：</p>
<ol>
<li>HTTP/2是基于HTTPS，安全有保证</li>
<li>队头压缩：如果同时发出多个请求，他们的请求头是一样的或者是相似的，就会消除重复的部分，原理是客户端和服务端同时维护一张头信息表，所有字段都会存在里面来进行索引</li>
<li>二进制格式：报文使用二进制格式，而不是使用纯文本的格式</li>
<li>并发传输，多路复用，一条TCP连接包含多个Stream，StreamID来区分，不同Stream的帧是可以乱序发送的</li>
<li>服务器可以主动推送资源<br>虽然在HTTP层解决了队头阻塞，但是TCP是字节流协议，导致必须满足一个一个字节才能够读取数据，从而降低效率，一旦丢包，必须进行TCP的重传，就会导致效率降低。</li>
</ol>
<h4 id="HTTP-x2F-3"><a href="#HTTP-x2F-3" class="headerlink" title="HTTP/3"></a>HTTP/3</h4><p>使用UDP来进行传输</p>
<h5 id="QUIC协议"><a href="#QUIC协议" class="headerlink" title="QUIC协议"></a>QUIC协议</h5><p>QUIC协议也实现了Stream的概念，从而某个流发生丢包时，只会则色这个流，而不会阻塞其他流，从而不会存在队头阻塞。<br>QUIC是google设计的一个基于UDP的网络传输协议，旨在替代TCP协议以提供更快的连接建立和数据传输速度。</p>
<ol>
<li>快速建立连接：使用基于TLS的安全连接，同时将连接的建立与TLS握手合并，从而减少了连接所需要的往返时间。</li>
<li>多路复用：允许在单个连接上同时进行多个独立的数据流，从避免了TCP连接中的队头阻塞</li>
<li>零RTT握手：QUIC支持零往返时间握手，允许客户端在第一次连接时发送数据，无需等待握手完成，进一步减少了连接建立时间。</li>
<li>动态调整拥塞控制：使用更先进的拥塞控制算法，能够动态的根据网络条件调增数据传输速率。</li>
<li>错误恢复：QUIC内置了一些错误恢复机制，包括快速重传和前向错误纠正，能够在发生丢包或网络拥塞时更快的恢复数据传输。</li>
</ol>
<p>HTTP/2 是⼀个应⽤层协议，是 HTTP/1.1 的后继版本，旨在提⾼ Web ⻚⾯加载速度和性能。 HTTP/2<br>在传输层使⽤了⼆进制分帧，头部压缩，多路复⽤等技术，以减少延迟和提⾼效率。 HTTP/2 不是⼀个<br>替代传输层协议，⽽是在传输层上实现的 HTTP 协议的增强版本。</p>
<h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><blockquote>
<p>HTTPS是在TCP和HTTP之间加入了SSL/TLS安全协议</p>
</blockquote>
<h4 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h4><ol>
<li>混合加密：对称加密和非对称加密的混合加密方式，通信建立之前使用的是非对称加密，建立之后通信使用的对称加密，对称加密只需要使用一个密钥，所以更加高效。</li>
<li>摘要算法 + 数字签名：通过摘要算法获得哈希值，来判断报文是否被修改。而数字签名则能保证通信双方的身份</li>
<li>数字证书：可信的第三方来保证双方身份，主要是CA通过私钥加密双方的公钥数字签名，然后CA的公钥是公开的，之后另一方通过CA的公钥解密获得对方的公钥，之后对方使用私钥加密，就可以使用公钥进行解密了或者是加密通信。<img src="/2023/10/23/46/CA%E7%AE%97%E6%B3%95.png"></li>
</ol>
<h4 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h4><ol>
<li>公钥加密，私钥解密：保证内容的安全，只有私钥可以解密内容</li>
<li>私钥加密，公钥解密：保证消息不可冒充，因为私钥是不可以泄漏的，验证双方身份，也就是数字签名算法<img src="/2023/10/23/46/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D%E7%AE%97%E6%B3%95.png" alt="|525"></li>
</ol>
<h4 id="流程-RSA算法为例"><a href="#流程-RSA算法为例" class="headerlink" title="流程(RSA算法为例)"></a>流程(RSA算法为例)</h4><ol>
<li>三次握手建立TCP连接</li>
<li>客户端发送ClientHello请求，携带客户端支持的TLS版本信息和客户端随机数Client Random，支持的密码套件列表(比如RSA算法)</li>
<li>ServerHello响应：确定TLS版本，浏览器不支持就断开，服务器随机数Server Random， 使用的加密算法，服务器的数字证书</li>
<li>客户端使用CA的公钥确定证书的真实性，之后取出公钥，加密报文发送：1. 随机数 pre-master key 2.加密通信算法改变通知，表示之后都将使用会话密钥(对称加密)进行通信，客户端握手结束通知，把之前所有的内容进行摘要，给服务器进行校验</li>
<li>双方使用这三个随机数和加密算法生成会话密钥</li>
<li>服务器最后1.加密算法改变 2.握手结束，生成摘要供客户端校验</li>
</ol>
<h4 id="HTTPS抓包-x2F-代理人"><a href="#HTTPS抓包-x2F-代理人" class="headerlink" title="HTTPS抓包/代理人"></a>HTTPS抓包/代理人</h4><p><img src="/2023/10/23/46/%E4%BB%A3%E7%90%86%E4%BA%BA.webp"></p>
<p>抓包工具的原理就是往系统受信任的根证书列表导入抓包工具生成的证书，这个证书会被浏览器新人，也就是转包工具给自己建立了一个CA。<br>如何解决中间人攻击：使用HTTPS双向认证，服务器也对客户端的认证信息进行验证。</p>
<h2 id="计网常问"><a href="#计网常问" class="headerlink" title="计网常问"></a>计网常问</h2><h3 id="一个请求整个网络的处理"><a href="#一个请求整个网络的处理" class="headerlink" title="一个请求整个网络的处理"></a>一个请求整个网络的处理</h3><ol>
<li>浏览器解析URL生成HTTP消息</li>
<li>通过DNS解析获得IP地址</li>
<li>之后将HTTP的传输工作通过调用Socket库交给操作系统的协议栈</li>
<li>TCP简历链接需要三次握手，保证双方都有发送和接收的能力</li>
<li>建立连接之后，TCP报文中的数据部分就是存放HTTP头部+数据，组装好TCP报文之后，交给下面的网络层处理</li>
<li>IP协议里需要源地址和目的地址IP，存在多个网卡时，需要根据路由表规则。</li>
<li>生成IP头部之后，需要在前面加上MAC头部，接收方的MAC地址通过ARP协议获得，并且放入ARP缓存</li>
<li>网卡驱动获得网络包，将其复制到网卡内的缓存区中，从开头加上包头和起始帧分节符，末尾加上用于校验错误的帧校验序列。之后网卡将包转为电信号，通过网线发送</li>
<li>电信号到达网线接口，交换机里的模块进行接收。之后将电信号转化为数字信号。FCS校验没问题后放入缓冲区，之后查询MAC地址，如果找不到，就发除了源端口的所有端口。</li>
<li>电信号到达⽹线接⼝部分，路由器中的模块会将电信号转成数字信号， FCS 进⾏错误校验没问题后确认接收⽅MAC地址，然后去掉MAC头部，查询路由表判断转发⽬标，如果⽹关为空则 IP 头部中的接收⽅ IP 地址就是要转发到的⽬标地址</li>
<li>知道对⽅的 IP 地址之后，接下来需要通过 ARP 协议根据 IP 地址查询 MAC 地址，加上MAC头部，发送⽹络包，通过交换机到达下⼀个路由器</li>
<li>最后数据包抵达了服务器</li>
</ol>
<h3 id="IPv6优点"><a href="#IPv6优点" class="headerlink" title="IPv6优点"></a>IPv6优点</h3><ol>
<li>更⼤的地址空间：IPv6将地址⻓度从IPv4的32位扩展到了128位，理论上可以分配⼤约3.4x10^38个唯⼀的IP地址。</li>
<li>简化的报⽂格式：IPv6头部格式更为简洁，减少了处理的复杂性，提⾼了路由效率。</li>
<li>改进的服务质量（QoS）：IPv6⽀持更好的流量分类和优先级处理，有助于提供更加可靠的服务质量。</li>
<li>内建的安全机制：IPv6原⽣⽀持IPsec（⽹络安全协议），为数据传输提供了端到端的加密和认证。</li>
<li>⾃动配置能⼒：IPv6⽀持有状态和⽆状态的地址⾃动配置（SLAAC），简化了⽹络设备的配置和管理</li>
</ol>
<h3 id="BGP、OSPF协议原理"><a href="#BGP、OSPF协议原理" class="headerlink" title="BGP、OSPF协议原理"></a>BGP、OSPF协议原理</h3><blockquote>
<p>边界⽹关协议(Border Gateway Protocol，简称BGP)和开放最短路径优先协议(Open Shortest Path<br>First，简称OSPF)是世界上最流⾏的两种基于标准的动态路由协议。</p>
</blockquote>
<h3 id="三握四挥"><a href="#三握四挥" class="headerlink" title="三握四挥"></a>三握四挥</h3><p><img src="/2023/10/23/46/%E4%B8%89%E6%8F%A1%E5%9B%9B%E6%8C%A5.png"></p>
<h3 id="TCP和UDP"><a href="#TCP和UDP" class="headerlink" title="TCP和UDP"></a>TCP和UDP</h3><p><img src="/2023/10/23/46/%E5%A4%B4%E9%83%A8.png" alt="|525"></p>
<ol>
<li>序列号：建立连接时，由计算机生成的随机数作为初始值，通过SYN包传给接收端主机，每发送一次，就累加一次该数据字节数的大小，解决网络包乱序问题。</li>
<li>确认应答号：下一次期望收到数据的序列号。发送端收到这个之后可以认为在这之前的数据都被正常接收，用于解决丢包问题。</li>
<li>控制位为1时：<ul>
<li>ACK：确认应答变为有效，TCP规定除了最初建立连接时的SYN包之外必须设为1</li>
<li>RST：标识连接异常必须强制断开连接</li>
<li>SYN：表示希望建立连接</li>
<li>FIN：今后不会再有数据发送，希望断开连接时，表示今后不再有数据发送，希望断开连接。当通信结束希望断开连接时，通信双方可以交换FIN位为1的TCP段。</li>
</ul>
</li>
</ol>
<h4 id="SYN攻击"><a href="#SYN攻击" class="headerlink" title="SYN攻击"></a>SYN攻击</h4><blockquote>
<p>攻击者短时间伪造不同的IP地址的SYN报文，沾满服务端的办理按揭队列，导致客户端无法和服务端建立连接。</p>
</blockquote>
<p>解决方案：</p>
<ol>
<li>增大netdev_max_backlog：网卡接收数据包的数据大于内核处理速度时保存数据包的队列长度</li>
<li>增大TCP半连接队列：<ul>
<li>增大net.ipv4.tcp_max_syn_backlog</li>
<li>增大listen()函数中的backlog</li>
<li>增大net.core.somaxconn</li>
</ul>
</li>
<li>开启net.ipv4.tcp_syncookies，就可以在使用SYN半连接的情况下成功建立连接。<img src="/2023/10/23/46/%E4%BD%BF%E7%94%A8cookie%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5.png" alt="|550"></li>
</ol>
<ul>
<li>减少SYN+ACK重传次数，tcp_synack_retries内核参数</li>
<li>Anti-DDoS系统拦截客⼾端发送的SYN报⽂，代替服务器向客⼾端发送SYN-ACK报⽂，如果客⼾端不应答，则认为该客⼾端为虚假源；如果客⼾端应答，则Anti-DDoS系统认为该客⼾端为真实源，并将其IP地址加⼊⽩名单，在⼀段时间允许该源发送的所有SYN报⽂通过，也不做代答。</li>
</ul>
<h4 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h4><p>滑动窗口机制允许发送方在等待接收方确认之前发送多个数据包，从而提高数据传输效率。<br>为了解决一发一答的效率问题。窗口的实现实际上是操作系统开辟一个缓存空间，发送方主机在等到确认应答返回之前，必须在缓冲区中保留已发送的数据，如果按期收到确认应答，这个数据就可以从缓冲区删除。<img src="/2023/10/23/46/TCP%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3.png"></p>
<h4 id="慢启动"><a href="#慢启动" class="headerlink" title="慢启动"></a>慢启动</h4><p>当连接开始时，以指数速率增加发送速率，直到第一次报文丢失事件发生为止。<br>初始：拥塞窗口值cwnd = 1 MSS<br>每RTT倍增cwnd<br>每收到一个ACK，增加cwnd<br>初始速率很低，但是以指数增加</p>
<h4 id="阻塞控制"><a href="#阻塞控制" class="headerlink" title="阻塞控制"></a>阻塞控制</h4><ol>
<li>慢启动：发送方每收到一个ACK，拥塞窗口cwnd大小指数增加</li>
<li>拥塞避免算法：当cwnd超过慢启动门限ssthresh就会进入拥塞避免算法：每个 RTT（往返时间）增加 1 个 MSS，而不是每个 ACK 增加 1 个 MSS。</li>
<li>拥塞发生：发生了 超时重传时，sshtresh设置为cwnd/2，cwnd恢复为初始化值，发生快速重传是，cwnd =cwnd/2，ssthresh=cwnd并进入快速恢复算法。</li>
<li>快速恢复<img src="/2023/10/23/46/%E5%BF%AB%E9%80%9F%E6%81%A2%E5%A4%8D.png"></li>
</ol>
<h4 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h4><p>主机名到IP地址的转换<br>主机别名：一个主机可以有一个规范主机名和多个主机别名。<br>邮件服务器别名：负载分配：DNS实现冗余服务器，一个IP地址集合可以对应同一个规范主机名。</p>
<p>DNS客⼾端设置使⽤的DNS服务器⼀般都是递归服务器，它负责全权处理客⼾端的DNS查询请求，直<br>到返回最终结果。⽽DNS服务器之间⼀般采⽤迭代查询⽅式。<br><img src="/2023/10/23/46/DNS%E8%AE%B0%E5%BD%95%E6%A0%BC%E5%BC%8F.png"></p>
<h4 id="DNS劫持"><a href="#DNS劫持" class="headerlink" title="DNS劫持"></a>DNS劫持</h4><blockquote>
<p>通过某些手段获得对某域名的解析控制权，修改此域名的解析结果，导致对该域名的访问由原IP转为修改后的指定IP，记过就是对特定网站不能访问/访问的是假网站</p>
</blockquote>
<p>防止：限制对DNS的访问、设置较小的TTL值，定期修改域名管理系统的账号，使用支持DNSSEC的注册商，使用可靠的DNS服务商。</p>
<blockquote>
<p>DNSSEC（Domain Name System Security Extensions，域名系统安全扩展）是一组用于保护 DNS（域名系统）信息安全的协议和技术。它通过数字签名验证 DNS 数据的真实性和完整性，防止 DNS 缓存投毒和其他类型的攻击。</p>
</blockquote>
<h2 id="网络核心"><a href="#网络核心" class="headerlink" title="网络核心"></a>网络核心</h2><p>概念：路由器的网状网络<br>提问： 数据怎么通过网络进行传输？</p>
<ul>
<li>电路电路交换：  不可共享资源，会造成资源浪费，不适合计算机之间的通讯，计算机通信的特点： 突发性，耗时短</li>
<li>分组交换： 存储 – 转发  ， 数据转发过程中使用所有的资源，而不是使用一部分pieces，会将所有的的分组都存储之后再进行转发，方便共享的实现</li>
</ul>
<h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><ol>
<li>应用架构<ul>
<li>CS体系 客户-服务器:<ul>
<li>服务器： 一直运行，固定ip和周知的端口号，扩展性差</li>
<li>客户端： 主动与服务器通信，可能是动态ip，不直接与其他客户端通信</li>
</ul>
</li>
<li>P2P 每个端都可以作为服务器，点对点</li>
<li>混合体 c/s + P2P</li>
</ul>
</li>
<li>TCP socket ：对于面向连接服务（TCP) 的应用而言，socket是四元组的一个具有本地意义的标示,相当于一个记录特定会话的指针，只需要用socket就可以指定这个应用<ul>
<li>socket 其实是应用层和传输层之间的，使得允许应用能发起通信，与其他主机上的应用进程进行通信</li>
<li>4元组  源IP 源port 目标IP 目标port</li>
<li>唯一指定了一个会话</li>
<li>应用使用这个标示，与远程的应用进程进行通讯</li>
<li>不必在每一个报文中都指定这四元组</li>
<li>udp 只提供源主机的ip 和 port</li>
</ul>
</li>
<li>WebSocket 工作过程：<ol>
<li>客户端发送一个HTTP请求，包含升级字段</li>
<li>服务器接收之后,进行协议升级，如果支持，会返回一个101状态码，包含一些对应响应头</li>
<li>进行双向通信，数据以帧的方式传送。</li>
<li>其中一方发送一个关闭帧，二者关闭TCP连接</li>
<li>通过心跳机制保证WebSocket的稳定性和活跃性</li>
</ol>
</li>
<li>UDP socket<br> UDP 两个进程之间的通信之前不需要建立连接，每个报文独立传输，前后报文可能给不同的分布式进程<br> udp socket 记录本IP 本port 但是传输报文时，需要提供对方ip， port ,接收报文时传输层需要上传对方IP port<br> 二元组： 源IP  源port</li>
</ol>
<p>TCP 服务：</p>
<ul>
<li><p>可靠的传输服务</p>
</li>
<li><p>流量控制：发送方不会淹</p>
</li>
</ul>
<p>没接受方</p>
<ul>
<li>拥塞控制：当网络出现拥</li>
</ul>
<p>塞时，能抑制发送方</p>
<ul>
<li><p>不能提供的服务：时间保证、最小吞吐保证和安全</p>
</li>
<li><p>面向连接：要求在客户端进程和服务器进程之间建立连接</p>
</li>
</ul>
<p>UDP 服务：</p>
<ul>
<li><p>不可靠数据传输</p>
</li>
<li><p>不提供的服务：可靠，流量控制、拥塞控制、时间、带宽保证、建立连接<br>UDP存在的必要性</p>
</li>
<li><p>能够区分不同的进程，而IP服务不能</p>
</li>
<li><p>在IP提供的主机到主机端到端功能的基础上，区分了主机的</p>
</li>
</ul>
<p>应用进程</p>
<ul>
<li>无需建立连接，省去了建立连接时间，适合事务性的</li>
</ul>
<p>应用</p>
<ul>
<li>不做可靠性的工作，例如检错重发，适合那些对实时</li>
</ul>
<p>性要求比较高而对正确性要求不高的应用</p>
<ul>
<li>因为为了实现可靠性（准确性、保序等），必须付出时间代</li>
</ul>
<p>价（检错重发）</p>
<ul>
<li>没有拥塞控制和流量控制，应用能够按照设定的速度</li>
</ul>
<p>发送数据</p>
<ul>
<li>而在TCP上面的应用，应用发送数据的速度和主机向网络发送</li>
</ul>
<p>的实际速度是不一致的，因为有流量控制和拥塞控制</p>
<ul>
<li>安全TCP<br>  TCP和UDP都没有加密，明文传输<br>  使用SSL协议来实现加密，在TCP的基础上实现，提供加密的TCP，私密性，数据完整性，段堆到端的鉴别<br>  SSL socket API 应用通过API将铭文交给socket，SSL将其加密<br>URL : 访问协议 + 用户名 + 口令字 + 端口等</li>
</ul>
<h3 id="常见的应用层协议"><a href="#常见的应用层协议" class="headerlink" title="常见的应用层协议"></a>常见的应用层协议</h3><h4 id="HTTP面试题"><a href="#HTTP面试题" class="headerlink" title="HTTP面试题"></a>HTTP面试题</h4><ul>
<li><p>状态码：</p>
<ol>
<li>200 </li>
<li>204 No Content 响应头没有body数据</li>
<li>206 &nbsp;<strong>Partial Content</strong> 表示返回的body数据不是资源的全部，只是一部分</li>
<li>301 <strong>Moved Permanently</strong> 永久重定向，请求的资源已经不存在的</li>
<li>302: Found: 表示临时重定向，301，302都会在响应头中使用字段Location指明后续要跳转URL,浏览器会自动重定向到新的URL</li>
<li>304：<strong>Not Modified</strong> 告诉客户端可以接着使用缓存资源</li>
<li>400<strong>Bad Request</strong> 报文有错</li>
<li>403 <strong>Forbidden</strong> 禁止访问</li>
<li>404 <strong>Not Found</strong> 资源不存在或者没找到</li>
<li>500 <strong>Internal Server Error</strong> 服务器内部错误</li>
<li><strong>501 Not Implemented</strong> 客户端请求还不支持</li>
<li><strong>502 Bad Gateway</strong> 通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。</li>
<li><strong>03 Service Unavailable</strong> 服务器忙，暂时无法响应</li>
</ol>
</li>
<li><p>缓存技术：把请求-响应的数据存到本地，下一次直接都本地数据，不需要等待服务器的想用了</p>
<ol>
<li>强制缓存<ul>
<li><code>Cache-Control</code>， 是一个相对时间；</li>
<li><code>Expires</code>，是一个绝对时间；</li>
</ul>
</li>
<li>协商缓存<ul>
<li>在强制缓存未命中时，服务器第一次请求资源时，会在Response头部加上ETag唯一表示</li>
<li>当浏览器再次请求访问服务器中的资源时，先检查缓存是否过期，如果没有过期直接使用本地缓存，如果过期了会在Request头部上加上If-None-Match紫萼段</li>
<li>服务器再次收到请求之后，会根据请求中的If-None-Match值是否与当前请求的资源生成的唯一标识比较<ul>
<li>如果值相等，返回304 Not Modified 不会返回资源</li>
<li>如果不相等，则返回 200 状态码和返回资源，并在 Response 头部加上新的 ETag 唯一标识；</li>
</ul>
</li>
<li>浏览器收到304响应码，会从本地加载资源否则更新资源。</li>
</ul>
</li>
</ol>
</li>
<li><p>HTTP/1.1 的优点：简单灵活、应用广泛</p>
<ul>
<li>缺点是：无状态一方面可以不需要服务器使用额外的资源来记录状态信息</li>
<li>坏处是：进行关联性操作时，需要每次都验证一次身份</li>
<li>解决方法：使用Cookie</li>
</ul>
</li>
<li></li>
<li><p>HTTP：超文本传输协议 HTTP默认80 HTTPS默认 443</p>
<ul>
<li>流程： 1. 客户发起一个与服务器的TCP连接，(建立socket) 2. 服务器接受TCP 连接 3. 浏览器和web服务器之间交换HTTP报文 4. TCP连接关闭 </li>
<li>HTTP 是无状态的连接，不会维护任何和客户有关的信息，这时候就需要websocket了</li>
<li>HTTP/1.1 之后默认使用持久连接，保证了多个u第项可以在一个TCP连接上传输 ，非持久连接下载多个文件需要及案例多个TCP连接<br> 响应时间<br> 往返时间 RTT round - trip - time： 一个小的分组从客户端到服务器，再回到客户端的时间，传输时间忽略不计<br> 响应时间为： 2RTT + 传输时间<br> 1. 一个RTT 用来发起TCP请求<br> 2. 一个用来HTTP请求和等待响应<br> 3. 文件传输时间<br> <strong>持久HTTP</strong> ： 一个TCP连接建立之后，不会断开然后进行多个HTTP请求<br> 服务器在发送响应之后仍然保持TCP连接<br> 在相同客户端和服务器之间的后续请求和响应报文通过相同的连接进行传送<br> 客户端，在遇到一个引用对象的时候就可以尽快的发送该对象的请求，<br> 1. 每个对象要两个RTT<br> 2. 操作系统必须为每一个TCP连接分配资源，但是浏览器通常并行打开TPC连接，以获得引用对象<br> 两种方式：<br>     1. 非流线方式的持久HTTP，客户端只能在前一个HTTP请求响应之后才能发送新的请求，每个引用对象花费一个RTT<br>     2. 流水线方式：客户端遇到一个引用对象（一个小的ui所指的资源）之后就立即产生一个请<br>     3. 所有(小)的引用对象只花费一个RTT是有可能的<br> HTTP 报文格式 ： 请求行 + 请求头 + (request body)<br> tips : PUT 请求是将实体对象中文件载到URL指定的路径(一般是更新资源)<br> POST 不需要在URL 中指定资源位置，一般用于创建资源<ul>
<li>缓存：命中率(h)： 百分之多少的请求可以在缓存中满足</li>
<li>接入链路的利用率:  (1-h) *  请求速率 / 带宽</li>
</ul>
</li>
</ul>
</li>
<li><p>FTP 文件传输协议(基于TCP)<br> ftp服务器端口号默认为 21，需要建立两个TCP连接，一个用于控制，一个用于传输</p>
</li>
<li><p>SMIT 电子邮件的邮件传输协议 (默认端口25)<br>  用于上传邮件，和HTTP的区别，HTTP的每个对象封装在各自的响应报文中，SMIT可以将多个 引用对象封装在一个报文中<br>  报文格式：<br>  HEAD<br>  To :<br>  From :<br>  Subject:<br>  BODY:<br>  报文</p>
<ul>
<li>MIME 多媒体邮件扩展</li>
<li>POP 邮局访问协议 用户确认身份(代理 &lt;–&gt;服务器)并下载<ul>
<li>POP3 不保留会话状态 本地管理文件夹</li>
</ul>
</li>
<li>IMAP Internet 邮件访问协议，保留用户状态 远程管理文件夹</li>
</ul>
</li>
<li><p><em>DNS</em> Domain Name System 建立IP 地址和 对应域名之间的映射<br>  <strong><em>DNS默认默认端口是53</em></strong><br>  主要思路：分层，基于域的命名机制，在若干分布式的数据库上完成转换<br>  也可以做到负载均衡<br>  域名结构：使用层次树状结构来进行命名<br>  域名结构：从本域开始往上直至树根，域严格遵循组织界限，而不是物理网络<br>  DNS 记录格式<br>  RP格式: (name,value,type , ttl)<br>  type=A  时， name 为主机 value 为IP<br>  =CNAME  Name 为规范名字的别名<br>  =NS           Name 为域名 (foo.com) value 为该域名的权威服务器的域名<br>  =MX          Value 为name对应邮件服务器名字</p>
<ul>
<li>应用调用 解析器(resolver)</li>
<li>解析器作为客户 向Name Server发出查询报文（封装在UDP段中）</li>
<li>Name Server返回响应报文(name/ip)</li>
<li>本地名字服务器 Local Name Server 起到代理的作用，将查询转发到DNS服务器<ul>
<li>不严格属于层次结构，每个ISP 都有一个本地DNS，优先去本地DNS服务器中查询</li>
<li>递归查询：本地LNS 无，<strong>直接</strong> 去找权威服务器，然后从权威服务器往下开始查询，只需要向一个服务器去请求，然后由这个服务器去查询或者去向其他服务器来进行查找，最终由这个服务器来返回结果</li>
<li>迭代查询：转发到服务器，如果这个服务器没有就告诉发起请求的服务器要去查询下个一个服务器，由请求服务器去接着请求其他服务器，最终由能查询到的服务器来返回结果，就可以降低根服务器的负荷了</li>
</ul>
</li>
<li>缓存，一旦名字服务器得到了一个映射，就将该映射缓存起来，根服务器一般在本地服务器中缓存着，使用TTL (Time to Live)</li>
<li>攻击DNS的方法： <ul>
<li>DDoS攻击：对根服务器进行流量轰炸，发送大量的ping</li>
<li>向TLD(权威，顶级域名)攻击</li>
<li>重定向攻击：</li>
</ul>
</li>
</ul>
</li>
<li><p>CDN 内容分发网络：在CDN节点中存储内容的多个拷贝，用户请求重定向到最近的一个CDN节点</p>
</li>
</ul>
<h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><p>提供服务：为运行在不同主机上应用程序提供逻辑通信<br>数据元为报文段<br>与网络层的区别：网络层提供不同主机之间的逻辑通信，传输层提供的应用程序之间的通讯<br>tips：TCP和UDP都不提供延时保证和带宽保证，都支持多路复用和解复用，TCP额外提供拥塞控制和流量控制，以及建立连接</p>
<ul>
<li>多路复用/解复用：多路复用指的是许多个信号或数据流共享同一物理通信通道，解复用指的是根据报文段的头背部信息中的IP地址和端口号将接受的报文段发给正确的socket</li>
<li>为何要有UDP ： <ol>
<li>不建立连接(会增加延时)</li>
<li>简单：在发送端和接收端没有连接状态</li>
<li>报文段的头部很小(开销小)</li>
<li>无阻塞控制和流量控制可以保证UDP尽快的发送报文段，应用-&gt; 传输速率 = 主机 -&gt; 网络的速率</li>
<li><u>UDP也会进行校验，但是只是通过校验和的方式来检测是否遭到篡改</u></li>
</ol>
</li>
<li>RDT 是一种模型: RDT（Reliable Data Transfer）是一种可靠的数据传输协议，用于在不可靠的通信信道上实现可靠的数据传输。<ol>
<li>RDT 1.0（停等协议）：相信信道可靠<ul>
<li>发送方只发送一次数据，不进行重传。</li>
<li>接收方只接受一次数据，不进行重传请求。</li>
<li>适用于理想化的通信信道，不考虑错误和丢失。</li>
</ul>
</li>
<li>RDT 2.0（回退N协议）： 相信会出现bits errors<ul>
<li>使用checksum 来进行错误检验</li>
<li>引入了有限状态自动机，来切换来指定发送者和接收者</li>
<li>发送方发送数据帧，并等待接收方的确认帧。</li>
<li>接收方接收数据帧，发送确认帧。</li>
<li>如果发送方未收到确认帧，它将重传数据帧。</li>
<li>接收方可能收到重复的数据帧，但通过带有序号的数据帧来排除重复。</li>
<li>问题：如果ACK或者NCK传错了，就会重复</li>
</ul>
</li>
<li>RDT 3.0 <ul>
<li>机制：在超过合理时间之后进行重传</li>
<li><ul>
<li>如果package（或ACK）只是被延迟了：</li>
<li>重传将会导致数据重复，但利用序列号已经可以处理这个问题</li>
<li>接收方必须指明被正确接收的序列号</li>
</ul>
</li>
</ul>
</li>
</ol>
<ul>
<li>需要一个倒计数定时器<ol>
<li>停等协议：发送方发送一个分组，然后等待接收方的应答</li>
<li>ACK NAK   NAK 是negative ACK</li>
</ol>
</li>
</ul>
</li>
<li>TCP:<ul>
<li>点对点：一个发送方，一个接收方 </li>
<li>可靠的、按顺序的字节流：没有报文边界 </li>
<li>管道化：TCP拥塞控制和流量控制设置窗口的大小</li>
<li>面向连接：交换数据之前，通过握手来初始化双方的状态变量</li>
<li>流量控制：发送方不会淹没接收方</li>
<li><img src="/2023/10/23/46/tcp%E6%8A%A5%E6%96%87.png" alt="tcp报文"></li>
<li>序号：报文段首字节在字节流的编号</li>
<li>确认号：期望从另一方收到的下一个字节的序号</li>
<li>TCP超时时间= EstimatedRTT + 安全边界时间</li>
<li>。。。。待续</li>
</ul>
</li>
</ul>
<h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><p>DU 为 数据包</p>
<ul>
<li>服务：在发送和接收主机之间传送段</li>
<li>功能：<ul>
<li>转发：将分组从路由器的输入接口转发到合适的输出接口上</li>
<li>路由：使用路由算法来决定分组从发送主机到目标接收主机的路径</li>
</ul>
</li>
<li>数据平面：转发</li>
<li>控制平面：路径</li>
<li>路由器的结构：<ul>
<li>路由：运行路由选择算法生成路由表</li>
<li>转发：从输入到输出链路交换数据报，根据路由表进行分组的转发</li>
</ul>
</li>
<li>查表方式： <ul>
<li>最长前缀匹配</li>
</ul>
</li>
<li>交换结构：<ul>
<li>通过内存交换，在cpu的直接控制下进行交换</li>
<li>使用总线进行交换： 数据报通过共享总线进行转发，交换速度受限于总线带宽</li>
<li>使用互联网络进行交换</li>
</ul>
</li>
<li>调度机制： 调度指的是选择下一个要通过链路交换的分组<ul>
<li>FIFO</li>
<li>优先权调度</li>
<li>轮询</li>
</ul>
</li>
<li>IP<ul>
<li>IP地址是对主机或者路由器的接口进行编址</li>
<li>接口指的是 主机/路由器 和 物理链路的连接处</li>
<li>关系是1 : 1</li>
<li><strong>子网</strong>：<ol>
<li>一个子网内的节点，他们IP地址的高位部分都相同，这些节点叫做子网</li>
<li>无需路由器介入，子网内的个主机在物理上是可以直接打到</li>
<li>将子网掩码转为二进制，则为1的部分代表着IP地址中的这一部分是网络中的地址，为0的部分是标识子网中的主机</li>
</ol>
</li>
<li>分类：根据第一个8位bit来进行分类<ul>
<li>A 类 最高位固定为0：也就是 1 - 126  7 位网络  24 位主机</li>
<li>B : 10  128 - 191 14位 网络 16主机</li>
<li>C : 110 192 - 223  21位 网络  8位主机</li>
<li>D : 224 - 239 用于多播</li>
<li>E : 240 - 255 保留用于实验和研究目的</li>
</ul>
</li>
<li>CIDR Classless InterDomain Routing 无类域间路由<ul>
<li>也就是 a.b.c.d/x x是子网掩码(mask)</li>
</ul>
</li>
<li>NAT 网络地址转换 <ul>
<li>将私有网络中的内部IP映射到公共网络中的单个IP地址</li>
</ul>
<ol>
<li><p>节省IP地址：NAT允许多个内部设备共享一个公共IP地址，因此可以延长IPv4地址池的使用寿命。</p>
</li>
<li><p>增强网络安全性：因为内部设备的私有IP地址不直接暴露在互联网上，NAT提供了一层基本的安全性，可以隐藏内部网络结构。</p>
</li>
<li><p>简化网络管理：NAT可以使网络管理员更轻松地管理多台设备，而无需为每个设备分配唯一的公共IP地址。</p>
</li>
</ol>
</li>
</ul>
</li>
<li>IPv6 <ul>
<li>IPv4和IPv6通信方式：隧道 Tunneling， 在IPv4路由器之间传输的IPv4报文中携带PIv6的报文</li>
</ul>
</li>
<li>SDN</li>
<li>OpenFlow</li>
<li>route 路由，按照某种指标找到一条从源节点到目标节点的较好路径<ul>
<li>路由算法分为 全局和 分布式</li>
<li>全局：<ul>
<li>所有边都拥有完整(所有的拓扑)的拓扑和边的代价的信息</li>
<li>link state  LS  链路状态路由选择算法</li>
</ul>
</li>
<li>分布式: <ul>
<li>路由器只知道与它物理连接关系的邻居路由器和到响应邻居路由器的代价</li>
<li>迭代的与邻居路由器交换路由信息，计算路由信息</li>
<li>distance vector DV算法  距离矢量路由选择算法</li>
</ul>
</li>
</ul>
</li>
<li>RIP（Routing Information Protocol）是一种用于计算机网络中的距离矢量路由协议</li>
<li>OSP</li>
<li>DNS 主机向要访问-&gt;向DNS查询IP地址-&gt;所查询的DNS服务器未知要查询的IP地址-&gt;向根域名服务器查询-&gt;根域名服务器收录了这个地址 -&gt;返回地址给客户端-&gt;客户端建立通信<br>网络层解决一个两个网络之间的问题，链路层要解决点对点传输的问题</li>
<li><strong>ARP</strong>:以目标IP地址为线索，来定位下一个应该接受数据分包的网络设备的MAC地址，沟通IP和MAC地址 **IP-&gt;MAC **数据元为 frame 帧，帧的头部时使用MAC地址来标示源和目的地<ul>
<li>ARP记录一个&lt;IP,MAC,TTL&gt; 的表，TTL是生存周期</li>
</ul>
</li>
<li><strong>RARP</strong> MAC-&gt;IP<br>实现是在适配器上实现的，例如以太网卡</li>
<li>WAN 广域网 网络形式采用点到点链路</li>
<li>LAN 局域网 一般采用多点连接的方式</li>
<li>奇偶校验<ul>
<li>单bit奇偶校验只能检测单个bit级别的错误，不能纠错</li>
<li>二维奇偶校验可以检测和纠正单个bit错误</li>
<li>checksum </li>
<li>CRC 循环冗余校验</li>
</ul>
</li>
</ul>
<h3 id="网络接口层：等价数据链路层，使用mac地址"><a href="#网络接口层：等价数据链路层，使用mac地址" class="headerlink" title="网络接口层：等价数据链路层，使用mac地址"></a>网络接口层：等价数据链路层，使用mac地址</h3><ul>
<li><p>NIC的驱动程序</p>
</li>
<li><p>NIC 是网络适配器，也就是网卡</p>
</li>
<li><p>PPP也属于数据链路层</p>
</li>
</ul>
<h2 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h2><h4 id="OSI参考模型-有七个分层"><a href="#OSI参考模型-有七个分层" class="headerlink" title="OSI参考模型 有七个分层"></a>OSI参考模型 有七个分层</h4><p>自上而下 每一层的功能和作用由协议规定，协议的内容是规范</p>
<ol>
<li><p><strong>应用层</strong></p>
<ul>
<li>针对特定应用的协议</li>
</ul>
</li>
<li><p><strong>表示层</strong></p>
<ul>
<li>设备固有数据格式和网络标准数据格式 比如：接受不同表现形式的信息</li>
</ul>
</li>
<li><p><em>会话层</em></p>
<ul>
<li>负责通信管理，负责建立连接和断开，管理传输层以下的分层</li>
</ul>
</li>
<li><p><strong>传输层</strong></p>
<ul>
<li>管理两个节点之间的数据传输，负责可靠传输</li>
</ul>
</li>
<li><p><strong>网络层</strong></p>
<ul>
<li>路由选择与地址管理</li>
</ul>
</li>
<li><p><strong>数据链路层</strong></p>
<ul>
<li>互连设备之间传送，和 识别数据帧</li>
</ul>
</li>
<li><p><strong>物理层</strong></p>
<ul>
<li>界定连接器和网线的规格，比特流和电子信号转换</li>
</ul>
</li>
</ol>
<h2 id="网络安全"><a href="#网络安全" class="headerlink" title="网络安全"></a>网络安全</h2><ul>
<li>对称加密：发送方和接收方的密钥相同</li>
<li>公开密钥加密：发送方使用接收方的公钥进行加密，接收方使用自己的私钥进行解密</li>
<li>数字签名：</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zuofw.github.io/2023/10/21/39/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="QingQiu">
      <meta itemprop="description" content="个人网站，学习记录，面试记录和经验总结、互联网中一块属于自己的小窝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="QingQiu'Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/10/21/39/" class="post-title-link" itemprop="url">简历</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-10-21 10:10:39" itemprop="dateCreated datePublished" datetime="2023-10-21T10:10:39+08:00">2023-10-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-10-24 22:18:40" itemprop="dateModified" datetime="2024-10-24T22:18:40+08:00">2024-10-24</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>37</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>国外的那些课的实验是可以写在简历上的比如 15445<br>苍穹外卖项目 + 服务器部署</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zuofw.github.io/2023/10/16/48/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="QingQiu">
      <meta itemprop="description" content="个人网站，学习记录，面试记录和经验总结、互联网中一块属于自己的小窝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="QingQiu'Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/10/16/48/" class="post-title-link" itemprop="url">计组</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-10-16 19:11:48" itemprop="dateCreated datePublished" datetime="2023-10-16T19:11:48+08:00">2023-10-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-07-19 16:42:27" itemprop="dateModified" datetime="2024-07-19T16:42:27+08:00">2024-07-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">计算机基础</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.5k</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>海明码:<a target="_blank" rel="noopener" href="https://www.cnblogs.com/godoforange/p/12003676.html">https://www.cnblogs.com/godoforange/p/12003676.html</a><br><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1t4411e7LH?p=38&amp;spm_id_from=pageDriver&amp;vd_source=603b67fa519e58ee792d9e969a3ad8a1">https://www.bilibili.com/video/BV1t4411e7LH?p=38&amp;spm_id_from=pageDriver&amp;vd_source=603b67fa519e58ee792d9e969a3ad8a1</a></p>
<h2 id="基本名词解释"><a href="#基本名词解释" class="headerlink" title="基本名词解释"></a>基本名词解释</h2><p>PC 程序计数器<br>IR 指令寄存器，存放当前正在执行的指令，<br>MAR<br>CU 控制单元，为控制器的核心部件，其功能是产生微操作命令序列。<br>ALU：Arithmetic Logic Unit，算术逻辑运算单元，为运算器的核心部件，其功能是进行算术、逻辑运算。<br>ACC：Accumulator，累加器，是运算器中既能存放运算前的操作数，又能存放运算结果的寄存器。<br>MQ：Multiplier-Quotient Register，乘商寄存器，乘法运算时存放乘数、除法时存放商的寄存器。<br>MAR：Memory Address Register，存储器地址寄存器，在主存中用来存放欲访问的存储单元的地址。<br>MDR：Memory Data Register，存储器数据缓冲寄存器，在主存中用来存放从某单元读出、或要写入某存储单元的数据。<br>I/O：Input/Output equipment，输入/输出设备，为输入设备和输出设备的总称，用于计算机内部和外界信息的转换与传送。</p>
<p>MIPS：Million Instruction Per Second，每秒执行百万条指令数，为计算机运算速度指标的一种计量单位。</p>
<p>CPI：执行一条指令所需的时钟周期（机器主频的倒数)。</p>
<p>FLOPS：浮点运算次数每秒。</p>
<h2 id="主存储器"><a href="#主存储器" class="headerlink" title="主存储器"></a>主存储器</h2><ul>
<li>汉明码</li>
</ul>
<ol>
<li>汉明码要添加 检测位要满足 2 ^k &gt;= n + k +1 k位检测位 ， n为总位数</li>
<li>检测位放在 2 ^i  次方处 i = 0 , 1 , ……</li>
</ol>
<h2 id="进制字母表示"><a href="#进制字母表示" class="headerlink" title="进制字母表示"></a>进制字母表示</h2><p>十进制数用D表示，二进制用B表示，十六进制数用H表示，八进制用O表示。</p>
<h2 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h2><p>命中率： 访问成功次数 / 总访问次数<br>命中率与Cache 的容量和块长有关<br>访问效率 = 访问Cache 的时间 / 平均访问时间   * 100 %<br>e 访问效率 ， h 命中率， 访问Cache 时间为tc 访问主存时间为tm<br>则 e = tc / h * tc   + ( 1 - h) * t    * 100%<br>访问时间 / 命中的时间 + 未命中的时间</p>
<ul>
<li>读写操作 <ul>
<li>写 ： 1. 写直达法 ： 写时同时写入Cache和主存</li>
<li><ol start="2">
<li>写回法： 只写入Cache 不写入内存，当Cache数据被替换出去的时候才写会主存，会导致Cache和主存的不一致</li>
</ol>
</li>
</ul>
</li>
<li>地址映射<ol>
<li>直接映射 Cache任意一块可以放在</li>
<li>全相联映射  主存任何一块可以放在Cache任意一块中</li>
<li></li>
</ol>
</li>
</ul>
<h2 id="DMA"><a href="#DMA" class="headerlink" title="DMA"></a>DMA</h2><ol start="3">
<li>DMA和 CPU交替访问<br> CPU工作周期  C1 专供DMA访存，C2专攻CPU访存</li>
</ol>
<ul>
<li>功能：<ol>
<li>向CPU申请DMA传送</li>
<li>处理总线控制权的转交</li>
<li>管理系统总线，控制数据传输</li>
<li>确定数据传送的首地址和长度，修正传送过程中的数据和长度</li>
<li>DMA传送结束时，给出操作完成的信号</li>
</ol>
</li>
</ul>
<h2 id="数"><a href="#数" class="headerlink" title="数"></a>数</h2><p>浮点数： 阶码组成为 阶符 + 数值部分   尾数由数符和数值组成<br>阶码是用二进制来表示的比如<br>2 ^15<br>就是 2 ^1111<br>即可，所以要用四位二进制来表示</p>
<ul>
<li>规格化<br>基数为<br>2  要求尾数最高位为 1  2 ^1<br>4                 最高2位为1  2 ^2</li>
</ul>
<p>8                 最高3位为 1  2 ^3</p>
<p>左规，数据左移，尾数变大<br>小数转二进制，直接把分子写成二进制，然后根据分母是2的多少次方，移动小数点就行了</p>
<ul>
<li><p>IEEE 754标准<br>数符 + 阶码(含阶符) 尾数<br>尾数使用规格化表示，非 0 的有效位最高位为1</p>
</li>
<li><p>运算<br>补码 左移时，后面加0 ， 右移时前面加 1<br>定点数运算：</p>
</li>
</ul>
<ol>
<li>补码加减运算，直接 A + B  mod 2 ^n+1</li>
<li>小数 就mod 2</li>
</ol>
<h2 id="指令系统"><a href="#指令系统" class="headerlink" title="指令系统"></a>指令系统</h2><ul>
<li>指令格式 ： 操作码 + 地址码+寻址方式<br>指令字长分为可变和固定字长<br>RISC 精简指令系统<br>长度可变的指令：操作码分散在指令字的不同字段中</li>
<li>地址码</li>
</ul>
<ol>
<li>四地址    op + A1 + A2 + A3 + A4  分别是第一操作数地址，第二操作数地址，结果地址，下一条指令地址  (A1) OP(A2) –&gt; A3</li>
<li>三地址  OP A1 A2 A3   </li>
<li>二地址   OP A1 A2    (A1) OP (A2) –&gt; A1 或者 (A1) OP(A2) -&gt; A2</li>
<li>一地址 OP A1     (ACC) OP (A1) -&gt; A1  ACC暂存</li>
<li>零地址，对ACC中的数据进行操作<br>可以使用寄存器地址来替代指令地址字段，因为寄存器很少，占用的位数少</li>
</ol>
<ul>
<li>指令寻址<br>顺序 PC + 1 -&gt; PC<br>跳跃 由转移指令给出<br>数据寻址： 操作码 + 寻址特征+ 形式地址A<br>形式地址 是指令字中的地址，有效地址是操作数的真实地址</li>
</ul>
<ol>
<li>立即寻址： 形式地址A就是操作数，OP # A   # 为立寻址标志 A 使用补码</li>
<li>直接寻址，EA = A 有效地址由形式地址给出，无偏移量</li>
<li>隐含寻址 间接寻址 有效地址由形式地址简介提供，A提供的是EA 的地址，需要去寻址，EA 的地址才是指向真实的数据</li>
<li>寄存器寻址，EA = Ri 有效地址为寄存器的编号</li>
<li>寄存器间接寻址： EA = (Ri) 有效地址在寄存器中</li>
</ol>
<ul>
<li>基址寻址<ol>
<li>使用专用寄存器作为基址寄存器<br> EA = (BR) + A BR 为基址寄存器，也就是 物理地址 = 逻辑地址 + 基址地址</li>
</ol>
</li>
</ul>
<h2 id="CPU-组成"><a href="#CPU-组成" class="headerlink" title="CPU 组成"></a>CPU 组成</h2><ul>
<li>寄存器<ol>
<li>通用寄存器 ： 存放操作数，可作为某中寻址方式的专用寄存器</li>
<li>数据寄存器：存放操作数，两个寄存器拼接放双倍字长的数据</li>
<li>地址寄存器： 存放地址</li>
<li>条件码寄存器： 存放条件码，可作为程序分支的依据，正负,0，溢出等</li>
<li>控制和状态寄存器： <ul>
<li>控制寄存器 PC -&gt; MAR -&gt; M -&gt; MDR -&gt; IR</li>
<li>PC用户可见</li>
<li>状态寄存器 存放条件码</li>
<li>PSW 存放程序状态字</li>
</ul>
</li>
</ol>
</li>
<li>指令周期 ： 取出并执行一条指令所需的全部时间</li>
<li>包括 取指，分析 =&gt; 取指周期  执行=&gt;执行周期</li>
</ul>
<p>流水线</p>
<ul>
<li>吞吐率： 单位时间内流水线所完成执行或输出结果的数量</li>
<li>最大吞吐率: Tpmax = 1 / Δt Δt为m段流水线各段时间</li>
<li>加速比 ： <ul>
<li>使用流水线的方式完成n条指令在m段流水线上共需 T = m * t + (n-1) * t   </li>
<li>使用等效的非流水线共需： T =  nmt</li>
<li>加速比等于  不使用 / 使用</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zuofw.github.io/2023/10/11/58/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="QingQiu">
      <meta itemprop="description" content="个人网站，学习记录，面试记录和经验总结、互联网中一块属于自己的小窝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="QingQiu'Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/10/11/58/" class="post-title-link" itemprop="url">人事</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-10-11 14:29:58" itemprop="dateCreated datePublished" datetime="2023-10-11T14:29:58+08:00">2023-10-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-11-16 09:01:22" itemprop="dateModified" datetime="2023-11-16T09:01:22+08:00">2023-11-16</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>5.6k</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="简单的增删改查练习"><a href="#简单的增删改查练习" class="headerlink" title="简单的增删改查练习"></a>简单的增删改查练习</h1><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><pre class="line-numbers language-none"><code class="language-none">## 服务器
给nginx设置负载均衡即可
## 具体编码
1. BeanUtils的使用
2. DigestUtils md5加密



- 一些借鉴
jwt拦截器,md5加密，全局错误处理，ThreadLocal 进行线程内部传递变量

PageHelper分页
```java
//设置分页和分页大小
    PageHelper.startPage(employeePageQueryDTO.getPage(), employeePageQueryDTO.getPageSize());
//进行查询
    Page&lt;Employee&gt; page = employeeMapper.pageQuery(employeePageQueryDTO);//后续定义
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>xml中的mapper示例:</p>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>pageQuery<span class="token punctuation">"</span></span> <span class="token attr-name">resultType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.sky.entity.Employee<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
        select * from employee
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>where</span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>if</span> <span class="token attr-name">test</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>name != null and name != ''<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
                and name like concat('%',#{name},'%')
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>if</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>where</span><span class="token punctuation">&gt;</span></span>
        order by create_time desc
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>对于时间格式的全局管理，在mvcconfig中</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">extendMessageConverters</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">HttpMessageConverter</span><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> converters<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"扩展消息转换器..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//创建一个消息转换器对象</span>
    <span class="token class-name">MappingJackson2HttpMessageConverter</span> converter <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MappingJackson2HttpMessageConverter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//需要为消息转换器设置一个对象转换器，对象转换器可以将Java对象序列化为json数据</span>
    converter<span class="token punctuation">.</span><span class="token function">setObjectMapper</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">JacksonObjectMapper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//将自己的消息转化器加入容器中</span>
    converters<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span>converter<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li><p>aop</p>
</li>
<li><p>Apache POI 来进行文件格式转换，导出为excel</p>
</li>
<li><p>Apache ECharts 可视化图表</p>
</li>
<li><p><strong>Spring Task</strong> 定时任务</p>
</li>
<li><p>HttpClient<br><strong>HttpClient的核心API：</strong></p>
</li>
<li><p>HttpClient：Http客户端对象类型，使用该类型对象可发起Http请求。</p>
</li>
<li><p>HttpClients：可认为是构建器，可创建HttpClient对象。</p>
</li>
<li><p>CloseableHttpClient：实现类，实现了HttpClient接口。</p>
</li>
<li><p>HttpGet：Get方式请求类型。</p>
</li>
<li><p>HttpPost：Post方式请求类型。</p>
</li>
</ul>
<p><strong>HttpClient发送请求步骤：</strong></p>
<ul>
<li><p>创建HttpClient对象</p>
</li>
<li><p>创建Http请求对象</p>
</li>
<li><p>调用HttpClient的execute方法发送请求</p>
</li>
</ul>
<h1 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h1><p>学生管理系统</p>
<p>一．功能要求</p>
<ul>
<li><p>添加学生功能：姓名、学号、性别、出生年月日。（学号自动生成且唯一）</p>
</li>
<li><p>添加学生成绩功能：每个人都有数学、Java、英语、体育四门课，可分课程输入成绩。</p>
</li>
<li><p>根据学生学号查找学生成绩功能：在界面上显示姓名、学号和成绩，学号不存在的能给出提示信息。</p>
</li>
<li><p>根据学生姓名（支持模糊匹配）查找学生成绩功能：并在界面上显示姓名、学号和成绩，如果有多个相同姓名学生存在，一起显示出来，姓名不存在的给出提示信息。</p>
</li>
<li><p>支持对单个学生各科成绩画出柱状分布图。</p>
</li>
<li><p>学生信息的修改与删除功能：不能修改学号。</p>
</li>
<li><p>生成学生学习情况报表功能：报表包含学号、姓名、各科目成绩及对应的该科目班级平均值，总成绩以及班级总成绩平均值，并将该排序结果输出至excel文件。</p>
</li>
</ul>
<h2 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h2><ol>
<li>admin<pre class="line-numbers language-css" data-language="css"><code class="language-css">id
username 
password<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li>
<li>student<pre class="line-numbers language-css" data-language="css"><code class="language-css">id <span class="token punctuation">(</span>学号自动生成且唯一<span class="token punctuation">)</span>
name
birthday<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li>
<li>score<pre class="line-numbers language-css" data-language="css"><code class="language-css">id
Math
Java
English
PE<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
sql设计</li>
</ol>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">DATABASE</span> management<span class="token punctuation">;</span>
<span class="token keyword">USE</span> management<span class="token punctuation">;</span>
<span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> admin<span class="token punctuation">(</span>
    Id <span class="token keyword">INT</span> <span class="token keyword">AUTO_INCREMENT</span> <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span><span class="token punctuation">,</span>
    Username <span class="token keyword">char</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
    Password <span class="token keyword">char</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span>
<span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8<span class="token punctuation">;</span>

<span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> student<span class="token punctuation">(</span>
    Id <span class="token keyword">INT</span> <span class="token keyword">AUTO_INCREMENT</span> <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span><span class="token punctuation">,</span>
    StudentId <span class="token keyword">char</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">UNIQUE</span><span class="token punctuation">,</span>
    StudentName <span class="token keyword">char</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
    Birthday <span class="token keyword">date</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> score<span class="token punctuation">(</span>
    Id <span class="token keyword">INT</span> <span class="token keyword">AUTO_INCREMENT</span> <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span><span class="token punctuation">,</span>
    Math <span class="token keyword">DOUBLE</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
    Java <span class="token keyword">DOUBLE</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
    English <span class="token keyword">DOUBLE</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
    PE <span class="token keyword">DOUBLE</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>ps: 使用方式 mysql -u username -p  &lt;  xxx.sql ，之后输入密码即可</p>
<p>xml配置<br>druid<br>knife4j生成接口文档</p>
<ul>
<li>部署<br>服务器配置:<br>mysql<br>将服务器上的mysql配置文件修改<pre class="line-numbers language-css" data-language="css"><code class="language-css">vim /etc/mysql/mysql.conf.d/mysqld.cnf
将bind-address 的127.0.0.1 改为  0.0.0.0 
服务器开放端口 3306<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
redis<br>1.打开redis的配置文件“redis.conf”。</li>
</ul>
<p>2.将“bind 127.0.0.1”注释掉。</p>
<p>3.将“protected-mode yes”改成“protected-mode no”。</p>
<p>4.添加以下一行代码。</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">daemonize no<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>复制</p>
<p>5.重启redis服务即可<br><code>sudo service redis restart</code></p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>knif4j注意设置好扫描的包</p>
<h2 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h2><ol>
<li>common module<ol>
<li>返回类封装Result</li>
<li>pageHelper所需的分页参数</li>
</ol>
</li>
<li></li>
</ol>
<h1 id="苍穹外卖项目"><a href="#苍穹外卖项目" class="headerlink" title="苍穹外卖项目"></a>苍穹外卖项目</h1><p>仓库： 已完成 <a target="_blank" rel="noopener" href="https://github.com/qiuEly/sky-take-out">https://github.com/qiuEly/sky-take-out</a></p>
<h2 id="知识"><a href="#知识" class="headerlink" title="知识"></a>知识</h2><ol>
<li>当前端传输的数据与实体类差距比较大时使用DTO来封装</li>
<li><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93/2987565?fromModule=lemma_inlink">数据传输</a>对象（DTO）(Data Transfer Object)，是一种<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/1212549?fromModule=lemma_inlink">设计模式</a>之间传输数据的软件<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F/56497111?fromModule=lemma_inlink">应用系统</a>。数据传输目标往往是<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE%E5%AF%B9%E8%B1%A1/3351868?fromModule=lemma_inlink">数据访问对象</a>从数据库中检索数据。数据传输对象与数据交互对象或数据访问对象之间的差异是一个以不具有任何行为除了存储和检索的数据（访问和存取器）。</li>
<li>ThreadLocal 不是一个线程，但是可以用于保存Thread的一个变量，相当于设置线程内部的变量，可以用来存token和cookie</li>
<li>mybatis-plus 分页插件的使用，并且配合queryWrapper来封装自定义查询</li>
<li>使用配置jackson和java格式互相转化器</li>
<li>‘ALTER TABLE table_name AUTO_INCREMENT = value;’  记得删除没有用的数据之后并且让value大于当前的行数</li>
<li>mp 实现递增需要在配置文件中加上 ‘mybatis-plus:<br>global-config:<br>db-config:<br>id-type: auto’</li>
<li>自定义注解： <ol>
<li><p><strong><code>@Target</code> 注解</strong>：</p>
<p> @Target注解：</p>
<ul>
<li>作用：<code>@Target</code> 注解用于指定可以将注解应用到的元素类型。它决定了注解可以用于标记哪些程序元素，例如类、方法、字段等。</li>
<li>参数：<code>@Target</code> 的参数是一个 <code>ElementType</code> 枚举数组，你可以在其中指定一个或多个目标元素类型。对于 <code>@ComponentScan</code> 来说，<code>@Target(ElementType.TYPE)</code> 表示该注解可以用于标记类。</li>
</ul>
</li>
<li><p><strong><code>@Retention</code> 注解</strong>：</p>
<ul>
<li>作用：<code>@Retention</code> 注解用于指定注解在编译后是否保留到运行时，并且是否可以通过反射访问注解。有三个可能的 <code>RetentionPolicy</code> 值：<code>SOURCE</code>、<code>CLASS</code> 和 <code>RUNTIME</code>。</li>
<li>参数：<code>@Retention</code> 的参数是一个 <code>RetentionPolicy</code> 枚举值。<code>@Retention(RetentionPolicy.RUNTIME)</code> 表示注解会在运行时保留，并可以通过反射访问。</li>
</ul>
</li>
<li><p><strong><code>@Documented</code> 注解</strong>：</p>
<ul>
<li>作用：<code>@Documented</code> 注解用于指示该注解应该包含在生成的文档中。如果你想要将注解的信息包含在 Java 文档中，可以使用 <code>@Documented</code> 注解。</li>
<li>参数：<code>@Documented</code> 注解没有参数，它只是一个标记注解，用于指示文档工具要包括注解信息。</li>
</ul>
</li>
</ol>
</li>
<li>阿里云oss使用，主要使用的是spring 中的MultipartFile </li>
<li>Redis的使用</li>
<li>通过给RestController设置标识名来防止依赖注入无法识别相同名称的Bean</li>
<li>vivo50<blockquote>
<p><strong>HttpClient的核心API：</strong></p>
</blockquote>
</li>
</ol>
<ul>
<li><p>HttpClient：Http客户端对象类型，使用该类型对象可发起Http请求。</p>
</li>
<li><p>HttpClients：可认为是构建器，可创建HttpClient对象。</p>
</li>
<li><p>CloseableHttpClient：实现类，实现了HttpClient接口。</p>
</li>
<li><p>HttpGet：Get方式请求类型。</p>
</li>
<li><p>HttpPost：Post方式请求类型。</p>
</li>
</ul>
<p><strong>HttpClient发送请求步骤：</strong></p>
<ul>
<li><p>创建HttpClient对象</p>
</li>
<li><p>创建Http请求对象</p>
</li>
<li><p>调用HttpClient的execute方法发送请求<br>用例：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>sky<span class="token punctuation">.</span>test</span><span class="token punctuation">;</span>

<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>http<span class="token punctuation">.</span></span><span class="token class-name">HttpEntity</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>http<span class="token punctuation">.</span>client<span class="token punctuation">.</span>methods<span class="token punctuation">.</span></span><span class="token class-name">CloseableHttpResponse</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>http<span class="token punctuation">.</span>client<span class="token punctuation">.</span>methods<span class="token punctuation">.</span></span><span class="token class-name">HttpGet</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>http<span class="token punctuation">.</span>impl<span class="token punctuation">.</span>client<span class="token punctuation">.</span></span><span class="token class-name">CloseableHttpClient</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>http<span class="token punctuation">.</span>impl<span class="token punctuation">.</span>client<span class="token punctuation">.</span></span><span class="token class-name">HttpClients</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>http<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">EntityUtils</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>junit<span class="token punctuation">.</span>jupiter<span class="token punctuation">.</span>api<span class="token punctuation">.</span></span><span class="token class-name">Test</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>test<span class="token punctuation">.</span>context<span class="token punctuation">.</span></span><span class="token class-name">SpringBootTest</span></span><span class="token punctuation">;</span>

<span class="token annotation punctuation">@SpringBootTest</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HttpClientTest</span> <span class="token punctuation">{</span>

    <span class="token comment">/**
     * 测试通过httpclient发送GET方式的请求
     */</span>
    <span class="token annotation punctuation">@Test</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testGET</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span><span class="token punctuation">{</span>
        <span class="token comment">//创建httpclient对象</span>
        <span class="token class-name">CloseableHttpClient</span> httpClient <span class="token operator">=</span> <span class="token class-name">HttpClients</span><span class="token punctuation">.</span><span class="token function">createDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">//创建请求对象</span>
        <span class="token class-name">HttpGet</span> httpGet <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HttpGet</span><span class="token punctuation">(</span><span class="token string">"http://localhost:8080/user/shop/status"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">//发送请求，接受响应结果</span>
        <span class="token class-name">CloseableHttpResponse</span> response <span class="token operator">=</span> httpClient<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>httpGet<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">//获取服务端返回的状态码</span>
        <span class="token keyword">int</span> statusCode <span class="token operator">=</span> response<span class="token punctuation">.</span><span class="token function">getStatusLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getStatusCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"服务端返回的状态码为："</span> <span class="token operator">+</span> statusCode<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">HttpEntity</span> entity <span class="token operator">=</span> response<span class="token punctuation">.</span><span class="token function">getEntity</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">String</span> body <span class="token operator">=</span> <span class="token class-name">EntityUtils</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>entity<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"服务端返回的数据为："</span> <span class="token operator">+</span> body<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">//关闭资源</span>
        response<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        httpClient<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
<ol start="13">
<li>spring cache<br>在SpringCache中提供了很多缓存操作的注解，常见的是以下的几个：</li>
</ol>
<table>
<thead>
<tr>
<th><strong>注解</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>@EnableCaching</td>
<td>开启缓存注解功能，通常加在启动类上</td>
</tr>
<tr>
<td>@Cacheable</td>
<td>在方法执行前先查询缓存中是否有数据，如果有数据，则直接返回缓存数据；如果没有缓存数据，调用方法并将方法返回值放到缓存中</td>
</tr>
<tr>
<td>@CachePut</td>
<td>将方法的返回值放到缓存中</td>
</tr>
<tr>
<td>@CacheEvict</td>
<td>将一条或多条数据从缓存中删除</td>
</tr>
</tbody></table>
<p>在spring boot项目中，使用缓存技术只需在项目中导入相关缓存技术的依赖包，并在启动类上使用@EnableCaching开启缓存支持即可。</p>
<ol start="14">
<li>spring task 定时任务</li>
<li>websocket<br>WebSocket 是基于 TCP 的一种新的<strong>网络协议</strong>。它实现了浏览器与服务器全双工通信——浏览器和服务器只需要完成一次握手，两者之间就可以创建<strong>持久性</strong>的连接， 并进行<strong>双向</strong>数据传输。</li>
</ol>
<p><strong>HTTP协议和WebSocket协议对比：</strong></p>
<ul>
<li><p>HTTP是<strong>短连接</strong></p>
</li>
<li><p>WebSocket是<strong>长连接</strong></p>
</li>
<li><p>HTTP通信是<strong>单向</strong>的，基于请求响应模式</p>
</li>
<li><p>WebSocket支持<strong>双向</strong>通信</p>
</li>
<li><p>HTTP和WebSocket底层都是TCP连接</p>
</li>
</ul>
<ol start="16">
<li>Apache ECharts</li>
<li>Apache POI</li>
<li>部署！！！</li>
</ol>
<ul>
<li>build过程中出现检测问题 <a target="_blank" rel="noopener" href="https://www.cnblogs.com/SparkMore/p/15919302.html">https://www.cnblogs.com/SparkMore/p/15919302.html</a></li>
</ul>
<ol start="19">
<li>当springboot项目不识别application配置文件时，右键resource -&gt; Mark Directory as &gt; Resources Root</li>
</ol>
<h2 id="修改建议Todo"><a href="#修改建议Todo" class="headerlink" title="修改建议Todo:"></a>修改建议Todo:</h2><ol>
<li>密码加密 使用 security + jwt ，前端保存session</li>
<li>微信小程序开发 + 前端 vue </li>
<li>docker环境下使用</li>
</ol>
<h1 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h1><ol>
<li>admin 界面来管理</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zuofw.github.io/2023/09/30/23/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="QingQiu">
      <meta itemprop="description" content="个人网站，学习记录，面试记录和经验总结、互联网中一块属于自己的小窝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="QingQiu'Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/09/30/23/" class="post-title-link" itemprop="url">blog搭建</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-09-30 10:45:23 / 修改时间：10:49:16" itemprop="dateCreated datePublished" datetime="2023-09-30T10:45:23+08:00">2023-09-30</time>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>43</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h1><p>一次自己blog手动搭建记录<br>技术栈：</p>
<ul>
<li>前端：vue</li>
<li>后端:   express redis</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zuofw.github.io/2023/09/29/36/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="QingQiu">
      <meta itemprop="description" content="个人网站，学习记录，面试记录和经验总结、互联网中一块属于自己的小窝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="QingQiu'Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/09/29/36/" class="post-title-link" itemprop="url">前端学习</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-09-29 20:52:36" itemprop="dateCreated datePublished" datetime="2023-09-29T20:52:36+08:00">2023-09-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-04-14 16:35:32" itemprop="dateModified" datetime="2024-04-14T16:35:32+08:00">2024-04-14</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>6.7k</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><ul>
<li>head中的<ul>
<li>meta的使用，description可以用来记录文章主要内容，方便搜索引擎使用</li>
<li><code>&lt;link rel="icon" href="./favicon.ico"&gt;</code> 引入ico</li>
</ul>
</li>
</ul>
<h1 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h1><p>文件结构:</p>
<ul>
<li>api 存放封装了Ajax的请求文件</li>
<li>components 公共组件存放目录</li>
<li>views 视图组件</li>
<li>App.vue 主组件，入口文件</li>
<li>main.ts 项目的路口文件</li>
<li>router.ts路由文件</li>
</ul>
<h2 id="打包部署在nginx上"><a href="#打包部署在nginx上" class="headerlink" title="打包部署在nginx上"></a>打包部署在nginx上</h2><p>使用npm run build 进行打包，将dist包放在/usr/share/nginx/html<br>即可，然后root路径要写全<br>本地使用vue，基于脚手架安装</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> create vue@latest
<span class="token builtin class-name">cd</span> xxx
<span class="token function">npm</span> <span class="token function">install</span>
<span class="token function">npm</span> run dev<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>基础语法:</li>
<li>v-bind:xxx 绑定语法，可简写为:xxx 如果绑定的是多个值，比如是一个json数组，那么可以把xxx省略留下 v-bind: = aaa</li>
<li>v-on 监听事件 简写为 @xxx 动态绑定事件 <code>@[事件列表] = "事件函数"</code></li>
<li><code>&lt;template&gt;</code> 不会被渲染，一般作为v-if根</li>
<li>第三个参数表示位置索引：<pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;li v-for="(value, key, index) in myObject"&gt;
  {{ index }}. {{ key }}: {{ value }}
&lt;/li&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li>
<li>setup是在建立渲染之前就会调用</li>
<li>想要使用变量就必须要把变量return 出来即可</li>
<li>使用语法糖可以简化代码，不需要一个个return了<pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;script setup&gt;  
   const msg = 'Hello Vite + Vue 3!'  
&lt;/script&gt;  
&lt;template&gt;  
  &lt;div id="app"&gt;  
    &lt;h1&gt;{{msg}}&lt;/h1&gt;  
  &lt;/div&gt;&lt;/template&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li>使用reactive函数来返回一个响应式对象<pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;script setup&gt;  
   import {reactive} from "vue";  
   const state = reactive({  
     msg: "hell world"  
   })  
   const setState = ()=&gt;{  
     state.msg = "hello vite"  
   }  
&lt;/script&gt;  
&lt;template&gt;  
  {{state.msg}}  
  &lt;button @click="setState"&gt;click&lt;/button&gt;  
&lt;/template&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li>使用ref来返回一个简单响应式对象<pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;script setup&gt;  
    import {ref} from "vue";  
    const msg = ref(0);  
&lt;/script&gt;  
&lt;template&gt;  
  &lt;div id="app"&gt;  
    &lt;button @click="msg++"&gt;count is: {{ msg }}&lt;/button&gt;  
  &lt;/div&gt;&lt;/template&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li>computed对象函数，里面传进去计算逻辑<pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;script setup&gt;  
import {computed, ref} from "vue";  
  const list = ref([1,2,3,4,5]);  
  const filterlist = computed(()=&gt;{  
    return list.value.filter(item=&gt;item&gt;3)  
  })  
&lt;/script&gt;  
&lt;template&gt;  
  &lt;div&gt;    &lt;ul&gt;      &lt;li v-for="item in filterlist" :key="item"&gt;{{item}}&lt;/li&gt;  
    &lt;/ul&gt;  &lt;/div&gt;&lt;/template&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li>watch 监听数据的变化，如果数据变化就执行回调函数，剩下两个参数，immediate 控制立刻执行，deep开启深度监听<ul>
<li>监听一个  <pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">	&lt;script setup&gt;  
import {ref, watch} from "vue";  
const count = ref(0);  
watch(count,(newCount, oldCount) =&gt; {  
  console.log(`new count is: ${newCount}, old count is: ${oldCount}`)  
})  
const increment = () =&gt; {  
  count.value++;  
}  
&lt;/script&gt;  
&lt;template&gt;  
&lt;button @click="increment"&gt;count is: {{count}}&lt;/button&gt;  
&lt;/template&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li>监听多个数据，只需要把参数化成数组即可<pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">watch([count, name], ([newCount, newName],[oldCount,oldName])=&gt;</span><span class="token punctuation">{</span>
  console.<span class="token function">log</span><span class="token punctuation">(</span>`count或者name变化了，[newCount<span class="token punctuation">,</span> newName]<span class="token punctuation">,</span>[oldCount<span class="token punctuation">,</span>oldName]<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li>
</ul>
</li>
<li>immediate 在创建时立刻出发<pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">watch(count, (newValue, oldValue)=&gt;</span><span class="token punctuation">{</span>
   <span class="token selector">console.log(`count发生了变化，老值为$</span><span class="token punctuation">{</span>oldValue<span class="token punctuation">}</span><span class="token selector">,新值为$</span><span class="token punctuation">{</span>newValue<span class="token punctuation">}</span>`<span class="token punctuation">)</span>
 <span class="token punctuation">}</span><span class="token selector">,</span><span class="token punctuation">{</span>
   <span class="token property">immediate</span><span class="token punctuation">:</span> true
 <span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li>deep通过watch监听的ref对象是浅层监听的，直接修改嵌套的对象属性是不会回调的，但是开启之后就可以回调了<pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;script setup&gt;
  // 1. 导入watch
  import { ref, watch } from 'vue'
  const state = ref({ count: 0 })
  // 2. 监听对象state
  watch(state, ()=&gt;{
    console.log('数据变化了')
  })
  const changeStateByCount = ()=&gt;{
    // 直接修改不会引发回调执行
    state.value.count++
  }
&lt;/script&gt;

&lt;script setup&gt;
  // 1. 导入watch
  import { ref, watch } from 'vue'
  const state = ref({ count: 0 })
  // 2. 监听对象state 并开启deep
  watch(state, ()=&gt;{
    console.log('数据变化了')
  },{deep:true})
  const changeStateByCount = ()=&gt;{
    // 此时修改可以触发回调
    state.value.count++
  }
&lt;/script&gt;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li>父组件传值给子组件: 1.引入子组件，使用子组件并绑定子组件中props中的属性 2. 子组件使用defineProps来接受父组件的传值<pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">父组件
&lt;script setup&gt;  
import son from './components/money.vue'  
&lt;/script&gt;  
  
&lt;template&gt;  
  &lt;son  message="hello world"/&gt;  
&lt;/template&gt;
&lt;!--子组件--&gt;
&lt;script setup&gt;  
const props =  defineProps({  
  message : String  
})  
&lt;/script&gt;  
&lt;template&gt;  
  {{message}}  
&lt;/template&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li>子组件传值给父组件: 1.子组件通过defineEmits来生成emit方法 2.子组件使用emit定义事件，并传递参数 3.父组件使用绑定子组件的事件，并绑定自己的函数，定义自己的函数使用传递的值<pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">子组件
&lt;script setup&gt;  
const props =  defineProps({  
  message : String  
})  
const emit = defineEmits(['say']) //事件列表  
const hh = ()=&gt;{  
  emit('say','hello world')  
}  
&lt;/script&gt;  
&lt;template&gt;  
  {{message}}  
  &lt;button @click="hh"&gt;click&lt;/button&gt;  
&lt;/template&gt;
父组件
&lt;script setup&gt;  
import son from './components/money.vue'  
const func = (msg,num)=&gt;{  
  console.log(msg,num)  
}  
&lt;/script&gt;  
&lt;template&gt;  
  &lt;son  messoage="hello world" @say="func"/&gt;  
&lt;/template&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li>模板使用 新建一个ref 然后在 html 中的ref来进行绑定这个ref即可获得dom元素，但是会在onmounted之后才能访问</li>
<li>父组件默认不会获得子组件的dom因为有setup 所以可以使用<pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">defineExpose({
	需要暴漏的属性和方法名或者一个匿名函数
})<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li>
<li>通过provide和inject来跨层传递<pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">顶层
provide('key',value) value可以是函数等
底层
const value = inject('key')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li>
<li>v-text 来更新文本内容，v-html来更新html元素</li>
</ul>
<h1 id="Express"><a href="#Express" class="headerlink" title="Express"></a>Express</h1><p>支持前后端分离的简单框架</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> express-generator <span class="token parameter variable">-g</span>
express --no-view server 新建项目
<span class="token builtin class-name">cd</span> server
<span class="token function">npm</span> <span class="token function">install</span>
ET DEBUG <span class="token operator">=</span> server:* <span class="token operator">&amp;</span> <span class="token function">npm</span> start 开启服务<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">user www-data<span class="token punctuation">;</span>
worker_processes auto<span class="token punctuation">;</span>
pid /run/nginx.pid<span class="token punctuation">;</span>
include /etc/nginx/modules-enabled/*.conf<span class="token punctuation">;</span>

events <span class="token punctuation">{</span>
        worker_connections <span class="token number">768</span><span class="token punctuation">;</span>
        <span class="token comment"># multi_accept on;</span>


        <span class="token comment">##自定义服务列表</span>

<span class="token punctuation">}</span>
http <span class="token punctuation">{</span>
        <span class="token comment">##</span>

        sendfile on<span class="token punctuation">;</span>
        tcp_nopush on<span class="token punctuation">;</span>
        types_hash_max_size <span class="token number">2048</span><span class="token punctuation">;</span>
        <span class="token comment"># server_tokens off;</span>

        <span class="token comment"># server_names_hash_bucket_size 64;</span>
        <span class="token comment"># server_name_in_redirect off;</span>

        include /etc/nginx/mime.types<span class="token punctuation">;</span>
        default_type application/octet-stream<span class="token punctuation">;</span><span class="token builtin class-name">.</span>
         ssl_protocols TLSv1 TLSv1.1 TLSv1.2 TLSv1.3<span class="token punctuation">;</span> <span class="token comment"># Dropping SSLv3, ref: POODLE</span>
        ssl_prefer_server_ciphers on<span class="token punctuation">;</span>

        <span class="token comment">##</span>
        <span class="token comment"># Logging Settings</span>
        <span class="token comment">##</span>

        access_log /var/log/nginx/access.log<span class="token punctuation">;</span>
        error_log /var/log/nginx/error.log<span class="token punctuation">;</span>

        <span class="token comment">##</span>
        <span class="token comment"># Gzip Settings</span>
        <span class="token comment">##</span>

        <span class="token function">gzip</span> on<span class="token punctuation">;</span>

        <span class="token comment"># gzip_vary on;</span>
        <span class="token comment"># gzip_proxied any;</span>
        <span class="token comment"># gzip_comp_level 6;</span>
        <span class="token comment"># gzip_buffers 16 8k;</span>
        <span class="token comment"># gzip_http_version 1.1;</span>
        <span class="token comment"># gzip_types text/plain text/css application/json application/javascript text/xml application/xml application/xml+rss text/javascript;</span>

        <span class="token comment">##</span>
        <span class="token comment"># Virtual Host Configs</span>
        <span class="token comment">##</span>
          include /etc/nginx/conf.d/*.conf<span class="token punctuation">;</span>
        include /etc/nginx/sites-enabled/*<span class="token punctuation">;</span>



<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h1><ul>
<li><p>进度条</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> ProgressBar <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'progress'</span><span class="token punctuation">)</span>  
<span class="token keyword">const</span> bar <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ProgressBar</span><span class="token punctuation">(</span><span class="token string">':bar'</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token literal-property property">total</span><span class="token operator">:</span><span class="token number">100</span><span class="token punctuation">}</span><span class="token punctuation">)</span>  
<span class="token keyword">const</span> timer <span class="token operator">=</span>  <span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>  
    bar<span class="token punctuation">.</span><span class="token function">tick</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  
    <span class="token keyword">if</span> <span class="token punctuation">(</span>bar<span class="token punctuation">.</span>complete<span class="token punctuation">)</span><span class="token punctuation">{</span>  
        <span class="token function">clearInterval</span><span class="token punctuation">(</span>timer<span class="token punctuation">)</span>  
    <span class="token punctuation">}</span>  
<span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token number">100</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><p>文件操作  require(‘fs’)</p>
</li>
<li><p>网络开发</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> net <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'net'</span><span class="token punctuation">)</span>  
<span class="token keyword">const</span> server <span class="token operator">=</span> net<span class="token punctuation">.</span><span class="token function">createServer</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">c</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>  
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'客户端已连接'</span><span class="token punctuation">)</span>  
    c<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'end'</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>  
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'断开连接'</span><span class="token punctuation">)</span>  
    <span class="token punctuation">}</span><span class="token punctuation">)</span>  
<span class="token punctuation">}</span><span class="token punctuation">)</span>  
server<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'error'</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token parameter">err</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>  
    <span class="token keyword">throw</span> err  
<span class="token punctuation">}</span><span class="token punctuation">)</span>  
server<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">8124</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>  
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'服务器已启动'</span><span class="token punctuation">)</span>  
<span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>on来绑定事件</p>
</li>
<li><p>udp 使用dgram模块</p>
</li>
<li><p>WebSocket 使用 ws模块，是对socket的具体实现</p>
</li>
<li><p>socket.io框架</p>
</li>
<li><p>常用api<br><img src="/2023/09/29/36/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/2.jpg"><br><img src="/2023/09/29/36/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/1.jpg"></p>
</li>
<li><p>express框架</p>
</li>
<li><p>koa框架</p>
</li>
<li><p>mongoose</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zuofw.github.io/2023/09/19/11/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="QingQiu">
      <meta itemprop="description" content="个人网站，学习记录，面试记录和经验总结、互联网中一块属于自己的小窝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="QingQiu'Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/09/19/11/" class="post-title-link" itemprop="url">软考</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-09-19 20:46:11" itemprop="dateCreated datePublished" datetime="2023-09-19T20:46:11+08:00">2023-09-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-03-20 14:58:42" itemprop="dateModified" datetime="2024-03-20T14:58:42+08:00">2024-03-20</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>918</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="软件工程"><a href="#软件工程" class="headerlink" title="软件工程"></a>软件工程</h1><p>描述软件需求的方法：</p>
<p>功能层次模型：一般来讲就是系统的功能图，模块分布图等描述整个系统的功能的分布和功能的层次结构；</p>
<p>数据流模型：就是以数据流为着眼点的分析方法得到的模型，主要通过数据在整个系统的流动情况来确定系统的主要功能主线和流程；</p>
<p>控制流模型：通过了解和界定系统中控制线，通过控制流的走向和控制的对象来确定系统的功能分布和控制与被控制的关系；</p>
<p><strong>结构化分析（SA)</strong> 方法是一种面向数据流的需求分析方法，它适用于分析大型数据处理系统。结构化分析方法的基本思想是自顶向下逐层分解，这样做可以把一个大问题分解成若干个小问题，经过多次逐层分解，每个最底层的问题都是足够简单、容易解决的，这个过程就是分解的过程。</p>
<p>结构化方法的分析结果由数据流图DFD、数据词典和加工逻辑说明几个部分组成。其中，DFD的基本成分有数据流（data flow）、加工（process）、文件（file）和源/宿（source/sink）。</p>
<p><strong>结构化设计（SD)</strong> 方法是一种面向数据流的设计方法，它可以与SA方法衔接。</p>
<p>结构化设计采用<strong>结构图（SC）</strong> 来描述程序的结构。其基本成分有模块、调用和输入/输出数据。</p>
<p>结构图：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml32068\wps1.jpg">　 <img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml32068\wps2.jpg"></td>
<td></td>
</tr>
<tr>
<td></td>
<td><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml32068\wps3.jpg"></td>
</tr>
</tbody></table>
<p>条件调用&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;循环调用</p>
<p>&nbsp;&nbsp;&nbsp;在需求分析阶段用SA方法产生了<strong>数据流图（DFD）</strong> 。面向数据流的设计可以方便的将DFD转换成程序结构图。DFD从系统的输入数据流到系统的输出数据流的一连串连续变换形成一条信息流。DFD的信息流大体可分为两种类型：变换流和事务流。与之对应的也存在两种分析，变换分析和事务分析。变换分析是从变换流型的DFD导出程序结构图，而事务分析则是从事务流行型的DFD导出程序结构图。</p>
<p>SD方法的具体设计步骤为：</p>
<p>Ø&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 复查并精化数据流图</p>
<p>Ø&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 确定DFD的信息流类型</p>
<p>Ø&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 根据信息流类型分别将变换流或事务流转换成程序结构图</p>
<p>Ø&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 根据软件设计的原则对程序结构图作改进</p>
<ul>
<li>测试</li>
</ul>
<p>白盒测试是根据程序的内部逻辑来设计测试用例，常用的技术是逻辑覆盖，即考察用例测试数据运行被测程序时对程序逻辑的覆盖程度。主要的覆盖标准有6种： </p>
<p>黑盒测试</p>
<p>黑盒测试时根据规格说明所规定的功能来设计测试用例，它不考虑程序的内部结构和处理过程。常用的黑盒测试技术有：</p>
<p>Ø&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 等价类划分</p>
<p>Ø&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 边值划分</p>
<p>Ø&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 错误猜测</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zuofw.github.io/2023/09/17/02/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="QingQiu">
      <meta itemprop="description" content="个人网站，学习记录，面试记录和经验总结、互联网中一块属于自己的小窝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="QingQiu'Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/09/17/02/" class="post-title-link" itemprop="url">ssm-practice</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-09-17 09:00:02" itemprop="dateCreated datePublished" datetime="2023-09-17T09:00:02+08:00">2023-09-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-08-09 22:10:01" itemprop="dateModified" datetime="2024-08-09T22:10:01+08:00">2024-08-09</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>6.5k</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Springboot练习"><a href="#Springboot练习" class="headerlink" title="Springboot练习"></a>Springboot练习</h1><p>通过atguigu的今日头条项目进行项目驱动式学习<br>前端已准备</p>
<h2 id="后端开发"><a href="#后端开发" class="headerlink" title="后端开发"></a>后端开发</h2><p>要求：后端使用springboot整合mybatis和springmvc来进行简单的增删改查</p>
<ol>
<li>导入依赖:<ul>
<li>springboot启动包，springboot-web项目启动包，mybatis插件，数据库配置启动器springboot-starter-jdbc，druid启动器，mysql驱动类，lombok，aop,test,打包插件</li>
</ul>
</li>
<li>编写配置类:<br>mybatis的配置类可以使用yaml格式或者是properties格式的文件，推荐使用yaml格式的文件，有分层的效果<br>[[Tools#yaml|查看Tools中的yaml]]<br><a target="_blank" rel="noopener" href="https://www.runoob.com/w3cnote/yaml-intro.html">菜鸟教程</a><br><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/current/reference/html/application-properties.html#appendix.application-properties">具体配置</a><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token comment"># server配置</span>
<span class="token key atrule">server</span><span class="token punctuation">:</span>
  <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">8080</span>
  <span class="token key atrule">servlet</span><span class="token punctuation">:</span>
    <span class="token key atrule">context-path</span><span class="token punctuation">:</span> / <span class="token comment">#默认的根路径</span>

<span class="token comment"># 连接池配置</span>
<span class="token key atrule">spring</span><span class="token punctuation">:</span>
  <span class="token key atrule">datasource</span><span class="token punctuation">:</span>
    <span class="token key atrule">type</span><span class="token punctuation">:</span> com.alibaba.druid.pool.DruidDataSource
    <span class="token key atrule">druid</span><span class="token punctuation">:</span>
      <span class="token key atrule">url</span><span class="token punctuation">:</span> jdbc<span class="token punctuation">:</span>mysql<span class="token punctuation">:</span>///sm_db1
      <span class="token key atrule">username</span><span class="token punctuation">:</span> root
      <span class="token key atrule">password</span><span class="token punctuation">:</span> root
      <span class="token key atrule">driver-class-name</span><span class="token punctuation">:</span> com.mysql.cj.jdbc.Driver

<span class="token comment"># mybatis-plus的配置</span>
<span class="token key atrule">mybatis-plus</span><span class="token punctuation">:</span>
  <span class="token key atrule">type-aliases-package</span><span class="token punctuation">:</span> com.atguigu.pojo
  <span class="token key atrule">global-config</span><span class="token punctuation">:</span>
    <span class="token key atrule">db-config</span><span class="token punctuation">:</span>
      <span class="token key atrule">logic-delete-field</span><span class="token punctuation">:</span> isDeleted  <span class="token comment">#全局逻辑删除</span>
      <span class="token key atrule">id-type</span><span class="token punctuation">:</span> auto <span class="token comment">#直接使用springboot来进行配置，就不需要再加上这个注解了</span>
      <span class="token key atrule">table-prefix</span><span class="token punctuation">:</span> news_ <span class="token comment"># 设置表的前缀</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li>druid兼容文件<pre class="line-numbers language-none"><code class="language-none">文件名:
org.springframework.boot.autoconfigure.AutoConfiguration.imports
内容:
com.alibaba.druid.spring.boot3.autoconfigure.DruidDataSourceAutoConfigure<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li>
<li>编写启动类main<br><strong>疑问： 什么是乐观锁和悲观锁</strong><br>配置使用的插件 [[Java#^f13de1]]<br><a target="_blank" rel="noopener" href="https://baomidou.com/pages/2976a3/#%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98-sql-%E8%A7%A3%E6%9E%90">教程</a><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@SpringBootApplication</span>
<span class="token annotation punctuation">@MapperScan</span><span class="token punctuation">(</span><span class="token string">"com.atguigu.mapper"</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">SpringApplication</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token class-name">Main</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">//配置mybatis-plus插件</span>
    <span class="token annotation punctuation">@Bean</span>
    <span class="token keyword">public</span> <span class="token class-name">MybatisPlusInterceptor</span> <span class="token function">mybatisPlusInterceptor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">MybatisPlusInterceptor</span> interceptor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MybatisPlusInterceptor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        interceptor<span class="token punctuation">.</span><span class="token function">addInnerInterceptor</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">PaginationInnerInterceptor</span><span class="token punctuation">(</span><span class="token class-name">DbType</span><span class="token punctuation">.</span><span class="token constant">MYSQL</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//分页</span>
        interceptor<span class="token punctuation">.</span><span class="token function">addInnerInterceptor</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">OptimisticLockerInnerInterceptor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//乐观锁</span>
        interceptor<span class="token punctuation">.</span><span class="token function">addInnerInterceptor</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">BlockAttackInnerInterceptor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//防全局修改和删除</span>
        <span class="token keyword">return</span> interceptor<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li>工具类封装:主要是统一返回结果的类<br> 结果封装类</li>
</ol>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/**
 * 全局统一返回结果类
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Result</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span> <span class="token comment">//T是要使用的泛型，要在这里声明</span>
    <span class="token comment">// 返回码</span>
    <span class="token keyword">private</span> <span class="token class-name">Integer</span> code<span class="token punctuation">;</span>
    <span class="token comment">// 返回消息</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> message<span class="token punctuation">;</span>
    <span class="token comment">// 返回数据</span>
    <span class="token keyword">private</span> <span class="token class-name">T</span> data<span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token class-name">Result</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token comment">// 返回数据</span>
    <span class="token comment">//泛型方法，要将 要使用的泛型在返回类型之前进行声明</span>
    <span class="token keyword">protected</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">Result</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token function">build</span><span class="token punctuation">(</span><span class="token class-name">T</span> data<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Result</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Result</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>data <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
            result<span class="token punctuation">.</span><span class="token function">setData</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> result<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">Result</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token function">build</span><span class="token punctuation">(</span><span class="token class-name">T</span> body<span class="token punctuation">,</span> <span class="token class-name">Integer</span> code<span class="token punctuation">,</span> <span class="token class-name">String</span> message<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Result</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> result <span class="token operator">=</span> <span class="token function">build</span><span class="token punctuation">(</span>body<span class="token punctuation">)</span><span class="token punctuation">;</span>
        result<span class="token punctuation">.</span><span class="token function">setCode</span><span class="token punctuation">(</span>code<span class="token punctuation">)</span><span class="token punctuation">;</span>
        result<span class="token punctuation">.</span><span class="token function">setMessage</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> result<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">Result</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token function">build</span><span class="token punctuation">(</span><span class="token class-name">T</span> body<span class="token punctuation">,</span> <span class="token class-name">ResultCodeEnum</span> resultCodeEnum<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Result</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> result <span class="token operator">=</span> <span class="token function">build</span><span class="token punctuation">(</span>body<span class="token punctuation">)</span><span class="token punctuation">;</span>
        result<span class="token punctuation">.</span><span class="token function">setCode</span><span class="token punctuation">(</span>resultCodeEnum<span class="token punctuation">.</span><span class="token function">getCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        result<span class="token punctuation">.</span><span class="token function">setMessage</span><span class="token punctuation">(</span>resultCodeEnum<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> result<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">/**
     * 操作成功
     * @param data  baseCategory1List
     * @param &lt;T&gt;
     * @return
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">Result</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token function">ok</span><span class="token punctuation">(</span><span class="token class-name">T</span> data<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token class-name">Result</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> result <span class="token operator">=</span> <span class="token function">build</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token function">build</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token class-name">ResultCodeEnum</span><span class="token punctuation">.</span><span class="token constant">SUCCESS</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token class-name">Result</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token function">message</span><span class="token punctuation">(</span><span class="token class-name">String</span> msg<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setMessage</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token class-name">Result</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token function">code</span><span class="token punctuation">(</span><span class="token class-name">Integer</span> code<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setCode</span><span class="token punctuation">(</span>code<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token class-name">Integer</span> <span class="token function">getCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> code<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setCode</span><span class="token punctuation">(</span><span class="token class-name">Integer</span> code<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>code <span class="token operator">=</span> code<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> message<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setMessage</span><span class="token punctuation">(</span><span class="token class-name">String</span> message<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>message <span class="token operator">=</span> message<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token class-name">T</span> <span class="token function">getData</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> data<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setData</span><span class="token punctuation">(</span><span class="token class-name">T</span> data<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>data <span class="token operator">=</span> data<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>解决枚举类<br>枚举类可以使用 常量(具体的常量内容来进行枚举)</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/**
 * 统一返回结果状态信息类
 *
 */</span>
<span class="token keyword">public</span> <span class="token keyword">enum</span> <span class="token class-name">ResultCodeEnum</span> <span class="token punctuation">{</span>

    <span class="token function">SUCCESS</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">,</span><span class="token string">"success"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token function">USERNAME_ERROR</span><span class="token punctuation">(</span><span class="token number">501</span><span class="token punctuation">,</span><span class="token string">"usernameError"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token function">PASSWORD_ERROR</span><span class="token punctuation">(</span><span class="token number">503</span><span class="token punctuation">,</span><span class="token string">"passwordError"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token function">NOTLOGIN</span><span class="token punctuation">(</span><span class="token number">504</span><span class="token punctuation">,</span><span class="token string">"notLogin"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token function">USERNAME_USED</span><span class="token punctuation">(</span><span class="token number">505</span><span class="token punctuation">,</span><span class="token string">"userNameUsed"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">private</span> <span class="token class-name">Integer</span> code<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> message<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">ResultCodeEnum</span><span class="token punctuation">(</span><span class="token class-name">Integer</span> code<span class="token punctuation">,</span> <span class="token class-name">String</span> message<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>code <span class="token operator">=</span> code<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>message <span class="token operator">=</span> message<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token class-name">Integer</span> <span class="token function">getCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> code<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> message<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>MD5加密工具类</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>security<span class="token punctuation">.</span></span><span class="token class-name">MessageDigest</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>security<span class="token punctuation">.</span></span><span class="token class-name">NoSuchAlgorithmException</span></span><span class="token punctuation">;</span>

<span class="token annotation punctuation">@Component</span>
<span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">MD5Util</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">String</span> <span class="token function">encrypt</span><span class="token punctuation">(</span><span class="token class-name">String</span> strSrc<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token keyword">char</span> hexChars<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token char">'0'</span><span class="token punctuation">,</span> <span class="token char">'1'</span><span class="token punctuation">,</span> <span class="token char">'2'</span><span class="token punctuation">,</span> <span class="token char">'3'</span><span class="token punctuation">,</span> <span class="token char">'4'</span><span class="token punctuation">,</span> <span class="token char">'5'</span><span class="token punctuation">,</span> <span class="token char">'6'</span><span class="token punctuation">,</span> <span class="token char">'7'</span><span class="token punctuation">,</span> <span class="token char">'8'</span><span class="token punctuation">,</span>
                    <span class="token char">'9'</span><span class="token punctuation">,</span> <span class="token char">'a'</span><span class="token punctuation">,</span> <span class="token char">'b'</span><span class="token punctuation">,</span> <span class="token char">'c'</span><span class="token punctuation">,</span> <span class="token char">'d'</span><span class="token punctuation">,</span> <span class="token char">'e'</span><span class="token punctuation">,</span> <span class="token char">'f'</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
            <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> bytes <span class="token operator">=</span> strSrc<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//获得m5的实例</span>
            <span class="token class-name">MessageDigest</span> md <span class="token operator">=</span> <span class="token class-name">MessageDigest</span><span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token string">"MD5"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            md<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span>bytes<span class="token punctuation">)</span><span class="token punctuation">;</span>
            bytes <span class="token operator">=</span> md<span class="token punctuation">.</span><span class="token function">digest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">int</span> j <span class="token operator">=</span> bytes<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
            <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> chars <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">char</span><span class="token punctuation">[</span>j <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> bytes<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">byte</span> b <span class="token operator">=</span> bytes<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
                chars<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> hexChars<span class="token punctuation">[</span>b <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">4</span> <span class="token operator">&amp;</span> <span class="token number">0xf</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
                chars<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> hexChars<span class="token punctuation">[</span>b <span class="token operator">&amp;</span> <span class="token number">0xf</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>chars<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">NoSuchAlgorithmException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token string">"MD5加密出错！！+"</span> <span class="token operator">+</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol start="6">
<li>使用mybatisX插件，选中表之后逆向工程生成实体类和接口(注意自己补充和删减一些注释)<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Data</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token keyword">implements</span> <span class="token class-name">Serializable</span> <span class="token punctuation">{</span>
    
    <span class="token annotation punctuation">@TableId</span> <span class="token comment">//主键</span>
    <span class="token keyword">private</span> <span class="token class-name">Integer</span> uid<span class="token punctuation">;</span>

    <span class="token keyword">private</span> <span class="token class-name">String</span> username<span class="token punctuation">;</span>

    <span class="token keyword">private</span> <span class="token class-name">String</span> userPwd<span class="token punctuation">;</span>

    <span class="token keyword">private</span> <span class="token class-name">String</span> nickName<span class="token punctuation">;</span>

    <span class="token annotation punctuation">@Version</span> <span class="token comment">//版本</span>
    <span class="token keyword">private</span> <span class="token class-name">Integer</span> version<span class="token punctuation">;</span>

    <span class="token annotation punctuation">@TableLogic</span> <span class="token comment">//逻辑删除</span>
    <span class="token keyword">private</span> <span class="token class-name">Integer</span> isDeleted<span class="token punctuation">;</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> <span class="token number">1L</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
补充:<br>[[Java#^86b436||逻辑删除]]</li>
<li>使用jwt来生成[[Web学习#Token是一种令牌，用来识别访问人员的|Token]]</li>
<li>JSON Web Token JWT由三部分组成: header(头部).payload(载荷).signature(签名)<br>1. 导入依赖</li>
</ol>
<pre><code><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>io.jsonwebtoken<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>jjwt<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>0.9.1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>javax.xml.bind<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>jaxb-api<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>2.3.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</code></pre>
<ol start="2">
<li><p>编写配置</p>
<p> application.yaml</p>
 <pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token comment">#jwt配置</span>
<span class="token key atrule">jwt</span><span class="token punctuation">:</span>
  <span class="token key atrule">token</span><span class="token punctuation">:</span>
    <span class="token key atrule">tokenExpiration</span><span class="token punctuation">:</span> <span class="token number">120</span> <span class="token comment">#有效时间,单位分钟</span>
    <span class="token key atrule">tokenSignKey</span><span class="token punctuation">:</span> headline123456  <span class="token comment">#当前程序签名秘钥 自定义</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>导入工具类</p>
<p> 封装jwt技术工具类</p>
 <pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>atguigu<span class="token punctuation">.</span>utils</span><span class="token punctuation">;</span>

<span class="token keyword">import</span> <span class="token import"><span class="token namespace">com<span class="token punctuation">.</span>alibaba<span class="token punctuation">.</span>druid<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">StringUtils</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">io<span class="token punctuation">.</span>jsonwebtoken<span class="token punctuation">.</span></span><span class="token operator">*</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">lombok<span class="token punctuation">.</span></span><span class="token class-name">Data</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>context<span class="token punctuation">.</span>properties<span class="token punctuation">.</span></span><span class="token class-name">ConfigurationProperties</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>context<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">Configuration</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>stereotype<span class="token punctuation">.</span></span><span class="token class-name">Component</span></span><span class="token punctuation">;</span>

<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Date</span></span><span class="token punctuation">;</span>

<span class="token annotation punctuation">@Data</span>
<span class="token annotation punctuation">@Component</span>
<span class="token annotation punctuation">@ConfigurationProperties</span><span class="token punctuation">(</span>prefix <span class="token operator">=</span> <span class="token string">"jwt.token"</span><span class="token punctuation">)</span> <span class="token comment">//使用这个就可以省略前缀，如果后面的变量名和配置中相同的话就可以自动装配而不用手动装配了</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">JwtHelper</span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span>  <span class="token keyword">long</span> tokenExpiration<span class="token punctuation">;</span> <span class="token comment">//有效时间,单位毫秒 1000毫秒 == 1秒</span>
    <span class="token keyword">private</span>  <span class="token class-name">String</span> tokenSignKey<span class="token punctuation">;</span>  <span class="token comment">//当前程序签名秘钥</span>

    <span class="token comment">//生成token字符串</span>
    <span class="token keyword">public</span>  <span class="token class-name">String</span> <span class="token function">createToken</span><span class="token punctuation">(</span><span class="token class-name">Long</span> userId<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"tokenExpiration = "</span> <span class="token operator">+</span> tokenExpiration<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"tokenSignKey = "</span> <span class="token operator">+</span> tokenSignKey<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">String</span> token <span class="token operator">=</span> <span class="token class-name">Jwts</span><span class="token punctuation">.</span><span class="token function">builder</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

                <span class="token punctuation">.</span><span class="token function">setSubject</span><span class="token punctuation">(</span><span class="token string">"YYGH-USER"</span><span class="token punctuation">)</span>
                <span class="token punctuation">.</span><span class="token function">setExpiration</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> tokenExpiration<span class="token operator">*</span><span class="token number">1000</span><span class="token operator">*</span><span class="token number">60</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//单位分钟</span>
                <span class="token punctuation">.</span><span class="token function">claim</span><span class="token punctuation">(</span><span class="token string">"userId"</span><span class="token punctuation">,</span> userId<span class="token punctuation">)</span>
                <span class="token punctuation">.</span><span class="token function">signWith</span><span class="token punctuation">(</span><span class="token class-name">SignatureAlgorithm</span><span class="token punctuation">.</span><span class="token constant">HS512</span><span class="token punctuation">,</span> tokenSignKey<span class="token punctuation">)</span>
                <span class="token punctuation">.</span><span class="token function">compressWith</span><span class="token punctuation">(</span><span class="token class-name">CompressionCodecs</span><span class="token punctuation">.</span><span class="token constant">GZIP</span><span class="token punctuation">)</span>
                <span class="token punctuation">.</span><span class="token function">compact</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> token<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">//从token字符串获取userid</span>
    <span class="token keyword">public</span>  <span class="token class-name">Long</span> <span class="token function">getUserId</span><span class="token punctuation">(</span><span class="token class-name">String</span> token<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token class-name">StringUtils</span><span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span>token<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token class-name">Jws</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Claims</span><span class="token punctuation">&gt;</span></span> claimsJws <span class="token operator">=</span> <span class="token class-name">Jwts</span><span class="token punctuation">.</span><span class="token function">parser</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setSigningKey</span><span class="token punctuation">(</span>tokenSignKey<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">parseClaimsJws</span><span class="token punctuation">(</span>token<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Claims</span> claims <span class="token operator">=</span> claimsJws<span class="token punctuation">.</span><span class="token function">getBody</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Integer</span> userId <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Integer</span><span class="token punctuation">)</span>claims<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"userId"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> userId<span class="token punctuation">.</span><span class="token function">longValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>



    <span class="token comment">//判断token是否有效</span>
    <span class="token keyword">public</span>  <span class="token keyword">boolean</span> <span class="token function">isExpiration</span><span class="token punctuation">(</span><span class="token class-name">String</span> token<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token keyword">boolean</span> isExpire <span class="token operator">=</span> <span class="token class-name">Jwts</span><span class="token punctuation">.</span><span class="token function">parser</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
                    <span class="token punctuation">.</span><span class="token function">setSigningKey</span><span class="token punctuation">(</span>tokenSignKey<span class="token punctuation">)</span>
                    <span class="token punctuation">.</span><span class="token function">parseClaimsJws</span><span class="token punctuation">(</span>token<span class="token punctuation">)</span>
                    <span class="token punctuation">.</span><span class="token function">getBody</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
                    <span class="token punctuation">.</span><span class="token function">getExpiration</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">before</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">//没有过期，有效，返回false</span>
            <span class="token keyword">return</span> isExpire<span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">//过期出现异常，返回true</span>
            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><p>编写controller<br>知识点：跨域: 例如从不同的服务器或域名获取信息。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
</ol>
<h2 id="时间格式解决"><a href="#时间格式解决" class="headerlink" title="时间格式解决"></a>时间格式解决</h2><p><img src="/2023/09/17/02/timeFormat.png" alt="timeformat"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zuofw.github.io/2023/09/09/34/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="QingQiu">
      <meta itemprop="description" content="个人网站，学习记录，面试记录和经验总结、互联网中一块属于自己的小窝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="QingQiu'Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/09/09/34/" class="post-title-link" itemprop="url">学算法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-09-09 20:35:34" itemprop="dateCreated datePublished" datetime="2023-09-09T20:35:34+08:00">2023-09-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-10-11 16:20:12" itemprop="dateModified" datetime="2024-10-11T16:20:12+08:00">2024-10-11</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>54k</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="JAVA-快写"><a href="#JAVA-快写" class="headerlink" title="JAVA 快写"></a>JAVA 快写</h2><h2 id="最短路与具体的路径记录问题"><a href="#最短路与具体的路径记录问题" class="headerlink" title="最短路与具体的路径记录问题"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-edges-in-shortest-paths/description/">最短路与具体的路径记录问题</a></h2><h2 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">TreeMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
map<span class="token punctuation">.</span><span class="token function">getOrDefault</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span> 获得这个数，如果为空<span class="token punctuation">,</span>返回默认值，可以自己设定
k <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">higherKey</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span> 获得下一个顺序的键<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h2 id="把toCharArray向右移动一位"><a href="#把toCharArray向右移动一位" class="headerlink" title="把toCharArray向右移动一位"></a>把toCharArray向右移动一位</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"> a <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token char">' '</span><span class="token operator">+</span> re<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="a-z-之间偏移量确认"><a href="#a-z-之间偏移量确认" class="headerlink" title="a ~ z 之间偏移量确认"></a>a ~ z 之间偏移量确认</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token char">'a'</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> offset <span class="token operator">-</span> <span class="token char">'a'</span><span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">26</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="看到唯一解，且是难以做的图形题，可以考虑转化为方程"><a href="#看到唯一解，且是难以做的图形题，可以考虑转化为方程" class="headerlink" title="看到唯一解，且是难以做的图形题，可以考虑转化为方程"></a>看到唯一解，且是难以做的图形题，可以考虑转化为方程</h2><p><a target="_blank" rel="noopener" href="https://www.lanqiao.cn/problems/17160/learning/?contest_id=179">https://www.lanqiao.cn/problems/17160/learning/?contest_id=179</a></p>
<h3 id="卡特兰数问题-：h-n-x3D-C-2n-n-−C-2n-n−1-n-x3D-0-1-2-…-组合数C不解释了；-C是组合数"><a href="#卡特兰数问题-：h-n-x3D-C-2n-n-−C-2n-n−1-n-x3D-0-1-2-…-组合数C不解释了；-C是组合数" class="headerlink" title="卡特兰数问题 ：h[n]=C[2n,n]−C [2n,n−1] (n=0,1,2,…)&nbsp;组合数C不解释了； C是组合数"></a>卡特兰数问题 ：h[n]=C[2n,n]−C [2n,n−1] (n=0,1,2,…)&nbsp;组合数C不解释了； C是组合数</h3><ol>
<li>出栈顺序问题 假设有N个数字依次入栈：1,2,3,…,n，试问有多少种出栈顺序？这里为表述简便，下文用+1表示一个元素入栈，用-1表示一个元素出栈</li>
<li>问题描述：有n对()括号，试问可以组成多少种合法正确的括号序列？</li>
</ol>
<h2 id="树是无向边"><a href="#树是无向边" class="headerlink" title="树是无向边"></a>树是无向边</h2><h2 id="Java日期"><a href="#Java日期" class="headerlink" title="Java日期"></a>Java日期</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">LocalDate</span> d1 <span class="token operator">=</span> <span class="token class-name">LocalDate</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span><span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>time<span class="token punctuation">.</span>format<span class="token punctuation">.</span></span>DateTimeFormatter</span><span class="token punctuation">.</span><span class="token constant">BASIC_ISO_DATE</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		s <span class="token operator">=</span> reader<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token class-name">LocalDate</span> d2 <span class="token operator">=</span> <span class="token class-name">LocalDate</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span><span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>time<span class="token punctuation">.</span>format<span class="token punctuation">.</span></span>DateTimeFormatter</span><span class="token punctuation">.</span><span class="token constant">BASIC_ISO_DATE</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">long</span> diff <span class="token operator">=</span> <span class="token class-name">ChronoUnit</span><span class="token punctuation">.</span><span class="token constant">DAYS</span><span class="token punctuation">.</span><span class="token function">between</span><span class="token punctuation">(</span>d1<span class="token punctuation">,</span> d2<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">abs</span><span class="token punctuation">(</span>diff<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">BufferedWriter</span> writer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedWriter</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">OutputStreamWriter</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
writer<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 才会写<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h2 id="JAVA更快更强的读入和写-https-www-luogu-com-cn-problem-P2367"><a href="#JAVA更快更强的读入和写-https-www-luogu-com-cn-problem-P2367" class="headerlink" title="JAVA更快更强的读入和写 https://www.luogu.com.cn/problem/P2367"></a>JAVA更快更强的读入和写 <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P2367">https://www.luogu.com.cn/problem/P2367</a></h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"> <span class="token class-name">StreamTokenizer</span> reader <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StreamTokenizer</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

reader<span class="token punctuation">.</span><span class="token function">nextToken</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
n <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> reader<span class="token punctuation">.</span>nval<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="取余数的小技巧"><a href="#取余数的小技巧" class="headerlink" title="取余数的小技巧"></a>取余数的小技巧</h2><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token punctuation">(</span>x + n<span class="token punctuation">)</span> % n 可以保证不会出现负数<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>先思考再做题，前几个题大概率时模拟题，所以别急着用算法</p>
<h2 id="常用算法"><a href="#常用算法" class="headerlink" title="常用算法"></a>常用算法</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">next_permutation</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>a<span class="token operator">+</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span> 对数组的前n个数进行全排列，并存储在这个数组中
<span class="token keyword">char</span> a<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span>
<span class="token function">puts</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> 可以直接输出一行，如果不是最后一行还会输出换行符
求 q<span class="token operator">^</span><span class="token number">0</span> <span class="token operator">+</span> q<span class="token operator">^</span><span class="token number">1</span> <span class="token operator">+</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token operator">+</span> q<span class="token operator">^</span>n
<span class="token keyword">long</span> <span class="token keyword">long</span> t <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token keyword">while</span><span class="token punctuation">(</span>n<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">//秦九zhao算法</span>
    t <span class="token operator">=</span> <span class="token punctuation">(</span>t <span class="token operator">*</span>q <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span>mod<span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>整数划分</strong><a target="_blank" rel="noopener" href="https://ac.nowcoder.com/acm/problem/252724">https://ac.nowcoder.com/acm/problem/252724</a></p>
<p>accumulate 求和</p>
<p>快乐的模板：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits/stdc++.h&gt;  
#define ll long long   
#define pii pair&lt;int,int&gt;  
using namespace std;  
void solve(){  
 &nbsp; &nbsp;return ;  
}  
int main(){  
 &nbsp; &nbsp;ios::sync_with_stdio(false);  
 &nbsp; &nbsp;cin.tie(nullptr);  
 &nbsp; &nbsp;int T;  
 &nbsp; &nbsp;cin &gt;&gt; T;  
 &nbsp; &nbsp;while (T--) solve();  
 &nbsp; &nbsp;return 0;  
}  
​```


## 小TIPS：

做题思路：

1. 从小数据，小范围推大范围
    
2. 划分，以及反证，如果要求全部满足一个性质，那么只要有部分不满足我们已经推出来的条件即可不满足所有性质
    

&gt; 1. 数组和字符串比较字典序是可以直接用大于号小于号比较的
&gt;     
&gt; 2. 字典序是指在ASCII码中出现的顺序所以 也就是 a b c 0 1 2 3 ABC 等z
&gt;     
&gt; 3. vector &lt;&gt; 可以直接赋值
&gt;     

## 牛顿迭代法：

求平方根

例子： f(x)=m,可转化为 g(x)=f(x)-m=0;

迭代公式：_x_n+1 = _x_n − _g_ (_x_n)/ _g_ ′ (_x_n)

例题：[力扣（LeetCode）官网 - 全球极客挚爱的技术成长平台](https://leetcode.cn/problems/sqrtx/submissions/431189596/)
```c++
//f (x) = x2 − a = 0  
int mySqrt(int a) {  
long x = a;  
while (x * x &gt; a) {  
x = (x + a / x) / 2;  
}  
return x;  
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="stl和一些内置函数"><a href="#stl和一些内置函数" class="headerlink" title="stl和一些内置函数"></a>stl和一些内置函数</h3><p>accumulate(num.begin(),num.end(),0); //第三个参数是初始化要返回的东西 </p>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="快速排序模板-根据数来分治"><a href="#快速排序模板-根据数来分治" class="headerlink" title="快速排序模板 根据数来分治"></a>快速排序模板 根据数来分治</h3><p>先找数字中的中位数，然后递归<br><strong>注意：</strong> while中先递归的左边，那么最后递归的时候就要以j来为界限，递归的顺序无所谓</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void quick_sort(int q[], int l, int r)
{
    if (l &gt;= r) return;
    int x = q[rand()% (r-l+1)+l]; // 随机取
    int i = l - 1, j = r + 1; 
    while (i &lt; j) {
        do i++; while (
        q[i] &lt; x);
        do j--; while (q[j] &gt; x);
        if (i &lt; j) swap(q[i], q[j]);    //如果i与j没有相遇，就交换一下
    }

    quick_sort(q, l, j);    //递归处理左右两边
    quick_sort(q, j + 1, r);
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="归并排序模板-分治-根据中间两个数为分界线"><a href="#归并排序模板-分治-根据中间两个数为分界线" class="headerlink" title="归并排序模板 分治 根据中间两个数为分界线"></a>归并排序模板 分治 根据中间两个数为分界线</h3><ol>
<li><p>确定分界点， mid=(l+r)/2</p>
</li>
<li><p>递归排序 left，right</p>
</li>
<li><p>归并 合二为一</p>
</li>
</ol>
<p>模板</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">
void msort(int a[], int l, int r) {  
    if (l &gt;= r) return;  
    //确定分界  
    int mid = l + r &gt;&gt; 1;  
    //递归  
    msort(a, l, mid); msort(a, mid + 1, r);  
    //归并  
    int k = 0, i = l, j = mid + 1;  
      
    while (i &lt;=mid &amp;&amp; j &lt;= r) {//左右比较，小的放在辅助数组里，直到有一个指针到达边界  
        if (a[i] &lt;= a[j]) tmp[k++] = a[i++];  
        else tmp[k++] = a[j++];  
    }  
    //这里继续把另一个没到边界的指针赋值给辅助数组  
    while (i &lt;= mid) tmp[k++] = a[i++];  
    while (j &lt;= r)tmp[k++] = a[j++];  
    //最后把辅助数组的元素还回去  
    for (int i = l, j = 0; i &lt;= r; i++, j++) a[i] = tmp[j];  
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="二分法-二分要保证有解"><a href="#二分法-二分要保证有解" class="headerlink" title="二分法 二分要保证有解"></a>二分法 二分要保证有解</h2><h3 id="整数二分"><a href="#整数二分" class="headerlink" title="整数二分"></a>整数二分</h3><p>一分为二，一边满足性质，一半不满足，可以来用来寻找性质的边界</p>
<p>两种模板：一种去检查满足的一半，另一种去检查不满足性质的的一半</p>
<p>考虑边界是否会包括进去</p>
<ol>
<li><p>先写出 mid=r+l&gt;&gt;1</p>
</li>
<li><p>二分要检查的性质</p>
</li>
<li><p>画图考虑，直线图</p>
</li>
<li><p>思考mid是否会包含</p>
</li>
<li><p>考虑不存在条件时</p>
</li>
</ol>
<h2 id="l-x3D-mid-1-时-输出的是-L-r-x3D-mid-1-时-输出的是r"><a href="#l-x3D-mid-1-时-输出的是-L-r-x3D-mid-1-时-输出的是r" class="headerlink" title="l = mid + 1 时,输出的是 L , r = mid -1 时 输出的是r"></a>l = mid + 1 时,输出的是 L , r = mid -1 时 输出的是r</h2><p>注意死循环，男左女右，查找从右侧往左的时候mid 要 + 1，否则不+1</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">l + (r - l + 1 &gt;&gt; 1); 
​<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">更好的二分模板
<span class="token keyword">while</span><span class="token punctuation">(</span>l<span class="token operator">&lt;=</span>r<span class="token punctuation">)</span><span class="token punctuation">{</span>
	mid <span class="token operator">=</span> <span class="token punctuation">(</span>l <span class="token operator">+</span> r<span class="token punctuation">)</span> <span class="token operator">&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>mid <span class="token operator">&lt;</span> r<span class="token punctuation">)</span> r <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token keyword">else</span>  mid <span class="token operator">=</span> l <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="浮点数二分-不要处理边界"><a href="#浮点数二分-不要处理边界" class="headerlink" title="浮点数二分 不要处理边界"></a>浮点数二分 不要处理边界</h3><p>思路：通过mid来判断，答案落在缩小的区间内，只要近似值</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">bool check(double x) {/* ... */} // 检查x是否满足某种性质  
  
double bsearch_3(double l, double r)  
{  
    const double eps = 1e-6;   // eps 表示精度，取决于题目对精度的要求  
    while (r - l &gt; eps)  
    {  
        double mid = (l + r) / 2;  
        if (check(mid)) r = mid;  
        else l = mid;  
    }  
    //或者直接不管精度，直接循环几百次  
    return l;  
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="高精度"><a href="#高精度" class="headerlink" title="高精度"></a>高精度</h2><h3 id="加法：-注意要把A设为位数更大的那一个，因为最后的位数取决于位数大的那一个，使用vector容器可以更方便的进行计算和进位和确定位数"><a href="#加法：-注意要把A设为位数更大的那一个，因为最后的位数取决于位数大的那一个，使用vector容器可以更方便的进行计算和进位和确定位数" class="headerlink" title="加法： 注意要把A设为位数更大的那一个，因为最后的位数取决于位数大的那一个，使用vector容器可以更方便的进行计算和进位和确定位数"></a>加法： 注意要把A设为位数更大的那一个，因为最后的位数取决于位数大的那一个，使用vector容器可以更方便的进行计算和进位和确定位数</h3><ol>
<li><p>逆序存数的每一位</p>
</li>
<li><p>从低位开始计算，之后计算进位</p>
</li>
<li><p>加完之后检查最后一位是否还有进位</p>
</li>
<li><p>返回数字</p>
</li>
</ol>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">vector&lt;int&gt; add(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B)  
{  
    if (A.size() &lt; B.size()) return add(B, A);  
  
    vector&lt;int&gt; C;  
    int t = 0;  
    for (int i = 0; i &lt; A.size(); i ++ )  
    {  
        t += A[i];  
        if (i &lt; B.size()) t += B[i];  
        C.push_back(t % 10);  
        t /= 10;  
    }  
  
    if (t) C.push_back(1);  
    return C;  
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="减法"><a href="#减法" class="headerlink" title="减法"></a>减法</h3><p>和加法基本一致，只要变进位为借位即可</p>
<p>// C = A - B, 满足A &gt;= B, A &gt;= 0, B &gt;= 0  </p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">vector&lt;int&gt; sub(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B)  
{  
    vector&lt;int&gt; C;  
    for (int i = 0, t = 0; i &lt; A.size(); i ++ )  
    {  
        t = A[i] - t;  
        if (i &lt; B.size()) t -= B[i];  
        C.push_back((t + 10) % 10);  
        if (t &lt; 0) t = 1;  
        else t = 0;  
    }  
  
    while (C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back();  
    return C;  
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="乘法"><a href="#乘法" class="headerlink" title="乘法"></a>乘法</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">vector&lt;int&gt; mul(vector&lt;int&gt;&amp;A,int b){  
 &nbsp; vector&lt;int&gt;C;  
 &nbsp; int t=0;  
 &nbsp; for(int i=0;i&lt;A.size()||t;i++){//出现进位  
 &nbsp; &nbsp; &nbsp;if(i&lt;A.size()) t+=A[i]*b;  
 &nbsp; &nbsp; &nbsp;C.push_back(t%10);  
 &nbsp; &nbsp; &nbsp;t/=10;  
 &nbsp; }  
 &nbsp; while(C.size()&gt;1&amp;&amp;C.back()==0) C.pop_back();  
 &nbsp; //去除前导零  
 &nbsp; return C;  
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">### 除法

vector&lt;int&gt; div(vector&lt;int&gt;&amp;A,int b){  
 &nbsp; vector&lt;int&gt;C;  
 &nbsp; int t=0;  
 &nbsp; for(int i=0;i&lt;A.size();i++){  
 &nbsp; &nbsp; &nbsp;t=t*10+A[i];  
 &nbsp; &nbsp; &nbsp;C.push_back(t/b);  
 &nbsp; &nbsp; &nbsp;t %= b;  
 &nbsp; }  
 &nbsp; //这里是清除前置零，不是后置零
 &nbsp; reverse(C.begin(),C.end());  
 &nbsp; while(C.size()&gt;1&amp;&amp;C.back()==0) C.pop_back();  
 &nbsp; return C;  
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="前缀和和差分"><a href="#前缀和和差分" class="headerlink" title="前缀和和差分"></a>前缀和和差分</h2><p><strong>构造差分可以用一个空数组，一直执行插入操作即可</strong></p>
<p>前缀和一般初始化为0到n但是只用1到n</p>
<p>二维</p>
<p>S[i, j] = 第i行j列格子左上部分所有元素的和<br>以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：<br>S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]</p>
<p>二维差分： 差分的前缀和就是原数组</p>
<p>给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：<br>S[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c//注意是x2+1,y2+1不是x2,y2</p>
<h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int x;  
int * p1 = &amp;x; // 指针可以被修改，值也可以被修改  
const int * p2 = &amp;x; // 指针可以被修改，值不可以被修改（const int）  
int * const p3 = &amp;x; // 指针不可以被修改（* const），值可以被修改  
const int * const p4 = &amp;x; // 指针不可以被修改，值也不可以被修改

for (int i = 0, j = 0; i &lt; n; i ++ )  
{  
    while (j &lt; i &amp;&amp; check(i, j)) j ++ ;  
  
    // 具体问题的逻辑  
}  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>常见问题分类：<br>    (1) 对于一个序列，用两个指针维护一段区间<br>    (2) 对于两个序列，维护某种次序，比如归并排序中合并两个有序序列的操作</p>
<h3 id="Floyd判圈法-龟兔赛跑法-用于判断链表有无环和求出环的长度"><a href="#Floyd判圈法-龟兔赛跑法-用于判断链表有无环和求出环的长度" class="headerlink" title="Floyd判圈法 龟兔赛跑法 用于判断链表有无环和求出环的长度"></a>Floyd判圈法 龟兔赛跑法 用于判断链表有无环和求出环的长度</h3><p>两个指针fast slow 都从起始位置出发，fast 一次走2步，slow一次走1步，如果能相遇，则存在环</p>
<p>计算环的长度</p>
<p>让其中一个指针停在环的起点不动，另一个一步一步向前走并记录步数，再次相遇时步数即为环的长度。</p>
<p>寻找环的起点</p>
<p>其中一个指针在环的起点不动，另一个放到起点，两个指针同时一步一步移动，则两指针将会在循环节的起点相遇。</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/linked-list-cycle-ii/description/">142. 环形链表 II - 力扣（Leetcode）</a></p>
<p>/**  </p>
<ul>
<li>Definition for singly-linked list.  </li>
<li>struct ListNode {  </li>
<li><pre><code>int val;  
</code></pre>
</li>
<li><pre><code>ListNode *next;  
</code></pre>
</li>
<li><pre><code>ListNode(int x) : val(x), next(NULL) {}  
</code></pre>
</li>
<li>};<br> */<br>class Solution {<br>public:<br> ListNode *detectCycle(ListNode *head) {<br>ListNode *fast=head,*slow=head;<br>   do{<br>   if(!fast||!fast-&gt;next) return NULL;//如果能到达末尾，则不存在环<br>   fast=fast-&gt;next-&gt;next;<br>   slow=slow-&gt;next;<br>   }while(fast!=slow);<br>   fast=head;<br>   while(fast!=slow){<br>   fast=fast-&gt;next;<br>   slow=slow-&gt;next;<br>   }<br>   return slow;<br> }<br>};</li>
</ul>
<h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><p>思路：</p>
<p>n的第k位是什么？ n&gt;&gt;k&amp;1 右移k位与1与得到是0就是0，反之就是1</p>
<ol>
<li><p>先把要判断的位置移到最左边</p>
</li>
<li><p>判断</p>
</li>
</ol>
<h3 id="lowbit"><a href="#lowbit" class="headerlink" title="lowbit"></a>lowbit</h3><p>解释：cpp的负数使用的补码表示的所以，-x就等于 ~x+1 反码+1</p>
<p>用法：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/93795692">树状数组</a>和求1的个数</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">

<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Scanner</span></span><span class="token punctuation">;</span>
<span class="token comment">// 1:无需package</span>
<span class="token comment">// 2: 类名必须Main, 不可修改</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>
    <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token class-name">N</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token number">1e5</span> <span class="token operator">+</span> <span class="token number">10</span><span class="token punctuation">;</span>
    <span class="token keyword">static</span> <span class="token keyword">long</span><span class="token punctuation">[</span><span class="token punctuation">]</span> tree <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">long</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">static</span> <span class="token keyword">int</span> n <span class="token punctuation">;</span>
    <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">lowbit</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    	<span class="token keyword">return</span> x <span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token operator">-</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">update</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token punctuation">,</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> pos <span class="token operator">=</span> i <span class="token punctuation">;</span> pos <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> pos <span class="token operator">+=</span> <span class="token function">lowbit</span><span class="token punctuation">(</span>pos<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    		tree<span class="token punctuation">[</span>pos<span class="token punctuation">]</span> <span class="token operator">+=</span> x<span class="token punctuation">;</span>
    	<span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">static</span> <span class="token keyword">long</span> <span class="token function">query</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    	<span class="token keyword">long</span> sum <span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
    	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> pos <span class="token operator">=</span> x<span class="token punctuation">;</span> pos <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">;</span> pos<span class="token operator">-=</span><span class="token function">lowbit</span><span class="token punctuation">(</span>pos<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    		sum <span class="token operator">+=</span>tree<span class="token punctuation">[</span>pos<span class="token punctuation">]</span><span class="token punctuation">;</span>
    	<span class="token punctuation">}</span>
    	<span class="token keyword">return</span> sum<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">static</span> <span class="token keyword">long</span> <span class="token function">ask</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span><span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    	<span class="token keyword">return</span> <span class="token function">query</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token function">query</span><span class="token punctuation">(</span>a<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Scanner</span> scan <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Scanner</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span>
        n <span class="token operator">=</span> scan<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> m <span class="token operator">=</span>scan<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        	<span class="token keyword">int</span> x <span class="token operator">=</span> scan<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        	<span class="token function">update</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>m<span class="token operator">--</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        	<span class="token keyword">int</span> k <span class="token operator">=</span> scan<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        	<span class="token keyword">int</span> a <span class="token operator">=</span> scan<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        	<span class="token keyword">int</span> b <span class="token operator">=</span> scan<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        	<span class="token keyword">if</span><span class="token punctuation">(</span>k <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        		<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token function">ask</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        	<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        		<span class="token function">update</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
        	<span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        scan<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="树状数组：对差分和前缀和的利用："><a href="#树状数组：对差分和前缀和的利用：" class="headerlink" title="树状数组：对差分和前缀和的利用："></a>树状数组：对差分和前缀和的利用：</h1><h3 id="使用情况："><a href="#使用情况：" class="headerlink" title="使用情况："></a>使用情况：</h3><ol>
<li><p>数组不变求区间和</p>
</li>
<li><p>多次修改某个区间，求区间和</p>
</li>
<li><p>将某个区间变为同一个数求区间和</p>
</li>
<li><p>多次修改区间，寻找定点值</p>
</li>
</ol>
<h2 id="模板："><a href="#模板：" class="headerlink" title="模板："></a>模板：</h2><p>说明：lowbit()奇妙用法…..</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define low
```bit(x) (-x)&amp;x  
///或者 int lowbit(int x) {return -x&amp;x;}  
int tree[length];//树状数组，长度和原数组相等  
//区间修改  
void update(int x,int val)  
{  
    while(x){  
        tree[x]+=val;  
        x+=lowbit(x);  
    }  
}  
//区间求和  
int sum(int l,int r){  
    int ans=0;  
    while(r){  
        ans+=tree[r];  
        r-=lowbit(r);  
    }  
    l--;//  
    while(l){  
        ans-=tree[l];  
        l-=lowbit(l);  
    }  
    return ans;  
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="使用方式："><a href="#使用方式：" class="headerlink" title="使用方式："></a>使用方式：</h2><ol>
<li><p>正常的顶点修改，区间求和直接用</p>
</li>
<li><p><strong>区间修改，求单独一个数</strong> <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3368">P3368 【模板】树状数组 2 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>
<ul>
<li><p>树状数组是保存的每一个下标为位置的前缀和</p>
</li>
<li><p>想要求指定位置的数值需要用到差分,差分的前缀和就是每一个位置的数据大小</p>
</li>
<li><p>修改时只需要修改 update(l,val),update(r+1,-val)</p>
</li>
<li><p>初始化时，要插入的是差分</p>
  <pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;  
#include &lt;algorithm&gt;  
#define ll long long  
#define lowbit(x) (x&amp;(-x))  
using namespace std;  
const int mx = 10e5 + 5;  
int t[mx], m, n;  
int add(int x, int k) {  
	while (x &lt;= n) {  
		t[x] += k;  
		x += lowbit(x);  
	}  
}  
int query(int x){  
	ll ans=0;  
	while(x){  
		ans+=t[x];  
		x-=lowbit(x);  
	}  
	return ans;  
}  
//用差分来的前缀和来表示每一位置上的数字，  
//第一个数字之后，每次把差分加入，再求前缀和就能得到每一个位置上的数字是多少了  
//修改时只需要修改x和y+1两个位置的差分，但是我们用的tree是前缀和，所以依然要用把和lowbit有关的都修改 了   
int main() {  
	cin &gt;&gt; n &gt;&gt; m;  
	int cf=0;   
	for (int i = 1; i &lt;= n; i++) {  
		int num;  
		scanf("%d", &amp;num);  
		add(i,num-cf);  
		cf=num;  
	}  
	  
	for (int i = 1; i &lt;= m; i++) {  
		int ch, x, y,k;  
		scanf("%d", &amp;ch);  
		if (ch == 1){  
			scanf("%d %d %d", &amp;x, &amp;y, &amp;k);  
			add(x,k);  
			add(y+1,-k);  
		}  
		else {  
			int s;  
			scanf("%d", &amp;s);  
			printf("%d\n", query(s));  
		}  
	}  
	return 0;  
}  
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
</li>
<li><p>用指定数据替换某个数据，然后求和 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/range-sum-query-mutable/submissions/429237767/">307. 区域和检索 - 数组可修改 - 力扣（Leetcode）</a></p>
<ul>
<li><p>更换数据也是用到了差分，新的数据-原数据==要更新的val</p>
</li>
<li><p>然后更新之后，原数组指定位置也要更新，方便下次修改同一位置</p>
</li>
<li><p>其他正常食用即可</p>
  <pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class NumArray {  
    int []t;  
    int n;  
    int []nums;  
    int lowbit(int x){return x&amp;(-x);}  
    public NumArray(int[] nums) {  
        this.nums=nums;  
        n=nums.length;  
        t=new int[n+1];  
        int i=1;  
        for (int num:nums  
             ) {  
            add(i++,num);  
        }  
    }  
    void add(int index,int val){  
        while(index&lt;=n){  
            t[index]+=val;  
            index+=lowbit(index);  
        }  
    }  
    public void update(int index, int val) {  
        add(index+1,val-nums[index]);  
        nums[index]=val;  
    }  
      
    public int sumRange(int left, int right) {  
        int ans=0;  
        right++;  
        while(right&gt;0){  
            ans+=t[right];  
            right-=lowbit(right);  
        }  
  
        while(left&gt;0){  
            ans-=t[left];  
            left-=lowbit(left);  
        }  
        return ans;  
    }  
}  
  
/**  
 * Your NumArray object will be instantiated and called as such:  
 * NumArray obj = new NumArray(nums);  
 * obj.update(index,val);  
 * int param_2 = obj.sumRange(left,right);  
 */<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
</li>
</ol>
<p>求1的个数</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;algorithm&gt;  
#include &lt;vector&gt;  
#include &lt;iostream&gt;  
#define lowbit(x) (-x)&amp;x  
using namespace std;  
int main(){  
 &nbsp; &nbsp;int n,ans=0;  
 &nbsp; &nbsp;cin&gt;&gt;n;  
 &nbsp; &nbsp;while(n){  
 &nbsp; &nbsp; &nbsp; &nbsp;ans++;  
 &nbsp; &nbsp; &nbsp; &nbsp;n-=lowbit(n);  
 &nbsp;  }  
 &nbsp; &nbsp;cout&lt;&lt;ans&lt;&lt;endl;  
 &nbsp; &nbsp;return 0;  
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="离散化"><a href="#离散化" class="headerlink" title="离散化"></a>离散化</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">unique 返回的是下下标
vector&lt;int&gt; alls; // 存储所有待离散化的值  
sort(alls.begin(), alls.end()); // 将所有值排序  
alls.erase(unique(alls.begin(), alls.end()), alls.end()); &nbsp; // 去掉重复元素  
//配合erase 即可把放在后面的重复元素删除  
/*  
该函数的作用是“去除”容器或者数组中相邻元素的重复出现的元素  
(1) 这里的去除并非真正意义的erase，而是将重复的元素放到容器的末尾，返回值是去重之后的尾地址。   
(2) unique针对的是相邻元素，所以对于顺序顺序错乱的数组成员，或者容器成员，需要先进行排序，可以调用std::sort()函数  
// 二分求出x对应的离散化的值*/  
int find(int x) // 找到第一个大于等于x的位置  
{  
 &nbsp; &nbsp;int l = 0, r = alls.size() - 1;  
 &nbsp; &nbsp;while (l &lt; r)  
 &nbsp;  {  
 &nbsp; &nbsp; &nbsp; &nbsp;int mid = l + r &gt;&gt; 1;  
 &nbsp; &nbsp; &nbsp; &nbsp;if (alls[mid] &gt;= x) r = mid;  
 &nbsp; &nbsp; &nbsp; &nbsp;else l = mid + 1;  
 &nbsp;  }  
 &nbsp; &nbsp;return r + 1; // 映射到1, 2, ...n  
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="区间和并"><a href="#区间和并" class="headerlink" title="区间和并"></a>区间和并</h2><p>每次维护一个右端点</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">// 将所有存在交集的区间合并  
void merge(vector&lt;PII&gt; &amp;segs)  
{  
    vector&lt;PII&gt; res;  
  
    sort(segs.begin(), segs.end());//根据first进行排序，默认的就是这样的不需要进行自定义  
  
    int st = -2e9, ed = -2e9;  
    for (auto seg : segs)  
        if (ed &lt; seg.first)  
        {  
            //当起点的值大于右端点的时候，一段区间结束，可以继续下一段区间了  
            if (st != -2e9) res.push_back({st, ed});  
            st = seg.first, ed = seg.second;  
        }  g
        else ed = max(ed, seg.second);//如果左没大于右端点，那么右端点每次更新完为最大值  
  
    if (st != -2e9) res.push_back({st, ed});  
    segs = res;  
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="数组模拟链表"><a href="#数组模拟链表" class="headerlink" title="数组模拟链表"></a>数组模拟链表</h2><h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">
int head,e[N],ne[N],idx;  
void init(){  
    head=-1;  
    idx=0;  
}  
//头插  
//head 也是指针,e[idx] 新节点  
void add_head(int x){  
    e[idx]=x;//插入数据  
    ne[idx]=head;//idx 当前的位置的指针指向head指向的位置 -1  
    head=idx;//head 指针指向idx   
    idx++;  
}  
//插入任意位置  
void insert_linkedlist(int k,int x){  
    e[idx]=x;//建立新节点  
    ne[idx]=ne[k];//新节点指向k的下一个节点  
    ne[k]=ne[idx]; //k指向idx这个结点  
    idx++;  
}  
void delete_linkedlist(int k){  
    ne[k]=ne[ne[k]];  
}  
int main(){  
    int k,x,m;  
    char op;  
    cin&gt;&gt;m;  
    init();  
    while(m--){  
        cin&gt;&gt;op;  
        if(op=='h'){  
            cin&gt;&gt;x;  
            add_head(x);  
        }  
        else if(op=='d'){  
            cin&gt;&gt;k;  
            delete_linkedlist(k-1);  
        }  
        else {  
            cin&gt;&gt;k&gt;&gt;x;  
            insert_linkedlist(k-1,x);  
        }  
    }  
    for(int i=head;i!=-1;i=ne[i]){cout&lt;&lt;e[i]&lt;&lt;' ';}  
    return 0;  
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">// e[]表示节点的值，l[]表示节点的左指针，r[]表示节点的右指针，idx表示当前用到了哪个节点  
int e[N], l[N], r[N], idx;  
  
// 初始化  
void init()  
{  
    //0是左端点，1是右端点  
    r[0] = 1, l[1] = 0;  
    idx = 2;  
}  
  
// 在节点a的右边插入一个数x  
void insert(int a, int x)  
{  
    e[idx] = x;  
    l[idx] = a, r[idx] = r[a];  
    l[r[a]] = idx, r[a] = idx ++ ;  
}  
  
// 删除节点a  
void remove(int a)  
{  
    l[r[a]] = l[a];  
    r[l[a]] = r[a];  
}  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">// tt表示栈顶  
int stk[N], tt = 0;  
  
// 向栈顶插入一个数  
stk[ ++ tt] = x;  
  
// 从栈顶弹出一个数  
tt -- ;  
  
// 栈顶的值  
stk[tt];  
  
// 判断栈是否为空，如果 tt &gt; 0，则表示不为空  
if (tt &gt; 0)  
{  
  
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h2><p>注意这个题目要的是结果的下标不是具体的数据</p>
<p>用栈暴力模拟一遍，然后再考虑哪些元素没有用处，就可以排除</p>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P5788">P5788 【模板】单调栈 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;  
#include &lt;cstdio&gt;  
#define ll long long   
using namespace std;  
const ll N=3*1000000+1;  
ll stk[N],a[N],ans[N];  
int tt=0;  
int main(){  
    int n;  
    cin&gt;&gt;n;  
    for(int i=1;i&lt;=n;i++){  
        scanf("%lld",&amp;a[i]);  
    }  
    for(int i=n;i&gt;0;i--){  
        while(tt!=0&amp;&amp;a[i]&gt;=a[stk[tt]]) tt--;  
        ans[i]= tt==0?0:stk[tt];  
        stk[++tt]=i;  
    }  
    for(int i=1;i&lt;=n;i++)printf("%lld ",ans[i]);  
    return 0;  
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">// hh 表示队头，tt表示队尾  
int q[N], hh = 0, tt = -1;  
  
// 向队尾插入一个数  
q[ ++ tt] = x;  
  
// 从队头弹出一个数  
hh ++ ;  
  
// 队头的值  
q[hh];  
  
// 判断队列是否为空，如果 hh &lt;= tt，则表示不为空  
if (hh &lt;= tt)  
{  
  
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h1 id="单调队列-（好东西）"><a href="#单调队列-（好东西）" class="headerlink" title="单调队列 （好东西）"></a>单调队列 （好东西）</h1><p><strong>几个点：</strong></p>
<ul>
<li><p>初始化时，hh=0,tt=-1 使得队列为空</p>
</li>
<li><p>比较的是队尾元素与当前元素</p>
</li>
<li><p>注意队列长度为0时不要输出</p>
</li>
</ul>
<p>常见模型：找出滑动窗口中的最大值/最小值  </p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int hh = 0, tt = -1;  
for (int i = 0; i &lt; n; i ++ )  
{  
    while (hh &lt;= tt &amp;&amp; check_out(q[hh])) hh ++ ;  // 判断队头是否滑出窗口  
    while (hh &lt;= tt &amp;&amp; check(q[tt], i)) tt -- ;  
    q[ ++ tt] = i;  
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>例题</p>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1886">P1886 滑动窗口 /【模板】单调队列 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;  
#include &lt;cstdio&gt;  
#define ll long long   
using namespace std;  
const int N=1000000+2;  
int n,k,a[N],q[N],ans,hh,tt;  
  
int main(){  
    cin&gt;&gt;n&gt;&gt;k;  
    for(int i=0;i&lt;n;i++){  
        scanf("%d",&amp;a[i]);  
    }  
    //队列存的是下标  
    //最小值  
    hh=0;tt=-1;//目的是让队列初始化为空  
    for(int i=0;i&lt;n;i++){  
        //判断队列是否为空  
        if(hh&lt;=tt&amp;&amp;i-k+1&gt;q[hh]) hh++;  
        //目的是把最小的元素放在队头  
        while(hh&lt;=tt&amp;&amp;a[q[tt]]&gt;=a[i]) tt--;//从队尾删除，因为经过我们的处理，已经是严格单调递增的了，所以如果第一个都大于这个元素的话，那么后面几个都大于，所以要删除  
        q[++tt]=i;  
        if(i&gt;=k-1)  
        printf("%d ",a[q[hh]]);  
    }  
    cout&lt;&lt;endl;  
    //最大值  
      hh=0;tt=-1;  
    for(int i=0;i&lt;n;i++){  
        //判断队列是否为空  
        if(hh&lt;=tt&amp;&amp;i-k+1&gt;q[hh]) hh++;  
        //目的是把最大的元素放在队头  
        while(hh&lt;=tt&amp;&amp;a[q[tt]]&lt;=a[i]) tt--;  
        q[++tt]=i;  
        if(i&gt;=k-1)  
        printf("%d ",a[q[hh]]);  
    }  
      
    return 0;  
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h2><p>对称的 ,以j这个点为中点的前后缀是相同的，所以可以直接变成next[ j ]<br><img src="file://D:/typora%E7%94%A8%E5%9B%BE/Screenshots/image-20230511171657614.png?lastModify=1694256669" alt="image-20230511171657614"></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">s从1开始，p从0开始

// s[]是长文本，p[]是模式串，n是s的长度，m是p的长度  
求模式串的Next数组：ne[1]=0  ,一开始就错了肯定从零开始
for (int i = 2, j = 0; i &lt;= m; i ++ )  
{  
    while (j &amp;&amp; p[i] != p[j + 1]) j = ne[j];  
    if (p[i] == p[j + 1]) j ++ ;  
    ne[i] = j;  
}  
  
// 匹配  
for (int i = 1, j = 0; i &lt;= n; i ++ )  
{  
    while (j &amp;&amp; s[i] != p[j + 1]) j = ne[j];  
    if (s[i] == p[j + 1]) j ++ ;  
    if (j == m)  
    {  
        j = ne[j];  
        // 匹配成功后的逻辑  
    }  
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>例题</strong></p>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3375">P3375 【模板】KMP字符串匹配 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">
#include &lt;iostream&gt;  
#include &lt;cstring&gt;  
#define N 1000010  
using namespace std;  
char s[N],p[N];  
int ls,lp,ne[N];  
int main(){  
    cin&gt;&gt;s+1&gt;&gt;p+1;  
    ls=strlen(s+1);  
    lp=strlen(p+1);  
    for(int i=2,j=0;i&lt;=lp;i++){  
        while(j&amp;&amp;p[i]!=p[j+1]) j=ne[j];  
        if(p[j+1]==p[i]) j++;  
        ne[i]=j;  
    }  
     for(int i=1,j=0;i&lt;=ls;i++){  
        while(j&amp;&amp;s[i]!=p[j+1]) j=ne[j];  
        if(s[i]==p[j+1]) j++;  
        if(j==lp){  
            cout&lt;&lt;i-lp+1&lt;&lt;endl;  
            j=ne[j];  
        }  
    }  
    for(int i=1;i&lt;=lp;i++){  
        cout&lt;&lt;ne[i]&lt;&lt;" ";  
    }  
    return 0;  
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="Trie树-高效存储和查找字符串"><a href="#Trie树-高效存储和查找字符串" class="headerlink" title="Trie树 高效存储和查找字符串"></a>Trie树 高效存储和查找字符串</h2><p>集合的数据结构</p>
<p>将字符串分解为一个一个单独的字符然后存储，然后查询这个字符串是否出现过，</p>
<p>出现过几次</p>
<h4 id="更全面-的映射"><a href="#更全面-的映射" class="headerlink" title="更全面 的映射"></a>更全面 的映射</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int getnum(char x){  
    if(x&gt;='A'&amp;&amp;x&lt;='Z')  
        return x-'A';  
    else if(x&gt;='a'&amp;&amp;x&lt;='z')  
        return x -'a'+26;  
    else  
        return x-'0'+52;  
} 

#include&lt;iostream&gt;  
#include &lt;algorithm&gt;  
#include &lt;cstdio&gt;  
using namespace std;  
const int N=100010;  
int son[N][26],cnt[N],idx;//子子节点的个数，只包含26个 小写字母 cnt是以这个字母为结尾的单词出现了福哦少个  
//idx 当前用到哪了  
//插入操作  
char str[N];  
void insert(char str[]){  
 &nbsp; &nbsp;int p=0;//当前的结点  
 &nbsp; &nbsp;for(int i=0;str[i];i++){  
 &nbsp; &nbsp; &nbsp; &nbsp;int u=str[i]-'a';//将26个小写字母映射为数字  
 &nbsp; &nbsp; &nbsp; &nbsp;if(!son[p][u]) son[p][u]=++idx;  
 &nbsp; &nbsp; &nbsp; &nbsp;p=son[p][u];  
 &nbsp;  }  
 &nbsp; &nbsp;cnt[p]++;  
}  
int query(char str[]){  
 &nbsp; &nbsp;int p=0;  
 &nbsp; &nbsp;for(int i=0;str[i];i++){  
 &nbsp; &nbsp; &nbsp; &nbsp;int u=str[i]-'a';  
 &nbsp; &nbsp; &nbsp; &nbsp;if(!son[p][u]) return 0;  
 &nbsp; &nbsp; &nbsp; &nbsp;p=son[p][u];  
 &nbsp;  }  
 &nbsp; &nbsp;return cnt[p];  
}  
int main(){  
 &nbsp; &nbsp;int n;  
 &nbsp; &nbsp;cin&gt;&gt;n;  
 &nbsp; &nbsp;while(n--){  
 &nbsp; &nbsp; &nbsp; char op[2];  
 &nbsp; &nbsp; &nbsp; cin&gt;&gt;op&gt;&gt;str;  
 &nbsp; &nbsp; &nbsp; if(op[0]=='i') insert(str);  
 &nbsp; &nbsp; &nbsp; else cout&lt;&lt;query(str)&lt;&lt;endl;  
 &nbsp;  }  
 &nbsp; &nbsp;return 0;  
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P8306">P8306 【模板】字典树 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;  
#include &lt;algorithm&gt;  
#include &lt;cstdio&gt;  
#include &lt;cstring&gt;  
using namespace std;  
const int N=3000005;  
int son[N][65],cnt[N],idx;//子子节点的个数，只包含26个 小写字母 cnt是以这个字母位借位的单词出现了福哦少个  
//idx 当前用到哪了  
//插入操作  
 int n,m,t;  
char str[N];  
int hashs(char x){  
    if(x&gt;='A'&amp;&amp;x&lt;='Z')  
        return x-'A';  
    else if(x&gt;='a'&amp;&amp;x&lt;='z')  
        return x-'a'+26;  
    else  
        return x-'0'+52;  
}  
void insert(char str[]){  
    int p=0;//当前的结点  
    int l=strlen(str);  
    for(int i=0;i&lt;l;i++){  
        int u=hashs(str[i]);//将26个小写字母映射为数字  
        if(!son[p][u]) son[p][u]=++idx;  
        p=son[p][u];  
        cnt[p]++;  
    }  
      
}  
int query(char str[]){  
    int p=0;//当前的结点  
    int l=strlen(str);  
    for(int i=0;i&lt;l;i++){  
        int u =hashs(str[i]);  
        if(!son[p][u]) return 0;  
        p=son[p][u];  
    }  
    return cnt[p];  
}  
int main(){  
     
    cin&gt;&gt;t;  
    while(t--){  
          for(int i=0;i&lt;=idx;i++){  
            for(int j=0;j&lt;=122;j++){  
                son[i][j]=0;  
            }  
          }  
          for(int i=0;i&lt;=idx;i++)  
            cnt[i]=0;  
        idx=0;  
       scanf("%d%d",&amp;n,&amp;m);  
        while(n--){  
            scanf("%s",str);  
            insert(str);  
        }  
        while(m--){  
             scanf("%s",str);  
            printf("%d\n",query(str));  
        }  
    }  
    return 0;  
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><p>用法：</p>
<h3 id="某些点或者数据是否处于一个连通块中"><a href="#某些点或者数据是否处于一个连通块中" class="headerlink" title="某些点或者数据是否处于一个连通块中"></a>某些点或者数据是否处于一个连通块中</h3><ol>
<li><p>将两个集合合并</p>
</li>
<li><p>询问两个元素是否在一个集合中</p>
</li>
</ol>
<p>基本原理：每个集合用一个树来表示，树根的编号就是整个集合的编号，</p>
<p>每一个结点表示他的父节点p[x] 表示x的父节点</p>
<ul>
<li><p>判断树根: if（p[x]==x）</p>
</li>
<li><p>如何集合的编号： while(p[x]!=x) x=p[x];</p>
</li>
<li><p>如何合并两个集合直接让其中一个的根节点的父节点为另一个集合的根节点就行</p>
</li>
<li><p>如何优化，查询一次后，将将所经过的路径的父节点全都修改为根节点</p>
</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;  
#include &lt;algorithm&gt;  
#include &lt;cstdio&gt;  
#include &lt;cstring&gt;  
using namespace std;  
const int N=10010;  
int p[N];  
//初始每个点都是一个单独的集合  
void init(int n){  
    for(int i=1;i&lt;=n;i++){  
        p[i]=i;  
    }  
}  
int find(int x){  
    if(p[x]!=x) p[x]=find(p[x]);  
    return p[x];  
}  
  
int main(){  
    int n,m;  
    cin&gt;&gt;n&gt;&gt;m;  
    init(n);  
    char op[2];  
    while(m--){  
        int a,b;  
        cin&gt;&gt;op&gt;&gt;a&gt;&gt;b;  
        //合并两个集合,路径压缩  
        if(op[0]=='i') p[find(a)]=find(b);//让a的父节点等于b的父节点，即可合并  
        else {  
            //查询  
            if(find(a)==find(b)) cout&lt;&lt;"yes"&lt;&lt;endl;  
            else cout&lt;&lt;"no"&lt;&lt;endl;  
        }  
    }  
    return 0;  
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3367">P3367 【模板】并查集 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>
<p>维护点的数量：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;  
#include &lt;algorithm&gt;  
#include &lt;cstdio&gt;  
#include &lt;cstring&gt;  
using namespace std;  
const int N=10010;  
int p[N],sizes[N];//每个集合中点的数量  
//初始每个点都是一个单独的集合  
void init(int n){  
    for(int i=1;i&lt;=n;i++){  
        p[i]=i;  
        sizes[i]=1;  
    }  
}  
int find(int x){  
    if(p[x]!=x) p[x]=find(p[x]);  
    return p[x];  
}  
  
int main(){  
    int n,m;  
    cin&gt;&gt;n&gt;&gt;m;  
    init(n);  
    int op;  
    while(m--){  
        int a,b;  
        cin&gt;&gt;op;  
        //合并两个集合,路径压缩  
        if(op==1){  
            cin&gt;&gt;a&gt;&gt;b;  
            if(find(a)==find(b)) continue;  
            sizes[find(b)]+=sizes[find(a)];  
            p[find(a)]=find(b);//让a的父节点等于b的父节点，即可合并  
      
        }  
        else if(op==2){  
            //查询  
            cin&gt;&gt;a&gt;&gt;b;  
            if(find(a)==find(b)) cout&lt;&lt;"Y"&lt;&lt;endl;  
            else cout&lt;&lt;"N"&lt;&lt;endl;  
        }  
        else {  
            //询问某个集合中点的数量  
            cin&gt;&gt;n;  
            cout&lt;&lt;sizes[find(a)]&lt;&lt;endl;  
        }  
    }  
    return 0;  
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="堆-只能保证堆顶是最值，保证不了左右两边的大小关系"><a href="#堆-只能保证堆顶是最值，保证不了左右两边的大小关系" class="headerlink" title="堆 只能保证堆顶是最值，保证不了左右两边的大小关系"></a>堆 只能保证堆顶是最值，保证不了左右两边的大小关系</h2><p>操作：down 和up 把元素向下或向上走，使用的是一维数组，x的左儿子2x,右儿子2x+1</p>
<p>size 表示数组的最后一个位置</p>
<ol>
<li><p>插入一个元素： heap[++size]=x up(size)</p>
</li>
<li><p>求最小值 heap[1]</p>
</li>
<li><p>删除最小值 数组尾部好删除，所以用最后一个元素覆盖数组的头，然后执行down，</p>
<p> 再删除尾部，head[k]=heap[size];size–; down(k)||up(k)</p>
</li>
<li><p>修改 heap[k]=k; down(k)||up(k);</p>
</li>
</ol>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">// h[N]存储堆中的值, h[1]是堆顶，x的左儿子是2x, 右儿子是2x + 1  
// ph[k]存储第k个插入的点在堆中的位置  
// hp[k]存储堆中下标是k的点是第几个插入的  
int h[N], ph[N], hp[N], size;  
  
// 交换两个点，及其映射关系  
void heap_swap(int a, int b)  
{  
    swap(ph[hp[a]],ph[hp[b]]);  
    swap(hp[a], hp[b]);  
    swap(h[a], h[b]);  
}  
  
void down(int u)  
{  
    int t = u;  
    //查找到三个结点中的最小值  
    if (u * 2 &lt;= size &amp;&amp; h[u * 2] &lt; h[t]) t = u * 2;  
    if (u * 2 + 1 &lt;= size &amp;&amp; h[u * 2 + 1] &lt; h[t]) t = u * 2 + 1;  
    if (u != t)  
    {  
        heap_swap(u, t);  
        down(t);  
    }  
}  
  
void up(int u)  
{  
    while (u / 2 &amp;&amp; h[u] &lt; h[u / 2])//父节点存在且当前结点小于父节点   
    {  
        heap_swap(u, u / 2);  
        u &gt;&gt;= 1;//下一个父节点  
    }  
}  
  
// O(n)建堆  
for (int i = n / 2; i; i -- ) down(i);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3378">P3378 【模板】堆 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits/stdc++.h&gt;  
using namespace std;  
const int N=1000001;  
int h[N],s;  
void down(int u){  
    int t=u;  
    if(u*2&lt;=s&amp;&amp;h[u*2]&lt;h[t]) t=u*2;  
    if(u*2+1&lt;=s&amp;&amp;h[u*2+1]&lt;h[t]) t=u*2+1;  
    if(u!=t){  
        swap(h[u],h[t]);  
        down(t);  
    }  
}  
void up(int u){  
    while(u/2&amp;&amp;h[u]&lt;h[u/2]){  
        swap(h[u],h[u/2]);  
        u&gt;&gt;=1;  
    }  
}  
int main(){  
    int n,op;  
    cin&gt;&gt;n;  
    for(int i=n/2;i;i--){  
        down(i);  
    }  
    while(n--){  
        scanf("%d",&amp;op);  
        if(op==1) {  
            int x;  
            scanf("%d",&amp;x);  
            h[++s]=x;  
            up(s);  
        }  
        else if(op==2){  
            printf("%d\n",h[1]);  
        }  
        else {  
            //最后一个换到第一个  
            swap(h[1],h[s]);  
            s--;//删除最后一个  
            down(1);  
        }  
    }  
  
}
			<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h2><p>删除的话打个标记<br>(1) 拉链法 </p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int h[N], e[N], ne[N], idx;  
  
// 向哈希表中插入一个数  
void insert(int x)  
{  
    int k = (x % N + N) % N;  
    e[idx] = x;  
    ne[idx] = h[k];  
    h[k] = idx ++ ;  
}  
  
// 在哈希表中查询某个数是否存在  
bool find(int x)  
{  
    int k = (x % N + N) % N;  
    for (int i = h[k]; i != -1; i = ne[i])  
        if (e[i] == x)  
            return true;  
  
    return false;  
}  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>开放寻址法，遇到冲突的话直接往后找没用的节点</p>
<p>数组要开比原来数据范围大2~3倍</p>
<p>//只要开一个h数组就可以了，不需要e和ne了，找一个不在数据范围内的数据来表示当前位置为空<br>(2) 开放寻址法  </p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">   int h[N];  
const int null =xxx;  
   // 如果x在哈希表中，返回x的下标；如果x不在哈希表中，返回x应该插入的位置  
   int find(int x)  
   {  
       int t = (x % N + N) % N;  
       while (h[t] != null &amp;&amp; h[t] != x)  
       {  
           t ++ ;  
           if (t == N) t = 0;  
       }  
       return t;  
   }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="字符串哈希"><a href="#字符串哈希" class="headerlink" title="字符串哈希"></a>字符串哈希</h3><p>快速判断两个字符串是否相等</p>
<p>核心思想：将字符串看成P进制数，P的经验值是131或13331，取这两个值的冲突概率低<br>小技巧：取模的数用2^64，这样直接用unsigned long long存储，溢出的结果就是取模的结果  </p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">typedef unsigned long long ULL;  
ULL h[N], p[N]; // h[k]存储字符串前k个字母的哈希值, p[k]存储 P^k mod 2^64  
  
// 初始化  
p[0] = 1;  
for (int i = 1; i &lt;= n; i ++ )  
{  
    h[i] = h[i - 1] * P + str[i];  
    p[i] = p[i - 1] * P;//P存储的是每一位的基数值  
}  
  
// 计算子串 str[l ~ r] 的哈希值  
ULL get(int l, int r)  
{  
    return h[r] - h[l - 1] * p[r - l + 1];  
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="STL常用"><a href="#STL常用" class="headerlink" title="STL常用"></a>STL常用</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">vector, 变长数组，倍增的思想 &nbsp;优化思路：减少申请空间的次数  
 &nbsp; &nbsp;size() &nbsp;返回元素个数  
 &nbsp; &nbsp;empty() &nbsp;返回是否为空  
 &nbsp; &nbsp;clear() &nbsp;清空  
 &nbsp; &nbsp;front()/back()  
 &nbsp; &nbsp;push_back()/pop_back()  
 &nbsp; &nbsp;begin()/end()  
 &nbsp;  []  
 &nbsp; &nbsp;支持比较运算，按字典序  
 &nbsp; &nbsp;vector&lt;int&gt; a(1,2),b(3,4);  
printf(a&lt;b) == 0  
​  
pair&lt;int, int&gt;  
 &nbsp; &nbsp;first, 第一个元素  
 &nbsp; &nbsp;second, 第二个元素  
 &nbsp; &nbsp;支持比较运算，以first为第一关键字，以second为第二关键字（字典序）  
​  
string，字符串  
 &nbsp; &nbsp;size()/length() &nbsp;返回字符串长度  
 &nbsp; &nbsp;empty()  
 &nbsp; &nbsp;clear()  
 &nbsp; &nbsp;substr(起始下标，(子串长度)) &nbsp;返回子串  
 &nbsp; &nbsp;c_str() &nbsp;返回字符串所在字符数组的起始地址  
​  
queue, 队列  
 &nbsp; &nbsp;size()  
 &nbsp; &nbsp;empty()  
 &nbsp; &nbsp;push() &nbsp;向队尾插入一个元素  
 &nbsp; &nbsp;front() &nbsp;返回队头元素  
 &nbsp; &nbsp;back() &nbsp;返回队尾元素  
 &nbsp; &nbsp;pop() &nbsp;弹出队头元素  
​  
priority_queue, 优先队列，默认是大根堆  
 &nbsp; &nbsp;size()  
 &nbsp; &nbsp;empty()  
 &nbsp; &nbsp;push() &nbsp;插入一个元素  
 &nbsp; &nbsp;top() &nbsp;返回堆顶元素  
 &nbsp; &nbsp;pop() &nbsp;弹出堆顶元素  
 &nbsp; &nbsp;定义成小根堆的方式：priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; q;  
​  
stack, 栈  
 &nbsp; &nbsp;size()  
 &nbsp; &nbsp;empty()  
 &nbsp; &nbsp;push() &nbsp;向栈顶插入一个元素  
 &nbsp; &nbsp;top() &nbsp;返回栈顶元素  
 &nbsp; &nbsp;pop() &nbsp;弹出栈顶元素  
​  
deque, 双端队列  
 &nbsp; &nbsp;size()  
 &nbsp; &nbsp;empty()  
 &nbsp; &nbsp;clear()  
 &nbsp; &nbsp;front()/back()  
 &nbsp; &nbsp;push_back()/pop_back()  
 &nbsp; &nbsp;push_front()/pop_front()  
 &nbsp; &nbsp;begin()/end()  
 &nbsp;  []  
​  
set, map, multiset, multimap, 基于平衡二叉树（红黑树），动态维护有序序列  
 &nbsp; &nbsp;size()  
 &nbsp; &nbsp;empty()  
 &nbsp; &nbsp;clear()  
 &nbsp; &nbsp;begin()/end()  
 &nbsp; &nbsp;++, -- 返回前驱和后继，时间复杂度 O(logn)  
​  
 &nbsp; &nbsp;set/multiset  
 &nbsp; &nbsp; &nbsp; &nbsp;insert() &nbsp;插入一个数  
 &nbsp; &nbsp; &nbsp; &nbsp;find() &nbsp;查找一个数  
 &nbsp; &nbsp; &nbsp; &nbsp;count() &nbsp;返回某一个数的个数  
 &nbsp; &nbsp; &nbsp; &nbsp;erase()  
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  (1) 输入是一个数x，删除所有x &nbsp; O(k + logn)  
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  (2) 输入一个迭代器，删除这个迭代器  
 &nbsp; &nbsp; &nbsp; &nbsp;lower_bound()/upper_bound()  
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;lower_bound(x) &nbsp;返回大于等于x的最小的数的迭代器  
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;upper_bound(x) &nbsp;返回大于x的最小的数的迭代器  
 &nbsp; &nbsp;map/multimap  
 &nbsp; &nbsp; &nbsp; &nbsp;insert() &nbsp;插入的数是一个pair  
 &nbsp; &nbsp; &nbsp; &nbsp;erase() &nbsp;输入的参数是pair或者迭代器  
 &nbsp; &nbsp; &nbsp; &nbsp;find()  
 &nbsp; &nbsp; &nbsp;  [] &nbsp;注意multimap不支持此操作。 时间复杂度是 O(logn)  
 &nbsp; &nbsp; &nbsp; &nbsp;lower_bound()/upper_bound()  
​  
unordered_set, unordered_map, unordered_multiset, unordered_multimap, 哈希表  
 &nbsp; &nbsp;和上面类似，增删改查的时间复杂度是 O(1)  
 &nbsp; &nbsp;不支持 lower_bound()/upper_bound()， 迭代器的++，--  
​  
bitset, 圧位 省空间 &nbsp; &nbsp;  
 &nbsp; &nbsp;bitset&lt;10000&gt; s; &nbsp;//&lt; &gt;里面是个数, 可以用来替代bool 数组  
    //以下操作都支持  
    ~, &amp;, |, ^  
 &nbsp; &nbsp;&gt;&gt;, &lt;&lt;  
 &nbsp; &nbsp;==, !=  
 &nbsp;  []  
​  
 &nbsp; &nbsp;count() &nbsp;返回有多少个1  
​  
 &nbsp; &nbsp;any() &nbsp;判断是否至少有一个1  
 &nbsp; &nbsp;none() &nbsp;判断是否全为0  
​  
 &nbsp; &nbsp;set() &nbsp;把所有位置成1  
 &nbsp; &nbsp;set(k, v) &nbsp;将第k位变成v  
 &nbsp; &nbsp;reset() &nbsp;把所有位变成0  
 &nbsp; &nbsp;flip() &nbsp;等价于~  
 &nbsp; &nbsp;flip(k) 把第k位取反  
​<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="图论背思路"><a href="#图论背思路" class="headerlink" title="图论背思路"></a>图论背思路</h2><h2 id="BFS和DFS"><a href="#BFS和DFS" class="headerlink" title="BFS和DFS"></a>BFS和DFS</h2><h3 id="非常完美的一道dfs-并查集-https-www-luogu-com-cn-problem-P1127"><a href="#非常完美的一道dfs-并查集-https-www-luogu-com-cn-problem-P1127" class="headerlink" title="非常完美的一道dfs + 并查集 https://www.luogu.com.cn/problem/P1127"></a>非常完美的一道dfs + 并查集 <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1127">https://www.luogu.com.cn/problem/P1127</a></h3><p><u>还原现场很重要</u> </p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span> start<span class="token punctuation">,</span><span class="token keyword">int</span> num<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>num <span class="token operator">==</span> n<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
		<span class="token comment">//开始搜索</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			<span class="token comment">//找start这个开头的string</span>
			<span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token char">'a'</span> <span class="token operator">==</span> start <span class="token operator">&amp;&amp;</span> st<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
				<span class="token comment">//标记</span>
				st<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
				ans<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">dfs</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token char">'a'</span><span class="token punctuation">,</span>num<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
				<span class="token comment">//还原现场</span>
				st<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
				ans<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>ans<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			
		<span class="token punctuation">}</span>
		<span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="DFS-回溯的时候记得回复现场"><a href="#DFS-回溯的时候记得回复现场" class="headerlink" title="DFS 回溯的时候记得回复现场"></a>DFS 回溯的时候记得回复现场</h3><h3 id="邻接矩阵：-p-a-b-a-gt-b-适合稠密图"><a href="#邻接矩阵：-p-a-b-a-gt-b-适合稠密图" class="headerlink" title="邻接矩阵： p[ a] [ b ] a -> b 适合稠密图"></a>邻接矩阵： p[ a] [ b ] a -&gt; b 适合稠密图</h3><h3 id="邻接表：-稀疏图"><a href="#邻接表：-稀疏图" class="headerlink" title="邻接表： 稀疏图"></a>邻接表： 稀疏图</h3><p>和哈希表思路一样</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">// 对于每个点k，开一个单链表，存储k所有可以走到的点。h[k]存储这个单链表的头结点  
int h[N], e[N], ne[N], idx; //e是终点end  
  
// 添加一条边a-&gt;b  
void add(int a, int b)  
{  
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;  
}   
// 初始化  
idx = 0;  
memset(h, -1, sizeof h);  
//遍历图  
for(int i = h[t] ; i != -1 ; i = ne[i] )

## 另一种使用结构体的邻接表存法

int idx=0,n;  
int h[N] , dis[N] , vis[N];  
struct Edge{  
    int ne,to,dis;  
}ed[N];  
//添加， 从 1 开始  
void add(int a,int b ,int c){  
    ed[++idx].ne = h[a];  
    ed[idx].to = b;  
    ed[idx].dis = c;  
    h[a] = idx;  
}
//遍历图  
for(int i = h[t] ; i ; i = ed[i].ne)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="BFS-可用于解决权值相等的最短路径问题"><a href="#BFS-可用于解决权值相等的最短路径问题" class="headerlink" title="BFS 可用于解决权值相等的最短路径问题"></a>BFS 可用于解决权值相等的最短路径问题</h3><h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><p>必须是又向无环</p>
<p>排完后，所有的起点都在终点之前</p>
<ol>
<li><p>统计每一个节点的入度和出度</p>
</li>
<li><p>每一次将入读相同的点放入queue</p>
</li>
<li><p>枚举队头的出边，删掉 出边,这条边的终点的入度-1</p>
</li>
<li><p>如果某个点的入度为0 放入队列</p>
</li>
</ol>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">bool topsort()  
{  
    int hh = 0, tt = -1;  
  
    // d[i] 存储点i的入度  
    for (int i = 1; i &lt;= n; i ++ )  
        if (!d[i])  
            q[ ++ tt] = i;//把每个入度为0的点加入队列  
  
    while (hh &lt;= tt)  
    {  
        int t = q[hh ++ ];//取出队头  
		//从队头开始找路径  
        for (int i = h[t]; i != -1; i = ne[i])  
        {  
            int j = e[i];  
            if (-- d[j] == 0)  
                q[ ++ tt] = j;  
        }  
    }  
  
    // 如果所有点都入队了，说明存在拓扑序列；否则不存在拓扑序列。  
    return tt == n - 1;  
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="最短路问题："><a href="#最短路问题：" class="headerlink" title="最短路问题："></a>最短路问题：</h2><h2 id="分层最短路-，适用于乘车路线和免费次数。"><a href="#分层最短路-，适用于乘车路线和免费次数。" class="headerlink" title="_分层最短路_，适用于乘车路线和免费次数。"></a>_分层最短路_，适用于乘车路线和免费次数。</h2><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P4568#submit">飞机路线</a></p>
<h3 id="单源最短路-一个点-x2F-到其他所有点的最短路"><a href="#单源最短路-一个点-x2F-到其他所有点的最短路" class="headerlink" title="单源最短路 一个点./.到其他所有点的最短路"></a>单源最短路 一个点./.到其他所有点的最短路</h3><ul>
<li><p>所有边的权都是正数</p>
<ol>
<li>朴素Dijkstra O(n^2) n为点的数量 稠密图 边很多 外部迭代n-1 次 <pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int g[N][N];  // 存储每条边  权值  
int dist[N];  // 存储1号点到每个点的最短距离  
bool st[N];   // 存储每个点的最短路是否已经确定  
  
// 求1号点到n号点的最短路，如果不存在则返回-1  
int dijkstra()  
{  
    memset(dist, 0x3f, sizeof dist);  
    dist[1] = 0;  
  
    for (int i = 0; i &lt; n - 1; i ++ )//迭代n-1 次，因为上来选中了一个点  
    {  
        int t = -1;     // 在还未确定最短路的点中，寻找距离最小的点  
        for (int j = 1; j &lt;= n; j ++ )  
            if (!st[j] &amp;&amp; (t == -1 || dist[t] &gt; dist[j]))  
                t = j;  
  
        // 用t更新其他点的距离  
        for (int j = 1; j &lt;= n; j ++ )  
            dist[j] = min(dist[j], dist[t] + g[t][j]);  
  
        st[t] = true;  
    }  
  
    if (dist[n] == 0x3f3f3f3f) return -1;  
    return dist[n];  
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li>堆优化版的 O(mlogn) 稀疏图  <pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">typedef pair&lt;int, int&gt; PII;  
  
int n;      // 点的数量  
int h[N], w[N], e[N], ne[N], idx;       // 邻接表存储所有边  
int dist[N];        // 存储所有点到1号点的距离  
bool st[N];     // 存储每个点的最短距离是否已确定  
  
// 求1号点到n号点的最短距离，如果不存在，则返回-1  
int dijkstra()  
{  
    memset(dist, 0x3f, sizeof dist);  
    dist[1] = 0;  
    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;  
    heap.push({0, 1});      // first存储距离，second存储节点编号  
  
    while (heap.size())  
    {  
        auto t = heap.top();  
        heap.pop();  
  
        int ver = t.second, distance = t.first;  
  
        if (st[ver]) continue;  
        st[ver] = true;  
  
        for (int i = h[ver]; i != -1; i = ne[i])  
        {  
            int j = e[i];  
            if (dist[j] &gt; distance + w[i])  
            {  
                dist[j] = distance + w[i];  
                heap.push({dist[j], j});  
            }  
        }  
    }  
  
    if (dist[n] == 0x3f3f3f3f) return -1;  
    return dist[n];  
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ol>
</li>
<li><p>存在负权边</p>
<ol>
<li><p>Bellman -Ford O(nm) <strong>奇妙的存图方式</strong> 无负权回路 经过路径有次数限制的话只能用这个了，外面限制的是经过i的点的个数，然后每次遍历边即可。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int n, m;       // n表示点数，m表示边数  
int dist[N];        // dist[x]存储1到x的最短路距离  
  
struct Edge     // 边，a表示出点，b表示入点，w表示边的权重  
{  
    int a, b, w;  
}edges[M];  
  
// 求1到n的最短路距离，如果无法从1走到n，则返回-1。  
int bellman_ford()  
{  
    memset(dist, 0x3f, sizeof dist);  
    dist[1] = 0;  
	//不需要进行收录顶点  
    // 如果第n次迭代仍然会松弛三角不等式，就说明存在一条长度是n+1的最短路径，由抽屉原理，路径中至少存在两个相同的点，说明图中存在负权回路。  
    for (int i = 0; i &lt; n; i ++ )//这个n是指的是最多不经过 多少次经过同一条边  
    {  
        for (int j = 0; j &lt; m; j ++ )  
        {  
            int a = edges[j].a, b = edges[j].b, w = edges[j].w;  
            if (dist[b] &gt; dist[a] + w)  
                dist[b] = dist[a] + w;  
        }  
    }  
  
    if (dist[n] &gt; 0x3f3f3f3f / 2) return -1;  
    return dist[n];  
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><p>SPFA 一般： O（m) 最坏O（nm） 不存在负权环才能使用 99%都没有负环比较好用</p>
<p> 优化思路：只有更新过点才对后面的点更新有影响</p>
<p> 要从 1 开始存比较好 ，e 是end 也就是一条边的终点</p>
 <pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int n;      // 总点数  
int h[N], w[N], e[N], ne[N], idx;       // 邻接表存储所有边  
int dist[N];        // 存储每个点到1号点的最短距离  
bool st[N];     // 存储每个点是否在队列中  
  
  
// 求x号点到n号点的最短路距离，如果从1号点无法走到n号点则返回-1  
int spfa(int x)  
{  
    memset(dist, 0x3f, sizeof dist);//初始化要根据题目来  
      
    dist[x] = 0;  
/*或者  
for(int i = 1 ; i &lt;= n ; i ++){  
        dis[i] = INT_MAX;  
    }*/	  
    queue&lt;int&gt; q;  
    q.push(x);  
  
    while (q.size())//不为空，即为还有更新的点  
    {  
        auto t = q.front();  
        q.pop();  
  
        st[t] = false;//这里不要忘记  
       //遍历所以能到达的顶点，进行更新  
        for (int i = h[t]; i != -1; i = ne[i])  
        {  
            int j = e[i];  
            if (dist[j] &gt; dist[t] + w[i])  
            {  
                dist[j] = dist[t] + w[i];  
                if (!st[j])     // 如果队列中已存在j，则不需要将j重复插入  
                {  
                    q.push(j);//这里是j  
                    st[j] = true;//这里是j  
                }  
            }  
        }  
    }  
  
    if (dist[n] == 0x3f3f3f3f) return -1;  
    return dist[n];  
}  
//初始化和存图  
void add(int a, int b , int c){  
    w[idx] = c;  
    ne[idx] = h[a];   
    en[idx] =  b;    
    h[a] = idx++;  
}  
void init(){  
    idx = 1;  
    memset(h , -1 ,sizeof h);  
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="模板题："><a href="#模板题：" class="headerlink" title="模板题："></a>模板题：</h4><p> <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3371">P3371 【模板】单源最短路径（弱化版） - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>
</li>
</ol>
</li>
</ul>
<h2 id="x3D-x3D-判断有无负环-用cnt-来记录当前最短路的边数"><a href="#x3D-x3D-判断有无负环-用cnt-来记录当前最短路的边数" class="headerlink" title="==判断有无负环 用cnt 来记录当前最短路的边数"></a>==<strong>判断有无负环 用cnt 来记录当前最短路的边数</strong></h2><p>例题： <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3385">负环路</a></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int n;      // 总点数  
int h[N], w[N], e[N], ne[N], idx;       // 邻接表存储所有边  
int dist[N], cnt[N];        // dist[x]存储1号点到x的最短距离，cnt[x]存储1到x的最短路中经过的点数  
bool st[N];     // 存储每个点是否在队列中  
  
// 如果存在负环，则返回true，否则返回false。  
bool spfa()  
{  
    // 不需要初始化dist数组  
    // 原理：如果某条最短路径上有n个点（除了自己），那么加上自己之后一共有n+1个点，由抽屉原理一定有两个点相同，所以存在环。  
  
    queue&lt;int&gt; q;  
    for (int i = 1; i &lt;= n; i ++ )  
    {  
        q.push(i);  
        st[i] = true;  
    }  
  
    while (q.size())  
    {  
        auto t = q.front();  
        q.pop();  
  
        st[t] = false;  
  
        for (int i = h[t]; i != -1; i = ne[i])  
        {  
            int j = e[i];  
            if (dist[j] &gt; dist[t] + w[i])  
            {  
                dist[j] = dist[t] + w[i];  
                cnt[j] = cnt[t] + 1;  
                if (cnt[j] &gt;= n) return true;       // 如果从1号点到x的最短路中包含至少n个点（不包括自己），则说明存在环  
                if (!st[j])  
                {  
                    q.push(j);  
                    st[j] = true;  
                }  
            }  
        }  
    }  
  
    return false;  
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="多源汇最短路-起点终点都不确定"><a href="#多源汇最短路-起点终点都不确定" class="headerlink" title="多源汇最短路 起点终点都不确定"></a>多源汇最短路 起点终点都不确定</h3><p>Floyd O(n^3)</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">初始化：  
 &nbsp; &nbsp;for (int i = 1; i &lt;= n; i ++ )  
 &nbsp; &nbsp; &nbsp; &nbsp;for (int j = 1; j &lt;= n; j ++ )  
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if (i == j) d[i][j] = 0;  
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;else d[i][j] = INF;  
​  
// 算法结束后，d[a][b]表示a到b的最短距离  
void floyd()  
{  
 &nbsp; &nbsp;for (int k = 1; k &lt;= n; k ++ )  
 &nbsp; &nbsp; &nbsp; &nbsp;for (int i = 1; i &lt;= n; i ++ )  
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;for (int j = 1; j &lt;= n; j ++ )  
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;d[i][j] = min(d[i][j], d[i][k] + d[k][j]);// i经过k 点到达j   
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><h3 id="普利姆算法-Prim-思路和Dijsktra算法相似-外部迭代-n-次，因为没有提前选中一个点"><a href="#普利姆算法-Prim-思路和Dijsktra算法相似-外部迭代-n-次，因为没有提前选中一个点" class="headerlink" title="普利姆算法 Prim 思路和Dijsktra算法相似 外部迭代 n 次，因为没有提前选中一个点"></a>普利姆算法 Prim 思路和Dijsktra算法相似 外部迭代 n 次，因为没有提前选中一个点</h3><h3 id="迭代n次因为没有提前选中一个点-枚举所有点"><a href="#迭代n次因为没有提前选中一个点-枚举所有点" class="headerlink" title="迭代n次因为没有提前选中一个点 枚举所有点"></a>迭代n次因为没有提前选中一个点 枚举所有点</h3><ol>
<li><p>朴素Prim算法 稠密图 每次找到未收录的距离最近的点，收录并进行更新其他点到<strong>集合</strong>的距离</p>
</li>
<li><p>找这个点是否与集合内部相连</p>
</li>
<li><p>某个点到这个集合的距离为某个点到这个集合当中的点的距离最短的边</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int n; &nbsp; &nbsp; &nbsp;// n表示点数  
int g[N][N]; &nbsp; &nbsp; &nbsp; &nbsp;// 邻接矩阵，存储所有边  
int dist[N]; &nbsp; &nbsp; &nbsp; &nbsp;// 存储其他点到当前最小生成树的距离  
bool st[N]; &nbsp; &nbsp; // 存储每个点是否已经在生成树中  
​  
​  
// 如果图不连通，则返回INF(值是0x3f3f3f3f), 否则返回最小生成树的树边权重之和  
int prim()  
{  
 &nbsp; &nbsp;memset(dist, 0x3f, sizeof dist);  
​  
 &nbsp; &nbsp;int res = 0;  
 &nbsp; &nbsp;for (int i = 0; i &lt; n; i ++ )  
 &nbsp;  {  
 &nbsp; &nbsp; &nbsp; &nbsp;int t = -1;  
 &nbsp; &nbsp; &nbsp; &nbsp;for (int j = 1; j &lt;= n; j ++ )  
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if (!st[j] &amp;&amp; (t == -1 || dist[t] &gt; dist[j]))  
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;t = j;  
​  
 &nbsp; &nbsp; &nbsp; &nbsp;if (i &amp;&amp; dist[t] == INF) return INF;  
​  
 &nbsp; &nbsp; &nbsp; &nbsp;if (i) res += dist[t];  
 &nbsp; &nbsp; &nbsp; &nbsp;st[t] = true;  
​  
 &nbsp; &nbsp; &nbsp; &nbsp;for (int j = 1; j &lt;= n; j ++ ) dist[j] = min(dist[j], g[t][j]);  
 &nbsp; &nbsp; &nbsp; &nbsp;//不是相加  
 &nbsp;  }  
​  
 &nbsp; &nbsp;return res;  
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>堆优化版的Prim 稀疏图 不常用</p>
</li>
</ol>
<h3 id="克鲁斯卡尔算法-Kruskal-先对边进行排序-稀疏图-可以用并查集-枚举所有边"><a href="#克鲁斯卡尔算法-Kruskal-先对边进行排序-稀疏图-可以用并查集-枚举所有边" class="headerlink" title="克鲁斯卡尔算法 Kruskal 先对边进行排序 稀疏图 可以用并查集 枚举所有边"></a>克鲁斯卡尔算法 Kruskal 先对边进行排序 稀疏图 可以用并查集 枚举所有边</h3><p>java版本:</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">bronya</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token operator">*</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>math<span class="token punctuation">.</span></span><span class="token class-name">BigInteger</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token operator">*</span></span><span class="token punctuation">;</span>


<span class="token keyword">class</span> <span class="token class-name">Edge</span> <span class="token punctuation">{</span>
	<span class="token keyword">int</span> a <span class="token punctuation">,</span> b <span class="token punctuation">,</span> w<span class="token punctuation">;</span>
	<span class="token keyword">public</span> <span class="token class-name">Edge</span><span class="token punctuation">(</span><span class="token keyword">int</span> a <span class="token punctuation">,</span> <span class="token keyword">int</span> b <span class="token punctuation">,</span> <span class="token keyword">int</span> w<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">this</span><span class="token punctuation">.</span>a <span class="token operator">=</span> a<span class="token punctuation">;</span>
		<span class="token keyword">this</span><span class="token punctuation">.</span>b <span class="token operator">=</span> b<span class="token punctuation">;</span>
		<span class="token keyword">this</span><span class="token punctuation">.</span>w <span class="token operator">=</span> w<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span><span class="token punctuation">{</span>

	<span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token class-name">N</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token number">2</span> <span class="token operator">*</span> <span class="token number">1e5</span> <span class="token operator">+</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">static</span> <span class="token keyword">int</span> n <span class="token punctuation">,</span> m <span class="token punctuation">;</span>
	<span class="token keyword">static</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token keyword">static</span> <span class="token class-name">Edge</span><span class="token punctuation">[</span><span class="token punctuation">]</span> ed <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Edge</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token keyword">static</span> <span class="token keyword">long</span> ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>x <span class="token operator">!=</span> p<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">)</span> p<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>p<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span> p<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">check</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n <span class="token punctuation">;</span>  i <span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			p<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>ed<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>m<span class="token punctuation">,</span><span class="token punctuation">(</span>e1<span class="token punctuation">,</span>e2<span class="token punctuation">)</span><span class="token operator">-&gt;</span>e1<span class="token punctuation">.</span>w <span class="token operator">-</span> e2<span class="token punctuation">.</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">int</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
		<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m <span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			<span class="token keyword">int</span> a <span class="token operator">=</span> ed<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>a<span class="token punctuation">;</span>
			<span class="token keyword">int</span> b <span class="token operator">=</span> ed<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>b<span class="token punctuation">;</span>
			<span class="token keyword">int</span> w <span class="token operator">=</span> ed<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>w<span class="token punctuation">;</span>
			a <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
			b <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">if</span><span class="token punctuation">(</span>a <span class="token operator">!=</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
				p<span class="token punctuation">[</span>a<span class="token punctuation">]</span> <span class="token operator">=</span> b<span class="token punctuation">;</span>
				ans <span class="token operator">+=</span> w<span class="token punctuation">;</span>
				cnt <span class="token operator">++</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>cnt <span class="token operator">&lt;</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
		<span class="token keyword">else</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">{</span>
		<span class="token class-name">BufferedReader</span> re <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> s <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		n <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		m <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span>  i <span class="token operator">&lt;</span> m <span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			s <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">int</span> w <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			ed<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Edge</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> w<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">boolean</span> f <span class="token operator">=</span> <span class="token function">check</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>ans<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">else</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"orz"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3366">P3366 【模板】最小生成树 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>
<ol>
<li><p>所有边按权重从小到大排序</p>
</li>
<li><p>枚举每条边a,b权重c if a,b不连通， 将这条边加入集合中</p>
</li>
</ol>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int n, m;       // n是点数，m是边数  
int p[N];       // 并查集的父节点数组  
  
struct Edge     // 存储边  
{  
    int a, b, w;  
  
    bool operator&lt; (const Edge &amp;W)const // 重载了 &lt;   
    {  
        return w &lt; W.w;  
    }  
}edges[M];  
  
int find(int x)     // 并查集核心操作  
{  
    if (p[x] != x) p[x] = find(p[x]);  
    return p[x];  
}  
  
int kruskal()  
{  
    sort(edges, edges + m);  
  
    for (int i = 1; i &lt;= n; i ++ ) p[i] = i;    // 初始化并查集  
  
    int res = 0, cnt = 0;  
    for (int i = 0; i &lt; m; i ++ )  
    {  
        int a = edges[i].a, b = edges[i].b, w = edges[i].w;  
  
        a = find(a), b = find(b);  
        if (a != b)     // 如果两个连通块不连通，则将这两个连通块合并  
        {  
            p[a] = b;  
            res += w;  
            cnt ++ ;  
        }  
    }  
  
    if (cnt &lt; n - 1) return INF;  
    return res;  
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="二分图-当且仅当图中没有奇数环"><a href="#二分图-当且仅当图中没有奇数环" class="headerlink" title="二分图 当且仅当图中没有奇数环"></a>二分图 当且仅当图中没有奇数环</h2><h3 id="染色法-O-n-m-判断是否是二分图"><a href="#染色法-O-n-m-判断是否是二分图" class="headerlink" title="染色法 O(n+m) 判断是否是二分图"></a>染色法 O(n+m) 判断是否是二分图</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int n;      // n表示点数  
int h[N], e[M], ne[M], idx;     // 邻接表存储图  
int color[N];       // 表示每个点的颜色，-1表示未染色，0表示白色，1表示黑色  
  
// 参数：u表示当前节点，c表示当前点的颜色  
bool dfs(int u, int c)  
{  
    color[u] = c;  
    for (int i = h[u]; i != -1; i = ne[i])  
    {  
        int j = e[i];  
        if (color[j] == -1)//未染色  
        {  
            if (!dfs(j, !c)) return false;//比如两种颜色， 0，1表示，那么这里就可以用 3- c,也就是用另一种颜色去染色  
        }  
        else if (color[j] == c) return false;  
    }  
  
    return true;  
}  
  
bool check()  
{  
    memset(color, -1, sizeof color);  
    bool flag = true;  
    //枚举所有点，去染色  
    for (int i = 1; i &lt;= n; i ++ )  
        if (color[i] == -1)  
            if (!dfs(i, 0))  
            {  
                flag = false;  
                break;  
            }  
    return flag;  
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="匈牙利算法-O-mn-实际运行时间一般小于这个值-稠密图不适合用邻接表，推荐使用临界矩阵"><a href="#匈牙利算法-O-mn-实际运行时间一般小于这个值-稠密图不适合用邻接表，推荐使用临界矩阵" class="headerlink" title="匈牙利算法 O(mn) 实际运行时间一般小于这个值 稠密图不适合用邻接表，推荐使用临界矩阵"></a>匈牙利算法 O(mn) 实际运行时间一般小于这个值 稠密图不适合用邻接表，推荐使用临界矩阵</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int n1, n2; &nbsp; &nbsp; // n1表示第一个集合中的点数，n2表示第二个集合中的点数  
int h[N], e[M], ne[M], idx; &nbsp; &nbsp; // 邻接表存储所有边，匈牙利算法中只会用到从第一个集合指向第二个集合的边，所以这里只用存一个方向的边  
int match[N]; &nbsp; &nbsp; &nbsp; // 存储第二个集合中的每个点当前匹配的第一个集合中的点是哪个  
bool st[N]; &nbsp; &nbsp; // 表示第二个集合中的每个点是否已经被遍历过  
​  
bool find(int x)  
{  
 &nbsp; &nbsp;for (int i = h[x]; i != -1; i = ne[i])  
 &nbsp;  {  
 &nbsp; &nbsp; &nbsp; &nbsp;int j = e[i];  
 &nbsp; &nbsp; &nbsp; &nbsp;if (!st[j])  
 &nbsp; &nbsp; &nbsp;  {  
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;st[j] = true;  
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if (match[j] == 0 || find(match[j]))//第二个集合的点未匹配，或者是可以为已经 匹配的第一个集合中的点找到别的集合二中的点  
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  {  
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;match[j] = x;  
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return true;  
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  }  
 &nbsp; &nbsp; &nbsp;  }  
 &nbsp;  }  
​  
 &nbsp; &nbsp;return false;  
}  
​  
// 求最大匹配数，依次枚举第一个集合中的每个点能否匹配第二个集合中的点  
int res = 0;  
for (int i = 1; i &lt;= n1; i ++ )  
{  
 &nbsp; &nbsp;memset(st, false, sizeof st);  
 &nbsp; &nbsp;if (find(i)) res ++ ;  
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>例题：<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3386">P3386 【模板】二分图最大匹配 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></strong></p>
<h2 id="邻接表的写法-稠密图会超时"><a href="#邻接表的写法-稠密图会超时" class="headerlink" title="邻接表的写法(稠密图会超时)"></a>邻接表的写法(稠密图会超时)</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits/stdc++.h&gt;  
using namespace std;  
const int N  = 505;  
int n1,n2,ed;//需要两个集合  
int h[N] , ne[N] , e[N] , idx;  
int match[N] ;  
bool vis[N];  
void init(){  
    memset(h,-1,sizeof h);  
    idx = 0;  
}  
void add(int a, int b){  
    e[idx] = b ;  
    ne[idx] = h[a];  
    h[a] = idx++;  
}  
bool find(int x){  
    for (int i = h[x] ; i != -1 ; i =ne[i]){  
        int j = e[i];  
        if(!vis[j]){  
            vis[j] = true;  
            if(match[j] == 0 || find(match[j])){  
                //如果终边的点未匹配，或者是可以为以匹配的起点找到另一个终点  
                match[j] = x;  
                return true;  
            }  
        }  
    }  
    return false;  
}  
int main(){  
    ios::sync_with_stdio(false);  
    cin.tie(nullptr);  
    cin &gt;&gt; n1 &gt;&gt; n2 &gt;&gt;ed;  
    init();  
    int u ,v;  
    for (int i = 1 ; i &lt;= ed ; i++){  
        cin &gt;&gt; u &gt;&gt; v;  
        if(v &lt;= n2){  
            add(u , v);  
        }  
         
    }  
    int ans = 0;  
    for (int i = 1 ; i &lt;= n1 ; i++){  
        memset(vis, false ,sizeof vis);  
        if(find(i)) ans++;  
    }  
    cout &lt;&lt; ans &lt;&lt;endl ;  
    return 0;  
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="邻接矩阵的写法："><a href="#邻接矩阵的写法：" class="headerlink" title="邻接矩阵的写法："></a>邻接矩阵的写法：</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits/stdc++.h&gt;  
using namespace std;  
const int N  = 505;  
int n1,n2,ed;//需要两个集合  
bool a[N][N];  
int match[N];  
bool vis[N];  
bool find(int x){  
    //枚举终边  
    for (int i = 1 ; i &lt;= n2 ; i ++){  
        if(!vis[i] &amp;&amp; a[x][i]){  
            vis[i] = true;  
            if(match[i] == 0 || find(match[i])){  
                //如果终边的点未匹配，或者是可以为以匹配的起点找到另一个终点  
                match[i] = x;  
                return true;  
            }  
        }  
    }  
    return false;  
}  
int main(){  
    ios::sync_with_stdio(false);  
    cin.tie(nullptr);  
    cin &gt;&gt; n1 &gt;&gt; n2 &gt;&gt;ed;  
    int u ,v;  
    for (int i = 1 ; i &lt;= ed ; i++){  
        cin &gt;&gt; u &gt;&gt; v;  
        if(v &lt;= n2){  
            a[u][v] = 1;  
        }  
         
    }  
    int ans = 0;  
    for (int i = 1 ; i &lt;= n1 ; i++){  
        ans+=find(i); // 这里不一样哦  
        memset(vis, false ,sizeof vis);  
    }  
    cout &lt;&lt; ans &lt;&lt;endl ;  
    return 0;  
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="数学知识"><a href="#数学知识" class="headerlink" title="数学知识"></a>数学知识</h2><blockquote>
<p>[!NOTE]</p>
<h2 id="当看见-0-的个数时考虑将结果分成-2-，-5-的个数-并且，末尾的0的个数一定是由5的个数决定的"><a href="#当看见-0-的个数时考虑将结果分成-2-，-5-的个数-并且，末尾的0的个数一定是由5的个数决定的" class="headerlink" title="当看见 0 的个数时考虑将结果分成 2 ， 5 的个数,并且，末尾的0的个数一定是由5的个数决定的"></a>当看见 0 的个数时考虑将结果分成 2 ， 5 的个数,并且，末尾的0的个数一定是由5的个数决定的</h2></blockquote>
<p><a target="_blank" rel="noopener" href="https://ac.nowcoder.com/acm/contest/57683/E">E-Kevin喜欢零(困难版本)_牛客小白月赛73 (nowcoder.com)</a></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits/stdc++.h&gt;  
​  
void solve() {#include &lt;bits/stdc++.h&gt;  
​  
void solve() {  
 &nbsp; &nbsp;int n, k;  
 &nbsp; &nbsp;std::cin &gt;&gt; n &gt;&gt; k;  
​  
 &nbsp; &nbsp;int64_t ans = 0;  
 &nbsp; &nbsp;std::unordered_map&lt;int, std::vector&lt;int&gt;&gt; tp, fp;  
 &nbsp; &nbsp;//tp 记录5的个数，fp记录2的个数  
 &nbsp; &nbsp;//两个是互补的  
 &nbsp; &nbsp;tp[0].push_back(0);  
 &nbsp; &nbsp;fp[0].push_back(0);  
​  
 &nbsp; &nbsp;for (int i = 0, t = 0, f = 0; i &lt; n; i++) {  
 &nbsp; &nbsp; &nbsp; &nbsp;int x;  
 &nbsp; &nbsp; &nbsp; &nbsp;std::cin &gt;&gt; x;  
 &nbsp; &nbsp; &nbsp; &nbsp;for (; x &amp;&amp; x % 2 == 0; x /= 2, t++) {  
 &nbsp; &nbsp; &nbsp;  }  
 &nbsp; &nbsp; &nbsp; &nbsp;for (; x &amp;&amp; x % 5 == 0; x /= 5, f++) {  
 &nbsp; &nbsp; &nbsp;  }  
 &nbsp; &nbsp; &nbsp; &nbsp;ans += std::max(  
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//需要 2^k &nbsp; * 5^k 即可满足 10^k 所以是动态规划  
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//每次计算出当前数据含有的2 和  5 的数量 和仍然需要 k  - 当前数量 &nbsp; 这一行的去更新  
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//因为同一个状态有可能对应多个数据， 所以只要找到第一个满足能凑出另一个2或者5的即可   
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//map不能使用upper_bound 但是 内部的vector 是可以使用的  
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;std::upper_bound(tp[t - k].begin(), tp[t - k].end(), f - k) - tp[t - k].begin(),  
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;std::upper_bound(fp[f - k].begin(), fp[f - k].end(), t - k) - fp[f - k].begin()  
 &nbsp; &nbsp; &nbsp;  );  
 &nbsp; &nbsp; &nbsp; &nbsp;tp[t].push_back(f);  
 &nbsp; &nbsp; &nbsp; &nbsp;fp[f].push_back(t);  
 &nbsp;  }  
​  
 &nbsp; &nbsp;std::cout &lt;&lt; ans &lt;&lt; "\n";  
}  
​  
int main() {  
 &nbsp; &nbsp;std::ios::sync_with_stdio(false);  
 &nbsp; &nbsp;std::cin.tie(nullptr);  
​  
 &nbsp; &nbsp;int t;  
 &nbsp; &nbsp;std::cin &gt;&gt; t;  
​  
 &nbsp; &nbsp;while (t--) {  
 &nbsp; &nbsp; &nbsp; &nbsp;solve();  
 &nbsp;  }  
​  
 &nbsp; &nbsp;return 0;  
}  
​  
 &nbsp; &nbsp;int n, k;  
 &nbsp; &nbsp;std::cin &gt;&gt; n &gt;&gt; k;  
​  
 &nbsp; &nbsp;int64_t ans = 0;  
 &nbsp; &nbsp;std::unordered_map&lt;int, std::vector&lt;int&gt;&gt; tp, fp;  
 &nbsp; &nbsp;//tp 记录5的个数，fp记录2的个数  
 &nbsp; &nbsp;//两个是互补的  
 &nbsp; &nbsp;tp[0].push_back(0);  
 &nbsp; &nbsp;fp[0].push_back(0);  
​  
 &nbsp; &nbsp;for (int i = 0, t = 0, f = 0; i &lt; n; i++) {  
 &nbsp; &nbsp; &nbsp; &nbsp;int x;  
 &nbsp; &nbsp; &nbsp; &nbsp;std::cin &gt;&gt; x;  
 &nbsp; &nbsp; &nbsp; &nbsp;for (; x &amp;&amp; x % 2 == 0; x /= 2, t++) {  
 &nbsp; &nbsp; &nbsp;  }  
 &nbsp; &nbsp; &nbsp; &nbsp;for (; x &amp;&amp; x % 5 == 0; x /= 5, f++) {  
 &nbsp; &nbsp; &nbsp;  }  
 &nbsp; &nbsp; &nbsp; &nbsp;ans += std::max(  
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//需要 2^k &nbsp; * 5^k 即可满足 10^k 所以是动态规划  
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//每次计算出当前数据含有的2 和  5 的数量 和仍然需要 k  - 当前数量 &nbsp; 这一行的去更新  
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//因为同一个状态有可能对应多个数据， 所以只要找到第一个满足能凑出另一个2或者5的即可   
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;std::upper_bound(tp[t - k].begin(), tp[t - k].end(), f - k) - tp[t - k].begin(),  
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;std::upper_bound(fp[f - k].begin(), fp[f - k].end(), t - k) - fp[f - k].begin()  
 &nbsp; &nbsp; &nbsp;  );  
 &nbsp; &nbsp; &nbsp; &nbsp;tp[t].push_back(f);  
 &nbsp; &nbsp; &nbsp; &nbsp;fp[f].push_back(t);  
 &nbsp;  }  
​  
 &nbsp; &nbsp;std::cout &lt;&lt; ans &lt;&lt; "\n";  
}  
​  
int main() {  
 &nbsp; &nbsp;std::ios::sync_with_stdio(false);  
 &nbsp; &nbsp;std::cin.tie(nullptr);  
​  
 &nbsp; &nbsp;int t;  
 &nbsp; &nbsp;std::cin &gt;&gt; t;  
​  
 &nbsp; &nbsp;while (t--) {  
 &nbsp; &nbsp; &nbsp; &nbsp;solve();  
 &nbsp;  }  
​  
 &nbsp; &nbsp;return 0;  
}  
​
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="数论"><a href="#数论" class="headerlink" title="数论"></a>数论</h1><ol>
<li><p>质数</p>
<ul>
<li><p>试除法判定质数，只枚举 d*d&lt;=n 即可`</p>
  <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token operator">/</span>i<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  
<span class="token comment">//不要担心	数据超过int  </span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>试除法分解质因子，质因数 ,求约数</p>
<ul>
<li>从小到大枚举所有的约数,n中最多只存在一个大于风雨根号n的质因子</li>
</ul>
</li>
</ul>
</li>
</ol>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">            <span class="token keyword">void</span> <span class="token function">divide</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span>  
            <span class="token punctuation">{</span>  
                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> x <span class="token operator">/</span> i<span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span>  
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">%</span> i <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>  
                    <span class="token punctuation">{</span>  
                        <span class="token keyword">int</span> s <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  
                        <span class="token keyword">while</span> <span class="token punctuation">(</span>x <span class="token operator">%</span> i <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> x <span class="token operator">/=</span> i<span class="token punctuation">,</span> s <span class="token operator">++</span> <span class="token punctuation">;</span>  
                        cout <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> <span class="token char">' '</span> <span class="token operator">&lt;&lt;</span> s <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>  
                    <span class="token punctuation">}</span>  
                <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span> cout <span class="token operator">&lt;&lt;</span> x <span class="token operator">&lt;&lt;</span> <span class="token char">' '</span> <span class="token operator">&lt;&lt;</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>  
                cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>  
            <span class="token punctuation">}</span>
            
```            

# 埃氏筛法： 枚举所有数据，然后把每个数的倍数筛去，留下的就是质数 <span class="token operator">*</span><span class="token operator">*</span>思想比较好<span class="token operator">*</span><span class="token operator">*</span> 思想太好了
``` cpp
	   <span class="token keyword">void</span> <span class="token function">get_primes</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>  
        	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  
        		<span class="token keyword">if</span><span class="token punctuation">(</span>st<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>  
                <span class="token comment">//删除所有质数的倍数  </span>
        		primes<span class="token punctuation">[</span>cnt<span class="token operator">++</span><span class="token punctuation">]</span><span class="token operator">=</span>i<span class="token punctuation">;</span>  
        		<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span>i<span class="token operator">+</span>i<span class="token punctuation">;</span>j<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>j<span class="token operator">+=</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>  
        			st<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span><span class="token boolean">true</span><span class="token punctuation">;</span>  
        		<span class="token punctuation">}</span>  
        	<span class="token punctuation">}</span>	  
        <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="线性筛法：-如果质数，把这个数加入集合中-最常用"><a href="#线性筛法：-如果质数，把这个数加入集合中-最常用" class="headerlink" title="线性筛法： 如果质数，把这个数加入集合中 最常用"></a><strong>线性筛法： 如果质数，把这个数加入集合中</strong> 最常用</h3> <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> primes<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span> cnt<span class="token punctuation">;</span>     <span class="token comment">// primes[]存储所有素数  </span>
<span class="token keyword">bool</span> st<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>         <span class="token comment">// st[x]存储x是否被筛掉  </span>
  
<span class="token keyword">void</span> <span class="token function">get_primes</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span>  
<span class="token punctuation">{</span>  
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span>  
    <span class="token punctuation">{</span>  
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>st<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> primes<span class="token punctuation">[</span>cnt <span class="token operator">++</span> <span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>  
        <span class="token comment">//枚举已有的质数，删除它的倍数  </span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> primes<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> n <span class="token operator">/</span> i<span class="token punctuation">;</span> j <span class="token operator">++</span> <span class="token punctuation">)</span>  
        <span class="token punctuation">{</span>  
            st<span class="token punctuation">[</span>primes<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">*</span> i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>  
            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">%</span> primes<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>  
        <span class="token punctuation">}</span>  
    <span class="token punctuation">}</span>  
<span class="token punctuation">}</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol start="2">
<li><p>约数</p>
<ul>
<li><p>试除法求所有约数</p>
<ul>
<li>只枚举较小的约数，较大的约数可以直接算出</li>
</ul>
</li>
</ul>
</li>
</ol>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>  
	vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> ans<span class="token punctuation">;</span>  
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token operator">/</span>i<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  
		<span class="token keyword">if</span><span class="token punctuation">(</span>n<span class="token operator">%</span>i<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  
			<span class="token comment">//从小到大枚举所有约数，并把n/i 得到的约数加入即可  </span>
			ans<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>  
			<span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">!=</span>n<span class="token operator">/</span>i<span class="token punctuation">)</span> ans<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>n<span class="token operator">/</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>  
		<span class="token punctuation">}</span>  
	<span class="token punctuation">}</span>  
	<span class="token function">sort</span><span class="token punctuation">(</span>ans<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>ans<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
	<span class="token keyword">return</span> ans<span class="token punctuation">;</span>  
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>约数个数,约数之和<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">        如果 N <span class="token operator">=</span> p1<span class="token operator">^</span>c1 <span class="token operator">*</span> p2<span class="token operator">^</span>c2 <span class="token operator">*</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token operator">*</span>pk<span class="token operator">^</span>ck  
        约数个数： <span class="token punctuation">(</span>c1 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>c2 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token operator">*</span> <span class="token punctuation">(</span>ck <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>  
        约数之和： <span class="token punctuation">(</span>p1<span class="token operator">^</span><span class="token number">0</span> <span class="token operator">+</span> p1<span class="token operator">^</span><span class="token number">1</span> <span class="token operator">+</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token operator">+</span> p1<span class="token operator">^</span>c1<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token operator">*</span> <span class="token punctuation">(</span>pk<span class="token operator">^</span><span class="token number">0</span> <span class="token operator">+</span> pk<span class="token operator">^</span><span class="token number">1</span> <span class="token operator">+</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token operator">+</span> pk<span class="token operator">^</span>ck
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;bits/stdc++.h&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
<span class="token keyword">typedef</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">long</span> ULL<span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> mod  <span class="token operator">=</span> <span class="token number">1e9</span> <span class="token operator">+</span> <span class="token number">7</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> n <span class="token punctuation">;</span>
    cin <span class="token operator">&gt;&gt;</span> n<span class="token punctuation">;</span>
    unordered_map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span><span class="token keyword">int</span><span class="token operator">&gt;</span> primes<span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>n<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> x<span class="token punctuation">;</span>
        <span class="token function">scanf</span> <span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> x <span class="token operator">/</span> i <span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">while</span><span class="token punctuation">(</span>x <span class="token operator">%</span> i <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                primes<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">++</span><span class="token punctuation">;</span>
                x <span class="token operator">/=</span> i<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span>  primes<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    ULL cnts <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span>res <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> <span class="token punctuation">[</span>prime<span class="token punctuation">,</span>cnt<span class="token punctuation">]</span><span class="token operator">:</span>primes<span class="token punctuation">)</span>  <span class="token punctuation">{</span>
        cnts <span class="token operator">=</span> <span class="token punctuation">(</span>cnts <span class="token operator">*</span> <span class="token punctuation">(</span>cnt <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">%</span> mod<span class="token punctuation">;</span>
        <span class="token comment">//求和</span>
        ULL t <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>cnt<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token comment">//秦九zhao算法</span>
            t <span class="token operator">=</span> <span class="token punctuation">(</span>t <span class="token operator">*</span>prime <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span>mod<span class="token punctuation">;</span>
        <span class="token punctuation">}</span> 
        res <span class="token operator">=</span> res <span class="token operator">*</span> t <span class="token operator">%</span> mod<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    cout <span class="token operator">&lt;&lt;</span> cnts <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> res<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
<ol start="3">
<li><p>欧几里得算法，辗转相除法，求最大公约数</p>
<ul>
<li>GCD(a,b) = =GCD(a.amodb)<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">        <span class="token keyword">int</span> <span class="token function">gcd</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span>  
        <span class="token punctuation">{</span>  
            <span class="token keyword">return</span> b <span class="token operator">?</span> <span class="token function">gcd</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> a <span class="token operator">%</span> b<span class="token punctuation">)</span> <span class="token operator">:</span> a<span class="token punctuation">;</span>  
        <span class="token punctuation">}</span>
        
```     
    <span class="token operator">-</span> LCM 最小公倍数 将两个数相乘再除以最大公因数即可得到最小公倍数
    ```cpp
        <span class="token keyword">int</span> <span class="token function">lcm</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span><span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">{</span>  
        	<span class="token keyword">return</span> a<span class="token operator">*</span>b<span class="token operator">/</span><span class="token function">gcd</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>  
        <span class="token punctuation">}</span>
        <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li>求ax+by=gcd(a,b)<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">        <span class="token keyword">int</span> <span class="token function">xGCD</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>x<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>y<span class="token punctuation">)</span> <span class="token punctuation">{</span>  
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>b<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//b = 0 时  </span>
                x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> y <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  
                <span class="token keyword">return</span> a<span class="token punctuation">;</span>  
            <span class="token punctuation">}</span>  
            <span class="token keyword">int</span> x1<span class="token punctuation">,</span> y10<span class="token punctuation">,</span> gcd <span class="token operator">=</span> <span class="token function">xGCD</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> a <span class="token operator">%</span> b<span class="token punctuation">,</span> x1<span class="token punctuation">,</span> y1<span class="token punctuation">)</span><span class="token punctuation">;</span>  
            x <span class="token operator">=</span> y1<span class="token punctuation">,</span> y <span class="token operator">=</span> x1 <span class="token operator">-</span> <span class="token punctuation">(</span>a <span class="token operator">/</span> b<span class="token punctuation">)</span> <span class="token operator">*</span> y1<span class="token punctuation">;</span>  
            <span class="token keyword">return</span> gcd<span class="token punctuation">;</span>  
        <span class="token punctuation">}</span>
        
```     
### 欧拉函数：小于x的整数中与x互质的数的个数<span class="token punctuation">]</span>
        
求出单个数的欧拉函数  
<span class="token function">f</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token operator">=</span> `n <span class="token operator">*</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">/</span> p1<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">/</span> p2a<span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>`
```cpp
        <span class="token keyword">int</span> <span class="token function">phi</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">{</span>  
        	<span class="token keyword">int</span> res<span class="token operator">=</span>x<span class="token punctuation">;</span>  
        	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>x<span class="token operator">/</span>i<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  
        		<span class="token keyword">if</span><span class="token punctuation">(</span>x<span class="token operator">%</span>i<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  
        			res<span class="token operator">=</span>res<span class="token operator">/</span>i<span class="token operator">*</span><span class="token punctuation">(</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
        			<span class="token keyword">while</span><span class="token punctuation">(</span>x<span class="token operator">%</span>i<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> x<span class="token operator">/=</span>i<span class="token punctuation">;</span>  
        		<span class="token punctuation">}</span>  
        	<span class="token punctuation">}</span>  
        	<span class="token keyword">if</span><span class="token punctuation">(</span>x<span class="token operator">&gt;</span><span class="token number">1</span><span class="token punctuation">)</span> res<span class="token operator">=</span>res<span class="token operator">/</span>x<span class="token operator">*</span><span class="token punctuation">(</span>x<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
        	<span class="token keyword">return</span> res<span class="token punctuation">;</span>  
        <span class="token punctuation">}</span>
        <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
</li>
</ol>
<p>筛法：求出1-n每个数的欧拉函数，在线性筛法的模板中加上三行</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> primes<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span> cnt<span class="token punctuation">;</span>     <span class="token comment">// primes[]存储所有素数  </span>
<span class="token keyword">int</span> euler<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>           <span class="token comment">// 存储每个数的欧拉函数  </span>
<span class="token keyword">bool</span> st<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>         <span class="token comment">// st[x]存储x是否被筛掉  </span>
  
  
<span class="token keyword">void</span> <span class="token function">get_eulers</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span>  
<span class="token punctuation">{</span>  
    euler<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span>  
    <span class="token punctuation">{</span>  
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>st<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>  
        <span class="token punctuation">{</span>  
            primes<span class="token punctuation">[</span>cnt <span class="token operator">++</span> <span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>  
            euler<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>  
        <span class="token punctuation">}</span>  
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> primes<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> n <span class="token operator">/</span> i<span class="token punctuation">;</span> j <span class="token operator">++</span> <span class="token punctuation">)</span>  
        <span class="token punctuation">{</span>  
            <span class="token keyword">int</span> t <span class="token operator">=</span> primes<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">*</span> i<span class="token punctuation">;</span>  
            st<span class="token punctuation">[</span>t<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>  
            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">%</span> primes<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>  
            <span class="token punctuation">{</span>  
                euler<span class="token punctuation">[</span>t<span class="token punctuation">]</span> <span class="token operator">=</span> euler<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">*</span> primes<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>  
                <span class="token keyword">break</span><span class="token punctuation">;</span>  
            <span class="token punctuation">}</span>  
            euler<span class="token punctuation">[</span>t<span class="token punctuation">]</span> <span class="token operator">=</span> euler<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token punctuation">(</span>primes<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
        <span class="token punctuation">}</span>  
    <span class="token punctuation">}</span>  
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="欧拉定理"><a href="#欧拉定理" class="headerlink" title="欧拉定理"></a>欧拉定理</h3><p>a ^f(n) % n = 1<br>a和n互质</p>
<h3 id="快速幂："><a href="#快速幂：" class="headerlink" title="快速幂："></a>快速幂：</h3>  <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">        把指数转为<span class="token number">2</span>进制就可以看出来有哪些含有了
        
        预处理时每一个结果都是前一个的平方再mod
        
        求 m<span class="token operator">^</span>k mod p，时间复杂度 <span class="token function">O</span><span class="token punctuation">(</span>logk<span class="token punctuation">)</span>。  
        ​  
        <span class="token keyword">int</span> <span class="token function">qmi</span><span class="token punctuation">(</span><span class="token keyword">int</span> m<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">,</span> <span class="token keyword">int</span> p<span class="token punctuation">)</span>  
        <span class="token punctuation">{</span>  
            <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">%</span> p<span class="token punctuation">,</span> t <span class="token operator">=</span> m<span class="token punctuation">;</span>  
            <span class="token keyword">while</span> <span class="token punctuation">(</span>k<span class="token punctuation">)</span>  
            <span class="token punctuation">{</span>  
                <span class="token keyword">if</span> <span class="token punctuation">(</span>k<span class="token operator">&amp;</span><span class="token number">1</span><span class="token punctuation">)</span> res <span class="token operator">=</span> res <span class="token operator">*</span> t <span class="token operator">%</span> p<span class="token punctuation">;</span>  
                t <span class="token operator">=</span> t <span class="token operator">*</span> t <span class="token operator">%</span> p<span class="token punctuation">;</span>  
                k <span class="token operator">&gt;&gt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>  
            <span class="token punctuation">}</span>  
            <span class="token keyword">return</span> res<span class="token punctuation">;</span>  
        <span class="token punctuation">}</span>
        
    
```      
### 快速幂求逆元
```cpp
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;bits/stdc++.h&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
<span class="token keyword">typedef</span> <span class="token keyword">long</span> <span class="token keyword">long</span> LL<span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">quick_mi</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span><span class="token keyword">int</span> b<span class="token punctuation">,</span><span class="token keyword">int</span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">%</span> p<span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>b<span class="token operator">&amp;</span><span class="token number">1</span><span class="token punctuation">)</span> res <span class="token operator">=</span> <span class="token punctuation">(</span>LL<span class="token punctuation">)</span> res<span class="token operator">*</span>a <span class="token operator">%</span>p<span class="token punctuation">;</span>
        b <span class="token operator">&gt;&gt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        a <span class="token operator">=</span> <span class="token punctuation">(</span>LL<span class="token punctuation">)</span> a <span class="token operator">*</span> a <span class="token operator">%</span> p<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> res<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> n<span class="token punctuation">;</span>
    <span class="token function">scanf</span> <span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>n<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> a<span class="token punctuation">,</span>p<span class="token punctuation">;</span>
        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d%d"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>a<span class="token punctuation">,</span><span class="token operator">&amp;</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>a <span class="token operator">%</span> p<span class="token punctuation">)</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span><span class="token function">quick_mi</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>p<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">,</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span> <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"impossible"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="扩展欧几里得算法-不会"><a href="#扩展欧几里得算法-不会" class="headerlink" title="扩展欧几里得算法(不会)"></a>扩展欧几里得算法(不会)</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">    <span class="token comment">// 求x, y，使得ax + by = gcd(a, b)  </span>
    <span class="token keyword">int</span> <span class="token function">exgcd</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>x<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>y<span class="token punctuation">)</span>  
    <span class="token punctuation">{</span>  
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>b<span class="token punctuation">)</span>  
        <span class="token punctuation">{</span>  
            x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> y <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  
            <span class="token keyword">return</span> a<span class="token punctuation">;</span>  
        <span class="token punctuation">}</span>  
        <span class="token keyword">int</span> d <span class="token operator">=</span> <span class="token function">exgcd</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> a <span class="token operator">%</span> b<span class="token punctuation">,</span> y<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>  
        y <span class="token operator">-=</span> <span class="token punctuation">(</span>a<span class="token operator">/</span>b<span class="token punctuation">)</span> <span class="token operator">*</span> x<span class="token punctuation">;</span>  
        <span class="token keyword">return</span> d<span class="token punctuation">;</span>  
    <span class="token punctuation">}</span>
```  
#### 高斯消元求解方程组的解
 ```cpp
	 <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;bits/stdc++.h&gt;</span>  </span>
    <span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>  
    <span class="token keyword">const</span> <span class="token keyword">int</span> N<span class="token operator">=</span><span class="token number">100</span><span class="token punctuation">;</span>  
    <span class="token keyword">int</span> n<span class="token punctuation">;</span>  
    <span class="token keyword">const</span> <span class="token keyword">double</span> eps<span class="token operator">=</span><span class="token number">1e-6</span><span class="token punctuation">;</span>  
    <span class="token keyword">double</span> a<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>  
    <span class="token comment">// a[N][N]是增广矩阵  </span>
    <span class="token comment">// a[N][N]是增广矩阵  </span>
    <span class="token keyword">int</span> <span class="token function">gauss</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  
    <span class="token punctuation">{</span>  
        <span class="token keyword">int</span> c<span class="token punctuation">,</span> r<span class="token punctuation">;</span>  
        <span class="token keyword">for</span> <span class="token punctuation">(</span>c <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> r <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> c <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> c <span class="token operator">++</span> <span class="token punctuation">)</span>  
        <span class="token punctuation">{</span>  
            <span class="token keyword">int</span> t <span class="token operator">=</span> r<span class="token punctuation">;</span>  
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> r<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span>   <span class="token comment">// 找到绝对值最大的行  </span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">fabs</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token function">fabs</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  
                    t <span class="token operator">=</span> i<span class="token punctuation">;</span>  
    ​  
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">fabs</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> eps<span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>  
    ​  
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> c<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token function">swap</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// 将绝对值最大的行换到最顶端  </span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n<span class="token punctuation">;</span> i <span class="token operator">&gt;=</span> c<span class="token punctuation">;</span> i <span class="token operator">--</span> <span class="token punctuation">)</span> a<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">/=</span> a<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">;</span>      <span class="token comment">// 将当前行的首位变成1  </span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> r <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span>       <span class="token comment">// 用当前行将下面所有的列消成0  </span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">fabs</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> eps<span class="token punctuation">)</span>  
                    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> n<span class="token punctuation">;</span> j <span class="token operator">&gt;=</span> c<span class="token punctuation">;</span> j <span class="token operator">--</span> <span class="token punctuation">)</span>  
                        a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">-=</span> a<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">*</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">;</span>  
    ​  
            r <span class="token operator">++</span> <span class="token punctuation">;</span>  
        <span class="token punctuation">}</span>  
    ​  
        <span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token operator">&lt;</span> n<span class="token punctuation">)</span>  
        <span class="token punctuation">{</span>  
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> r<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span>  
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">fabs</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> eps<span class="token punctuation">)</span>  
                    <span class="token keyword">return</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">// 无解  </span>
            <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 有无穷多组解  </span>
        <span class="token punctuation">}</span>  
    ​  
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">--</span> <span class="token punctuation">)</span>  
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j <span class="token operator">++</span> <span class="token punctuation">)</span>  
                a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">-=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">*</span> a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>  
    ​  
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 有唯一解  </span>
    <span class="token punctuation">}</span>  
    <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  
        cin<span class="token operator">&gt;&gt;</span>n<span class="token punctuation">;</span>  
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>  
            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  
                cin<span class="token operator">&gt;&gt;</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>  
            <span class="token punctuation">}</span>  
    ​  
    <span class="token keyword">int</span> t<span class="token operator">=</span><span class="token function">gauss</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
        <span class="token keyword">if</span><span class="token punctuation">(</span>t<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  
            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  
                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%.2lf "</span><span class="token punctuation">,</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
            <span class="token punctuation">}</span>  
        <span class="token punctuation">}</span>  
        <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>t<span class="token operator">==</span><span class="token number">2</span><span class="token punctuation">)</span> cout<span class="token operator">&lt;&lt;</span><span class="token string">"无解"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>  
        <span class="token keyword">else</span> cout<span class="token operator">&lt;&lt;</span><span class="token string">"有无数组解"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>  
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  
    <span class="token punctuation">}</span>
    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="递推求组合数，dp法-适合询问次数-gt-10w"><a href="#递推求组合数，dp法-适合询问次数-gt-10w" class="headerlink" title="递推求组合数，dp法 适合询问次数>10w"></a>递推求组合数，dp法 适合询问次数&gt;10w</h3> <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// c[a][b] 表示从a个苹果中选b个的方案数  </span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span>  
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> i<span class="token punctuation">;</span> j <span class="token operator">++</span> <span class="token punctuation">)</span>  
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>j<span class="token punctuation">)</span> c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  
        <span class="token keyword">else</span> c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>c<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> c<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">%</span> mod<span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="通过预处理逆元的方式求组合数-询问1w"><a href="#通过预处理逆元的方式求组合数-询问1w" class="headerlink" title="通过预处理逆元的方式求组合数 询问1w"></a>通过预处理逆元的方式求组合数 询问1w</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">    首先预处理出所有阶乘取模的余数fact<span class="token punctuation">[</span>N<span class="token punctuation">]</span>，以及所有阶乘取模的逆元infact<span class="token punctuation">[</span>N<span class="token punctuation">]</span>  
    如果取模的数是质数，可以用费马小定理求逆元  
    <span class="token keyword">int</span> <span class="token function">qmi</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">,</span> <span class="token keyword">int</span> p<span class="token punctuation">)</span>    <span class="token comment">// 快速幂模板  </span>
    <span class="token punctuation">{</span>  
        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  
        <span class="token keyword">while</span> <span class="token punctuation">(</span>k<span class="token punctuation">)</span>  
        <span class="token punctuation">{</span>  
            <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">)</span> res <span class="token operator">=</span> <span class="token punctuation">(</span>LL<span class="token punctuation">)</span>res <span class="token operator">*</span> a <span class="token operator">%</span> p<span class="token punctuation">;</span>  
            a <span class="token operator">=</span> <span class="token punctuation">(</span>LL<span class="token punctuation">)</span>a <span class="token operator">*</span> a <span class="token operator">%</span> p<span class="token punctuation">;</span>  
            k <span class="token operator">&gt;&gt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>  
        <span class="token punctuation">}</span>  
        <span class="token keyword">return</span> res<span class="token punctuation">;</span>  
    <span class="token punctuation">}</span>  
    ​  
    <span class="token comment">// 预处理阶乘的余数和阶乘逆元的余数  </span>
    fact<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> infact<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span>  
    <span class="token punctuation">{</span>  
        fact<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>LL<span class="token punctuation">)</span>fact<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">*</span> i <span class="token operator">%</span> mod<span class="token punctuation">;</span>  
        infact<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>LL<span class="token punctuation">)</span>infact<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token function">qmi</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> mod <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">,</span> mod<span class="token punctuation">)</span> <span class="token operator">%</span> mod<span class="token punctuation">;</span>  
    <span class="token punctuation">}</span>  
    ​
```    
### Lucas定理求组合数 <span class="token number">20</span>次询问以下
    
<span class="token operator">!</span><span class="token punctuation">[</span>image<span class="token operator">-</span><span class="token number">20230519193526425</span><span class="token punctuation">]</span><span class="token punctuation">(</span>file<span class="token operator">:</span><span class="token comment">//D:/typora%E7%94%A8%E5%9B%BE/Screenshots/image-20230519193526425.png?lastModify=1694256669)    </span>
```cpp
      <span class="token comment">//若p是质数，则对于任意整数 1 &lt;= m &lt;= n，有：  </span>
      <span class="token comment">//  C(n, m) = C(n % p, m % p) * C(n / p, m / p) (mod p)  </span>
    ​  
    <span class="token keyword">int</span> <span class="token function">qmi</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">,</span> <span class="token keyword">int</span> p<span class="token punctuation">)</span>  <span class="token comment">// 快速幂模板  </span>
    <span class="token punctuation">{</span>  
        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">%</span> p<span class="token punctuation">;</span>  
        <span class="token keyword">while</span> <span class="token punctuation">(</span>k<span class="token punctuation">)</span>  
        <span class="token punctuation">{</span>  
            <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">)</span> res <span class="token operator">=</span> <span class="token punctuation">(</span>LL<span class="token punctuation">)</span>res <span class="token operator">*</span> a <span class="token operator">%</span> p<span class="token punctuation">;</span>  
            a <span class="token operator">=</span> <span class="token punctuation">(</span>LL<span class="token punctuation">)</span>a <span class="token operator">*</span> a <span class="token operator">%</span> p<span class="token punctuation">;</span>  
            k <span class="token operator">&gt;&gt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>  
        <span class="token punctuation">}</span>  
        <span class="token keyword">return</span> res<span class="token punctuation">;</span>  
    <span class="token punctuation">}</span>  
    ​  
    <span class="token keyword">int</span> <span class="token function">C</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">,</span> <span class="token keyword">int</span> p<span class="token punctuation">)</span>  <span class="token comment">// 通过定理求组合数C(a, b)  </span>
    <span class="token punctuation">{</span>  
        <span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">&lt;</span> b<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  
    ​  
        LL x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> y <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">// x是分子，y是分母  </span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> a<span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> b<span class="token punctuation">;</span> i <span class="token operator">--</span><span class="token punctuation">,</span> j <span class="token operator">++</span> <span class="token punctuation">)</span>  
        <span class="token punctuation">{</span>  
            x <span class="token operator">=</span> <span class="token punctuation">(</span>LL<span class="token punctuation">)</span>x <span class="token operator">*</span> i <span class="token operator">%</span> p<span class="token punctuation">;</span>  
            y <span class="token operator">=</span> <span class="token punctuation">(</span>LL<span class="token punctuation">)</span> y <span class="token operator">*</span> j <span class="token operator">%</span> p<span class="token punctuation">;</span>  
        <span class="token punctuation">}</span>  
    ​  
        <span class="token keyword">return</span> x <span class="token operator">*</span> <span class="token punctuation">(</span>LL<span class="token punctuation">)</span><span class="token function">qmi</span><span class="token punctuation">(</span>y<span class="token punctuation">,</span> p <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">,</span> p<span class="token punctuation">)</span> <span class="token operator">%</span> p<span class="token punctuation">;</span>  
    <span class="token punctuation">}</span>  
    ​  
    <span class="token keyword">int</span> <span class="token function">lucas</span><span class="token punctuation">(</span>LL a<span class="token punctuation">,</span> LL b<span class="token punctuation">,</span> <span class="token keyword">int</span> p<span class="token punctuation">)</span>  
    <span class="token punctuation">{</span>  
        <span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">&lt;</span> p <span class="token operator">&amp;&amp;</span> b <span class="token operator">&lt;</span> p<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token function">C</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>  
        <span class="token keyword">return</span> <span class="token punctuation">(</span>LL<span class="token punctuation">)</span><span class="token function">C</span><span class="token punctuation">(</span>a <span class="token operator">%</span> p<span class="token punctuation">,</span> b <span class="token operator">%</span> p<span class="token punctuation">,</span> p<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token function">lucas</span><span class="token punctuation">(</span>a <span class="token operator">/</span> p<span class="token punctuation">,</span> b <span class="token operator">/</span> p<span class="token punctuation">,</span> p<span class="token punctuation">)</span> <span class="token operator">%</span> p<span class="token punctuation">;</span>  
    <span class="token punctuation">}</span>
    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="file://D:/typora%E7%94%A8%E5%9B%BE/Screenshots/image-20230519193254443.png?lastModify=1694256669" alt="image-20230519193254443"></p>
<h3 id="逆元："><a href="#逆元：" class="headerlink" title="逆元："></a>逆元：</h3><p>可以在快速幂中求出</p>
<p>也就是a的p-2次方的</p>
<blockquote>
<p>在模为素数p的情况下，有费马小定理 a^(p-1)=1（mod p） 那么a^(p-2)=a^-1(mod p) 也就是说a的逆元为a^(p-2)</p>
</blockquote>
<h4 id="分解质因数法求组合数"><a href="#分解质因数法求组合数" class="headerlink" title="分解质因数法求组合数"></a>分解质因数法求组合数</h4><p> &nbsp; </p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">    当我们需要求出组合数的真实值，而非对某个数的余数时，分解质因数的方式比较好用：  
        <span class="token number">1.</span> 筛法求出范围内的所有质数  
        <span class="token number">2.</span> 通过 <span class="token function">C</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token operator">=</span> a<span class="token operator">!</span> <span class="token operator">/</span> b<span class="token operator">!</span> <span class="token operator">/</span> <span class="token punctuation">(</span>a <span class="token operator">-</span> b<span class="token punctuation">)</span><span class="token operator">!</span> 这个公式求出每个质因子的次数。 n<span class="token operator">!</span> 中p的次数是 n <span class="token operator">/</span> p <span class="token operator">+</span> n <span class="token operator">/</span> p<span class="token operator">^</span><span class="token number">2</span> <span class="token operator">+</span> n <span class="token operator">/</span> p<span class="token operator">^</span><span class="token number">3</span> <span class="token operator">+</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  
        <span class="token number">3.</span> 用高精度乘法将所有质因子相乘  
      
    <span class="token keyword">int</span> primes<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span> cnt<span class="token punctuation">;</span>     <span class="token comment">// 存储所有质数  </span>
    <span class="token keyword">int</span> sum<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>     <span class="token comment">// 存储每个质数的次数  </span>
    <span class="token keyword">bool</span> st<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>     <span class="token comment">// 存储每个数是否已被筛掉</span>

    <span class="token keyword">void</span> <span class="token function">get_primes</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span>      <span class="token comment">// 线性筛法求素数  </span>
•        <span class="token punctuation">{</span>  
•            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span>  
•            <span class="token punctuation">{</span>  
•                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>st<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> primes<span class="token punctuation">[</span>cnt <span class="token operator">++</span> <span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>  
•                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> primes<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> n <span class="token operator">/</span> i<span class="token punctuation">;</span> j <span class="token operator">++</span> <span class="token punctuation">)</span>  
•                <span class="token punctuation">{</span>  
•                    st<span class="token punctuation">[</span>primes<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">*</span> i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>  
•                    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">%</span> primes<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>  
•                <span class="token punctuation">}</span>  
•            <span class="token punctuation">}</span>  
•        <span class="token punctuation">}</span>  
​  
​  
•          
•        <span class="token keyword">int</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> p<span class="token punctuation">)</span>       <span class="token comment">// 求n！中的次数  </span>
•        <span class="token punctuation">{</span>  
•            <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  
•            <span class="token keyword">while</span> <span class="token punctuation">(</span>n<span class="token punctuation">)</span>  
•            <span class="token punctuation">{</span>  
•                res <span class="token operator">+=</span> n <span class="token operator">/</span> p<span class="token punctuation">;</span>  
•                n <span class="token operator">/=</span> p<span class="token punctuation">;</span>  
•            <span class="token punctuation">}</span>  
•            <span class="token keyword">return</span> res<span class="token punctuation">;</span>  
•        <span class="token punctuation">}</span>  
​  
​  
•          
•        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">mul</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span>       <span class="token comment">// 高精度乘低精度模板  </span>
•        <span class="token punctuation">{</span>  
•            vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> c<span class="token punctuation">;</span>  
•            <span class="token keyword">int</span> t <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  
•            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> a<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span>  
•            <span class="token punctuation">{</span>  
•                t <span class="token operator">+=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">*</span> b<span class="token punctuation">;</span>  
•                c<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>t <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
•                t <span class="token operator">/=</span> <span class="token number">10</span><span class="token punctuation">;</span>  
•            <span class="token punctuation">}</span>  
•          
•            <span class="token keyword">while</span> <span class="token punctuation">(</span>t<span class="token punctuation">)</span>  
•            <span class="token punctuation">{</span>  
•                c<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>t <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
•                t <span class="token operator">/=</span> <span class="token number">10</span><span class="token punctuation">;</span>  
•            <span class="token punctuation">}</span>  
•          
•            <span class="token keyword">return</span> c<span class="token punctuation">;</span>  
•        <span class="token punctuation">}</span>  
•        

    <span class="token function">get_primes</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 预处理范围内的所有质数  </span>
      
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> cnt<span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span>     <span class="token comment">// 求每个质因数的次数  </span>
    <span class="token punctuation">{</span>  
        <span class="token keyword">int</span> p <span class="token operator">=</span> primes<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>  
        sum<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">get</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> p<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token function">get</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> p<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token function">get</span><span class="token punctuation">(</span>a <span class="token operator">-</span> b<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token punctuation">}</span>  
      
    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> res<span class="token punctuation">;</span>  
    res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
      
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> cnt<span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span>     <span class="token comment">// 用高精度乘法将所有质因子相乘  </span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> sum<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> j <span class="token operator">++</span> <span class="token punctuation">)</span>  
            res <span class="token operator">=</span> <span class="token function">mul</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> primes<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p>
<h2 id="动态规划DP"><a href="#动态规划DP" class="headerlink" title="动态规划DP"></a>动态规划DP</h2><p>思路：</p>
<ol>
<li><p>状态表示：需要几维的动态规划</p>
<ul>
<li><p>集合 所有选法</p>
<ol>
<li><p>所有选法</p>
</li>
<li><p>条件</p>
<ul>
<li><p>只从前i个物品中选择</p>
</li>
<li><p>总体积&lt;=j</p>
</li>
</ul>
</li>
</ol>
</li>
<li><p>属性 最大值？最小值?……</p>
</li>
</ul>
</li>
<li><p>状态计算：怎么得到结果</p>
</li>
</ol>
<h3 id="01背包-每个物品只能用一次"><a href="#01背包-每个物品只能用一次" class="headerlink" title="01背包 每个物品只能用一次"></a>01背包 每个物品只能用一次</h3><p>一维优化;</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">///f[N][N] 表示前i个物品，j的容量下的最大值  </span>
进行压缩，因为每次更新i是时只用到了i<span class="token operator">-</span><span class="token number">1</span> 这个位置的数据，所以可以使用滚动数组，实现每次i<span class="token operator">-</span><span class="token number">1</span>到i的更新<span class="token punctuation">;</span>  
所以编成  f<span class="token punctuation">[</span>N<span class="token punctuation">]</span> 表示j的背包容量下的最大值<span class="token punctuation">;</span>  
j<span class="token operator">=</span><span class="token number">0</span>的结果都为<span class="token number">0</span> 所以可以跳过<span class="token punctuation">;</span>i<span class="token operator">=</span><span class="token number">0</span>的结果也都为<span class="token number">0</span><span class="token punctuation">,</span>同时，如果当前的背包容量不足以把当前物品装入也不需要进行更新了，所以小于当前背包容量的就不要考虑了<span class="token punctuation">;</span>  
不能更新也就是f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>f<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> 所以可以直接去掉，变为  f<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>f<span class="token punctuation">[</span>j<span class="token punctuation">]</span>  
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//遍览物品  </span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span>m<span class="token punctuation">;</span>j<span class="token operator">&gt;=</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>j<span class="token operator">--</span><span class="token punctuation">)</span><span class="token comment">//m为最大背包容量  </span>
        f<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span><span class="token function">max</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>f<span class="token punctuation">[</span>j<span class="token operator">-</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">+</span>w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="多状态dp"><a href="#多状态dp" class="headerlink" title="多状态dp"></a>多状态dp</h2><p>示例：<br><a target="_blank" rel="noopener" href="https://www.lanqiao.cn/problems/2223/learning/?subject_code=2&amp;group_code=4&amp;match_num=13&amp;match_flow=2&amp;origin=cup">魔法背包</a><br><a target="_blank" rel="noopener" href="https://www.lanqiao.cn/problems/2224/learning/?subject_code=2&amp;group_code=4&amp;match_num=13&amp;match_flow=2&amp;origin=cup">修路</a><br><a target="_blank" rel="noopener" href="https://www.lanqiao.cn/problems/3542/learning/?subject_code=2&amp;group_code=4&amp;match_num=14&amp;match_flow=1&amp;origin=cup">魔法阵</a><br>存在多个状态，其中每一个状态内的转移是正常转移的，而状态之间是需要满足条件进行转移的。</p>
<h3 id="完全背包-每件物品有无限个"><a href="#完全背包-每件物品有无限个" class="headerlink" title="完全背包 每件物品有无限个"></a>完全背包 每件物品有无限个</h3><p>01背包：从f[i-1]转过来 f[i,h]=max(f[i-1,j],f[i-1,j-v]+w[i]) //优化后:f[j]=max(f[j],f[v-v[i]]+w[i])</p>
<p>完全背包：从f[i]转移 f[i,j]=max(f[i-1,j],f[i,j-v[i]]+w[i])</p>
<p>每次更新：k是每个物品可以有多少个，i是前i个物品，j是当前背包容量</p>
<p>f[i][j]=max(f[i][j],f[i-j][j-v[i]*k]+w[i]*k</p>
<p>优化思路：</p>
<p><img src="file://D:/typora%E7%94%A8%E5%9B%BE/Screenshots/image-20230521084412853.png?lastModify=1694256669" alt="image-20230521084412853"></p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">​  
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span> <span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> m <span class="token punctuation">;</span> j <span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// for (int k = 0 ; k * v[i] &lt;= j ; k ++) {</span>
            <span class="token comment">//     f[i][j] = max(f[i][j],f[i - 1][j - k *v[i]] + k * w[i]);</span>
            <span class="token comment">// }</span>
            <span class="token comment">//f[i][j] = max(f[i-1][j],f[i-1][j-v]+w,f[i-1][j-2v] + 2w , ......)</span>
            <span class="token comment">//f[i][j-v] = max(        ,f[i-1][j-v],f[i-1][j-2v]+2w,....)</span>
            <span class="token comment">//错位相减</span>
            <span class="token comment">// f[i][j] - f[i][j-v] = w</span>
            <span class="token comment">// f[i][j] = f[i][j-v] + w</span>
            <span class="token comment">//所以 </span>
            <span class="token comment">//f[i][j] = max(f[i-1][j],f[i][j-v] + w)</span>
            <span class="token comment">//根据递推，每一个max后面那个数都等于上一个的f[i][j-v] + w</span>
            <span class="token comment">//前提是要大于v[i]等式才成立</span>
            f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> f<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//前一个转移</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">&gt;=</span> v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">+</span>w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

一维优化：删去一维

<span class="token comment">//f[i][j]=f[i-1][j];  f[i]==f[i-1] 直接删去  </span>
​  
<span class="token comment">//if(j&gt;=v[i]){ 只有当前背包容量大于当前的物品时才能装入，采用从v[i]遍历背包容量  </span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>  
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>j<span class="token operator">&lt;=</span>m<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>  
    <span class="token comment">//f[i,j]=max(f[i-1,j],f[i,j-v[i]]+w[i])  </span>
        f<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span><span class="token function">max</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>f<span class="token punctuation">[</span>j<span class="token operator">-</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">+</span>w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
<span class="token comment">//}  </span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>01和完全背包区别：</p>
<p>背包容量的遍历不同</p>
<p>01:</p>
<p> for(int j=m;j&gt;=v[i];j–)//m为最大背包容量<br>        f[j]=max(f[j],f[j-v[i]+w[i]]);</p>
<p>完全：</p>
<p>for(int j=v[i],j&lt;=m;j++)<br>        f[j]=max(f[j],f[j-v[i]]+w[i]);</p>
<h3 id="多重背包问题-优化"><a href="#多重背包问题-优化" class="headerlink" title="多重背包问题 优化"></a>多重背包问题 优化</h3><p>每个物品有个数限制，但不是无限</p>
<ol>
<li><p>状态表示：f[ i ] [ j ]</p>
<ul>
<li><p>集合</p>
</li>
<li><p>属性</p>
</li>
</ul>
</li>
<li><p>状态计算：</p>
<p> f[i][j]=max(f[i-1][j-v[i]*k]+w[i]*k)  k有范围</p>
<p> 优化：将数量打包，比如打包成1个物品一起，2个物品一起……</p>
<p> 之后用01背包做即可</p>
</li>
</ol>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;bits/stdc++.h&gt;</span>  </span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>  
<span class="token keyword">const</span> <span class="token keyword">int</span> N <span class="token operator">=</span> <span class="token number">1001</span><span class="token punctuation">;</span>  
<span class="token keyword">int</span> f<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span>v<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span>w<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>  
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  
    <span class="token keyword">int</span> n<span class="token punctuation">,</span>m<span class="token punctuation">,</span>cnt<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>  
    cin<span class="token operator">&gt;&gt;</span>n<span class="token operator">&gt;&gt;</span>m<span class="token punctuation">;</span>  
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  
        <span class="token keyword">int</span> a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>s<span class="token punctuation">;</span><span class="token comment">//容量，价值  </span>
        cin<span class="token operator">&gt;&gt;</span>a<span class="token operator">&gt;&gt;</span>b<span class="token operator">&gt;&gt;</span>s<span class="token punctuation">;</span>  
        <span class="token keyword">int</span> k<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//用来打包  </span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>k<span class="token operator">&lt;=</span>s<span class="token punctuation">)</span><span class="token punctuation">{</span>  
            cnt<span class="token operator">++</span><span class="token punctuation">;</span>  
            v<span class="token punctuation">[</span>cnt<span class="token punctuation">]</span><span class="token operator">=</span>a<span class="token operator">*</span>k<span class="token punctuation">;</span>  
            w<span class="token punctuation">[</span>cnt<span class="token punctuation">]</span><span class="token operator">=</span>b<span class="token operator">*</span>k<span class="token punctuation">;</span>  
            s<span class="token operator">-=</span>k<span class="token punctuation">;</span>  
            k<span class="token operator">*=</span><span class="token number">2</span><span class="token punctuation">;</span>  
        <span class="token punctuation">}</span>  
        <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token operator">&gt;</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  
            cnt<span class="token operator">++</span><span class="token punctuation">;</span>  
            v<span class="token punctuation">[</span>cnt<span class="token punctuation">]</span><span class="token operator">=</span>a<span class="token operator">*</span>s<span class="token punctuation">;</span>  
            w<span class="token punctuation">[</span>cnt<span class="token punctuation">]</span><span class="token operator">=</span>b<span class="token operator">*</span>s<span class="token punctuation">;</span>  
        <span class="token punctuation">}</span>  
    <span class="token punctuation">}</span>  
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>cnt<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span>m<span class="token punctuation">;</span>j<span class="token operator">&gt;=</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>j<span class="token operator">--</span><span class="token punctuation">)</span>  
        f<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span><span class="token function">max</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>f<span class="token punctuation">[</span>j<span class="token operator">-</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">+</span>w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token punctuation">}</span>  
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="分组背包问题"><a href="#分组背包问题" class="headerlink" title="分组背包问题"></a>分组背包问题</h3><h2 id="线性DP"><a href="#线性DP" class="headerlink" title="线性DP"></a>线性DP</h2><p>递归方程有线性关系，具有求的先后顺序</p>
<p>具体有各种子序列</p>
<p>建议看leetcode101 里面的比较好</p>
<h1 id="数位统计DP"><a href="#数位统计DP" class="headerlink" title="数位统计DP"></a>数位统计DP</h1><p>给出两个数字 a, b</p>
<p>统计a到b 中每一位 的0~9的出现次数</p>
<p>思路：分情况讨论 + 前缀和思想</p>
<p><img src="file://D:/typora%E7%94%A8%E5%9B%BE/Screenshots/image-20230524164849922.png?lastModify=1694256669" alt="image-20230524164849922"></p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">include <span class="token operator">&lt;</span>iostream<span class="token operator">&gt;</span>  
<span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">include</span> <span class="token string">&lt;cmath&gt;</span>  </span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>  
  
<span class="token keyword">int</span> <span class="token function">dgt</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token comment">// 计算整数n有多少位  </span>
<span class="token punctuation">{</span>  
    <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  
    <span class="token keyword">while</span> <span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token operator">++</span> res<span class="token punctuation">,</span> n <span class="token operator">/=</span> <span class="token number">10</span><span class="token punctuation">;</span>  
    <span class="token keyword">return</span> res<span class="token punctuation">;</span>  
<span class="token punctuation">}</span>  
  
<span class="token keyword">int</span> <span class="token function">cnt</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token comment">// 计算从1到n的整数中数字i出现多少次   </span>
<span class="token punctuation">{</span>  
    <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> d <span class="token operator">=</span> <span class="token function">dgt</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> d<span class="token punctuation">;</span> j <span class="token operator">++</span><span class="token punctuation">)</span> <span class="token comment">// 从右到左第j位上数字i出现多少次，所有位上的次数加起来就是i出现的总次数  </span>
    <span class="token punctuation">{</span>  
        <span class="token comment">// l和r是第j位左边和右边的整数 (视频中的abc和efg); dj是第j位的数字  </span>
        <span class="token keyword">int</span> p <span class="token operator">=</span> <span class="token function">pow</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> l <span class="token operator">=</span> n <span class="token operator">/</span> p <span class="token operator">/</span> <span class="token number">10</span><span class="token punctuation">,</span> r <span class="token operator">=</span> n <span class="token operator">%</span> p<span class="token punctuation">,</span> dj <span class="token operator">=</span> n <span class="token operator">/</span> p <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">;</span>  
        <span class="token comment">// 计算第j位左边的整数小于l (视频中xxx = 000 ~ abc - 1)的情况  </span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>i<span class="token punctuation">)</span> res <span class="token operator">+=</span> l <span class="token operator">*</span> p<span class="token punctuation">;</span>   
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>i <span class="token operator">&amp;&amp;</span> l<span class="token punctuation">)</span> res <span class="token operator">+=</span> <span class="token punctuation">(</span>l <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> p<span class="token punctuation">;</span> <span class="token comment">// 如果i = 0, 左边高位不能全为0(视频中xxx = 001 ~ abc - 1)，并且&amp;&amp;l表示这时i也不能在最高位出现。  </span>
        <span class="token comment">// 计算第j位左边的整数等于l (视频中xxx = abc)的情况  </span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token punctuation">(</span>dj <span class="token operator">&gt;</span> i<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>i <span class="token operator">||</span> l<span class="token punctuation">)</span> <span class="token punctuation">)</span> res <span class="token operator">+=</span> p<span class="token punctuation">;</span>  <span class="token comment">//(i || l)表示i=0时，i不能出现在最高位（即l不能为0），因为这种数是不存在的  </span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token punctuation">(</span>dj <span class="token operator">==</span> i<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>i <span class="token operator">||</span> l<span class="token punctuation">)</span> <span class="token punctuation">)</span> res <span class="token operator">+=</span> r <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">//(i || l)表示i=0时，i不能出现在最高位（即l不能为0），因为这种数是不存在的  </span>
    <span class="token punctuation">}</span>  
    <span class="token keyword">return</span> res<span class="token punctuation">;</span>  
<span class="token punctuation">}</span>  
  
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  
<span class="token punctuation">{</span>  
    <span class="token keyword">int</span> a<span class="token punctuation">,</span> b<span class="token punctuation">;</span>  
    <span class="token keyword">while</span> <span class="token punctuation">(</span>cin <span class="token operator">&gt;&gt;</span> a <span class="token operator">&gt;&gt;</span> b <span class="token punctuation">,</span> a<span class="token punctuation">)</span>  
    <span class="token punctuation">{</span>  
        <span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">&gt;</span> b<span class="token punctuation">)</span> <span class="token function">swap</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>  
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">9</span><span class="token punctuation">;</span> <span class="token operator">++</span> i<span class="token punctuation">)</span> cout <span class="token operator">&lt;&lt;</span> <span class="token function">cnt</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> i<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token function">cnt</span><span class="token punctuation">(</span>a <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token char">' '</span><span class="token punctuation">;</span>  
        cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>  
    <span class="token punctuation">}</span>  
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="数位DP-重要"><a href="#数位DP-重要" class="headerlink" title="数位DP(重要)"></a>数位DP(重要)</h1><p>DP时间复杂度：状态个数*转移个数</p>
<p>相当于往空里填数字</p>
<p><strong>知识点1：</strong>mask集合</p>
<blockquote>
<p>集合和数字的替换，使用二进制转化集合来实现某些数字不选择</p>
<p>例： 10011 从高到低依次代表者 4 3 2 1 0 这几个数字选不选，1表示选择，那么，</p>
<p>集合mask &gt;&gt; d &amp; 1 d为这个数字，进行这样的运算就可以判断mask 对应的d数字这个位置上是1还是0</p>
<p>同理 mask|(1&lt;&lt;d) 将1移位到mask上 代表d这个数字的位置，进行或运算，即可将d加入集合中</p>
</blockquote>
<h2 id="模板：-1"><a href="#模板：-1" class="headerlink" title="模板："></a>模板：</h2><p>将问题转化为填数字受限问题：</p>
<blockquote>
<p>递归中的变量：</p>
<p>i 当前下标 当 i == 最大长度时，根据是否满足条件返回 0 或 1</p>
<p>mask 集合 代表着一种状态的记录，比如某位填了哪些数字，或者截止到上一位已经积累的某个要求满足条件的数据是多少，这个一般是变化的</p>
<p>is_limit 前一个位置是否收到原来的数字的限制：123 第一个填1 了后面一定受限，同时如果前面受限了，那么后面所有的都受限</p>
<p>is_num 前一个位置是否填数字，如果前一个没填数字，那么这一位无法填0了，如果填了可以填任意数字，当0对题目没影响时，可以不用这个东西</p>
</blockquote>
<p><strong>模板公式：</strong></p>
<ol>
<li><p>求出最大长度和memo，记忆数组，并初始化为-1 memo数组的一维是长度，二维是能包含所有枚举的最大长度，具体问题具体分析</p>
</li>
<li><p>递归函数</p>
<ul>
<li><p>结束递归条件<code>i == m 返回是否满足 满足为1 满足为0</code></p>
</li>
<li><p>记忆化剪枝：当is_limit 和 is_num 只有一个为真时，后面的数字也是可以任意填的，所以可以剪枝</p>
</li>
<li><p><code>!is_limit &amp;&amp; is_num &amp;&amp; memo[i][mask] != -1 return memo[i][mask]</code></p>
</li>
<li><p>设出res = 0 即为我们要求的答案</p>
</li>
<li><p>(可能不存在这种情况)这一位不填数字：<code>res = (i+1 , mask不改变, false , false)</code></p>
</li>
<li><p>求出这一位数字可以填写的上下界：根据is_limit来求 <code>up = is_limit ? s[i] - '0' : 9</code></p>
</li>
<li><p>枚举这一位数字，进行递归 (条件判断不一定需要)</p>
</li>
<li><p><code>for (int d = 初始 ; d &lt;= up ; d++) if(当前这个数字没使用) 把这个数字加入mask</code></p>
</li>
<li><p>循环内：<code>res = (i+1 , mask 的改变 , is_limit &amp;&amp; d == up , is_num的变化)</code></p>
</li>
<li><p>当is_limit 和 is_num 只有一个为真时将答案加入memo中 <code>if(!is_limit &amp;&amp; is_num) memo[i][mask] = res</code></p>
</li>
<li><p>返回res</p>
</li>
</ul>
</li>
</ol>
<p><strong>例题：</strong></p>
<ol>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/numbers-with-repeated-digits/description/">1012. 至少有 1 位重复的数字 - 力扣（Leetcode）</a></li>
</ol>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>  
<span class="token keyword">public</span><span class="token operator">:</span>  
    <span class="token keyword">int</span> <span class="token function">numDupDigitsAtMostN</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>  
        <span class="token comment">//将n转化为字符串，方便枚举每一位置上的数字  </span>
        <span class="token keyword">auto</span> s <span class="token operator">=</span><span class="token function">to_string</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//使用auto 防止爆int  </span>
        <span class="token comment">//记忆化数组，当dp到相同的情况时直接可以使用以前的的出来的  </span>
        <span class="token comment">//第一维为长度  </span>
        <span class="token comment">//第二位代表可以选择的数字有哪些  </span>
        <span class="token comment">//这题从高到低每一位代表着 9876543210 所以需要移动到第11位，才能出现10个数字都选择的情况  </span>
        <span class="token keyword">int</span> m <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>memo<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  
        <span class="token function">memset</span><span class="token punctuation">(</span>memo<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token punctuation">,</span><span class="token keyword">sizeof</span> memo<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//-1表示没有计算过这种情况  </span>
        <span class="token comment">//递归函数  </span>
        function<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span><span class="token keyword">int</span><span class="token punctuation">,</span><span class="token keyword">bool</span><span class="token punctuation">,</span><span class="token keyword">bool</span><span class="token punctuation">)</span><span class="token operator">&gt;</span> f <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token punctuation">,</span><span class="token keyword">int</span> mask<span class="token punctuation">,</span> <span class="token keyword">bool</span> is_limit <span class="token punctuation">,</span> <span class="token keyword">bool</span> is_num<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token keyword">int</span> <span class="token punctuation">{</span>  
            <span class="token comment">//i 下标  </span>
            <span class="token comment">//mask 是记录当前已经选择数字的集合  </span>
            <span class="token comment">//is_limit 代表当前位置是否受到n这个数字的制约，比如不能超过某个数字  </span>
            <span class="token comment">//is_num 代表前一位是否填数字了，这个是用来判断0是否可填的，如果0可不可填都无所谓就可以不使用这个了  </span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> m<span class="token punctuation">)</span> <span class="token comment">//如果dp到了最后一个位置了，要返回是否得到合法数字了  </span>
                 <span class="token keyword">return</span> is_num<span class="token punctuation">;</span><span class="token comment">//合法数字一定为true，因为长度到了前一个一定要填数字的  </span>
            <span class="token comment">//如果没收到限制或者没收到前一个的填数字的限制，后面可以任意填了，所以必定会有很小重复性的，所以可以直接返回  </span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>is_limit <span class="token operator">&amp;&amp;</span> is_num <span class="token operator">&amp;&amp;</span>memo<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>mask<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> memo<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>mask<span class="token punctuation">]</span><span class="token punctuation">;</span>  
            <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>is_num<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//前一个数字没填，这个数字当然也可以不填  </span>
                res <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span> <span class="token punctuation">,</span> mask <span class="token punctuation">,</span> <span class="token boolean">false</span> <span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
                <span class="token comment">//继续递归  </span>
            <span class="token punctuation">}</span>  
            <span class="token comment">//如果当前数字没收到限制，那么当然可以继续任意填  </span>
            <span class="token comment">//如果收到限制了，那么最多只能填当前这一位置上的数字  </span>
            <span class="token keyword">int</span> up <span class="token operator">=</span> is_limit <span class="token operator">?</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token char">'0'</span> <span class="token operator">:</span> <span class="token number">9</span><span class="token punctuation">;</span>  
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> d <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">-</span> is_num <span class="token punctuation">;</span> d <span class="token operator">&lt;=</span> up <span class="token punctuation">;</span> <span class="token operator">++</span>d<span class="token punctuation">)</span>  
                <span class="token comment">//枚举可以填入的数据，前一位没填数字 ，那么这一位只能从1开始，否则可以从0开始，那么可以填0，如果没被限制，那么要小心是否是第一位了，所以从1开始  </span>
                <span class="token comment">//当d == up 时，  </span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>mask <span class="token operator">&gt;&gt;</span> d <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">// d 不在 mask 中  </span>
                <span class="token comment">//d != up 时，所有的后面的位置都不会受限  </span>
                <span class="token comment">//d == up 时，如果前一位已经受限了，那么后面还会接着受限  </span>
                    res <span class="token operator">+=</span> <span class="token function">f</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> mask <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> d<span class="token punctuation">)</span><span class="token punctuation">,</span> is_limit <span class="token operator">&amp;&amp;</span> d <span class="token operator">==</span> up<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     
              
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>is_limit <span class="token operator">&amp;&amp;</span> is_num<span class="token punctuation">)</span>  
            <span class="token comment">//如果没收到限制或者没收到前一个的填数字的限制，后面可以任意填了  </span>
                memo<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>mask<span class="token punctuation">]</span> <span class="token operator">=</span> res<span class="token punctuation">;</span>  
            <span class="token keyword">return</span> res<span class="token punctuation">;</span>  
        <span class="token punctuation">}</span><span class="token punctuation">;</span>  
        <span class="token keyword">return</span> n <span class="token operator">-</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token number">0</span> <span class="token punctuation">,</span> <span class="token number">0</span> <span class="token punctuation">,</span> <span class="token boolean">true</span> <span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//第一个数字肯定受限了  </span>
    <span class="token punctuation">}</span>  
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token number">2.</span> <span class="token punctuation">[</span><span class="token number">6396.</span> 统计整数数目 <span class="token operator">-</span> 力扣（Leetcode）<span class="token punctuation">]</span><span class="token punctuation">(</span>https<span class="token operator">:</span><span class="token comment">//leetcode.cn/problems/count-of-integers/description/) 一种变形，好好理解</span>
    <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>  
    <span class="token keyword">public</span><span class="token operator">:</span>  
        <span class="token keyword">const</span> <span class="token keyword">int</span> mod <span class="token operator">=</span> <span class="token number">1e9</span> <span class="token operator">+</span> <span class="token number">7</span><span class="token punctuation">;</span>  
        <span class="token keyword">int</span> <span class="token function">cmp</span><span class="token punctuation">(</span>string s <span class="token punctuation">,</span> <span class="token keyword">int</span> min_sum <span class="token punctuation">,</span> <span class="token keyword">int</span> max_sum<span class="token punctuation">)</span><span class="token punctuation">{</span>  
            <span class="token comment">//memo数组最大有 n个9 或者是被迫的这个最大数字 记得 + 1  </span>
            <span class="token keyword">int</span> n <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">,</span> memo<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token function">min</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token operator">*</span>n<span class="token punctuation">,</span>max_sum<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  
            <span class="token function">memset</span><span class="token punctuation">(</span>memo <span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token punctuation">,</span> <span class="token keyword">sizeof</span> memo<span class="token punctuation">)</span><span class="token punctuation">;</span>  
            <span class="token comment">//因为0无影响，所以is_num可以不要了  </span>
            <span class="token comment">//sum 就是mask  </span>
            function <span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token punctuation">,</span><span class="token keyword">int</span> <span class="token punctuation">,</span><span class="token keyword">bool</span><span class="token punctuation">)</span><span class="token operator">&gt;</span> f <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token punctuation">,</span> <span class="token keyword">int</span> sum <span class="token punctuation">,</span> <span class="token keyword">bool</span> is_limit<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token keyword">int</span> <span class="token punctuation">{</span>  
            <span class="token comment">//1.非法情况  </span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>sum <span class="token operator">&gt;</span> max_sum<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//结束递归，sum是一直增加的，后面无法减小的  </span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> n<span class="token punctuation">)</span> <span class="token keyword">return</span> sum <span class="token operator">&gt;=</span> min_sum<span class="token punctuation">;</span><span class="token comment">//结束递归的时候如果数字合法且满足  </span>
            <span class="token comment">//少了一个is_num,只要后面不受限制，那么，后面一定重复  </span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>is_limit <span class="token operator">&amp;&amp;</span> memo<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>sum<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> memo<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>sum<span class="token punctuation">]</span><span class="token punctuation">;</span>  
            <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span> <span class="token comment">//计算所要的答案，也就是计数  </span>
            <span class="token keyword">int</span> up <span class="token operator">=</span> is_limit <span class="token operator">?</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token char">'0'</span> <span class="token operator">:</span> <span class="token number">9</span><span class="token punctuation">;</span><span class="token comment">//上界  </span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> d <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span> d <span class="token operator">&lt;=</span> up <span class="token punctuation">;</span> d<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//枚举位置上的数字  </span>
                <span class="token comment">//d == up的时候，如果前面受限了，后面继续受限，如果前面没受限，那么后面也不受限  </span>
                res <span class="token operator">=</span> <span class="token punctuation">(</span>res <span class="token operator">+</span> <span class="token function">f</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span> <span class="token punctuation">,</span> sum <span class="token operator">+</span> d  <span class="token punctuation">,</span> is_limit <span class="token operator">&amp;&amp;</span> d <span class="token operator">==</span> up<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">%</span> mod<span class="token punctuation">;</span>  
            <span class="token punctuation">}</span>  
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>is_limit<span class="token punctuation">)</span> memo<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>sum<span class="token punctuation">]</span> <span class="token operator">=</span> res <span class="token punctuation">;</span>  <span class="token comment">//与上面保持一致  </span>
            <span class="token keyword">return</span> res <span class="token punctuation">;</span><span class="token comment">//返回答案  </span>
            <span class="token punctuation">}</span><span class="token punctuation">;</span>  
            <span class="token keyword">return</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token number">0</span> <span class="token punctuation">,</span> <span class="token number">0</span> <span class="token punctuation">,</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//初始状态下，一定受限  </span>
        <span class="token punctuation">}</span>  
        <span class="token keyword">int</span> <span class="token function">count</span><span class="token punctuation">(</span>string num1<span class="token punctuation">,</span> string num2<span class="token punctuation">,</span> <span class="token keyword">int</span> min_sum<span class="token punctuation">,</span> <span class="token keyword">int</span> max_sum<span class="token punctuation">)</span> <span class="token punctuation">{</span>  
            <span class="token comment">//转化：  </span>
            <span class="token comment">/*  
                计算 &lt;= num2 的合法数字a和 &lt;= num2 的合法数字b 答案就等于 a - b  
                可以直接计算 &lt;= num1 的合法数字，最后单独判定 num1是否合法  
                套模板： mask 在这里指的是各位数字之和  
                递归结束条件：  
                sum &gt; max_sum 直接返回0 ，不成立，因为sum不能减小，所以继续递归下去也没有用  
                递归到就结束的时候，如果 sum &gt;= min_sum 那么就是满足的，可以直接返回1了  
                前导零对和没有影响，所以isnum可以不用  
                最后：取模运算  
                (a+b)mod m = ((a mod m) + (b mod m )) mod m  
                (a*b)mode m = ((a mod m) * (b mod m )) mod m  
            */</span>  
            <span class="token keyword">int</span> ans <span class="token operator">=</span> <span class="token function">cmp</span><span class="token punctuation">(</span>num2 <span class="token punctuation">,</span> min_sum <span class="token punctuation">,</span>max_sum<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token function">cmp</span><span class="token punctuation">(</span>num1 <span class="token punctuation">,</span> min_sum <span class="token punctuation">,</span>max_sum<span class="token punctuation">)</span><span class="token punctuation">;</span>  
            <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  
            <span class="token comment">//最后一个num1单独判断，因为上面计算的是 num1 &lt; x &lt;= num2的，和前缀和一样  </span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> c <span class="token operator">:</span> num1<span class="token punctuation">)</span> sum <span class="token operator">+=</span> c <span class="token operator">-</span> <span class="token char">'0'</span><span class="token punctuation">;</span>  
            ans <span class="token operator">+=</span> min_sum <span class="token operator">&lt;=</span> sum <span class="token operator">&amp;&amp;</span> sum <span class="token operator">&lt;=</span> max_sum <span class="token punctuation">;</span>  
            <span class="token keyword">return</span> ans <span class="token operator">%</span> mod<span class="token punctuation">;</span>  
        <span class="token punctuation">}</span>  
    <span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="状压DP-状态压缩-动态规划-利用二进制把状态记录成二进制数"><a href="#状压DP-状态压缩-动态规划-利用二进制把状态记录成二进制数" class="headerlink" title="状压DP 状态压缩+动态规划 利用二进制把状态记录成二进制数"></a>状压DP 状态压缩+动态规划 利用二进制把状态记录成二进制数</h2><p>291 91</p>
<pre class="line-numbers language-css" data-language="css"><code class="language-css"><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="树形DP-各层选择取最大值"><a href="#树形DP-各层选择取最大值" class="headerlink" title="树形DP 各层选择取最大值"></a>树形DP 各层选择取最大值</h2><p>将状态分为当前节点选择和不选择</p>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/287/">285. 没有上司的舞会 - AcWing题库</a></p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;bits/stdc++.h&gt;</span>  </span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>  
<span class="token keyword">const</span> <span class="token keyword">int</span> N <span class="token operator">=</span> <span class="token number">6010</span><span class="token punctuation">;</span>  
<span class="token keyword">int</span> happy<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>  
<span class="token keyword">int</span> n<span class="token punctuation">;</span>  
<span class="token keyword">int</span> e<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token comment">/*e存的是编号1*/</span> <span class="token punctuation">,</span> ne<span class="token punctuation">[</span>N<span class="token punctuation">]</span> <span class="token punctuation">,</span> idx <span class="token punctuation">,</span>h<span class="token punctuation">[</span>N<span class="token punctuation">]</span> <span class="token punctuation">,</span> dp<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>  
<span class="token keyword">bool</span> fa<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>  
<span class="token comment">/*  
    状态定义：dp[i][1] dp[i][0] 当前节点选不选  
    状态转移 ： dp[i][0] = sum(子树)   子树有可以分为选与不选  取最大值  
                dp[i][1] = sum(下一层子树不选)    
    属性： 最大值  
   
*/</span>  
<span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  
    idx <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  
    <span class="token function">memset</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token punctuation">,</span> <span class="token keyword">sizeof</span> h<span class="token punctuation">)</span><span class="token punctuation">;</span>  
<span class="token punctuation">}</span>  
<span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">{</span>  
    e<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> b<span class="token punctuation">;</span>  
    ne<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> h<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">;</span>  
    h<span class="token punctuation">[</span>a<span class="token punctuation">]</span> <span class="token operator">=</span> idx<span class="token operator">++</span><span class="token punctuation">;</span>  
<span class="token punctuation">}</span>  
<span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span> u<span class="token punctuation">)</span><span class="token punctuation">{</span>  
        <span class="token comment">//如果当前的节点要选择的话，要初始化数据  </span>
        dp<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> happy<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">;</span>  
        <span class="token comment">//遍历u的子树  </span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> h<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token punctuation">;</span> i <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token punctuation">;</span> i <span class="token operator">=</span> ne<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  
            <span class="token keyword">int</span> j <span class="token operator">=</span> e<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>  
            <span class="token comment">//递归到最低层，实现一层层的求和  </span>
            <span class="token function">dfs</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>  
            <span class="token comment">//当前不选，则是子树的最大值  </span>
            dp<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token punctuation">,</span> dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
            <span class="token comment">//当前选择，那么就是下一层子树不选  </span>
            dp<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+=</span> dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  
        <span class="token punctuation">}</span>  
<span class="token punctuation">}</span>  
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  
    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span> <span class="token punctuation">,</span><span class="token operator">&amp;</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  
        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>happy<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token punctuation">}</span>  
    <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token operator">-</span><span class="token number">1</span> <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  
        <span class="token keyword">int</span> a <span class="token punctuation">,</span> b <span class="token punctuation">;</span>  
        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d%d"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>a<span class="token punctuation">,</span><span class="token operator">&amp;</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>  
        fa<span class="token punctuation">[</span>a<span class="token punctuation">]</span> <span class="token operator">=</span><span class="token boolean">true</span><span class="token punctuation">;</span>  
        <span class="token function">add</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token punctuation">}</span>  
    <span class="token keyword">int</span> root <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  
    <span class="token keyword">while</span><span class="token punctuation">(</span>fa<span class="token punctuation">[</span>root<span class="token punctuation">]</span><span class="token punctuation">)</span> root<span class="token operator">++</span><span class="token punctuation">;</span>  
    <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span><span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>root<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>dp<span class="token punctuation">[</span>root<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="状态机："><a href="#状态机：" class="headerlink" title="状态机："></a>状态机：</h2><blockquote>
<p>通过表示出状态的转换方式即可自动得到答案</p>
</blockquote>
<h2 id="DP行-x2F-列问题"><a href="#DP行-x2F-列问题" class="headerlink" title="DP行/列问题"></a>DP行/列问题</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-strictly-increasing-cells-in-a-matrix/">6456. 矩阵中严格递增的单元格数 - 力扣（Leetcode）</a></p>
<h3 id="例题：股票买卖问题"><a href="#例题：股票买卖问题" class="headerlink" title="例题：股票买卖问题"></a>例题：股票买卖问题</h3><p><strong>含有冷却时间需要用四个状态，正常两个即可，具体问题具体分析</strong></p>
<ol>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/description/">714. 买卖股票的最佳时机含手续费 - 力扣（Leetcode）</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/solutions/2283535/zhuang-tai-ji-dp-by-hardcore-dubinsky348-1qew/">309. 最佳买卖股票时机含冷冻期 - 力扣（Leetcode）</a></p>
</li>
</ol>
<h2 id="通过stoi-和隔板法实现枚举每一个数字的任意子子串"><a href="#通过stoi-和隔板法实现枚举每一个数字的任意子子串" class="headerlink" title="通过stoi 和隔板法实现枚举每一个数字的任意子子串"></a>通过stoi 和隔板法实现枚举每一个数字的任意子子串</h2><p>stoi substr to_string 的妙用</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-the-punishment-number-of-an-integer/">6441. 求一个整数的惩罚数 - 力扣（LeetCode）</a></p>
<h2 id="子列和-x2F-字串问题："><a href="#子列和-x2F-字串问题：" class="headerlink" title="子列和/字串问题："></a>子列和/字串问题：</h2><ol>
<li><p>求任意子列的乘积最大 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-strength-of-a-group/">6393. 一个小组的最大实力值 - 力扣（Leetcode）</a></p>
</li>
<li><p>一个字符串匹配另一个字典求最大匹配长度问题：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/extra-characters-in-a-string/">6394. 字符串中的额外字符 - 力扣（Leetcode）</a></p>
</li>
<li><p>反转01得到相等字符串问题：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-cost-to-make-all-characters-equal/">6455. 使所有字符相等的最小成本 - 力扣（Leetcode）</a></p>
</li>
</ol>
<h1 id="暴力枚举法"><a href="#暴力枚举法" class="headerlink" title="暴力枚举法"></a>暴力枚举法</h1><p>使用于组合的数量少，但是需要找到最合适的组合的题目<br>例题<br><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-moves-to-spread-stones-over-grid/submissions/">3*3</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/4/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/6/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">QingQiu</p>
  <div class="site-description" itemprop="description">个人网站，学习记录，面试记录和经验总结、互联网中一块属于自己的小窝</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">56</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">26</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Zuofw/zuofw-rpc" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Zuofw&#x2F;zuofw-rpc" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2022 – 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">QingQiu</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="站点总字数">466k</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  















  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
