<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"zuofw.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="个人网站，学习记录，面试记录和经验总结、互联网中一块属于自己的小窝">
<meta property="og:type" content="website">
<meta property="og:title" content="QingQiu&#39;Blog">
<meta property="og:url" content="https://zuofw.github.io/page/3/index.html">
<meta property="og:site_name" content="QingQiu&#39;Blog">
<meta property="og:description" content="个人网站，学习记录，面试记录和经验总结、互联网中一块属于自己的小窝">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="QingQiu">
<meta property="article:tag" content="博客，学习，成长">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://zuofw.github.io/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>QingQiu'Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>


<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">QingQiu'Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">清秋的博客</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-fa fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-fa fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-fa fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-fa fa-archive"></i>归档</a>

  </li>
        <li class="menu-item menu-item-github">

    <a href="https://github.com/Zuofw" rel="noopener" target="_blank"><i class="fa fa-fw fa-fab fa-github"></i>Github</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zuofw.github.io/2024/06/07/04/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="QingQiu">
      <meta itemprop="description" content="个人网站，学习记录，面试记录和经验总结、互联网中一块属于自己的小窝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="QingQiu'Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/06/07/04/" class="post-title-link" itemprop="url">深入浅出Spring</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-06-07 16:30:04" itemprop="dateCreated datePublished" datetime="2024-06-07T16:30:04+08:00">2024-06-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-10-14 20:40:12" itemprop="dateModified" datetime="2024-10-14T20:40:12+08:00">2024-10-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Spring/" itemprop="url" rel="index"><span itemprop="name">Spring</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>18k</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="面试常问"><a href="#面试常问" class="headerlink" title="面试常问"></a>面试常问</h1><h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><ul>
<li>@Nullable 注解的主要作用是为开发者和静态分析工具提供信息，指示某个字段、方法返回值或参数可以为 null。具体来说，它会：  帮助静态分析工具：静态分析工具可以利用 @Nullable 注解来检查代码中是否正确处理了可能为 null 的情况，并在发现潜在问题时发出警告。增强代码可读性：开发者可以通过查看注解来了解哪些变量或返回值可能为 null，从而在使用这些变量时进行适当的空值检查。文档生成：在生成文档时，@Nullable 注解可以帮助其他开发者理解哪些字段、方法返回值或参数可以为 null。它不会直接阻止 NullPointerException 的发生，但能帮助开发者在编写和维护代码时进行适当的空值检查，从而减少空指针异常的发生</li>
<li>Bean相关<ul>
<li>@Autowired和@Resource<br>  @Autowired默认注入方式是byType，也就是优先根据接口类型去匹配并注入Bean<br>  @Resource默认是byName注入的，如果不能通过name匹配会变为byType，可以使用只当以下两个属性其中之一来确定，不建议同时指定两个属性</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token annotation punctuation">@interface</span> <span class="token class-name">Resource</span> <span class="token punctuation">{</span>
    <span class="token class-name">String</span> <span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token string">""</span><span class="token punctuation">;</span>
    <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> <span class="token function">type</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token class-name">Object</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li><code>@RestController</code>注解是<code>@Controller</code>和<code>@ResponseBody</code>,会将函数的返回值直接填入HTTP响应体中，是REST风格的控制器</li>
<li>@Scope(““)生命作用域：<ul>
<li>singleton单例作用域，默认全是单例</li>
<li>prototype 每次请求都创建一个新的实例</li>
<li>request 每次HTTP请求都会创建一个bean，在当前HTTP request有效</li>
<li>session 在当前的HTTP session中有效</li>
</ul>
</li>
<li><code>@SpringBootApplication</code> 是<code>@Configuration</code>、<code>@EnableAutoConfiguration</code>、<code>@ComponentScan</code>&nbsp;注解的集合。<ul>
<li><code>@EnableAutoConfiguration</code> 启动自动装配</li>
<li><code>@ComponentScan</code>：扫描注解标记的组件，默认送奥妙该类所在的包下的所有的类</li>
<li><code>@Configuration</code> 允许在 Spring 上下文中注册额外的 bean 或导入其他配置类</li>
</ul>
</li>
<li>读取配置信息并且与bean绑定<ul>
<li><code>@Value("${property}")</code>&nbsp;读取比较简单的配置信息</li>
<li><code>@ConfigurationProperties</code>读取配置信息并与 bean 绑定。<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Component</span>
<span class="token annotation punctuation">@ConfigurationProperties</span><span class="token punctuation">(</span>prefix <span class="token operator">=</span> <span class="token string">"library"</span><span class="token punctuation">)</span>
<span class="token keyword">class</span> <span class="token class-name">LibraryProperties</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@NotEmpty</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> location<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Book</span><span class="token punctuation">&gt;</span></span> books<span class="token punctuation">;</span>

    <span class="token annotation punctuation">@Setter</span>
    <span class="token annotation punctuation">@Getter</span>
    <span class="token annotation punctuation">@ToString</span>
    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Book</span> <span class="token punctuation">{</span>
        <span class="token class-name">String</span> name<span class="token punctuation">;</span>
        <span class="token class-name">String</span> description<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  省略getter<span class="token operator">/</span>setter
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
</li>
</ul>
<h3 id="Bean"><a href="#Bean" class="headerlink" title="Bean"></a>Bean</h3><ul>
<li>Bean的作用域<ol>
<li>singleton单例：Spring中的bean默认都是单例的</li>
<li>prototype：每次获取都会创建一个新的Bean，也就是连续两次获取Bean都会是不同的Bean实例</li>
<li>request：每一次HTTP请求都会产生一个新的bean，bean在当前HTTP request内生效</li>
<li>sesson：在HTTP的session中有效，session是多个HTTP之间使用的连续会话</li>
<li><strong>application/global-session</strong>&nbsp;（仅 Web 应用可用）：每个 Web 应用在启动时创建一个 Bean（应用 Bean），该 bean 仅在当前应用启动时间内有效。</li>
<li>websocket：每一次WebSocket都会产生一个新的bean<br>配置方式：<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Bean</span>
<span class="token annotation punctuation">@Scope</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token class-name">ConfigurableBeanFactory</span><span class="token punctuation">.</span><span class="token constant">SCOPE_PROTOTYPE</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token class-name">Person</span> <span class="token function">personPrototype</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ol>
</li>
<li>Bean的生命周期<ol>
<li>创建Bean的实例：Bean容器会先找到Bean的定义，然后通过Java反射API来创建Bean的实例</li>
<li>Bean属性赋值/填充：为Bean设置相关属性和依赖，例如填入@Autowired等注解注入的对象，setter方法和构造函数</li>
<li>Bean初始化:<img src="/2024/06/07/04/Bean%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96.png" alt="Bean的初始化"></li>
<li>销毁Bean：把Bean的销毁方法记录下来，将爱需要销毁Bean或者销毁容器时，调用这些方法去释放Bean所持有的资源<ul>
<li>如果 Bean 实现了 <code>DisposableBean</code> 接口，执行 <code>destroy()</code> 方法。</li>
<li>如果 Bean 在配置文件中的定义包含 <code>destroy-method</code> 属性，执行指定的 Bean 销毁方法。或者，也可以直接通过<code>@PreDestroy</code> 注解标记 Bean 销毁之前执行的方法。</li>
</ul>
</li>
</ol>
</li>
</ul>
<p><img src="/2024/06/07/04/Bean%E7%9A%84%E5%91%A8%E6%9C%9F.png" alt="|475"></p>
<hr>
<h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h3><h4 id="常见实现"><a href="#常见实现" class="headerlink" title="常见实现"></a>常见实现</h4><p>Spring AOP实现方式有动态代理、字节码等操作方式</p>
<h4 id="常见术语："><a href="#常见术语：" class="headerlink" title="常见术语："></a>常见术语：<img src="/2024/06/07/04/AOP%E5%B8%B8%E8%A7%81%E6%9C%AF%E8%AF%AD.png"></h4><h4 id="AspectJ定义的通知类型"><a href="#AspectJ定义的通知类型" class="headerlink" title="AspectJ定义的通知类型"></a>AspectJ定义的通知类型</h4><ul>
<li>Before 前置通知：在目标方法调用之前，所以获得不到目标方法的具体东西</li>
<li>After 后置通知：目标方法调用之后，类似于finally，无论方法是否成功都会调用</li>
<li>AfterReturing：目标方法调用之后，返回结果之后触发，只有方法完成成功会调用</li>
<li>AfterThrowing：异常通知，出现异常时触发，类似catch</li>
<li>Around环绕通知：可以拿到目标对象<br>对于多个切面的执行顺序可以通过@Order(数字) 来指定</li>
</ul>
<h3 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h3><p>MVC 是模型(Model)、视图(View)、控制器(Controller)的简写，其核心思想是通过将业务逻辑、数据、显示分离来组织代码。<img src="/2024/06/07/04/MVC.png"><br>核心组件：</p>
<ul>
<li>**<code>DispatcherServlet</code>**“：核心中央处理器，用汉语接受请求、分发请求，给予客户端响应</li>
<li>HandlerMapping：处理器映射器，根据URL去匹配查找能处理的Handler，并将涉及的拦截器和Handler一起封装</li>
<li>HandlerAdapter：处理器适配器，根据HandlerMapping找到的Handler，设配置型对应的Handler</li>
<li>Handler：请求处理器</li>
<li>ViewResolver：视图解析器，根据Handler返回的逻辑视图/试图，解析并渲染真正的试图，传递给DispatcherServlet响应客户端。<br><img src="/2024/06/07/04/MVC%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B.png"><br><strong>流程说明（重要）：</strong></li>
</ul>
<ol>
<li>客户端（浏览器）发送请求， <code>DispatcherServlet</code>拦截请求。</li>
<li><code>DispatcherServlet</code> 根据请求信息调用 <code>HandlerMapping</code> 。<code>HandlerMapping</code> 根据 URL 去匹配查找能处理的 <code>Handler</code>（也就是我们平常说的 <code>Controller</code> 控制器） ，并会将请求涉及到的拦截器和 <code>Handler</code> 一起封装。</li>
<li><code>DispatcherServlet</code> 调用 <code>HandlerAdapter</code>适配器执行 <code>Handler</code> 。</li>
<li><code>Handler</code> 完成对用户请求的处理后，会返回一个 <code>ModelAndView</code> 对象给<code>DispatcherServlet</code>，<code>ModelAndView</code> 顾名思义，包含了数据模型以及相应的视图的信息。<code>Model</code> 是返回的数据对象，<code>View</code> 是个逻辑上的 <code>View</code>。</li>
<li><code>ViewResolver</code> 会根据逻辑 <code>View</code> 查找实际的 <code>View</code>。</li>
<li><code>DispaterServlet</code> 把返回的 <code>Model</code> 传给 <code>View</code>（视图渲染）。</li>
<li>把 <code>View</code> 返回给请求者（浏览器）</li>
</ol>
<hr>
<p><a target="_blank" rel="noopener" href="https://javaguide.cn/system-design/framework/spring/spring-design-patterns-summary.html">Spring使用的设计模式：</a><br><img src="/2024/06/07/04/Spring%E4%BD%BF%E7%94%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.png"></p>
<h3 id="Spring事务"><a href="#Spring事务" class="headerlink" title="Spring事务"></a>Spring事务</h3><p>ACID AID是手段，最终目的是保证C</p>
<h5 id="相关接口"><a href="#相关接口" class="headerlink" title="相关接口"></a>相关接口</h5><ul>
<li><p>**<code>PlatformTransactionManager</code>**：（平台）事务管理器，Spring 事务策略的核心。</p>
</li>
<li><p>**<code>TransactionDefinition</code>**：事务定义信息(事务隔离级别、传播行为、超时、只读、回滚规则)。</p>
</li>
<li><p>**<code>TransactionStatus</code>**：事务运行状态。</p>
<ul>
<li>编程式事务 (推荐在分布式系统中使用)通过手动使用TransactionTemplate或者TranctionManager手动管理事务，事务范围过大会出现事务未提交导致超时，因此事务要比锁的颗粒度更小</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserService</span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> <span class="token class-name">TransactionTemplate</span> transactionTemplate<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">UserService</span><span class="token punctuation">(</span><span class="token class-name">TransactionTemplate</span> transactionTemplate<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>transactionTemplate <span class="token operator">=</span> transactionTemplate<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token class-name">User</span> <span class="token function">createUser</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token class-name">String</span> username<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> transactionTemplate<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">TransactionCallback</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token annotation punctuation">@Override</span>
            <span class="token keyword">public</span> <span class="token class-name">User</span> <span class="token function">doInTransaction</span><span class="token punctuation">(</span><span class="token class-name">TransactionStatus</span> status<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">try</span> <span class="token punctuation">{</span>
                    <span class="token comment">// 这里是你的业务代码</span>
                    <span class="token comment">// 如果在这里抛出了异常，TransactionTemplate会捕获这个异常并回滚事务</span>
                    <span class="token comment">// 如果这里没有抛出异常，TransactionTemplate会提交事务</span>
                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    status<span class="token punctuation">.</span><span class="token function">setRollbackOnly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword">throw</span> e<span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>声明式事务：通过使用@Tranctional全注解<br>事务<br>Spring事务中有哪几种传播行为</li>
</ul>
<ol>
<li>**<code>TransactionDefinition.PROPAGATION_REQUIRED</code>**，默认，如果当前存在事务，就加入该事务，否则创建一个新的 事务</li>
<li><strong><code>TransactionDefinition.PROPAGATION_REQUIRES_NEW</code></strong> 创建一个新事务，当前存在事务就把</li>
<li><strong><code>TransactionDefinition.PROPAGATION_NESTED</code></strong> 没有事务就创建一个事务左伟当前事务的嵌套事务，存在事务就和 1 相同</li>
<li><strong><code>TransactionDefinition.PROPAGATION_MANDATORY</code></strong> 如果存在事务就加入该事务，不存在事务就报错</li>
</ol>
<ul>
<li><strong><code>TransactionDefinition.PROPAGATION_SUPPORTS</code></strong>: 如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。</li>
<li><strong><code>TransactionDefinition.PROPAGATION_NOT_SUPPORTED</code></strong>: 以非事务方式运行，如果当前存在事务，则把当前事务挂起。</li>
<li><strong><code>TransactionDefinition.PROPAGATION_NEVER</code></strong>: 以非事务方式运行，如果当前存在事务，则抛出异常。</li>
</ul>
<hr>
<p>Spring事务隔离级别</p>
<ol>
<li>**<code>TransactionDefinition.ISOLATION_DEFAULT</code>**：使用后端数据库的默认隔离等级，MySQL采用可重复读，Oracle默认采用读已提交</li>
<li>**<code>TransactionDefinition.ISOLATION_READ_UNCOMMITTED</code>**：最低的隔离等级，允许读已提交，可能会导致脏读，幻读和不可重复读</li>
<li>**<code>TransactionDefinition.ISOLATION_READ_COMMITTED</code>**：允许读并发事务已提交的事务，可以阻止脏读，但是幻读和不可重复仍有可能发生。</li>
<li>**<code>TransactionDefinition.ISOLATION_REPEATABLE_READ</code>**：对同意字段多次读都是相同的，可以组织脏读和不可重复读，但是幻读仍然会发生</li>
<li>**<code>TransactionDefinition.ISOLATION_SERIALIZABLE</code>**： 序列化，最高的隔离级别，影响程序性能</li>
</ol>
<hr>
<h2 id="Transactional-rollbackFor-x3D-Exception-class-默认回滚是只有遇到RuntimeException运行时异常或者Error才进行回滚，而不会回滚，Checked-Exception-Checked-Exception是那些在编译时期就需要被处理的异常-，"><a href="#Transactional-rollbackFor-x3D-Exception-class-默认回滚是只有遇到RuntimeException运行时异常或者Error才进行回滚，而不会回滚，Checked-Exception-Checked-Exception是那些在编译时期就需要被处理的异常-，" class="headerlink" title="Transactional(rollbackFor = Exception.class)    默认回滚是只有遇到RuntimeException运行时异常或者Error才进行回滚，而不会回滚，Checked Exception(Checked Exception是那些在编译时期就需要被处理的异常)，"></a>Transactional(rollbackFor = Exception.class)<br>    默认回滚是只有遇到RuntimeException运行时异常或者Error才进行回滚，而不会回滚，Checked Exception(Checked Exception是那些在编译时期就需要被处理的异常)，<br><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Transactional</span><span class="token punctuation">(</span>rollbackFor <span class="token operator">=</span> <span class="token class-name">Exception</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span>rollbackFor <span class="token operator">=</span> <span class="token class-name">Exception</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">someMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token comment">// some business logic</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></h2><h3 id="Spirng-Data-JPA-Java-Persistence-API"><a href="#Spirng-Data-JPA-Java-Persistence-API" class="headerlink" title="Spirng Data JPA (Java Persistence API)"></a>Spirng Data JPA (Java Persistence API)</h3><p>是Java平台上的一个规范，用于将对象映射到关系数据库</p>
<h4 id="如何使用JPA在数据库中非持久化一个字段"><a href="#如何使用JPA在数据库中非持久化一个字段" class="headerlink" title="如何使用JPA在数据库中非持久化一个字段"></a>如何使用JPA在数据库中非持久化一个字段</h4><p>非持久化：也就是不被数据库存储<br>可以使用注解的方式：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Entity</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"student"</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Id</span>
    <span class="token annotation punctuation">@GeneratedValue</span><span class="token punctuation">(</span>strategy<span class="token operator">=</span> <span class="token class-name">GenerationType</span><span class="token punctuation">.</span><span class="token constant">AUTO</span><span class="token punctuation">)</span> <span class="token comment">// 自增</span>
    <span class="token annotation punctuation">@Column</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"id"</span><span class="token punctuation">)</span>
    <span class="token keyword">private</span> <span class="token class-name">Long</span> id<span class="token punctuation">;</span>
    <span class="token annotation punctuation">@Column</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"name"</span><span class="token punctuation">)</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>
    <span class="token annotation punctuation">@Column</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"age"</span><span class="token punctuation">)</span>
    <span class="token keyword">private</span> <span class="token class-name">Integer</span> age<span class="token punctuation">;</span>
    
    <span class="token annotation punctuation">@Transient</span> <span class="token comment">// 不映射到数据库</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> secrect<span class="token punctuation">;</span>
    
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="JPA审计功能"><a href="#JPA审计功能" class="headerlink" title="JPA审计功能"></a>JPA审计功能</h4><p>  审计功能主要是帮助我们记录数据库操作的具体行为比如某条记录是谁创建的、什么时间创建的、最后修改人是谁、最后修改时间是什么时候。<br>  示例：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Data</span>
<span class="token annotation punctuation">@AllArgsConstructor</span>
<span class="token annotation punctuation">@NoArgsConstructor</span>
<span class="token annotation punctuation">@MappedSuperclass</span>
<span class="token annotation punctuation">@EntityListeners</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token class-name">AuditingEntityListener</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">AbstractAuditBase</span> <span class="token punctuation">{</span>

    <span class="token annotation punctuation">@CreatedDate</span> <span class="token comment">//该字段为创建时间字段，在insert时会插入</span>
    <span class="token annotation punctuation">@Column</span><span class="token punctuation">(</span>updatable <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">)</span>
    <span class="token annotation punctuation">@JsonIgnore</span> <span class="token comment">//不进行序列化</span>
    <span class="token keyword">private</span> <span class="token class-name">Instant</span> createdAt<span class="token punctuation">;</span>

    <span class="token annotation punctuation">@LastModifiedDate</span> <span class="token comment">//最后一次更新时间</span>
    <span class="token annotation punctuation">@JsonIgnore</span>
    <span class="token keyword">private</span> <span class="token class-name">Instant</span> updatedAt<span class="token punctuation">;</span>

    <span class="token annotation punctuation">@CreatedBy</span> <span class="token comment">//标记创建人</span>
    <span class="token annotation punctuation">@Column</span><span class="token punctuation">(</span>updatable <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token comment">//不允许更新</span>
    <span class="token annotation punctuation">@JsonIgnore</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> createdBy<span class="token punctuation">;</span>

    <span class="token annotation punctuation">@LastModifiedBy</span> <span class="token comment">//最后一次更新人</span>
    <span class="token annotation punctuation">@JsonIgnore</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> updatedBy<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="Spring-Security"><a href="#Spring-Security" class="headerlink" title="Spring Security"></a>Spring Security</h3><h4 id="控制访问权限的方法："><a href="#控制访问权限的方法：" class="headerlink" title="控制访问权限的方法："></a>控制访问权限的方法：</h4><ul>
<li><code>permitAll()</code>：无条件允许任何形式访问，不管你登录还是没有登录。</li>
<li><code>anonymous()</code>：允许匿名访问，也就是没有登录才可以访问。</li>
<li><code>denyAll()</code>：无条件决绝任何形式的访问。</li>
<li><code>authenticated()</code>：只允许已认证的用户访问。</li>
<li><code>fullyAuthenticated()</code>：只允许已经登录或者通过 remember-me 登录的用户访问。</li>
<li><code>hasRole(String)</code> : 只允许指定的角色访问。</li>
<li><code>hasAnyRole(String)</code> : 指定一个或者多个角色，满足其一的用户即可访问。</li>
<li><code>hasAuthority(String)</code>：只允许具有指定权限的用户访问</li>
<li><code>hasAnyAuthority(String)</code>：指定一个或者多个权限，满足其一的用户即可访问。</li>
<li><code>hasIpAddress(String)</code> : 只允许指定 ip 的用户访问。</li>
</ul>
<hr>
<h1 id="参数校验"><a href="#参数校验" class="headerlink" title="参数校验"></a>参数校验</h1><h4 id="Hibernate-Validator"><a href="#Hibernate-Validator" class="headerlink" title="Hibernate Validator"></a>Hibernate Validator</h4><p>使用时建议使用**<code>javax.validation.constraints</code>**中的注解<br>常见的注解：</p>
<ul>
<li><code>@NotEmpty</code> 被注释的字符串的不能为 null 也不能为空</li>
<li><code>@NotBlank</code> 被注释的字符串非 null，并且必须包含一个非空白字符</li>
<li><code>@Null</code> 被注释的元素必须为 null</li>
<li><code>@NotNull</code> 被注释的元素必须不为 null</li>
<li><code>@AssertTrue</code> 被注释的元素必须为 true</li>
<li><code>@AssertFalse</code> 被注释的元素必须为 false</li>
<li><code>@Pattern(regex=,flag=)</code>被注释的元素必须符合指定的正则表达式</li>
<li><code>@Email</code> 被注释的元素必须是 Email 格式。</li>
<li><code>@Min(value)</code>被注释的元素必须是一个数字，其值必须大于等于指定的最小值</li>
<li><code>@Max(value)</code>被注释的元素必须是一个数字，其值必须小于等于指定的最大值</li>
<li><code>@DecimalMin(value)</code>被注释的元素必须是一个数字，其值必须大于等于指定的最小值</li>
<li><code>@DecimalMax(value)</code> 被注释的元素必须是一个数字，其值必须小于等于指定的最大值</li>
<li><code>@Size(max=, min=)</code>被注释的元素的大小必须在指定的范围内</li>
<li><code>@Digits(integer, fraction)</code>被注释的元素必须是一个数字，其值必须在可接受的范围内</li>
<li><code>@Past</code>被注释的元素必须是一个过去的日期</li>
<li><code>@Future</code> 被注释的元素必须是一个将来的日期</li>
<li><code>@Positive</code>和<code>@PositiveOrZero</code>验证数字必须为正数/包括0，同理 <code>@Negative</code>为负数</li>
</ul>
<hr>
<p>示例1：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Data</span>
<span class="token annotation punctuation">@AllArgsConstructor</span>
<span class="token annotation punctuation">@NoArgsConstructor</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>

    <span class="token annotation punctuation">@NotNull</span><span class="token punctuation">(</span>message <span class="token operator">=</span> <span class="token string">"classId 不能为空"</span><span class="token punctuation">)</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> classId<span class="token punctuation">;</span>

    <span class="token annotation punctuation">@Size</span><span class="token punctuation">(</span>max <span class="token operator">=</span> <span class="token number">33</span><span class="token punctuation">)</span>
    <span class="token annotation punctuation">@NotNull</span><span class="token punctuation">(</span>message <span class="token operator">=</span> <span class="token string">"name 不能为空"</span><span class="token punctuation">)</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>

    <span class="token annotation punctuation">@Pattern</span><span class="token punctuation">(</span>regexp <span class="token operator">=</span> <span class="token string">"((^Man$|^Woman$|^UGM$))"</span><span class="token punctuation">,</span> message <span class="token operator">=</span> <span class="token string">"sex 值不在可选范围"</span><span class="token punctuation">)</span>
    <span class="token annotation punctuation">@NotNull</span><span class="token punctuation">(</span>message <span class="token operator">=</span> <span class="token string">"sex 不能为空"</span><span class="token punctuation">)</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> sex<span class="token punctuation">;</span>

    <span class="token annotation punctuation">@Email</span><span class="token punctuation">(</span>message <span class="token operator">=</span> <span class="token string">"email 格式不正确"</span><span class="token punctuation">)</span>
    <span class="token annotation punctuation">@NotNull</span><span class="token punctuation">(</span>message <span class="token operator">=</span> <span class="token string">"email 不能为空"</span><span class="token punctuation">)</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> email<span class="token punctuation">;</span>

<span class="token punctuation">}</span>
<span class="token comment">//在需要校验的参数上使用@Valid，如果验证失败，会抛出我们在需要验证的参数上加上了`@Valid`注解，如果验证失败，它将抛出MethodArgumentNotValidException</span>
<span class="token annotation punctuation">@RestController</span>
<span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/api"</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PersonController</span> <span class="token punctuation">{</span>

    <span class="token annotation punctuation">@PostMapping</span><span class="token punctuation">(</span><span class="token string">"/person"</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token class-name">ResponseEntity</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Person</span><span class="token punctuation">&gt;</span></span> <span class="token function">getPerson</span><span class="token punctuation">(</span><span class="token annotation punctuation">@RequestBody</span> <span class="token annotation punctuation">@Valid</span> <span class="token class-name">Person</span> person<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token class-name">ResponseEntity</span><span class="token punctuation">.</span><span class="token function">ok</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">body</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>示例2：验证请求参数，要求在类上加@Validated注解</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@RestController</span>
<span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/api"</span><span class="token punctuation">)</span>
<span class="token annotation punctuation">@Validated</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PersonController</span> <span class="token punctuation">{</span>

    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/person/{id}"</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token class-name">ResponseEntity</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> <span class="token function">getPersonByID</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Valid</span> <span class="token annotation punctuation">@PathVariable</span><span class="token punctuation">(</span><span class="token string">"id"</span><span class="token punctuation">)</span> <span class="token annotation punctuation">@Max</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">,</span>message <span class="token operator">=</span> <span class="token string">"超过 id 的范围了"</span><span class="token punctuation">)</span> <span class="token class-name">Integer</span> id<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token class-name">ResponseEntity</span><span class="token punctuation">.</span><span class="token function">ok</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">body</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="使用-Validated来指定不同的组别条件下使用不同的校验方法"><a href="#使用-Validated来指定不同的组别条件下使用不同的校验方法" class="headerlink" title="使用@Validated来指定不同的组别条件下使用不同的校验方法"></a>使用@Validated来指定不同的组别条件下使用不同的校验方法</h4><ol>
<li>定义组别接口，为空即可<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>

    <span class="token annotation punctuation">@NotBlank</span><span class="token punctuation">(</span>groups <span class="token operator">=</span> <span class="token class-name">CreateGroup</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token comment">// 创建时需要校验</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> username<span class="token punctuation">;</span>

    <span class="token annotation punctuation">@Size</span><span class="token punctuation">(</span>min <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">,</span> max <span class="token operator">=</span> <span class="token number">14</span><span class="token punctuation">,</span> groups <span class="token operator">=</span> <span class="token class-name">UpdateGroup</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token comment">// 更新时需要校验</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> password<span class="token punctuation">;</span>

    <span class="token comment">// getters and setters</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li>定义类的校验规则，根据组别来写<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>

    <span class="token annotation punctuation">@NotBlank</span><span class="token punctuation">(</span>groups <span class="token operator">=</span> <span class="token class-name">CreateGroup</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token comment">// 创建时需要校验</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> username<span class="token punctuation">;</span>

    <span class="token annotation punctuation">@Size</span><span class="token punctuation">(</span>min <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">,</span> max <span class="token operator">=</span> <span class="token number">14</span><span class="token punctuation">,</span> groups <span class="token operator">=</span> <span class="token class-name">UpdateGroup</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token comment">// 更新时需要校验</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> password<span class="token punctuation">;</span>

    <span class="token comment">// getters and setters</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li>不同的方法上的传参使用不同的组别来进行校验<pre class="line-numbers language-java" data-language="java"><code class="language-java">
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>

    <span class="token annotation punctuation">@NotBlank</span><span class="token punctuation">(</span>groups <span class="token operator">=</span> <span class="token class-name">CreateGroup</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token comment">// 创建时需要校验</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> username<span class="token punctuation">;</span>

    <span class="token annotation punctuation">@Size</span><span class="token punctuation">(</span>min <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">,</span> max <span class="token operator">=</span> <span class="token number">14</span><span class="token punctuation">,</span> groups <span class="token operator">=</span> <span class="token class-name">UpdateGroup</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token comment">// 更新时需要校验</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> password<span class="token punctuation">;</span>

    <span class="token comment">// getters and setters</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ol>
<h4 id="全局处理Controller层异常"><a href="#全局处理Controller层异常" class="headerlink" title="全局处理Controller层异常"></a>全局处理Controller层异常</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@ControllerAdvice</span>
<span class="token annotation punctuation">@ResponseBody</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GlobalExceptionHandler</span> <span class="token punctuation">{</span>

    <span class="token comment">/**
     * 请求参数异常处理
     */</span>
    <span class="token annotation punctuation">@ExceptionHandler</span><span class="token punctuation">(</span><span class="token class-name">MethodArgumentNotValidException</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token class-name">ResponseEntity</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> <span class="token function">handleMethodArgumentNotValidException</span><span class="token punctuation">(</span><span class="token class-name">MethodArgumentNotValidException</span> ex<span class="token punctuation">,</span> <span class="token class-name">HttpServletRequest</span> request<span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="JPA"><a href="#JPA" class="headerlink" title="JPA"></a>JPA</h3><ul>
<li><code>@Entity</code>声明一个类对应一个数据库实体。</li>
<li><code>@Table</code>&nbsp;设置表名</li>
<li><code>@Id</code>声明主键</li>
<li><code>GeneratedValue</code> 主键填充策略<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">enum</span> <span class="token class-name">GenerationType</span> <span class="token punctuation">{</span>

    <span class="token comment">/**
     * 使用一个特定的数据库表格来保存主键
     * 持久化引擎通过关系数据库的一张特定的表格来生成主键,
     */</span>
    <span class="token constant">TABLE</span><span class="token punctuation">,</span>

    <span class="token comment">/**
     *在某些数据库中,不支持主键自增长,比如Oracle、PostgreSQL其提供了一种叫做"序列(sequence)"的机制生成主键
     */</span>
    <span class="token constant">SEQUENCE</span><span class="token punctuation">,</span>

    <span class="token comment">/**
     * 主键自增长
     */</span>
    <span class="token constant">IDENTITY</span><span class="token punctuation">,</span>

    <span class="token comment">/**
     *把主键生成策略交给持久化引擎(persistence engine),
     *持久化引擎会根据数据库在以上三种主键生成 策略中选择其中一种
     */</span>
    <span class="token constant">AUTO</span> <span class="token comment">//默认</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><code>@Column</code> 设置字段<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//设置字段类型，并且增加一个默认值</span>
<span class="token annotation punctuation">@Column</span><span class="token punctuation">(</span>columnDefinition <span class="token operator">=</span> <span class="token string">"tinyint(1) default 1"</span><span class="token punctuation">)</span>
<span class="token keyword">private</span> <span class="token class-name">Boolean</span> enabled<span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li>
<li><code>@Transient</code> 声明不需要持久化的字段，也就是不需要保存进数据库</li>
<li>声明大字段:<ul>
<li>TEXT：用于存储大量的非二进制字符串（字符数据）。它可以存储最多 2^16 - 1 字符。  </li>
<li>BLOB：用于存储大量的二进制数据。它可以存储最多 2^16 - 1 字节的数据。  </li>
<li>MEDIUMTEXT 和 MEDIUMBLOB：这两种类型可以存储更多的数据，最多 2^24 - 1 字符或字节。  </li>
<li>LONGTEXT 和 LONGBLOB：这两种类型可以存储最多 2^32 - 1 字符或字节的数据，适用于非常大的数据。<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Lob</span>
<span class="token comment">//指定 Lob 类型数据的获取策略， FetchType.EAGER 表示非延迟加载，而 FetchType.LAZY 表示延迟加载 ；</span>
<span class="token annotation punctuation">@Basic</span><span class="token punctuation">(</span>fetch <span class="token operator">=</span> <span class="token class-name">FetchType</span><span class="token punctuation">.</span><span class="token constant">EAGER</span><span class="token punctuation">)</span>
<span class="token comment">//columnDefinition 属性指定数据表对应的 Lob 字段类型</span>
<span class="token annotation punctuation">@Column</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"content"</span><span class="token punctuation">,</span> columnDefinition <span class="token operator">=</span> <span class="token string">"LONGTEXT NOT NULL"</span><span class="token punctuation">)</span>
<span class="token keyword">private</span> <span class="token class-name">String</span> content<span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
</li>
<li>创建枚举字段：自己创建枚举类，然后在枚举字段上加上@Enumerated注解即可<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">enum</span> <span class="token class-name">Gender</span> <span class="token punctuation">{</span>
    <span class="token function">MALE</span><span class="token punctuation">(</span><span class="token string">"男性"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token function">FEMALE</span><span class="token punctuation">(</span><span class="token string">"女性"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">private</span> <span class="token class-name">String</span> value<span class="token punctuation">;</span>
    <span class="token class-name">Gender</span><span class="token punctuation">(</span><span class="token class-name">String</span> str<span class="token punctuation">)</span><span class="token punctuation">{</span>
        value<span class="token operator">=</span>str<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token annotation punctuation">@Entity</span>
<span class="token annotation punctuation">@Table</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"role"</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Role</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Id</span>
    <span class="token annotation punctuation">@GeneratedValue</span><span class="token punctuation">(</span>strategy <span class="token operator">=</span> <span class="token class-name">GenerationType</span><span class="token punctuation">.</span><span class="token constant">IDENTITY</span><span class="token punctuation">)</span>
    <span class="token keyword">private</span> <span class="token class-name">Long</span> id<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> description<span class="token punctuation">;</span>
    <span class="token annotation punctuation">@Enumerated</span><span class="token punctuation">(</span><span class="token class-name">EnumType</span><span class="token punctuation">.</span><span class="token constant">STRING</span><span class="token punctuation">)</span>
    <span class="token keyword">private</span> <span class="token class-name">Gender</span> gender<span class="token punctuation">;</span>
    省略getter<span class="token operator">/</span>setter<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li>审计: <del>待补</del></li>
<li>删除/修改数据:<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Repository</span>
<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">UserRepository</span> <span class="token keyword">extends</span> <span class="token class-name">JpaRepository</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>

    <span class="token annotation punctuation">@Modifying</span>
    <span class="token annotation punctuation">@Transactional</span><span class="token punctuation">(</span>rollbackFor <span class="token operator">=</span> <span class="token class-name">Exception</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>
    <span class="token keyword">void</span> <span class="token function">deleteByUserName</span><span class="token punctuation">(</span><span class="token class-name">String</span> userName<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li>关联关系：<ul>
<li><code>@OneToOne</code>&nbsp;声明一对一关系</li>
<li><code>@OneToMany</code>&nbsp;声明一对多关系</li>
<li><code>@ManyToOne</code>&nbsp;声明多对一关系</li>
<li><code>@ManyToMany</code>&nbsp;声明多对多关系</li>
</ul>
</li>
</ul>
<h3 id="JSON处理"><a href="#JSON处理" class="headerlink" title="JSON处理"></a>JSON处理</h3><ul>
<li><code>@JsonIgnoreProperties</code> 用于类上</li>
<li><code>JsonIgnore</code> 用于属性上<br>进行序列化时，会忽略标记的值，示例：<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token punctuation">{</span>
    <span class="token string">"from"</span><span class="token operator">:</span> <span class="token string">"user1"</span><span class="token punctuation">,</span>
    <span class="token string">"to"</span><span class="token operator">:</span> <span class="token string">"user2"</span><span class="token punctuation">,</span>
    <span class="token string">"content"</span><span class="token operator">:</span> <span class="token punctuation">{</span><span class="token string">"text"</span><span class="token operator">:</span> <span class="token string">"Hello"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token string">"image"</span><span class="token operator">:</span> <span class="token string">"image_url"</span><span class="token punctuation">,</span>
    <span class="token string">"readed"</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
    <span class="token string">"date"</span><span class="token operator">:</span> <span class="token string">"2023-01-01 12:00:00"</span>
<span class="token punctuation">}</span>
<span class="token comment">//在类上的image字段上标记 @Ignore</span>
那么序列化之后的结果是
<span class="token punctuation">{</span>
    <span class="token string">"from"</span><span class="token operator">:</span> <span class="token string">"user1"</span><span class="token punctuation">,</span>
    <span class="token string">"to"</span><span class="token operator">:</span> <span class="token string">"user2"</span><span class="token punctuation">,</span>
    <span class="token string">"content"</span><span class="token operator">:</span> <span class="token punctuation">{</span><span class="token string">"text"</span><span class="token operator">:</span> <span class="token string">"Hello"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token string">"readed"</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
    <span class="token string">"date"</span><span class="token operator">:</span> <span class="token string">"2023-01-01 12:00:00"</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li>JSON扁平化：<code>@JsonUnwrapped</code>.</li>
</ul>
<h3 id="测试相关"><a href="#测试相关" class="headerlink" title="测试相关"></a>测试相关</h3><ul>
<li>@ActiveProfiles(“prod”) 作用于类上，用于生命生效的Spring配置文件<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@SpringBootTest</span><span class="token punctuation">(</span>webEnvironment <span class="token operator">=</span> <span class="token constant">RANDOM_PORT</span><span class="token punctuation">)</span>
<span class="token annotation punctuation">@ActiveProfiles</span><span class="token punctuation">(</span><span class="token string">"test"</span><span class="token punctuation">)</span>
<span class="token annotation punctuation">@Slf4j</span>
<span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">TestBase</span> <span class="token punctuation">{</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><code>@Test</code> 声明为一个测试方法，<code>@Transactional</code>用于回滚测试数据， <strong>注意：</strong> @Transactional无法回滚MongoDB等NoSQL数据库，MongoDB支持副本集回滚事务</li>
</ul>
<h3 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h3><p>控制反转，将new 交由Spring框架管理，Bean的生命周期都由Spring调用<br>优点：</p>
<ol>
<li>资源变得容易管理：</li>
<li>降低对象之间的耦合和依赖</li>
</ol>
<h1 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h1><h3 id="SpringBootConfiguration注解"><a href="#SpringBootConfiguration注解" class="headerlink" title="@SpringBootConfiguration注解"></a>@SpringBootConfiguration注解</h3><p>里面包含三个注解</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@SpringBootConfiguration</span> <span class="token comment">// 标识这是一个配置类</span>
<span class="token annotation punctuation">@EnableAutoConfiguration</span> <span class="token comment">// 开启自动装配</span>
<span class="token annotation punctuation">@ComponentScan</span><span class="token punctuation">(</span> <span class="token comment">// 配置扫描路径，用来加载使用注解格式自定的Bean</span>
    excludeFilters <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token annotation punctuation">@Filter</span><span class="token punctuation">(</span>
    type <span class="token operator">=</span> <span class="token class-name">FilterType</span><span class="token punctuation">.</span><span class="token constant">CUSTOM</span><span class="token punctuation">,</span>
    classes <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token class-name">TypeExcludeFilter</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">}</span>
<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token annotation punctuation">@Filter</span><span class="token punctuation">(</span>
    type <span class="token operator">=</span> <span class="token class-name">FilterType</span><span class="token punctuation">.</span><span class="token constant">CUSTOM</span><span class="token punctuation">,</span>
    classes <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token class-name">AutoConfigurationExcludeFilter</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">}</span>
<span class="token punctuation">)</span><span class="token punctuation">}</span>
<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其中@EnableAutoConfiguration注解又包括以下两种注解：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@AutoConfigurationPackage</span> <span class="token comment">// 指定默认的包规则，也就是主程序类所在的包及其所有子包下的组件扫描到Spring容器中</span>
<span class="token annotation punctuation">@Import</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token class-name">AutoConfigurationImportSelector</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token comment">// 引入AutoConfigurationImportSelector类，通过该类的selectImports方法去读取META-INF/spring.factories文件中配置的组件的全类名，并且按照一定的规则过滤掉不符合要求的组件的全类名，将剩余读取到的哥哥组件中的全类名集合返回给IOC容器，并将这些组件注册为bean</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>这是@AutoConfigurationPackage注解的内容</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token class-name">ElementType</span><span class="token punctuation">.</span><span class="token constant">TYPE</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span><span class="token class-name">RetentionPolicy</span><span class="token punctuation">.</span><span class="token constant">RUNTIME</span><span class="token punctuation">)</span>
<span class="token annotation punctuation">@Documented</span>
<span class="token annotation punctuation">@Inherited</span>
<span class="token annotation punctuation">@Import</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token class-name">AutoConfigurationPackages<span class="token punctuation">.</span>Registrar</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token annotation punctuation">@interface</span> <span class="token class-name">AutoConfigurationPackage</span> <span class="token punctuation">{</span>
    <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">basePackages</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">basePackageClasses</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>1、利用getAutoConfigurationEntry(annotationMetadata);给容器中批量导入一些组件<br>2、调用List configurations = getCandidateConfigurations(annotationMetadata, attributes)获取到所有需要导入到容器中的配置类<br>3、利用工厂加载 Map&lt;String, List&gt; loadSpringFactories(@Nullable ClassLoader classLoader)；得到所有的组件<br>4、从META-INF/spring.factories位置来加载一个文件。默认扫描我们当前系统里面所有META-INF/spring.factories位置的文件，按照条件装配（ @ C o n d i t i o n a l ) 最终会按需配置 {按照条件装配（@Conditional)最终会按需配置}按照条件装配（@Conditional)最终会按需配置</p>
<h3 id="SpringBoot自动装配原理"><a href="#SpringBoot自动装配原理" class="headerlink" title="SpringBoot自动装配原理"></a>SpringBoot自动装配原理</h3><h5 id="EnableAutoConfiguration：实现自动装配的核心"><a href="#EnableAutoConfiguration：实现自动装配的核心" class="headerlink" title="@EnableAutoConfiguration：实现自动装配的核心"></a>@EnableAutoConfiguration：实现自动装配的核心</h5><p>先说结论：实际上就是从META-INF/spring.factories文件中获取需要进行自动装配的类，生成响应的Bean对象，然后交给Spring容器管理。这个和手写starter包很类似</p>
<h1 id="Spring源码阅读"><a href="#Spring源码阅读" class="headerlink" title="Spring源码阅读"></a>Spring源码阅读</h1><p>推荐文章：<a target="_blank" rel="noopener" href="https://github.com/xuchengsheng/spring-reading/tree/master">xuchengsheng/spring-reading(github.com)</a></p>
<h2 id="Resource"><a href="#Resource" class="headerlink" title="Resource"></a>Resource</h2><p><code>Resource</code> 是Spring框架中用于简化和统一对底层资源（如文件、classpath 资源、URL 等）的访问的一个核心接口。</p>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>classpath 是 Java 虚拟机（JVM）和 Java 编译器用来查找类文件和资源文件的路径。它指定了 Java 应用程序在运行时或编译时需要的类和资源的位置。classpath 可以包含目录、JAR 文件或 ZIP 文件。</p>
<h3 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h3><ol>
<li>统一的资源抽象，无论资源来自文件系统、classpath、URL还是其他，Resource提供统一的抽象</li>
<li>资源描述通过getDescription来获得底层资源提供的描述性信息</li>
<li>读取能力：Resource提供了getInputStream方法，允许直接读取资源内容而无需关心资源的实际来源。</li>
<li>存在与可读性：Resource提供了两个方法来确定资源是否存在以及是否可读。</li>
<li>开放性检查：isOpen()用来检查资源是否标识一个已经打开的流，有助于避免重复读取流资源。</li>
<li>文件访问：当资源代表一个文件夹中的文件时，可以通过getFile()直接访问该文件</li>
<li>Spring提供了多种Resource的实现</li>
</ol>
<h3 id="源码："><a href="#源码：" class="headerlink" title="源码："></a>源码：</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/**
 * 表示可以提供输入流的资源或对象的接口。
 */</span>
<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">InputStreamSource</span> <span class="token punctuation">{</span>

	<span class="token comment">/**
	 * 返回基础资源内容的 InputStream。
	 * 期望每次调用都会创建一个新的流。
	 * 当我们考虑到像 JavaMail 这样的API时，这个要求尤为重要，因为在创建邮件附件时，JavaMail需要能够多次读取流。对于这样的用例，要求每个 getInputStream() 调用都返回一个新的流。
	 * @return 基础资源的输入流（不能为 null）
	 * @throws java.io.FileNotFoundException 如果基础资源不存在
	 * @throws IOException 如果无法打开内容流
	 */</span>
	<span class="token class-name">InputStream</span> <span class="token function">getInputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span><span class="token punctuation">;</span>

<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="ResourceLoader"><a href="#ResourceLoader" class="headerlink" title="ResourceLoader"></a>ResourceLoader</h2><p>Spring 框架中的一个关键接口，它定义了如何获取资源（例如类路径资源、文件系统资源或网页资源）的策略。这个接口是 Spring 资源加载抽象的核心，使得应用程序可以从不同的资源位置以统一的方式加载资源。<br>用于获取Resource对象的工厂。</p>
<h3 id="主要功能-1"><a href="#主要功能-1" class="headerlink" title="主要功能"></a>主要功能</h3><ol>
<li>统一的资源加载，提供了一个标准化的方法来加载资源，不论资源是存放在类路径、文件系统、网络URL还是其他位置</li>
<li>资源位置解析：根据提供的资源字符串位置，可以确定资源的类型，并且为其创建响应的Resource实例</li>
<li>返回Resource实例：getResource(String location)方法，返回一个Resource对象，代表了指定位置的资源。</li>
<li>与ClassLoader交互：通过getClassLoader()方法返回其关联的ClassLoader</li>
<li>扩展性：<code>ResourceLoader</code>&nbsp;是一个接口，这意味着我们可以实现自己的资源加载策略，或者扩展默认的策略以满足特定需求。</li>
<li>内置实现与整合：Spring 提供了默认的&nbsp;<code>ResourceLoader</code>&nbsp;实现，如&nbsp;<code>DefaultResourceLoader</code>。但更重要的是，<code>org.springframework.context.ApplicationContext</code>&nbsp;也实现了&nbsp;<code>ResourceLoader</code>，这意味着 Spring 上下文本身就是一个资源加载器。</li>
</ol>
<h3 id="源码：-1"><a href="#源码：-1" class="headerlink" title="源码："></a>源码：</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">ResourceLoader</span> <span class="token punctuation">{</span>
	<span class="token comment">//默认的classpath路径</span>
    <span class="token class-name">String</span> <span class="token constant">CLASSPATH_URL_PREFIX</span> <span class="token operator">=</span> <span class="token string">"classpath:"</span><span class="token punctuation">;</span>

    <span class="token class-name">Resource</span> <span class="token function">getResource</span><span class="token punctuation">(</span><span class="token class-name">String</span> var1<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token annotation punctuation">@Nullable</span>
    <span class="token class-name">ClassLoader</span> <span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>默认实现</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DefaultResourceLoader</span> <span class="token keyword">implements</span> <span class="token class-name">ResourceLoader</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Nullable</span>
    <span class="token keyword">private</span> <span class="token class-name">ClassLoader</span> classLoader<span class="token punctuation">;</span>
    <span class="token comment">//自定义的协议</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ProtocolResolver</span><span class="token punctuation">&gt;</span></span> protocolResolvers <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedHashSet</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">//缓存</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Class</span><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span><span class="token punctuation">,</span> <span class="token class-name">Map</span><span class="token punctuation">&lt;</span><span class="token class-name">Resource</span><span class="token punctuation">,</span> <span class="token operator">?</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> resourceCaches <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentHashMap</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    
<span class="token comment">/* 
省略构造方法和一些不重要的方法
*/</span>

    <span class="token keyword">public</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Resource</span><span class="token punctuation">,</span> <span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token function">getResourceCache</span><span class="token punctuation">(</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> valueType<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token class-name">Map</span><span class="token punctuation">)</span><span class="token keyword">this</span><span class="token punctuation">.</span>resourceCaches<span class="token punctuation">.</span><span class="token function">computeIfAbsent</span><span class="token punctuation">(</span>valueType<span class="token punctuation">,</span> <span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentHashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>


<span class="token comment">// 根据不同的路径参数来返回对应的Resource</span>
    <span class="token keyword">public</span> <span class="token class-name">Resource</span> <span class="token function">getResource</span><span class="token punctuation">(</span><span class="token class-name">String</span> location<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Assert</span><span class="token punctuation">.</span><span class="token function">notNull</span><span class="token punctuation">(</span>location<span class="token punctuation">,</span> <span class="token string">"Location must not be null"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Iterator</span> var2 <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getProtocolResolvers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">Resource</span> resource<span class="token punctuation">;</span>
        <span class="token keyword">do</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>var2<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>location<span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getResourceByPath</span><span class="token punctuation">(</span>location<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>

                <span class="token keyword">if</span> <span class="token punctuation">(</span>location<span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token string">"classpath:"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ClassPathResource</span><span class="token punctuation">(</span>location<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token string">"classpath:"</span><span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>

                <span class="token keyword">try</span> <span class="token punctuation">{</span>
                    <span class="token class-name">URL</span> url <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">URL</span><span class="token punctuation">(</span>location<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token class-name">Resource</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token class-name">ResourceUtils</span><span class="token punctuation">.</span><span class="token function">isFileURL</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token keyword">new</span> <span class="token class-name">FileUrlResource</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token keyword">new</span> <span class="token class-name">UrlResource</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">MalformedURLException</span> var5<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getResourceByPath</span><span class="token punctuation">(</span>location<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>

            <span class="token class-name">ProtocolResolver</span> protocolResolver <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">ProtocolResolver</span><span class="token punctuation">)</span>var2<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            resource <span class="token operator">=</span> protocolResolver<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>location<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">while</span><span class="token punctuation">(</span>resource <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">return</span> resource<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">protected</span> <span class="token class-name">Resource</span> <span class="token function">getResourceByPath</span><span class="token punctuation">(</span><span class="token class-name">String</span> path<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ClassPathContextResource</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">protected</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">ClassPathContextResource</span> <span class="token keyword">extends</span> <span class="token class-name">ClassPathResource</span> <span class="token keyword">implements</span> <span class="token class-name">ContextResource</span> <span class="token punctuation">{</span>
        <span class="token keyword">public</span> <span class="token class-name">ClassPathContextResource</span><span class="token punctuation">(</span><span class="token class-name">String</span> path<span class="token punctuation">,</span> <span class="token annotation punctuation">@Nullable</span> <span class="token class-name">ClassLoader</span> classLoader<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">super</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span> classLoader<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getPathWithinContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getPath</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">public</span> <span class="token class-name">Resource</span> <span class="token function">createRelative</span><span class="token punctuation">(</span><span class="token class-name">String</span> relativePath<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">String</span> pathToUse <span class="token operator">=</span> <span class="token class-name">StringUtils</span><span class="token punctuation">.</span><span class="token function">applyRelativePath</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getPath</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> relativePath<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ClassPathContextResource</span><span class="token punctuation">(</span>pathToUse<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>computeIfAbsent 是 Java 8 引入的 Map 接口中的一个默认方法。它用于在 Map 中查找指定键的值，如果该键不存在，则使用提供的映射函数计算该键的值，并将其插入到 Map 中，第二个参数可以传入lambda</p>
<h2 id="ResourcePatternResolver"><a href="#ResourcePatternResolver" class="headerlink" title="ResourcePatternResolver"></a>ResourcePatternResolver</h2><p>用于解析资源模式，支持通过模式匹配检索多个资源，支持通过模式匹配检索多个资源。</p>
<h3 id="主要功能-2"><a href="#主要功能-2" class="headerlink" title="主要功能"></a>主要功能</h3><ol>
<li><p><strong>资源模式解析</strong></p>
<ul>
<li>通过<code>getResources(String locationPattern)</code>方法，支持使用通配符的资源模式，如<code>classpath*:com/example/**/*.xml</code>，用于检索匹配特定模式的多个资源。</li>
</ul>
</li>
<li><p><strong>资源获取</strong></p>
<ul>
<li>通过<code>getResources(Resource location)</code>方法，根据给定的资源对象，返回匹配的资源数组。这使得可以获取与特定资源相关联的其他资源，例如获取与给定类路径下的一个文件相关的所有资源。</li>
</ul>
</li>
<li><p><strong>多种资源位置支持</strong></p>
<ul>
<li>可以处理不同的资源位置，包括类路径（classpath）、文件系统、URL等。这使得应用程序能够以不同的方式组织和存储资源，而不影响资源的检索和加载。</li>
</ul>
</li>
<li><p><strong>灵活的资源加载</strong></p>
<ul>
<li>结合<code>ResourceLoader</code>的能力，<code>ResourcePatternResolver</code>允许在应用程序中以统一的方式加载各种资源，而无需关心底层资源的存储位置或形式。</li>
</ul>
</li>
<li><p><strong>通用资源操作</strong></p>
<ul>
<li>通过<code>Resource</code>接口，提供了对资源的通用操作，例如获取资源的URL、输入流、文件句柄等。</li>
</ul>
</li>
</ol>
<h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">ResourcePatternResolver</span> <span class="token keyword">extends</span> <span class="token class-name">ResourceLoader</span> <span class="token punctuation">{</span>

    <span class="token comment">/**
     * 类路径匹配所有资源的伪 URL 前缀："classpath*:"
     * 这与 ResourceLoader 的类路径 URL 前缀不同，它检索给定名称（例如 "/beans.xml"）的
     * 所有匹配资源，例如在所有部署的 JAR 文件的根目录中。
     * 详见 org.springframework.core.io.ResourceLoader#CLASSPATH_URL_PREFIX
     */</span>
    <span class="token class-name">String</span> <span class="token constant">CLASSPATH_ALL_URL_PREFIX</span> <span class="token operator">=</span> <span class="token string">"classpath*:"</span><span class="token punctuation">;</span>

    <span class="token comment">/**
     * 将给定的位置模式解析为 Resource 对象。
     * 应尽可能避免指向相同物理资源的重叠资源条目。结果应具有集合语义。
     * @param locationPattern 要解析的位置模式
     * @return 相应的 Resource 对象数组
     * @throws IOException 如果发生 I/O 错误
     */</span>
    <span class="token class-name">Resource</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">getResources</span><span class="token punctuation">(</span><span class="token class-name">String</span> locationPattern<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="DocumentLoader"><a href="#DocumentLoader" class="headerlink" title="DocumentLoader"></a>DocumentLoader</h2><p>用于加载和解析 XML 文档</p>
<h3 id="主要功能-3"><a href="#主要功能-3" class="headerlink" title="主要功能"></a>主要功能</h3><ol>
<li>加载XML文档</li>
<li>解析XML文档</li>
<li>支持验证：通过指定验证模式（如 DTD 或 XML Schema 验证），可以确保文档的结构和内容符合规定的标准。</li>
<li>处理实体引用</li>
<li>错误处理</li>
</ol>
<h2 id="MetadataReader"><a href="#MetadataReader" class="headerlink" title="MetadataReader"></a>MetadataReader</h2><h3 id="一些重要概念"><a href="#一些重要概念" class="headerlink" title="一些重要概念"></a>一些重要概念</h3><p>内部类在编译后，其文件名格式为 OuterClass$InnerClass.class。</p>
<h3 id="主要功能-4"><a href="#主要功能-4" class="headerlink" title="主要功能"></a>主要功能</h3><ol>
<li>获取类的基本信息</li>
<li>获取类上的注解信息</li>
<li>获取方法上的注解信息</li>
<li>获取类的成员类信息</li>
<li>获取类的资源信息</li>
<li>获取类的超类信息</li>
</ol>
<h3 id="源码-1"><a href="#源码-1" class="headerlink" title="源码"></a>源码</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">MetadataReaderFactory</span> <span class="token punctuation">{</span>
    <span class="token class-name">MetadataReader</span> <span class="token function">getMetadataReader</span><span class="token punctuation">(</span><span class="token class-name">String</span> var1<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span><span class="token punctuation">;</span>

    <span class="token class-name">MetadataReader</span> <span class="token function">getMetadataReader</span><span class="token punctuation">(</span><span class="token class-name">Resource</span> var1<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h1 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h1><h2 id="拦截器和过滤器的区别"><a href="#拦截器和过滤器的区别" class="headerlink" title="拦截器和过滤器的区别"></a>拦截器和过滤器的区别</h2><p><img src="/2024/06/07/04/%E8%BF%87%E6%BB%A4%E5%99%A8%E5%92%8C%E6%8B%A6%E6%88%AA%E5%99%A8.png"></p>
<ol>
<li>过滤器来自Servlet，而拦截器属于Spring框架中的</li>
<li>请求进入容器-&gt;过滤器-&gt;Servlet-&gt;进入拦截器-&gt;执行Controller</li>
<li>过滤器是基于方法回调，doFilter来执行的，而拦截器则是基于动态代理实现的</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zuofw.github.io/2024/05/23/22/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="QingQiu">
      <meta itemprop="description" content="个人网站，学习记录，面试记录和经验总结、互联网中一块属于自己的小窝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="QingQiu'Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/23/22/" class="post-title-link" itemprop="url">运维</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-05-23 08:52:22" itemprop="dateCreated datePublished" datetime="2024-05-23T08:52:22+08:00">2024-05-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-05-24 13:29:55" itemprop="dateModified" datetime="2024-05-24T13:29:55+08:00">2024-05-24</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.1k</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Docker-Compose"><a href="#Docker-Compose" class="headerlink" title="Docker Compose"></a>Docker Compose</h2><p>编写docker-compose.yml脚本，配合dockerfile和sh脚本进行搭建</p>
<ul>
<li>示例一：搭建一主二从三哨兵的redis集群 ^220b94<pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token property">version</span><span class="token punctuation">:</span> <span class="token string">'3'</span> #dockercompose版本
<span class="token property">services</span><span class="token punctuation">:</span> #定义应用的的服务，每个服务运行一个镜像
  <span class="token property">redis-master</span><span class="token punctuation">:</span> #服务名称
    <span class="token property">image</span><span class="token punctuation">:</span> <span class="token property">redis</span><span class="token punctuation">:</span>latest #镜像
    <span class="token property">command</span><span class="token punctuation">:</span> redis-server --appendonly yes --requirepass bronya #启动容器时要执行命令
    <span class="token property">volumes</span><span class="token punctuation">:</span> #挂载数据卷，不存在的目录会自动创建
      - ./data/<span class="token property">master</span><span class="token punctuation">:</span>/data
    <span class="token property">ports</span><span class="token punctuation">:</span> #定义端口映射
      - <span class="token string">"6379:6379"</span>

  <span class="token property">redis-slave1</span><span class="token punctuation">:</span>
    <span class="token property">image</span><span class="token punctuation">:</span> <span class="token property">redis</span><span class="token punctuation">:</span>latest
    <span class="token property">command</span><span class="token punctuation">:</span> redis-server --slaveof redis-master 6379 --appendonly yes
    <span class="token property">depends_on</span><span class="token punctuation">:</span>
      - redis-master
    <span class="token property">volumes</span><span class="token punctuation">:</span>
      - ./data/<span class="token property">slave1</span><span class="token punctuation">:</span>/data

  <span class="token property">redis-slave2</span><span class="token punctuation">:</span>
    <span class="token property">image</span><span class="token punctuation">:</span> <span class="token property">redis</span><span class="token punctuation">:</span>latest
    <span class="token property">command</span><span class="token punctuation">:</span> redis-server --slaveof redis-master 6379 --appendonly yes
    <span class="token property">depends_on</span><span class="token punctuation">:</span>
      - redis-master
    <span class="token property">volumes</span><span class="token punctuation">:</span>
      - ./data/<span class="token property">slave2</span><span class="token punctuation">:</span>/data

  <span class="token property">redis-sentinel1</span><span class="token punctuation">:</span>
    <span class="token property">image</span><span class="token punctuation">:</span> <span class="token property">redis</span><span class="token punctuation">:</span>latest
    <span class="token property">command</span><span class="token punctuation">:</span> redis-sentinel /etc/redis/sentinel.conf
    <span class="token property">depends_on</span><span class="token punctuation">:</span>
      - redis-master
    <span class="token property">volumes</span><span class="token punctuation">:</span>
      - ./sentinel1.<span class="token property">conf</span><span class="token punctuation">:</span>/etc/redis/sentinel.conf

  <span class="token property">redis-sentinel2</span><span class="token punctuation">:</span>
    <span class="token property">image</span><span class="token punctuation">:</span> <span class="token property">redis</span><span class="token punctuation">:</span>latest
    <span class="token property">command</span><span class="token punctuation">:</span> redis-sentinel /etc/redis/sentinel.conf
    <span class="token property">depends_on</span><span class="token punctuation">:</span>
      - redis-master
    <span class="token property">volumes</span><span class="token punctuation">:</span>
      - ./sentinel2.<span class="token property">conf</span><span class="token punctuation">:</span>/etc/redis/sentinel.conf

  <span class="token property">redis-sentinel3</span><span class="token punctuation">:</span>
    <span class="token property">image</span><span class="token punctuation">:</span> <span class="token property">redis</span><span class="token punctuation">:</span>latest
    <span class="token property">command</span><span class="token punctuation">:</span> redis-sentinel /etc/redis/sentinel.conf
    <span class="token property">depends_on</span><span class="token punctuation">:</span>
      - redis-master
    <span class="token property">volumes</span><span class="token punctuation">:</span>
      - ./sentinel3.<span class="token property">conf</span><span class="token punctuation">:</span>/etc/redis/sentinel.conf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span>
<span class="token function">docker-compose</span> up <span class="token parameter variable">--build</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li>
<li>示例二：基于dockerfile<pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token property">version</span><span class="token punctuation">:</span> <span class="token string">'3'</span>
<span class="token property">services</span><span class="token punctuation">:</span>
  <span class="token property">app</span><span class="token punctuation">:</span>
    <span class="token property">build</span><span class="token punctuation">:</span> 
      <span class="token property">context</span><span class="token punctuation">:</span> .
      <span class="token property">dockerfile</span><span class="token punctuation">:</span> Dockerfile
    <span class="token property">ports</span><span class="token punctuation">:</span>
      - <span class="token string">"8080:8080"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
Dockerfile文件<pre class="line-numbers language-css" data-language="css"><code class="language-css"># 使用官方的java镜像作为基础镜像
FROM <span class="token property">openjdk</span><span class="token punctuation">:</span>8-jdk-alpine

# 设置工作目录
WORKDIR /app

# 将本地的jar包复制到Docker镜像中
COPY ./your-app.jar /app

# 设置启动命令
ENTRYPOINT [<span class="token string">"java"</span><span class="token punctuation">,</span> <span class="token string">"-jar"</span><span class="token punctuation">,</span> <span class="token string">"/app/your-app.jar"</span>]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
<h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><h3 id="常见命令"><a href="#常见命令" class="headerlink" title="常见命令"></a>常见命令</h3><ul>
<li>之间的关系：<br><img src="/2024/05/23/22/docker%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4%E7%9A%84%E5%85%B3%E7%B3%BB.png" alt="常见命令与他们之间的关系"></li>
<li>使用format对ps的结果进行格式化，更容易观察<pre class="line-numbers language-css" data-language="css"><code class="language-css">docker ps -a --format <span class="token selector">"table</span> <span class="token punctuation">{</span><span class="token punctuation">{</span>.ID<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token selector">\t</span><span class="token punctuation">{</span><span class="token punctuation">{</span>.Image<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token selector">\t</span><span class="token punctuation">{</span><span class="token punctuation">{</span>.Ports<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token selector">\t</span><span class="token punctuation">{</span><span class="token punctuation">{</span>.Status<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token selector">\t</span><span class="token punctuation">{</span><span class="token punctuation">{</span>.Names<span class="token punctuation">}</span><span class="token punctuation">}</span>"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
<li>可以通过编辑/root/.bashrc文件去给常用的命令起别名<pre class="line-numbers language-css" data-language="css"><code class="language-css"># 修改/root/.bashrc文件
vi /root/.bashrc
内容如下：
# .bashrc

# User specific aliases and functions

alias rm=<span class="token string">'rm -i'</span>
alias cp=<span class="token string">'cp -i'</span>
alias mv=<span class="token string">'mv -i'</span>
alias dps=<span class="token string">'docker ps --format "table {{.ID}}\t{{.Image}}\t{{.Ports}}\t{{.Status}}\t{{.Names}}"'</span>
alias dis=<span class="token string">'docker images'</span>

# Source global definitions
if [ -f /etc/bashrc ]<span class="token punctuation">;</span> then
        . /etc/bashrc
fi<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><h2 id="网络问题：-容器的ip是一个虚拟ip，其值并不与容器绑定-可以使用docker的网络功能实现容器的互联"><a href="#网络问题：-容器的ip是一个虚拟ip，其值并不与容器绑定-可以使用docker的网络功能实现容器的互联" class="headerlink" title="网络问题：  - 容器的ip是一个虚拟ip，其值并不与容器绑定  - 可以使用docker的网络功能实现容器的互联"></a>网络问题：<br>  - 容器的ip是一个虚拟ip，其值并不与容器绑定<br>  - 可以使用docker的网络功能实现容器的互联</h2></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zuofw.github.io/2024/05/16/42/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="QingQiu">
      <meta itemprop="description" content="个人网站，学习记录，面试记录和经验总结、互联网中一块属于自己的小窝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="QingQiu'Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/16/42/" class="post-title-link" itemprop="url">Java新特性</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-05-16 10:11:42 / 修改时间：16:09:30" itemprop="dateCreated datePublished" datetime="2024-05-16T10:11:42+08:00">2024-05-16</time>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.5k</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Java新特性面试"><a href="#Java新特性面试" class="headerlink" title="Java新特性面试"></a>Java新特性面试</h1><h2 id="Java8"><a href="#Java8" class="headerlink" title="Java8"></a>Java8</h2><ul>
<li>接口：interface 中可以有默认方法，无需被子类实现，通过Interface实现调用</li>
<li><strong>“函数式接口”是指仅仅只包含一个抽象方法,但是可以有多个非抽象方法(也就是上面提到的默认方法)的接口。</strong><ol>
<li>default实现,可以被子类继承重写，使用this调用</li>
<li>static实现使用方法和静态方法一样，但是不能被子类继承</li>
<li>interface和abstract class的区别：interface是为了快速扩展功能，而abstract class是为了被继承实现的。<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token keyword">implements</span> <span class="token class-name">InterfaceNew</span><span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">InterfaceNew</span><span class="token punctuation">.</span><span class="token function">sm</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//调用df方法</span>
        <span class="token class-name">Main</span> main <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        main<span class="token punctuation">.</span><span class="token function">df</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">/**
 * InnerMain
 */</span>
<span class="token keyword">interface</span> <span class="token class-name">InterfaceNew</span> <span class="token punctuation">{</span>
    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sm</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"interface中的sm实现"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
    <span class="token keyword">default</span> <span class="token keyword">void</span>  <span class="token function">df</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"interface提供的df实现"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ol>
</li>
<li>Lambda</li>
<li>Stream：不存储数据，只是对数据进行一系列的处理<ul>
<li>串行流：<ul>
<li>.stream() 为集合创建串行流</li>
</ul>
</li>
<li>并行流：可以多线程执行<ul>
<li>parallelStream()获得并行流</li>
</ul>
</li>
<li>API：<ul>
<li>forEach() 迭代每个数据</li>
<li>map()传入函数作为变量，对每个数据进行映射(处理)</li>
<li>limit() 获取指定数量的流</li>
<li>sorted() 对流进行排序</li>
<li>Collectors 提供很多归约操作，可以讲将流转化为集合或者聚合元素，要配合collect()来实现</li>
<li>count()返回流的的数据</li>
<li>distinct() 返回一个去除重复元素的流</li>
<li>anyMathch() 检查是否有满足条件的元素，返回值为boolean</li>
<li>allMatch() 检查是否所有元素都满足匹配的条件</li>
<li>noneMathc()都不符合匹配条件</li>
<li>findFirst() 返回流中的第一个元素</li>
<li>findAny()返回流中的任意元素，这个任意元素只有在多线程中可以看出不同，他会任何线程中选择一个元素返回</li>
<li>reduce() 将流中元素合并成一个元素 <code>numbers.stream().reduce((n1, n2) -&gt; n1 + n2);</code></li>
<li>filter()过滤</li>
</ul>
</li>
</ul>
</li>
<li>Optional：用于避免空指针<ul>
<li>Optional .ofNullable()返回一个包含指定值Optional对象，如果值为null，则返回一个空的Optional对象</li>
<li>isPresent() Optional不为空，返回true</li>
<li>get()返回值</li>
<li>ifPresent() 如果不为空，可以以调用指定的方法</li>
<li>orElse(默认值) 如果为空返回这个默认值 </li>
<li>orElseGet() 如果为空调用指定的函数</li>
<li>filter() 过滤，如果不满足，返回一个空的Optional</li>
<li>map() 如果对象是Optional，那么就执行给定的函数</li>
<li>flatMap()将Optional展开，不再包装成嵌套的Optional</li>
</ul>
</li>
</ul>
<h2 id="Java9"><a href="#Java9" class="headerlink" title="Java9"></a>Java9</h2><ul>
<li>JShell 类似于python实时命令行交互工具</li>
<li>G1成为默认的垃圾回收器</li>
<li>String使用byte[ ]作为底层，节省空间</li>
</ul>
<h2 id="Java10"><a href="#Java10" class="headerlink" title="Java10"></a>Java10</h2><ul>
<li>var关键字局部变量 ，主要作用是，当类型特别长时，可以使用var替代</li>
<li>Optional增加了orElseThrow来在没有值时抛出指定的异常</li>
</ul>
<h2 id="Java17"><a href="#Java17" class="headerlink" title="Java17"></a>Java17</h2><p>- </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zuofw.github.io/2024/05/13/08/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="QingQiu">
      <meta itemprop="description" content="个人网站，学习记录，面试记录和经验总结、互联网中一块属于自己的小窝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="QingQiu'Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/13/08/" class="post-title-link" itemprop="url">多线程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-05-13 18:05:08" itemprop="dateCreated datePublished" datetime="2024-05-13T18:05:08+08:00">2024-05-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-10-11 10:52:06" itemprop="dateModified" datetime="2024-10-11T10:52:06+08:00">2024-10-11</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B9%B6%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">并发</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>8.7k</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><p>#todo </p>
<ul>
<li><input disabled type="checkbox"> <a target="_blank" rel="noopener" href="https://www.yuque.com/tulingzhouyu/db22bv/gd98aqe6nn6e73qq">金三银四精选面试题系列-徐庶 (yuque.com)</a>专门写一个线程池相关的文章</li>
<li><input disabled type="checkbox"> 泛型相关的<a target="_blank" rel="noopener" href="https://www.yuque.com/tulingzhouyu/db22bv/avpxs3qirk1w4qod">👍 2024金三银四100道面试题笔记资料 (yuque.com)</a></li>
</ul>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ol>
<li>CAS (Compare-And-Swap，比较并交换)，是一种用于实现多线程同步的原子操作。主要原理：1.比较内存中的某个位置的当前值和预期值 2.交换如果当前值与预期值相等，则将该位置的值更新为新值，否则不进行任何操作。<ul>
<li>因为是原子操作所以在多线程中很高效。可以实现无锁编程，避免了上下文切换的开销。</li>
<li>缺点是如果CAS操作失败后，通常会进行自旋，消耗CPU资源。</li>
</ul>
</li>
<li>自旋：当一个线程尝试获取锁但是所以经被其他线程获取时，该线程不会进入睡眠模式，而是会在一个循环中不断的检查锁的状态，直到锁被释放，这种方式叫做自旋。<ul>
<li>优点是：低开销，可以避免线程上下文切换的开销，因为线程不会进入睡眠状态。适用于短时间的锁定，因为时间段，自旋等待的开销可能比线程切换开销更低。</li>
<li>缺点是：CPU消耗搞，自旋不断等待占用CPU，也不适合长时间锁定，因为线程会长时间占用CPU资源进行无效的检查。</li>
</ul>
</li>
<li>并发：一段时间内进行  并行：同一时刻同时进行</li>
</ol>
<h2 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h2><p><img src="/2024/05/13/08/CPU%E6%A6%82%E5%BF%B5.png"></p>
<h3 id="处理器如何实现原子操作的"><a href="#处理器如何实现原子操作的" class="headerlink" title="处理器如何实现原子操作的"></a>处理器如何实现原子操作的</h3><ol>
<li>使用总线锁来保证原子性：如果多个处理器同时对共享变量进行读改写操作(例如i++)，共享会被多个处理器同时进行操作，导致共享变量的值与期望不同。<img src="/2024/05/13/08/i++.png">因为他们会从自己的缓存中读取变量i，然后分别进行+1，之后分别写入系统内存中<ul>
<li>处理器总线锁：使用了处理器提供的LOCK#信号，当一个处理器在总线上发出这个信号，其他处理器的请求将被阻塞住。从而实现独占共享内存。</li>
</ul>
</li>
<li>使用缓存锁：总线锁会导致其他处理器不能处理其他内存地址的数据，我们只需要保证对某个内存地址的操作是原子的就行。<ul>
<li>频繁使用的内存会缓存在处理器的L1、L2、L3高速缓存中。</li>
<li>缓存锁定：缓存锁定是某个CPU对缓存数据进行更改时，会通知缓存了该数据的该数据的CPU抛弃缓存的数据或者从内存重新读取。</li>
</ul>
</li>
</ol>
<h2 id="多线程就一定快吗？"><a href="#多线程就一定快吗？" class="headerlink" title="多线程就一定快吗？"></a>多线程就一定快吗？</h2><p>不一定，因为线程切换涉及到上下文切换和线程创建的开销</p>
<h2 id="如何减少上下文的切换次数"><a href="#如何减少上下文的切换次数" class="headerlink" title="如何减少上下文的切换次数"></a>如何减少上下文的切换次数</h2><ol>
<li>无锁并发编程：避免使用锁，利用将数据的ID按照Hash算法取模运算，不同线程处理不同段的数据</li>
<li>CAS算法：不需要加锁</li>
<li>使用最少线程：避免创建不需要的线程</li>
<li>协程：单线程中实现多任务的调度，并且再单线程中维持多个任务间的切</li>
</ol>
<h2 id="资源限制"><a href="#资源限制" class="headerlink" title="资源限制"></a>资源限制</h2><p>并发编程中，如果多线程占用的资源超过系统资源的限制，实际上仍然是串行执行的，而且因为有上下文切换的影响，反而会更慢</p>
<h2 id="如何避免死锁"><a href="#如何避免死锁" class="headerlink" title="如何避免死锁"></a>如何避免死锁</h2><ol>
<li>避免一个线程同时获得多个锁</li>
<li>避免一个线程在锁内同事占用多个资源，尽量保证每个锁只占用一个资源</li>
<li>尝试使用定时锁 <code>lock.tryLock(timeout)</code>来替代内部锁机制</li>
<li>对于数据库锁，枷锁和解锁必须在一个数据库连接里，否则会出现解锁失败的情况</li>
</ol>
<h2 id="常用的线程分析工具"><a href="#常用的线程分析工具" class="headerlink" title="常用的线程分析工具"></a>常用的线程分析工具</h2><h3 id="vmstat"><a href="#vmstat" class="headerlink" title="vmstat"></a>vmstat</h3><p>常用指令，具体的参数自己去搜，这里主要看的是cs指标，代表每秒上下文切换次数</p>
<pre class="line-numbers language-css" data-language="css"><code class="language-css">vmstat [delay] [count] 后面参数可选
每隔delay秒输出一次统计信息，总共输出count次
vmstat -s 显示系统的累计统计信息
	   -d 显示统计信息
	   -p +指定分区 显示指定分区的统计信息
	   -a 显示活动内存和非活动内存的信息
	   -m 显示slabinfo信息<span class="token punctuation">(</span>`slabinfo` 是 Linux 内核中用于显示 slab 分配器（slab allocator）信息的工具<span class="token punctuation">)</span>
	   -t 在输出中添加时间戳<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="Java中的多线程"><a href="#Java中的多线程" class="headerlink" title="Java中的多线程"></a>Java中的多线程</h2><p>当在一个JVM进程里面开多个线程时，这些线程被分成两类：守护线程和非守护线程。默认开的都是非守护线程。在Java中有一个规定：当所有的非守护线程退出后，整个JVM进程就会退出。意思就是守护线程“不算作数”，守护线程不影响整个 JVM 进程的退出。例如，垃圾回收线程就是守护线程，它们在后台默默工作，当开发者的所有前台线程（非守护线程）都退出之后，整个JVM进程就退出了。</p>
<h2 id="Wait方法为什么不定义在Thread中？"><a href="#Wait方法为什么不定义在Thread中？" class="headerlink" title="Wait方法为什么不定义在Thread中？"></a>Wait方法为什么不定义在Thread中？</h2><p>Wait释放的锁是写在Java对象头中，所以是写在Object中而非当前线程</p>
<h3 id="锁的分类和对比"><a href="#锁的分类和对比" class="headerlink" title="锁的分类和对比"></a>锁的分类和对比</h3><p>Java中锁存在四种状态</p>
<ol>
<li>无锁状态</li>
<li>偏向锁状态</li>
<li>轻量级锁状态</li>
<li>重量级锁状态<br>锁可以升级但是不能降级，这种设定能够提高获得锁和释放锁的效率<br><img src="/2024/05/13/08/%E9%94%81%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9.png"></li>
</ol>
<h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><p>大多数情况下锁不仅不存在多线程竞争，而且总是由同意线程多次获得。<br>当一个线程访问同步块并且获得锁时，会在对象头和栈帧中的锁记录里面存锁偏向的线程ID，以后该线程进入/推出额同步块块时，不需要进行CAS来进行枷锁和解锁，只需要测试对象头Mark Word里是否存储着这项当前线程的偏向锁。<br>如果测试失败就看偏向锁的标识是否为1，1是偏向锁，如果不是就用CAS竞争锁，否则尝试使用CAS将偏向锁设置为当前线程</p>
<h5 id="偏向锁的撤销"><a href="#偏向锁的撤销" class="headerlink" title="偏向锁的撤销"></a>偏向锁的撤销</h5><ol>
<li>偏向锁只有其他线程尝试竞争偏向锁时持有偏向锁的线程才会释放锁。</li>
<li>偏向锁的撤销，需要在全局安全点(在这个事件电商没有正在执行的字节码)，会先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否或者，如果线程处于不活跃状态，则将对象头设置成无锁状态；如果线程仍然存活，则拥有偏向锁的栈会被执行，便利偏向对象的锁记录，要么重新偏向其他线程，要么恢复到无锁或者标记独享不适合作为偏向锁，最后唤醒暂停的线程。</li>
</ol>
<h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><h5 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h5><blockquote>
<p>线程在执行同步块之前，JVM会在当前线程的栈帧中创建用于存储锁记录的空间，并且将对象头中的Mark Word复制到锁记录中(Displaced Mark Word替)。然后线程尝试使用CAS将对象头中的Mark Word替换为只想所记录的指针。如果成功，当前线程获得锁，如果失败，尝试使用自旋来获得锁。</p>
</blockquote>
<h5 id="解锁"><a href="#解锁" class="headerlink" title="解锁"></a>解锁</h5><blockquote>
<p>会使用原子的CAS操作将Displaced Mark Word替换回对象头。如果成功则说明没有竞争发生，如果失败，标识当前锁存在竞争。锁会升级成重量级锁。</p>
</blockquote>
<h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><p>volatile是轻量级的synchronized，保证了共享变量的可见性，同时不会引起上下文的切换和调度。<br>但是i++不能保证原子性的，因为i++是读写两次操作。<br>JVM中并没有要求64位long/double写入是原子的。所以多线程读取时又可以读到的是”一半”的值。这个时候就需要使用volatile了</p>
<h4 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h4><ol>
<li>保证单词写入/读入原子性</li>
<li>内存可见性</li>
<li>禁止重排序</li>
</ol>
<h4 id="前置概念"><a href="#前置概念" class="headerlink" title="前置概念"></a>前置概念</h4><p><img src="/2024/05/13/08/%E5%89%8D%E7%BD%AE%E6%A6%82%E5%BF%B5.png"></p>
<h4 id="volatile是如何实现的？"><a href="#volatile是如何实现的？" class="headerlink" title="volatile是如何实现的？"></a>volatile是如何实现的？</h4><ol>
<li>转变成汇编语言之后会多一个Lock前缀，这个前缀会将当前处理器缓存行的数据写回系统内存，同时其他CPU中缓存了该内存地址的数据无效。修改volatile变量会强制将修改之后的值刷新到内存中同时导致其他线程中的该变量值失效。</li>
<li>处理器会根据MESI(修改、独占、共享、无效)控制协议去维护内部缓存。处理器使用嗅探技术保证它的内部缓存、系统内存和其他处理器的缓存的数据在总线上保持一致。</li>
</ol>
<p>可见性：<br>修改volatile变量会强制将修改之后的值刷新到内存中<br>同时导致其他线程中的该变量值失效。<br>有序性：遵循happen-before<br>内存屏障：JVM通过内存屏障来实现的</p>
<h4 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h4><p>CPU防止代码进行重排序而提供的指令。<br>Unsafe提供了以下的内存屏障方法</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//内存屏障，禁止load操作重排序。屏障前的load操作不能被重排序到屏障后，屏障后的load操作不能被重排序到屏障前</span>
<span class="token keyword">public</span> <span class="token keyword">native</span> <span class="token keyword">void</span> <span class="token function">loadFence</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//内存屏障，禁止store操作重排序。屏障前的store操作不能被重排序到屏障后，屏障后的store操作不能被重排序到屏障前</span>
<span class="token keyword">public</span> <span class="token keyword">native</span> <span class="token keyword">void</span> <span class="token function">storeFence</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//内存屏障，禁止load、store操作重排序</span>
<span class="token keyword">public</span> <span class="token keyword">native</span> <span class="token keyword">void</span> <span class="token function">fullFence</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="重排序问题"><a href="#重排序问题" class="headerlink" title="重排序问题"></a>重排序问题</h4><blockquote>
<p>执行程序时，为了提高性能编译器和处理器常常会对执行进行重排序。</p>
<ol>
<li>编译器优化的重排序：不改变单线程语义的情况下，可以重新安排语句的执行顺序</li>
<li>指令级并行的重排序：现代处理器采用了指令级并行技术来讲多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</li>
<li>内存系统的重排序：由于处理器使用缓存和读/写缓冲区，是的加载和存储操作看上去可能时再乱序执行</li>
</ol>
</blockquote>
<p><img src="/2024/05/13/08/%E9%87%8D%E6%8E%92%E5%BA%8F.png"></p>
<h5 id="as-if-serial"><a href="#as-if-serial" class="headerlink" title="as-if-serial"></a>as-if-serial</h5><p>多线程程序中的重排序，编译器和CPU只能保证每个线程的线程内部之间都是“看似完全串行的”，但是多个线程会相互读取和写入共享的变量不会进行考虑。</p>
<h5 id="happen-before"><a href="#happen-before" class="headerlink" title="happen-before"></a>happen-before</h5><p>保证一个线程的执行结果对另一个线程可见。<br>#todo </p>
<ul>
<li><input disabled type="checkbox"> synchronized原理</li>
</ul>
<h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><h4 id="是可重入的吗"><a href="#是可重入的吗" class="headerlink" title="是可重入的吗"></a>是可重入的吗</h4><blockquote>
<p>可重入（Reentrant）是指在多线程环境中，一个函数可以被多个线程同时调用而不会引起任何问题。</p>
</blockquote>
<p>是可重入的，因为synchronized关键字是基于JVM内部的监视器锁，这种锁是依赖于对象头中的标记字段来管理锁的状态。<br>当线程第一次获得锁时，他的线程ID会被记录在对象头的标记字段中，并且计数器设置为1，如果同一线程需要再次进入由自己持有锁的synchronized块时，计数器就会+1，当synchronized块时，计数器-1。当计数器回到0时，锁才真正被释放，此时其他线程可以尝试获取这个锁。</p>
<h4 id="synchronized可以锁的类型"><a href="#synchronized可以锁的类型" class="headerlink" title="synchronized可以锁的类型"></a>synchronized可以锁的类型</h4><ol>
<li>对于普通同步方法，锁的是实例对象</li>
<li>对于静态同步方法，锁的是当前类的Class对象，包括这个类的所有对象</li>
<li>对于同步方法块，锁的是Synchornized括号里的对象</li>
</ol>
<h4 id="实现和原理"><a href="#实现和原理" class="headerlink" title="实现和原理"></a>实现和原理</h4><ol>
<li>synchronized用的锁是存在Java对象头里的，如果对象是数组类型，则虚拟机用三个字宽存储对象头。<img src="/2024/05/13/08/Java%E5%AF%B9%E8%B1%A1%E5%A4%B4.png"></li>
<li>对象头会随着锁标志位的变化而变化 <img src="/2024/05/13/08/%E5%AF%B9%E8%B1%A1%E5%A4%B4%E4%BC%9A%E9%9A%8F%E7%9D%80%E9%94%81%E6%A0%87%E5%BF%97%E4%BD%8D%E7%9A%84%E5%8F%98%E5%8C%96%E8%80%8C%E5%8F%98%E5%8C%96.png" alt="对象头会随着锁标志位的变化而变化"></li>
</ol>
<h3 id="Java内存模型的基础"><a href="#Java内存模型的基础" class="headerlink" title="Java内存模型的基础"></a>Java内存模型的基础</h3><p>并发编程中常常需要解决线程之间如何进行通信和如何进行同步。<br>在命令式编程中，线程之间的通信机制有两种：共享内存和消息传递。</p>
<blockquote>
<p>共享内存是线程共享程序的公共状态，通过读写内存的公共状态来进行通信。消息传递则是线程之间必须通过发送消息来显示的进行通信。</p>
</blockquote>
<p>Java中使用的是共享内存模型。<img src="/2024/05/13/08/Java%E7%BA%BF%E7%A8%8B%E5%86%85%E5%AD%98%E5%85%B1%E4%BA%AB.png"><br>他们之间的通信需要修改共享变量，然后由另一个去读取共享变量来实现。<br>JDK5 开始，Java使用JSP-133内存模型，使用happens-before：前一个操作的结果对后一个操作可见 </p>
<h3 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h3><h4 id="什么是CountDownLatch？"><a href="#什么是CountDownLatch？" class="headerlink" title="什么是CountDownLatch？"></a>什么是CountDownLatch？</h4><p>CountDownLatch 是通过一个计数器来实现的，计数器的初始值就是线程的数量，每当一个线程执行完毕之后，计数器的值就-1，然后在闭锁上等待的线程就可以恢复工作了。<br>主要使用场景：</p>
<ul>
<li>用于等待多个线程完成一个整体的前提任务<br>实例：在进行业务之前将两个数据库中的数据进行同步(非集群的数据库)<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span></span><span class="token class-name">CountDownLatch</span></span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DatabaseSync</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">syncDatabase1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 这里是同步数据库1的代码</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">syncDatabase2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 这里是同步数据库2的代码</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sync</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>
        <span class="token class-name">CountDownLatch</span> latch <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountDownLatch</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
            <span class="token function">syncDatabase1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            latch<span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
            <span class="token function">syncDatabase2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            latch<span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 等待两个数据库同步操作完成</span>
        latch<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Both databases have been synchronized."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>
        <span class="token keyword">new</span> <span class="token class-name">DatabaseSync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
<h3 id="JUC包"><a href="#JUC包" class="headerlink" title="JUC包"></a>JUC包</h3><h4 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a>CompletableFuture</h4><p>Future的缺点：不支持异步任务的编排，同时get方法是阻塞调用<br>完全可控的Fututure<br>使⽤线程池时，我们应该尽量避免将耗时任务提交到线程池中执⾏。对于⼀些⽐较耗时的操作，如<br>⽹络请求、⽂件读写等，可以采⽤ CompletableFuture 等其他异步操作的⽅式来处理，以避<br>免阻塞线程池中的线程<br>示例代码：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">CompletableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Map</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Map</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> future <span class="token operator">=</span> <span class="token class-name">CompletableFuture</span><span class="token punctuation">.</span><span class="token function">supplyAsync</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> adminClient<span class="token punctuation">.</span><span class="token function">distributedInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h4 id="CompletableFuture源码分析"><a href="#CompletableFuture源码分析" class="headerlink" title="CompletableFuture源码分析"></a>CompletableFuture源码分析</h4><ul>
<li>runAsync不允许返回值，适合需要一步操作但是不关心返回结果 </li>
<li>supplyAsync需要返回值，适合需要返回值的异步操作</li>
<li>thenApply、thenAccept、thenRun、whenComplete 可以对结果进行进一步处理</li>
<li>异常处理使用handle</li>
<li>合并future结果，thenCompose是链接两个CompletabelFuture，并将前一个结果作为下一个任务参数，thenCombine会将两个任务都结束之后，将两个任务的结果合并，并行执行</li>
<li>allOf等待所有的执行完成之后再调用<br>默认使用的是ForkJoinPool.commonPool作为执行器，这个线程池全局共享，可能会被其他任务占用</li>
</ul>
<h4 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h4><p>线程安全的HashMap，多线程情况下HashMap进行put操作会进入死循环。而使用HashTable效率又很低，因为当一个线程访问HashTable的同步方法，其他线程也访问时，会进入阻塞或轮询状态，所有的线程都必须竞争同一把锁。而我们只需要有多把锁，每一把锁都只锁住某一部分数据即可。这就是ConcurrentHashMap使用的锁分段技术。<br>JDK1.7使用的是分段的数据+链表实现的，JDK1.8使用的数据结构跟HashMap一职，数组+链表/红黑树。使用的是Node数组+链表+红黑树，通过synchronized和CAS操作来帮正线程安全</p>
<h4 id="实现原理-具体看源码"><a href="#实现原理-具体看源码" class="headerlink" title="实现原理 具体看源码"></a>实现原理 具体看源码</h4><h5 id="1-7"><a href="#1-7" class="headerlink" title="1.7"></a>1.7</h5><p>Segment数组(不可扩容) 作为分段锁，是可重入锁，对其中的一部分加锁<img src="/2024/05/13/08/JDK1.67%E5%AE%9E%E7%8E%B0.png"></p>
<h4 id="1-8"><a href="#1-8" class="headerlink" title="1.8"></a>1.8</h4><p>使用的是Node数组+链表/红黑树，Node只适用于链表的情况，而红黑树需要TreeNode。使用Node+CAS+synchronized来保证线程安全<img src="/2024/05/13/08/JDK1.8%E5%AE%9E%E7%8E%B0.png"></p>
<h5 id="常用的api"><a href="#常用的api" class="headerlink" title="常用的api"></a>常用的api</h5><h6 id="get"><a href="#get" class="headerlink" title="get"></a>get</h6><p>先进性一次散列，然后使用这个散列值定位到Segment，再进行散列定位到元素。<br>get不需要加锁，因为get方法中使用的共享变量都顶i成volatile类型，额能够在线程之间保持可见性。保证不会读到过期的值，但是只能被单线程写(如果写入的值依赖原值)<br>根据happen before原则，对volatile字段的写是优先于读的。</p>
<h6 id="put"><a href="#put" class="headerlink" title="put"></a>put</h6><p>对共享变量进行写入操作，为了线程安全必须加锁。<br>先定位到Segment，之后再Segment里进行操作，所以只需要锁住一个Segment即可<br>扩容机制：只会对某个segment进行扩容。</p>
<h6 id="count"><a href="#count" class="headerlink" title="count"></a>count</h6><p>先尝试不加锁来统计各个Segment的大小，如果两次中出现了不同的数值，就采用加锁的方式来统计所有Segment大小。<br>原理是格局modCount变量，put、remove、clean方法都会把modCount+1</p>
<h4 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h4><p>线程安全的&nbsp;List，用来替代Vector<br>Vector的核心思想是每次访问都上锁，使用synchronized进行加锁，会导致性能很差<br>而CopyOnWriteArrayList则是使用了跟读写锁相似的思想，读读不互斥。写不会堵塞读取操作，只有写写才会出现互斥，核心思想是写时复制：不会直接修改原数组，而是先创建底层数组的副本，对副本进行修改，修改完之后再将修改后的数据赋值回去。</p>
<h4 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h4><p>线程安全的队列，是非阻塞实现的</p>
<h5 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h5><p>入队<br>使用CAS算法实现的</p>
<ol>
<li>定位尾节点</li>
<li>使用CAS算法来不断尝试将节点加入队列：如果尾节点的next是null表示已经是尾节点了，如果不是说明其他县城更新了尾节点，需要重新或如当前队列的尾节点。<br>出队<br>先获得头节点的元素，判断头节点元素是否为空，如果为空就是已经被别的线程取走，如果不为空就用CAS尝试出队</li>
</ol>
<h4 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h4><p>有多种实现<br>值得注意的时Pirority和Delay<br>阻塞队列，当队列满时，队列会阻塞插入元素的线程，之道队列布满。<br>当队列为空时，获取元素的线程会等待队列变成非空<br>常用于成缠着消费者问题</p>
<h5 id="实现原理-1"><a href="#实现原理-1" class="headerlink" title="实现原理"></a>实现原理</h5><p>通知模式实现</p>
<blockquote>
<p>通知模式是生产者往满的队列中添加队列时会阻塞住生产者。当消费者消费了一个队列中的元素后，会通知生产者当前的队列可用</p>
</blockquote>
<h4 id="CountDownLatch-1"><a href="#CountDownLatch-1" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h4><p>示例代码</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>

    <span class="token keyword">static</span> <span class="token class-name">CountDownLatch</span> countDownLatch <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountDownLatch</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>
        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token punctuation">{</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            countDownLatch<span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            countDownLatch<span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        countDownLatch<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h4><p>同步屏障<br>功能是让一组线程到达一个屏障(同步点)时被阻塞，直到最后一个线程到达屏障时才开门，所有被阻塞的线程才会继续运行。<br>与CountDownLatch的区别：countdownlatch只能使用一次，计数器无法重置。cyclicbarrier可以多次重复使用，当所有的线程到达同步点之后屏障会重置。</p>
<p><strong>CyclicBarrier：用于让一组线程互相等待，直到所有线程都到达某个屏障点，然后所有线程再继续执行。可以重用。<br>CountDownLatch：用于一个或多个线程等待其他线程完成某些操作。不能重用。</strong> </p>
<p>二者使用方法相似<br>如何选择：<br>简单的一次性同步任务可以使用countdownlatch，例如初始化一些配置<br>多阶段反复同步线程或者并发任务需要分阶段执行，每个阶段都需要等待所有的线程完成，选择cyclicbarrier</p>
<h4 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h4><p>信号量，控制同时访问特定资源的线程数量。</p>
<h4 id="Exchanger"><a href="#Exchanger" class="headerlink" title="Exchanger"></a>Exchanger</h4><p>进行线程之间协作的工具类。提供一个同步点，两个线程可以在这个同步点交换彼此的数据。</p>
<h3 id="原子类"><a href="#原子类" class="headerlink" title="原子类"></a>原子类</h3><p>Atomic包</p>
<h3 id="Java中的线程池"><a href="#Java中的线程池" class="headerlink" title="Java中的线程池"></a>Java中的线程池</h3><h4 id="实现原理-2"><a href="#实现原理-2" class="headerlink" title="实现原理"></a>实现原理</h4><ol>
<li>判断核心线程池里的线程是否都在执行任务，如果不是则新建一个工作线程来执行任务；如果都在执行任务，则进入下一个流程</li>
<li>判断工作 队列是否已经满，如果没满，将新提交的任务存储在这个工作队列里，如果满了，进入下一个流程</li>
<li>判断线程池中 当线程是否都在工作中，如果没有就创建一个新的工作线程来执行任务，如果已经满了，则交给饱和策略来处理这个任务<br><img src="/2024/05/13/08/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%89%A7%E8%A1%8C%E7%A4%BA%E6%84%8F%E5%9B%BE.png"><br><img src="/2024/05/13/08/jdk%E7%BA%BF%E7%A8%8B%E6%B1%A0.png"></li>
</ol>
<h4 id="核心参数"><a href="#核心参数" class="headerlink" title="核心参数"></a>核心参数</h4><ol>
<li>核心线程数：任务队列没满时可以同时执行的最大线程数</li>
<li>最大线程数：任务队列满时，可以同时运行的线程数</li>
<li>线程空闲时间：线程数量超过核心线程数时，多余的空闲线程再中止前等待新任务的最长时间</li>
<li>时间单位</li>
<li>任务队列：</li>
<li>线程工厂</li>
<li>拒绝策略：当任务无法提交到线程池时的处理策略。<ul>
<li><code>AbortPolicy</code>：抛出&nbsp;<code>RejectedExecutionException</code>&nbsp;异常（默认策略）。</li>
<li><code>CallerRunsPolicy</code>：由调用线程处理该任务。</li>
<li><code>DiscardPolicy</code>：直接丢弃任务。</li>
<li><code>DiscardOldestPolicy</code>：丢弃队列中最旧的任务，然后重新提交新任务。<br><img src="/2024/05/13/08/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F.png"></li>
</ul>
</li>
</ol>
<h4 id="任务执行顺序"><a href="#任务执行顺序" class="headerlink" title="任务执行顺序"></a>任务执行顺序</h4><ol>
<li>当前运行中的线程数小于核心线程数，就新建一个线程来执行任务，即使线程池中存在空闲线程</li>
<li>如果大于等于核心线程数，但是小于最大线程数，就把任务加入到任务队列中</li>
<li>如果队列已满，但是线程数小于最大线程数，就新建一个线程来执行任务</li>
<li>如果新创建线程会导致当前运行中的线程数大于最大线程数，就会调用拒绝策略</li>
</ol>
<h3 id="生产者-消费者模型："><a href="#生产者-消费者模型：" class="headerlink" title="生产者-消费者模型："></a>生产者-消费者模型：</h3><p>一个内存队列，多个生产线程往内存队列中放数据，多个消费者线程从内存对俄中取数据。</p>
<ol>
<li>内存队列本身需要枷锁，才能实现线程安全</li>
<li>阻塞。当内存队列满了，生产者被阻塞，内存队列为空时消费者被阻塞。</li>
<li>双向通知：消费者被阻塞之后，生产者放入新数据，要通知消费者，反之要通知生产者。</li>
</ol>
<h1 id="Unsafe"><a href="#Unsafe" class="headerlink" title="Unsafe"></a>Unsafe</h1><p>主要功能</p>
<ol>
<li>内存屏障</li>
</ol>
<h1 id="ReenTrantLock"><a href="#ReenTrantLock" class="headerlink" title="ReenTrantLock"></a>ReenTrantLock</h1><h2 id="实现原理-3"><a href="#实现原理-3" class="headerlink" title="实现原理"></a>实现原理</h2><p>实现是一种自旋锁，使用循环调用CAS操作来进行加锁。</p>
<h1 id="线程同步的方法"><a href="#线程同步的方法" class="headerlink" title="线程同步的方法"></a>线程同步的方法</h1><ol>
<li>Synchronized</li>
<li>ReentrantLock</li>
<li>CountDownLatch</li>
<li>CyclicBarrier</li>
<li>Semaphore</li>
<li>Wait和No</li>
</ol>
<p>#todo </p>
<ul>
<li><input disabled type="checkbox"> 加上书签</li>
</ul>
<h1 id="Fork-x2F-Join与线程池的区别"><a href="#Fork-x2F-Join与线程池的区别" class="headerlink" title="Fork/Join与线程池的区别"></a>Fork/Join与线程池的区别</h1><p>核心是ForkJoinPool，使用的是工作窃取方来平衡</p>
<h1 id="AQS-AbstactQueuedSynchronizer"><a href="#AQS-AbstactQueuedSynchronizer" class="headerlink" title="AQS (AbstactQueuedSynchronizer)"></a>AQS (AbstactQueuedSynchronizer)</h1><p>是一个抽象类，提供了线程同步的底层实现机制，</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zuofw.github.io/2024/05/13/00/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="QingQiu">
      <meta itemprop="description" content="个人网站，学习记录，面试记录和经验总结、互联网中一块属于自己的小窝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="QingQiu'Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/13/00/" class="post-title-link" itemprop="url">Spring 循环依赖会出现什么情况？ 如何解决?</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-05-13 15:46:00" itemprop="dateCreated datePublished" datetime="2024-05-13T15:46:00+08:00">2024-05-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-06-08 15:00:56" itemprop="dateModified" datetime="2024-06-08T15:00:56+08:00">2024-06-08</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.3k</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="一、什么是循环依赖"><a href="#一、什么是循环依赖" class="headerlink" title="一、什么是循环依赖?"></a>一、什么是循环依赖?</h2><p>在Spring项目中我们经常使用 @Autowired或者@Resource去注入Bean，我们称之为依赖。<br>当多个Bean之间存在互相依赖的关系，并且出现了循环调用时，Spring就会找不到依赖的七点，就会死循环直到抛出异常。<br>例如：A依赖B,B依赖C,C依赖A，三者必须在依赖的类初始化之后才会初始化自己，从而出现死循环。</p>
<h2 id="二、实战场景"><a href="#二、实战场景" class="headerlink" title="二、实战场景"></a>二、实战场景</h2><p>笔者是在使用Spring Security 编写登录和权限验证代码时出现了循环依赖的场景。</p>
<h2 id="三、解决方法"><a href="#三、解决方法" class="headerlink" title="三、解决方法"></a>三、解决方法</h2><p>省流： 笔者使用的方法</p>
<ol>
<li>使用@Lazy延迟创建对象</li>
<li>将@Resource替换为@Autowired</li>
<li>新建一个空Bean，来解决依赖问题： 例如 A依赖B,B依赖A,我们可以新建一个C，然后让A依赖C，B实现C即可将直接依赖转化为间接依赖关系 中介方式打破循环链<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 新的接口</span>
<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">C</span> <span class="token punctuation">{</span>
    <span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// B实现C</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token keyword">implements</span> <span class="token class-name">C</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// ...</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// A依赖C，而不是直接依赖B</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token class-name">C</span> c<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">A</span><span class="token punctuation">(</span><span class="token class-name">C</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>c <span class="token operator">=</span> c<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        c<span class="token punctuation">.</span><span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ol>
<h2 id="四、扩展：-Autowired是如何解决循环依赖的的问题的"><a href="#四、扩展：-Autowired是如何解决循环依赖的的问题的" class="headerlink" title="四、扩展：@Autowired是如何解决循环依赖的的问题的"></a>四、扩展：@Autowired是如何解决循环依赖的的问题的</h2><p>解决的核心是使用了Spring的三级缓存：</p>
<ul>
<li>第一级缓存：singletonObjects，用于存放完全初始化好的bean，避免重复创建，单例池</li>
<li>二级缓存：earlySingletonObjects 存放原始的bean对象，尚未填充属性，同时也没有进行完成依赖注入的类 (<strong>核心</strong>)</li>
<li>三级缓存：singletonFactories 用于存放bean工厂对象中的getObject方法，用于产生原始的bean或者代理对象(如果Bean被AOP切面代理)来放入二级缓存<br>首先我们要知道，实例化 ≠ 完全初始化，当Spring容器创建bean时，会从一级缓存中寻找，如果没找到，会搜索二级缓存，如果存在就会把它注入，如果没有会找三级缓存。当bean初始化时，如果发现依赖的类没有完成完全初始化，就会先使用二级缓存中的bean实例，当所有的bean都初始化之后再从一级缓存中获取完全初始化的bean<br>而我们使用的@Resource并不存在这种机制，会直接抛出BeanCurrentlyInCreationException<br><strong>只用两级缓存可以吗？</strong><br>如果没有AOP的情况下只是用一级和三级缓存就能解决，但是涉及到AOP时，必须使用了<br>如果发生循环依赖的话，就去 <strong>三级缓存 <code>singletonFactories</code></strong> 中拿到三级缓存中存储的 <code>ObjectFactory</code> 并调用它的 <code>getObject()</code> 方法来获取这个循环依赖对象的前期暴露对象（虽然还没初始化完成，但是可以拿到该对象在堆中的存储地址了），并且将这个前期暴露对象放到二级缓存中，这样在循环依赖时，就不会重复初始化了！</li>
</ul>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zuofw.github.io/2024/04/23/25/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="QingQiu">
      <meta itemprop="description" content="个人网站，学习记录，面试记录和经验总结、互联网中一块属于自己的小窝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="QingQiu'Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/23/25/" class="post-title-link" itemprop="url">train</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-04-23 13:39:25" itemprop="dateCreated datePublished" datetime="2024-04-23T13:39:25+08:00">2024-04-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-05-01 20:56:27" itemprop="dateModified" datetime="2024-05-01T20:56:27+08:00">2024-05-01</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.5k</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Tigs:</p>
<ol>
<li>相同的application文件优先使用公共的配置</li>
</ol>
<h2 id="一些没什么用的小概念"><a href="#一些没什么用的小概念" class="headerlink" title="一些没什么用的小概念"></a>一些没什么用的小概念</h2><ul>
<li>并发量：同一时间内，系统中同时处理的用户请求数</li>
<li>响应时间：系统处理一个请求所需的时间</li>
<li>吞吐量：系统在给定时间内处理处理的业务请求数量</li>
<li>QPS(Queries Per Second) 表示系统每秒钟处理的请求数量</li>
<li>TPS(Transactions Per Second ) 表示系统每秒钟完成的事务数量</li>
</ul>
<h2 id="Gateway-网关负责分发前端请求"><a href="#Gateway-网关负责分发前端请求" class="headerlink" title="Gateway 网关负责分发前端请求"></a>Gateway 网关负责分发前端请求</h2><p>使用分布式锁来解决缓存击穿</p>
<ul>
<li><strong>以下是要自己完成的：</strong><ol>
<li>使用Spring Security和GateWay完成路由转发和认证</li>
<li>使用kafka或rocketmq<br>Redis作为缓存</li>
</ol>
</li>
<li>缓存问题：<ol>
<li>每天的用户很多但是用户每天使用的次数很少，同时会员的信息涉及的表很多<ul>
<li>解决：使用本地缓存，因为每个会员使用次数很少，一分钟有效，</li>
<li>问题:fullgc频繁，导致短时间内大量请求失败，因为缓存时间很短，所以大量的新生代出现，引起频繁的gc，然后大量放入老年代引起fullgc ， 解决：不用本地缓存，而是用线程本地变量，放在内存中。</li>
</ul>
</li>
</ol>
</li>
</ul>
<h2 id="Senta"><a href="#Senta" class="headerlink" title="Senta"></a>Senta</h2><ul>
<li>原理：生成反向sql</li>
<li>模式：<ol>
<li>AT模式：默认，添加undo_log,反向生成sql，回滚之后原来没数据的依然没有数据<ul>
<li>使用方法：<ol>
<li>建立undo_log表</li>
</ol>
</li>
</ul>
</li>
<li>TCC模式： try confirm/cancel 三个阶段的代码自己实现，Seata负责调度</li>
<li>SAGA模式：长事务解决方案，需要编写两个阶段的代码，需要一个JSON文件，可以异步执行</li>
<li>XA模式：适用于银行和金融，需要数据库支持XA协议<br>  try 之前的代码出现异常会直接结束，不会走finally</li>
</ol>
</li>
</ul>
<h2 id="如何处理多并发的买票"><a href="#如何处理多并发的买票" class="headerlink" title="如何处理多并发的买票"></a>如何处理多并发的买票</h2><ol>
<li>使用synchronized ，缺点：会导致卡住，只适合单机</li>
<li>使用Redis分布式锁，使用日期+车次来作为锁key，然后放入Redis中，如果拿到锁则继续执行，使用的使setIfAbsent(key,value,timeout),如果这个锁不存在则设置并且返回true，买到票之后删除key 缺点：如果线程执行时间超过了超时时间，也会导致超卖    <strong>对应Redis的命令是setnx</strong></li>
<li>使用Redisson看门狗，使用一个守护线程来关注超时间是，如果事务未完成但是锁即将过期则重置时间，如果事务结束则守护线程结束，lock.isHeldByCurrentThread来判断是否是当前线程的锁，缺点：Redis集群中Redis宕机，会导致获得得不到锁，然后新的线程向新的Redis主节点中获得锁，仍然可以获得锁 ， <strong>最常用</strong> ，Redisson中的锁在释放了之后Redis就查不到了！！！</li>
<li>使用红锁：只有拿到半数以上的同等地位的Redis的锁才算拿到锁，Redisson中也有自带的红锁，不常用， 缺点：性能问题，并且如果都得不到锁就都会等待了，尽量去尝试获得更多的锁来解决单机宕机问题</li>
</ol>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@RestController</span>
<span class="token annotation punctuation">@Slf4j</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RedisController</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Resource</span>
    <span class="token keyword">private</span> <span class="token class-name">RedissonClient</span> redissonClient<span class="token punctuation">;</span>

    <span class="token annotation punctuation">@PostMapping</span><span class="token punctuation">(</span><span class="token string">"/buy"</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">set</span><span class="token punctuation">(</span><span class="token class-name">String</span> ticket<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>
        <span class="token comment">//当前日期</span>
        <span class="token class-name">String</span> key <span class="token operator">=</span> ticket <span class="token punctuation">;</span>
        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"key:{}"</span><span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">RLock</span> lock <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>

            <span class="token comment">//获取锁</span>
            lock <span class="token operator">=</span> redissonClient<span class="token punctuation">.</span><span class="token function">getLock</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">//尝试加锁，最多等待100秒，上锁以后10秒自动解锁</span>
            <span class="token keyword">boolean</span> tryLock <span class="token operator">=</span> lock<span class="token punctuation">.</span><span class="token function">tryLock</span><span class="token punctuation">(</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">SECONDS</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//等待100秒，上锁以后10秒自动解锁</span>
            log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"tryLock:{}"</span><span class="token punctuation">,</span> tryLock<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">//模拟业务处理</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>tryLock<span class="token punctuation">)</span><span class="token punctuation">{</span>
                <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">10000</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//单位是毫秒</span>
                log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"购买成功"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">null</span> <span class="token operator">!=</span> lock <span class="token operator">&amp;&amp;</span> lock<span class="token punctuation">.</span><span class="token function">isHeldByCurrentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                    lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                <span class="token keyword">return</span> <span class="token string">"购买成功"</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"没拿到锁"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">return</span> <span class="token string">"购买失败"</span><span class="token punctuation">;</span>
<span class="token comment">//                throw new RuntimeException("没拿到锁");</span>
            <span class="token punctuation">}</span>


    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="使用Sentinal进行限流和降级"><a href="#使用Sentinal进行限流和降级" class="headerlink" title="使用Sentinal进行限流和降级"></a>使用Sentinal进行限流和降级</h3><ul>
<li>常见的限流算法：<ol>
<li>静态窗口限流：每秒限制多少个请求，例如：第2.5会统计第2秒到现在的流量</li>
<li>动态窗口限流：滑动窗口，往前取1秒,例如：第2.5秒会统计第1.5秒到现在的请求数</li>
<li>漏桶限流：队列，请求全在队列中，出队是匀速的</li>
<li>令牌桶限流：放的是令牌，令牌就是计数，会有一个计数器匀速产生令牌,出队不是匀速的可以适应短时间内大量请求</li>
<li>令牌大闸：当令牌到达一定数量就不再产生新的令牌</li>
</ol>
</li>
</ul>
<h2 id="如何应对刷票"><a href="#如何应对刷票" class="headerlink" title="如何应对刷票"></a>如何应对刷票</h2><p>使用令牌大闸：令牌按照匀速生成，即使有再多的机器人刷票也会被领票的数量限制，判断令牌肯定比更新库存更快</p>
<ol>
<li>使用令牌锁，持有令牌锁的人才能对令牌进行操作</li>
<li>检测令牌数量，如果有就执行，没有就不能执行</li>
<li>不要立刻释放令牌锁，使用固定的时间来释放令牌锁，这样即使有机器人也得等待令牌锁的释放</li>
</ol>
<ul>
<li>同时也可以加入验证码来防止机器人刷票<br>优化：使用缓存加速令牌锁<br>将数据库查出来的令牌存在Redis中，每次对Redis中的令牌数量-1，只有当数量等于我们设定的阈值时再去更改数据库的令牌数量，所以需要在Redis中长期保持这个key</li>
</ul>
<h2 id="使用RocketMQ"><a href="#使用RocketMQ" class="headerlink" title="使用RocketMQ"></a>使用RocketMQ</h2><p>使用RocketMQ来完成<br>购票之后，将请求发送给RocketMQ，然后另一边去消费这个消息，并且进行数据库的增删改查，可以将请求直接转为String 发送，之后另一端pull然后转为需要的类，之后执行具体具体的逻辑</p>
<h2 id="纯手写"><a href="#纯手写" class="headerlink" title="纯手写"></a>纯手写</h2><ol>
<li>登录：<ul>
<li>使用gateway + SpringSecurity + JWT + Redis实现微服务登录</li>
<li>Mybatis+Mybatis-plus</li>
</ul>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zuofw.github.io/2024/04/14/28/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="QingQiu">
      <meta itemprop="description" content="个人网站，学习记录，面试记录和经验总结、互联网中一块属于自己的小窝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="QingQiu'Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/14/28/" class="post-title-link" itemprop="url">es</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-04-14 19:45:28" itemprop="dateCreated datePublished" datetime="2024-04-14T19:45:28+08:00">2024-04-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-10-09 14:14:17" itemprop="dateModified" datetime="2024-10-09T14:14:17+08:00">2024-10-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">分布式</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.3k</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Elasticsearch学习笔记"><a href="#Elasticsearch学习笔记" class="headerlink" title="Elasticsearch学习笔记"></a>Elasticsearch学习笔记</h1><h2 id="Analyzer"><a href="#Analyzer" class="headerlink" title="Analyzer"></a>Analyzer</h2><p>Analyzer是ES中的一个组件，用于将输入的文本转化为索引时锁使用的文本特征向量。将文本分解，然后转化为特定的文本特征。</p>
<h2 id="分片"><a href="#分片" class="headerlink" title="分片"></a>分片</h2><p>分片就是将索引内部的数据分割成多个部分的机制，用于分布、存储和管理索引的数据 。允许索引被拆分为多个物理或逻辑部分从而实现分布式存储和处理数据的能力</p>
<h1 id="面试常问："><a href="#面试常问：" class="headerlink" title="面试常问："></a>面试常问：</h1><ol>
<li>索引文档的过程：<br> 1. 协调节点默认使用文档ID参与计算，为路由提供合适的分片，转发请求<br> 2. 分片所在节点接收到请求之后，将请求写入内存缓冲区，定时refresh到文件系统缓存，经过这一步既可以被搜索到了，当Filesystem cache中的数据写入到磁盘中时，才会清除掉translog，这个过程叫做flush；<ol start="2">
<li>es的删除：es中的文件并没有删除，每个段都有一个.del文件，删除是在这里进行标志，该文档仍然能够匹配到，但是会在结果中被过滤掉，后续在执行merge(周期性的将较小的段合并为一个较大的段)操作时，会被彻底清除掉</li>
<li>更新：每次更新都是先标记旧的文档为已删除，重新建立一个文档，并通过版本号来区分</li>
<li>搜索过程：<ul>
<li>Query Then Fetch</li>
</ul>
<ol>
<li>查询广播到每一个分片，分片本地执行搜索，建立一个优先队列，搜索只能搜到文件缓存的内容，所以并不是完全实时的</li>
<li>分片返回优先队列中文档的ID和排序值给协调节点，协调节点合并结果并排序</li>
<li>协调节点确定要取回的文档，然后向对应分片发送请求，最后协调节点返回给客户端</li>
</ol>
</li>
<li>写过程：客户端选择一个node(作为协调节点）发请求，协调节点对文档进行路由，将请求转发给有这个文档的主分片的节点，主分片处理请求，并将将数据同步到副本中，之后协调节点根据完成状态，相应给客户端</li>
<li>读过程：协调节点根据doc id来查询，然后对doc id进行hash来确认到了哪个分片上，然后转发请求到对应的节点，使用负载均衡 来选取一个分片来处理，并转发给它，之后由这个节点来读取并返回给协调节点，协调节点返回给客户端</li>
<li>es相对于mongodb，mysql的优势：1.全文检索，相关性排名 2.近实时性3.分布式处理4.数据分析 缺点：不支持事务</li>
</ol>
</li>
</ol>
<ul>
<li>DSL查询：由es提供的基于JSON的DSL语句<ul>
<li>叶子查询：在特定字段中查询特定值</li>
<li>符合查询：以逻辑方式组合多个叶子查询或者更改叶子查询的行为方式</li>
<li>指定高亮字段：<pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">GET /</span><span class="token punctuation">{</span>索引库名<span class="token punctuation">}</span><span class="token selector">/_search</span>
<span class="token punctuation">{</span>
  <span class="token string">"query"</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>
    <span class="token string">"match"</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>
      <span class="token string">"搜索字段"</span><span class="token punctuation">:</span> <span class="token string">"搜索关键字"</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token selector">,
  "highlight":</span> <span class="token punctuation">{</span>
    <span class="token string">"fields"</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>
      <span class="token string">"高亮字段名称"</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>
        <span class="token string">"pre_tags"</span><span class="token punctuation">:</span> <span class="token string">"&lt;em&gt;"</span><span class="token punctuation">,</span>
        <span class="token string">"post_tags"</span><span class="token punctuation">:</span> <span class="token string">"&lt;/em&gt;"</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
</li>
<li>索引 :<img src="/2024/04/14/28/%E4%B8%8Emysql%E5%AF%B9%E6%AF%94.png" alt="|725"><ul>
<li>倒排索引和正排索引的区别：<ul>
<li>正排索引是词条分到文档中</li>
<li>倒排索引是给词条统计文档</li>
<li><img src="/2024/04/14/28/%E4%BA%8C%E8%80%85%E5%8C%BA%E5%88%AB.png" alt="|275"></li>
</ul>
</li>
<li>使用索引模板来加快索引的创建与属性设置</li>
<li>索引结构：倒排索引，使用分词，记录每一个分词出现的文档编号和在文档中出现的位置<ul>
<li><img src="/2024/04/14/28/%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95.jpg"></li>
<li>搜索模块，路由值时，</li>
</ul>
</li>
<li>索引搜索：<ul>
<li>当搜索请求不带路由值时，接收到请求的节点成为协调节点，之后会选择使用的分片，之后会转发请求到拥有这些分片的节点上，每个分片产生一部分的局部结果汇总给协调节点，由协调节点汇总并排序之后返回。</li>
<li>使用路由条件进行搜索时，会将请求转发，之后直接由选中的节点进行返回</li>
</ul>
</li>
<li>索引映射：<ul>
<li>相当于指定了索引字段的名字和能够存储的类型</li>
<li>常用的数据类型：long , integer,short,byte,double,date(date可以在后面加一个format字段来执行时间的格式转换),keyword(用于保存原始文本，不会进行分词处理，用于精确匹配)，boolean,geo_poinst经纬度类型，json格式(需要使用properties来指定内部对象的属性，实际存储时会使用 . 来表示层次结构)，lists(数组)</li>
<li>**<em>如何既能快速匹配，又能精确匹配?</em>**，给字段添加一个fields参数，然后在里面放一个keyword字段</li>
<li>在每一个字段的后面使用：”copy_to”:”复制出来的新字段名字” 可以做到复制这些字段的内容</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">PUT mysougoulog/_mapping</span> 
<span class="token punctuation">{</span>
  <span class="token string">"properties"</span><span class="token punctuation">:</span><span class="token punctuation">{</span>
      <span class="token string">"visitTime"</span><span class="token punctuation">:</span><span class="token punctuation">{</span>
        <span class="token string">"type"</span><span class="token punctuation">:</span><span class="token string">"date"</span><span class="token punctuation">,</span>
        <span class="token string">"format"</span><span class="token punctuation">:</span><span class="token string">"yyyy-MM-dd HH:mm:ss || epoch_millis"</span><span class="token punctuation">,</span>
        <span class="token string">"ignore_malformed"</span><span class="token punctuation">:</span>true # 这个字段类型不对时，不写入，但是不影响其他字段的写入
      <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token selector"># 二者兼得
PUT mysougoulog/_mapping</span> 
<span class="token punctuation">{</span>
    <span class="token string">"properties"</span><span class="token punctuation">:</span><span class="token punctuation">{</span>
        <span class="token string">"key"</span><span class="token punctuation">:</span><span class="token punctuation">{</span>
          <span class="token string">"type"</span><span class="token punctuation">:</span><span class="token string">"text"</span><span class="token punctuation">,</span>
          <span class="token string">"fields"</span><span class="token punctuation">:</span><span class="token punctuation">{</span>
            <span class="token string">"keyword"</span><span class="token punctuation">:</span><span class="token punctuation">{</span>
              <span class="token string">"type"</span><span class="token punctuation">:</span><span class="token string">"keyword"</span><span class="token punctuation">,</span>
              <span class="token string">"ignore_above"</span><span class="token punctuation">:</span>256 # 表示256个字符后面的内容被忽略，用来节省字段
            <span class="token punctuation">}</span>
          <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>文档：<ul>
<li>CRUD时如何控制并发：<ul>
<li>修改时，加上?if_seq_no = xx&amp;if_primary_term=xx来使用乐观锁来控制，这两个字段是可以查到的，Elastisearch不支持事务管理</li>
</ul>
</li>
<li>文本分析：<ul>
<li>文本分析需要经过&gt;=0个字符过滤器一个分词器，&gt;=0 个分词过滤器<ul>
<li>字符过滤器：对原始文档本进行转换，如去掉html标签</li>
<li>分词器：按照规则切分为单词，</li>
<li>分词过滤器：过滤掉一些没有用的词比如，的，删除停用词,也可进行分词的处理，如大小写转化，添加同义词</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>分词器：<ul>
<li>创建倒排索引时对文档进行分词，用户搜索时，对输入的内容进行分词</li>
<li>IK分词器：<ul>
<li>ik_smart 智能切分模式，粗粒度</li>
<li>ik_max_word：最细切分，细粒度</li>
</ul>
</li>
</ul>
</li>
<li><h2 id="数据：-搜索数据：-1-精确搜索：搜索内容不经过文本分析直接进行文本匹配，适用于非text类，一般用于keyword字段-2-全文检索：对检索内容和字段都会进行文本分析-3-经纬度搜索，可以指定某个区域，例如⚪-4-复合搜索：-布尔搜索：通过指定布尔逻辑条件来组织多条查询语句，同时满足整个布尔条件的才会被搜索出来-等等-父子关联-因为es会把数据折叠起来，使用点，所以当一个对象有多个相同的key时，不能进行搜索了，例如goods商品，里面存放商品id和生产时间，就会被折叠-警告：-避免使用对象数组-解决方法：使用嵌套对象-使用join字段来明确父子关系-聚集统计：用于分析索引和文档，类似于mysql中的聚集操作"><a href="#数据：-搜索数据：-1-精确搜索：搜索内容不经过文本分析直接进行文本匹配，适用于非text类，一般用于keyword字段-2-全文检索：对检索内容和字段都会进行文本分析-3-经纬度搜索，可以指定某个区域，例如⚪-4-复合搜索：-布尔搜索：通过指定布尔逻辑条件来组织多条查询语句，同时满足整个布尔条件的才会被搜索出来-等等-父子关联-因为es会把数据折叠起来，使用点，所以当一个对象有多个相同的key时，不能进行搜索了，例如goods商品，里面存放商品id和生产时间，就会被折叠-警告：-避免使用对象数组-解决方法：使用嵌套对象-使用join字段来明确父子关系-聚集统计：用于分析索引和文档，类似于mysql中的聚集操作" class="headerlink" title="数据：  - 搜索数据：      1. 精确搜索：搜索内容不经过文本分析直接进行文本匹配，适用于非text类，一般用于keyword字段      2. 全文检索：对检索内容和字段都会进行文本分析      3. 经纬度搜索，可以指定某个区域，例如⚪      4. 复合搜索：          - 布尔搜索：通过指定布尔逻辑条件来组织多条查询语句，同时满足整个布尔条件的才会被搜索出来          - 等等  - 父子关联:      - 因为es会把数据折叠起来，使用点，所以当一个对象有多个相同的key时，不能进行搜索了，例如goods商品，里面存放商品id和生产时间，就会被折叠 警告： 避免使用对象数组      - 解决方法：使用嵌套对象      - 使用join字段来明确父子关系  - 聚集统计：用于分析索引和文档，类似于mysql中的聚集操作"></a>数据：<br>  - 搜索数据：<br>      1. 精确搜索：搜索内容不经过文本分析直接进行文本匹配，适用于非text类，一般用于keyword字段<br>      2. 全文检索：对检索内容和字段都会进行文本分析<br>      3. 经纬度搜索，可以指定某个区域，例如⚪<br>      4. 复合搜索：<br>          - 布尔搜索：通过指定布尔逻辑条件来组织多条查询语句，同时满足整个布尔条件的才会被搜索出来<br>          - 等等<br>  - 父子关联:<br>      - 因为es会把数据折叠起来，使用点，所以当一个对象有多个相同的key时，不能进行搜索了，例如goods商品，里面存放商品id和生产时间，就会被折叠 <strong>警告：</strong> 避免使用对象数组<br>      - 解决方法：使用嵌套对象<br>      - 使用join字段来明确父子关系<br>  - 聚集统计：用于分析索引和文档，类似于mysql中的聚集操作</h2></li>
<li>集群：<ol>
<li>新集群的产生：master节点的职责主要包括集群、节点和索引的管理，不负责文档级别的管理，主节点和数据节点不是一个<ul>
<li>初始化投票配置：将配置文件中的候选节点写入投票配置，所有节点均可参与投票</li>
<li>选举主节点：超过半数就可成为主节点</li>
<li>发现集群中的其他节点，节点尝试连接主节点，连接上之后主节点把最新的状态发布到这些节点中</li>
<li>集群完成，对外启动统一的服务</li>
</ul>
</li>
<li>集群状态的发布过程:  <strong>删除或者新增节点时触发</strong><ul>
<li>主节点把最新的集群状态发送到每个节点上，每个节点将数据保存并向主节点发送确认响应</li>
<li>主节点接收到半数以上的确认消息，开始提交，发送给每个节点通知使用最新的集群状态，子节点接收后发送确认响应，所有的都确认即可完成发布</li>
<li>响应超过时间限制，则删除这个子节点</li>
</ul>
</li>
</ol>
</li>
<li>如何实现master选举？<ul>
<li>对于所有可以成为master的节点，根据nodeId来排序，每个节点把自己直到的节点排一次序，然后选出第一个节点，认为他是master节点，入股某个节点到达可以成为超过master节点的一半，那就成为了master节点</li>
</ul>
</li>
<li>脑裂问题：<ul>
<li>设置最小主节点设置，设置的值应该是集群中节点总数的一半 + 1</li>
</ul>
</li>
<li>读写一致：<ul>
<li>版本控制：每个文档在ES中都有一个版本号，每次被修改后，版本号会增加，获取文档时，会同时或者它的版本号，更新时可以指定这个版本号，如果版本号不匹配，更新操作就会被拒绝</li>
<li>刷新与同步：向ES中写入数据时，数据先被写入内存缓冲区，然后每隔一段时间刷新一次或者缓冲区满时被刷新到磁盘后就可以被搜索到了，但是没有被写入磁盘，之后定期同步到磁盘中，同步后就是持久化存储了</li>
<li>副本和分片:只有主节点可以写入数据，然后被复制到副本分片中，读取数据时可以从任何一个包含该数据的分片中获取</li>
<li>设置写入确认级别</li>
</ul>
</li>
<li>代码中使用:<img src="/2024/04/14/28/%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%811.png" alt="|575"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Test</span>
<span class="token keyword">void</span> <span class="token function">testMatchAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">{</span>
    <span class="token comment">// 1.创建Request</span>
    <span class="token class-name">SearchRequest</span> request <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SearchRequest</span><span class="token punctuation">(</span><span class="token string">"items"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 2.组织请求参数</span>
    request<span class="token punctuation">.</span><span class="token function">source</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">query</span><span class="token punctuation">(</span><span class="token class-name">QueryBuilders</span><span class="token punctuation">.</span><span class="token function">matchAllQuery</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 3.发送请求</span>
    <span class="token class-name">SearchResponse</span> response <span class="token operator">=</span> client<span class="token punctuation">.</span><span class="token function">search</span><span class="token punctuation">(</span>request<span class="token punctuation">,</span> <span class="token class-name">RequestOptions</span><span class="token punctuation">.</span><span class="token constant">DEFAULT</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 4.解析响应</span>
    <span class="token function">handleResponse</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">handleResponse</span><span class="token punctuation">(</span><span class="token class-name">SearchResponse</span> response<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">SearchHits</span> searchHits <span class="token operator">=</span> response<span class="token punctuation">.</span><span class="token function">getHits</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 1.获取总条数</span>
    <span class="token keyword">long</span> total <span class="token operator">=</span> searchHits<span class="token punctuation">.</span><span class="token function">getTotalHits</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>value<span class="token punctuation">;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"共搜索到"</span> <span class="token operator">+</span> total <span class="token operator">+</span> <span class="token string">"条数据"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 2.遍历结果数组</span>
    <span class="token class-name">SearchHit</span><span class="token punctuation">[</span><span class="token punctuation">]</span> hits <span class="token operator">=</span> searchHits<span class="token punctuation">.</span><span class="token function">getHits</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">SearchHit</span> hit <span class="token operator">:</span> hits<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 3.得到_source，也就是原始json文档</span>
        <span class="token class-name">String</span> source <span class="token operator">=</span> hit<span class="token punctuation">.</span><span class="token function">getSourceAsString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 4.反序列化并打印</span>
        <span class="token class-name">ItemDoc</span> item <span class="token operator">=</span> <span class="token class-name">JSONUtil</span><span class="token punctuation">.</span><span class="token function">toBean</span><span class="token punctuation">(</span>source<span class="token punctuation">,</span> <span class="token class-name">ItemDoc</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
<h2 id="MeiliSearch-gt-轻量级的ES"><a href="#MeiliSearch-gt-轻量级的ES" class="headerlink" title="MeiliSearch->轻量级的ES"></a>MeiliSearch-&gt;轻量级的ES</h2><p>ES虽然扩展性和实时性都比较好，但是中小型项目中，ES有些过剩，对设备的要求也比较高，可以使用MeiliSearch来替代。同时MeiliSearch本身就支持中文搜索，而无需配置</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zuofw.github.io/2024/04/11/19/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="QingQiu">
      <meta itemprop="description" content="个人网站，学习记录，面试记录和经验总结、互联网中一块属于自己的小窝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="QingQiu'Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/11/19/" class="post-title-link" itemprop="url">k8s</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-04-11 10:12:19" itemprop="dateCreated datePublished" datetime="2024-04-11T10:12:19+08:00">2024-04-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-07-19 16:43:54" itemprop="dateModified" datetime="2024-07-19T16:43:54+08:00">2024-07-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%BF%90%E7%BB%B4/" itemprop="url" rel="index"><span itemprop="name">运维</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>13</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>执行kubeadm 时报错，</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zuofw.github.io/2024/04/07/18/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="QingQiu">
      <meta itemprop="description" content="个人网站，学习记录，面试记录和经验总结、互联网中一块属于自己的小窝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="QingQiu'Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/07/18/" class="post-title-link" itemprop="url">MQ</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-04-07 10:07:18" itemprop="dateCreated datePublished" datetime="2024-04-07T10:07:18+08:00">2024-04-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-09-03 14:58:41" itemprop="dateModified" datetime="2024-09-03T14:58:41+08:00">2024-09-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">分布式</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.3k</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="面试常问："><a href="#面试常问：" class="headerlink" title="面试常问："></a>面试常问：</h1><h2 id="生产者出现堆积如何解决"><a href="#生产者出现堆积如何解决" class="headerlink" title="生产者出现堆积如何解决"></a>生产者出现堆积如何解决</h2><ol>
<li>增加消费者</li>
<li>优化消费者的处理速度</li>
<li>使用优先队列，优先处理优先级高的消息</li>
<li>消息压缩：如果网络带宽是瓶颈</li>
<li>升级设备</li>
<li>消息过滤：生产者端发送真正需要处理的消息</li>
<li>调整生产者的速度</li>
</ol>
<h2 id="生产消费过程中如果服务出现异常，如何恢复"><a href="#生产消费过程中如果服务出现异常，如何恢复" class="headerlink" title="生产消费过程中如果服务出现异常，如何恢复"></a>生产消费过程中如果服务出现异常，如何恢复</h2><ol>
<li>重试机制：</li>
<li>死信队列：将无法处理的消息放在一个特殊的队列中，由人工去处理或者特殊处理</li>
<li>备份和恢复：对于重要数据应该定期进行备份，当服务出现异常时，从备份中恢复数据。</li>
<li>服务降级</li>
<li>容错和冗余设计</li>
</ol>
<h2 id="AMQP协议"><a href="#AMQP协议" class="headerlink" title="AMQP协议"></a>AMQP协议</h2><ul>
<li>AMQ Model组件：<ol>
<li>Producer </li>
<li>Exchange 交换器，从Producer中收集消息并根据路由规则发送到对应的消息队列中</li>
<li>Queue 消息队列，存储消息，直到消息被安全的投递到了消费者</li>
<li>Binding 定义了 mq 和 exchange之间的关系，是路由表</li>
<li>Consumer</li>
</ol>
</li>
</ul>
<h2 id="RocketMQ"><a href="#RocketMQ" class="headerlink" title="RocketMQ"></a>RocketMQ</h2><p><a target="_blank" rel="noopener" href="https://javaguide.cn/high-performance/message-queue/rocketmq-questions.html">常见问题</a></p>
<p><img src="/2024/04/07/18/%E8%A7%92%E8%89%B2.png"></p>
<ol>
<li>生产者组-&gt;发送消息的一方<ul>
<li>消息的类型：<ol>
<li>普通消息：并发消息，并发消息没有顺序</li>
<li>分区有序消息:把一个Topic消息分为多个分区，保护和消费，分区内的消息就是队列，FIFO</li>
<li>全局有序：把一个Topic分区数设为1，所有的消息都支持FIFO</li>
<li>延迟消息：消息发送后，消费者不能立刻消费，需要等待</li>
<li>事务消息：涉及分布式事务，保证多个操作同时成功或者失败，消费者才能使用</li>
<li><img src="/2024/04/07/18/%E4%B8%8D%E5%90%8C%E6%B6%88%E6%81%AF%E7%89%B9%E7%82%B9.png"></li>
</ol>
</li>
<li>消息保证机制：<ol>
<li>客户端保证：重试机制和客户端容错(选择延迟较低的Broker来发送消息)</li>
<li>Broker保证</li>
</ol>
</li>
<li>消息发送流程:<ol>
<li>业务层调用Client 发送API业务代码</li>
<li>消息处理层：Client获取消息对象后进行参数检查，准备和封装</li>
<li>通信层：基于Netty封装的RPC通信</li>
</ol>
</li>
</ul>
</li>
<li>Topic：</li>
<li>消费者组： <ul>
<li>订阅关系：一个消费者组订阅一个Topic中的某一个Tag</li>
<li>消费模式：<ul>
<li>集群消费模式：同一个组中的消费者实例负载均衡的消费Topic中的消息，消费进度保存在Broker端，即使应用崩溃，消费进度也不会出错</li>
<li>广播消费：所有消息广播分发，全部的消费者实例可以消费整个Topic中的所有消息，消费进度保存子啊客户端文件中，适用于通知其他服务刷新缓存</li>
</ul>
</li>
<li>可靠消费保证：<ol>
<li>重试-死信机制：正常Topic遭遇消费失败后-&gt;消息被保存在重试Topic中-&gt;多次间隔时间进行重新消费后仍然失败-&gt;进入死信Topic，经由人工处理，不会再被消费者消费</li>
<li>Rebalance机制：重平衡， 用于在发生Broker掉线、Topic扩容和缩容、消费者扩容和缩容等变化时，自动感知并调整自身消费，以尽量减少甚至避免消息没有被消费。</li>
</ol>
</li>
<li>消费方式：<ol>
<li>pull 用户主动pull消息，自主管理位点，由用户代码来进行管理</li>
<li>push 自动pull消息，用户可直接使用，</li>
</ol>
</li>
<li>消费过滤，Broker端可以根据tag进行消费过滤，只返回满足的tag,broker端使用Hash过滤，客户端再进行一次Tag字符串过滤， 因为Hash过来吧可以快速过滤大量数据，但是存在Hash碰撞</li>
</ul>
</li>
</ol>
<ul>
<li>Namesrv集群：一个无状态的元数据管理，Namesrv之于RocketMQ等价于Zookeeper之于Kafka。Topic路由注册和管理、Broker注册和发现的管理者</li>
</ul>
<h1 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h1><p><a target="_blank" rel="noopener" href="https://javaguide.cn/high-performance/message-queue/rabbitmq-questions.html">常见问题</a></p>
<h2 id="RabbitMQ主要架构"><a href="#RabbitMQ主要架构" class="headerlink" title="RabbitMQ主要架构"></a>RabbitMQ主要架构</h2><p><img src="/2024/04/07/18/RabbitMQ%E6%9E%B6%E6%9E%84.png" alt="RabbitMQ架构"></p>
<ul>
<li><p>**<code>publisher</code>**：生产者，也就是发送消息的一方</p>
</li>
<li><p>**<code>consumer</code>**：消费者，也就是消费消息的一方</p>
</li>
<li><p>**<code>queue</code>**：队列，存储消息。生产者投递的消息会暂存在消息队列中，等待消费者处理</p>
</li>
<li><p>**<code>exchange</code>**：交换机，负责消息路由。生产者发送的消息由交换机决定投递到哪个队列。不会持久化数据</p>
</li>
<li><p>**<code>virtual host</code>**：虚拟主机，起到数据隔离的作用。每个虚拟主机相互独立，有各自的exchange、queue，也就是将exchange和queue进行分组</p>
</li>
</ul>
<h2 id="Spring中使用"><a href="#Spring中使用" class="headerlink" title="Spring中使用"></a>Spring中使用</h2><p>使用Spring AMQP来实现</p>
<h3 id="publisher"><a href="#publisher" class="headerlink" title="publisher"></a>publisher</h3><p>使用RabbitTemplate来发送消息</p>
<h3 id="consumer"><a href="#consumer" class="headerlink" title="consumer"></a>consumer</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Component</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SpringRabbitListener</span> <span class="token punctuation">{</span>
        <span class="token comment">// 利用RabbitListener来声明要监听的队列信息</span>
    <span class="token comment">// 将来一旦监听的队列中有了消息，就会推送给当前服务，调用当前方法，处理消息。</span>
    <span class="token comment">// 可以看到方法体中接收的就是消息体的内容</span>
    <span class="token annotation punctuation">@RabbitListener</span><span class="token punctuation">(</span>queues <span class="token operator">=</span> <span class="token string">"simple.queue"</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">listenSimpleQueueMessage</span><span class="token punctuation">(</span><span class="token class-name">String</span> msg<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"spring 消费者接收到消息：【"</span> <span class="token operator">+</span> msg <span class="token operator">+</span> <span class="token string">"】"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="交换机的类型："><a href="#交换机的类型：" class="headerlink" title="交换机的类型："></a>交换机的类型：</h2><h3 id="Fanout"><a href="#Fanout" class="headerlink" title="Fanout"></a><strong>Fanout</strong></h3><p>广播，将消息交给所有绑定到交换机的队列。我们最早在控制台使用的正是Fanout交换机<br>特点：</p>
<ol>
<li>可以有多个队列</li>
<li>每个队列都要绑定到Exchange</li>
<li>生产者发送的消息只能发送到交换机</li>
<li>交换机把消息发送给绑定过的所有队列</li>
<li>订阅队列的消费者都能拿到消息</li>
</ol>
<h3 id="Direct"><a href="#Direct" class="headerlink" title="Direct"></a><strong>Direct</strong></h3><p>订阅，基于RoutingKey（路由key）发送给订阅了消息的队列<br>特点：</p>
<ol>
<li>队列需要与交换机绑定，指定一个RountingKey</li>
<li>消息发送方发送时也需要指定RountingKey</li>
<li>Exchange把消息发送给RountingKey对应的队列</li>
</ol>
<h3 id="Topic"><a href="#Topic" class="headerlink" title="Topic"></a><strong>Topic</strong></h3><p>通配符订阅，与Direct类似，只不过RoutingKey可以使用通配符</p>
<ul>
<li><p><code>#</code>：匹配一个或多个词</p>
</li>
<li><p><code>*</code>：匹配不多不少恰好1个词<br>举例：</p>
</li>
<li><p><code>item.#</code>：能够匹配<code>item.spu.insert</code> 或者 <code>item.spu</code></p>
</li>
<li><p><code>item.*</code>：只能匹配<code>item.spu</code><br>与DIrect类似，但是可以使用通配符来进行队列绑定</p>
</li>
<li><p><strong>Headers</strong>：头匹配，基于MQ的消息头匹配，用的较少。</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zuofw.github.io/2024/03/30/44/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="QingQiu">
      <meta itemprop="description" content="个人网站，学习记录，面试记录和经验总结、互联网中一块属于自己的小窝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="QingQiu'Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/03/30/44/" class="post-title-link" itemprop="url">Netty</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-03-30 19:25:44" itemprop="dateCreated datePublished" datetime="2024-03-30T19:25:44+08:00">2024-03-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-10-01 17:26:48" itemprop="dateModified" datetime="2024-10-01T17:26:48+08:00">2024-10-01</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>6.4k</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>#todo </p>
<ul>
<li><input disabled type="checkbox"> 使用Netty替代springboot的tomcat作为服务器</li>
<li><input disabled type="checkbox"> 使用Netty替代websocket来通信</li>
<li><input disabled type="checkbox"> 更新一下一致性哈希算法，如何更高效，顺便加上解释</li>
</ul>
<h1 id="基本介绍和使用介绍"><a href="#基本介绍和使用介绍" class="headerlink" title="基本介绍和使用介绍"></a>基本介绍和使用介绍</h1><h2 id="I-x2F-O模型："><a href="#I-x2F-O模型：" class="headerlink" title="I/O模型："></a>I/O模型：</h2><ol>
<li>阻塞I/O BIO：程序向内核发起I/O调用，发起调用的线程就一直等待内核返回结果。如果使用BIO实现异步，只能使用多线程模型，会导致增加线程切换的开销。</li>
<li>同步非阻塞IO NIO：应用程序通过轮询的方式获取请求结果。</li>
<li>多路复用I/O：多个进程的I/O可以注册到一个复用器上(Selector)，如果Selector监听的所有的I/O内核缓冲区都没有可读数据，select调用会被阻塞，直到任意I/O在内核缓冲区中有刻度数据时，会立刻返回。并通知其他进程再次发起I/O，也就是使用一个线程监控多个IO操作。 </li>
<li>信号驱动I/O：进程预先告知内核，向内核注册一个信号处理函数，之后进程返回不阻塞，进程通过信号处理函数继续调用I/O读取数据。IO操作就绪后，操作系统会发送信号通知应用程序。 通知何时可以开始一个I/O操作</li>
<li>异步I/O AIO：应用程序发起IO操作之后，立刻返回，操作系统在IO操作执行后，会通知应用程序，应用程序无需轮询IO状态。 通知I/O操作何时结束</li>
</ol>
<ul>
<li>BIO和NIO的区别: <img src="/2024/03/30/44/BIOandNIO.png"></li>
<li>AIO-&gt;异步I/O</li>
</ul>
<h3 id="Reactor-模型"><a href="#Reactor-模型" class="headerlink" title="Reactor 模型"></a>Reactor 模型</h3><blockquote>
<p>是一种处理并发I/O操作的设计模式。核心思想是通过实践多路复用机制来管理多个I/O事件。<br>主要的组件：1. 事件多路分发器(负责监听多个I/O事件，将这些事件分发给相应的事件处理器)<br>2.事件处理器 3.事件分发器：将事件从多路分发器中分发到响应的处理器。</p>
</blockquote>
<h3 id="select、poll、epoll的区别"><a href="#select、poll、epoll的区别" class="headerlink" title="select、poll、epoll的区别"></a>select、poll、epoll的区别</h3><ol>
<li>select：将已连接的Socket都放在一个文件描述符集合中，然后调用select函数将文件描述集合拷贝到内核中，让内核来检查是否有网络事件发生，检查方式就是遍历文件描述符集合。</li>
<li>poll：与select区别是，不再使用BitMap来存储文件描述符，突破了个数上限</li>
<li>epoll：内核使用红黑树来关注待检测的Socket高效，使用事件驱动，内核维护了一个链表来记录就绪事件，只会将事件发生的Socket集合传递给应用程序吗，而不是轮询整个集合</li>
</ol>
<h2 id="如何解决对象创建和销毁问题"><a href="#如何解决对象创建和销毁问题" class="headerlink" title="如何解决对象创建和销毁问题"></a>如何解决对象创建和销毁问题</h2><ol>
<li>对象池服用技术</li>
<li>零拷贝技术：Netty在进行I/O读写时，直接使用DirectBuffer，从而直接避免了数据在堆内存和堆外内存之间的拷贝</li>
</ol>
<h3 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h3><blockquote>
<p>数据从读取到内核缓冲区，然后直接由内核缓冲区发送到网络。而不是拷贝到用户缓冲区域再拷贝到内核缓冲区进行发送。</p>
</blockquote>
<p>Netty零拷贝实现</p>
<ul>
<li>使用堆外内存，避免JVM堆内存到堆外内存的数据拷贝</li>
<li>CompositeByteBuf 类，可以组合多个 Buffer 对象合并成一个逻辑上的对象，避免通过传统内存拷贝的方式将几个 Buffer 合并成一个大的 Buffer。</li>
<li>通过 Unpooled.wrappedBuffer 可以将 byte 数组包装成 ByteBuf 对象，包装过程中不会产生内存拷贝。</li>
<li>ByteBuf.slice ，slice 操作可以将一个 ByteBuf 对象切分成多个 ByteBuf 对象，切分过程中不会产生内存拷贝，底层共享一个 byte 数组的存储空间。</li>
<li>Netty 使用 封装了transferTo() 方法 FileRegion，可以将文件缓冲区的数据直接传输到目标 Channel，避免内核缓冲区和用户态缓冲区之间的数据拷贝</li>
</ul>
<h3 id="Java中的IO模型"><a href="#Java中的IO模型" class="headerlink" title="Java中的IO模型"></a>Java中的IO模型</h3><ol>
<li>BIO java.io是BIO</li>
<li>NIO java.nio包是NIO的实现，实质上仍然是同步的，读写操作时非同步的，但是这些操作是由应用程序主动发起和处理的，所以仍然是同步的。</li>
<li>AIO java.nio.channels是NIO的实现</li>
</ol>
<h2 id="按照定义来说，Netty是一个异步的、事件驱动的、用来做高性能高可靠性的网络应用的框架"><a href="#按照定义来说，Netty是一个异步的、事件驱动的、用来做高性能高可靠性的网络应用的框架" class="headerlink" title="按照定义来说，Netty是一个异步的、事件驱动的、用来做高性能高可靠性的网络应用的框架"></a>按照定义来说，Netty是一个异步的、事件驱动的、用来做高性能高可靠性的网络应用的框架</h2><p>Netty相比于Tomcat，不需要遵循Serlet规范，可以最大化的发挥NIO的特性。<br>如果需要面向TCP的网络应用开发，那么Netty才是最佳选择</p>
<h3 id="三大组件"><a href="#三大组件" class="headerlink" title="三大组件"></a>三大组件</h3><ol>
<li>Channel &amp; Buffer</li>
<li>Selector</li>
<li>Bootstrap</li>
</ol>
<h4 id="逻辑架构"><a href="#逻辑架构" class="headerlink" title="逻辑架构"></a>逻辑架构</h4><p><img src="/2024/03/30/44/Netty%E6%95%B4%E4%BD%93%E9%80%BB%E8%BE%91.png"></p>
<ol>
<li>网络通信层：支持多种网络协议，当网络数据读取到内核缓冲区后，会触发各种网络事件，会分发给事件调度层进行处理。核心是<ul>
<li>BootStrap，负责Netty客户端的启动、初始化、服务器连接等过程</li>
<li>ServerBootStrap：用于服务端绑定本地端端口，会绑定Boss和Worker两个EventLoopGroup</li>
<li>Channle 通道，基于NIO更高层次的抽象吗</li>
</ul>
</li>
<li>事件调度层：通过Reactor线程模型对各种事件进行聚合处理。通过Selector主循环线程继承u洞中时间，实际业务处理逻辑是交由服务编排曾中的Handler解决的。<ul>
<li>EventLoopGroup（核心）：本质是一个<strong>线程池</strong>，主要负责接收I/O请求，并分配线程执行处理请求。通过创建不同的EventLoopGroup参数可以支持Reactor三种线程模型：<ul>
<li>单线程模型：Group中只包含一个EventLoop，Boss和Worker使用同一个Group</li>
<li>多线程：多个EventLoop，B和W使用同一个</li>
<li>主从多线程：多个EventLoop，B和W使用不同的Group</li>
</ul>
</li>
<li>EventLoop负责处理Channel生命周期中所有的I/O事件，一个EventLoopGroup包含一个或者多个EventLoop，一个EventLoop同一时间只会绑定一个Channel，Channel生命周期内可以和多个EventLoop进行多次绑定和解绑<img src="/2024/03/30/44/EventLoop.png"></li>
</ul>
</li>
<li>服务编排层：负责组装各种服务，是核心处理链。<ul>
<li>ChannelPipeline核心编排组件，负责组装各种ChannelHandler，I/O读写触发时，会依次调用Handler进行拦截和处理。</li>
<li>ChannelHandler完成具体的树decode和encode工作和处理公国。</li>
<li>ChannelHandlerContext：用于保存上下文，通过HandlerContext可以知道Pipeline和Handler的关联关系，包含Handler生命周期的所有事件。</li>
</ul>
</li>
</ol>
<h2 id="Bootstrap"><a href="#Bootstrap" class="headerlink" title="Bootstrap"></a>Bootstrap</h2><blockquote>
<p>Netty客户端的启动</p>
</blockquote>
<h2 id="ServerBootStrap"><a href="#ServerBootStrap" class="headerlink" title="ServerBootStrap"></a>ServerBootStrap</h2><blockquote>
<p>服务端启动，会绑定Boss和 Worker两个EventLoopGroup</p>
</blockquote>
<p>Boss线程会不断接受新的连接，然后将连接分给Worker去处理</p>
<h2 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h2><h3 id="常用的Channel实现类"><a href="#常用的Channel实现类" class="headerlink" title="常用的Channel实现类"></a>常用的Channel实现类</h3><ul>
<li>NioServerSocketChannel 异步 TCP 服务端。</li>
<li>NioSocketChannel 异步 TCP 客户端。</li>
<li>OioServerSocketChannel 同步 TCP 服务端。</li>
<li>OioSocketChannel 同步 TCP 客户端。</li>
<li>NioDatagramChannel 异步 UDP 连接。</li>
<li>OioDatagramChannel 同步 UDP 连接。</li>
</ul>
<h3 id="Channel与事件"><a href="#Channel与事件" class="headerlink" title="Channel与事件"></a>Channel与事件</h3><ul>
<li>channelRegistered：Channel创建后被注册后被注册</li>
<li>channelUnregistered：Channel创建后未注册或者从EventLoop取消注册</li>
<li>channelActive：Channel处于就绪状态，可以被读写</li>
<li>channelInactive：处于非就绪状态</li>
<li>channelRead：Channel可以从远端读取数据</li>
<li>channelReadComplete：Channel读取数据完成</li>
</ul>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul>
<li>ChannelFuture<ul>
<li>其 addListener()方法会注册一个ChannelFutureListener来等待通知</li>
</ul>
</li>
<li>ChannelHandler：事件处理的具体逻辑<ol>
<li>生存周期：handlerAddedChannelHandler被添加到ChannelPipeline中时被调用，handlerRemoved被被移除，exceptionCaught处理过程中在ChannelPipeline中有错误产生时。</li>
<li>ChannelInboundHandler-&gt;处理入站数据及状态变化。<ul>
<li>方法：<img src="/2024/03/30/44/ChannelInboundHandler.png"></li>
<li>SimpleChannelInboundHandler会自动释放资源</li>
<li><img src="/2024/03/30/44/ChannelOutboundHandler.png"></li>
</ul>
</li>
</ol>
</li>
<li>ChannelPipeline<ul>
<li>每建立一个新的Channel都会分配一个ChannelPipeline，不可修改</li>
<li>提供了 ChannelHandler 链的容器，channel被创建时会被分配到ChannelPipeline中，ChannelHandler会被安装到其中</li>
<li>流程： ChannelInitializer的实现被注册进ServerBootstrapy中</li>
<li>调用initChannel()方法， ChannelInitializer会在ChannelPipeline中安装一组自定义的ChannelHandler</li>
<li>ChannelInitializer将自己从 ChannelPipeline中移除<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token punctuation">.</span><span class="token function">childHandler</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ChannelInitializer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">SocketChannel</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                       <span class="token comment">//添加一个EchoServerHandle到子Channel的ChannelPipeline</span>
                        <span class="token comment">//ChannelInitializer是一个特殊的处理程序，用于帮助用户配置新的Channel</span>
                        <span class="token annotation punctuation">@Override</span>
                        <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">initChannel</span><span class="token punctuation">(</span><span class="token class-name">SocketChannel</span> socketChannel<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
                            <span class="token comment">//EchoServerHandle被标注为@Shareable，所以我们可以总是使用同样的实例</span>
                            <span class="token comment">//@Shareable表示一个ChannelHandler可以被多个Channel安全地共享</span>
                            <span class="token comment">//在哪标注的呢？在EchoServerHandle类上</span>
                            socketChannel<span class="token punctuation">.</span><span class="token function">pipeline</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span>serverHandle<span class="token punctuation">)</span><span class="token punctuation">;</span>
                        <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
</li>
<li>ChannerlHandlerContext接口<ol>
<li>用于管理关联的ChannelHandler和同一个pipeline中其他的Handler</li>
<li></li>
</ol>
</li>
<li>二者的联系和区别：<img src="/2024/03/30/44/PipeLine%E5%92%8CHandler%E7%9A%84%E5%8C%BA%E5%88%AB.png"><br>  通过使用作为参数传递到每个方法的 ChannelHandlerContext，事件可以被传递给当前ChannelHandler 链中的下一个 ChannelHandler。<ul>
<li>ChannelInboundHandler </li>
<li>SimpleChannelInboundHandler&lt; T &gt; T是要处理消息的Java类型，适用于只需要解码消息并处理逻辑<ul>
<li>channelRead0(ChannelHandlerContext,T)</li>
</ul>
</li>
</ul>
</li>
<li>BootStrap 引导类，用于为应用程序的网络层配置提供了容器<ol>
<li>Bootstrap 用于客户端 ，可以直接.connect来连接服务器，</li>
<li>ServerBootstrap 用于客户端，需要.connect(new  InetSocketAddress) 才能等待客户端的连接</li>
</ol>
</li>
<li>Channel接口：<ul>
<li>方法：</li>
<li><img src="/2024/03/30/44/Channel%E6%96%B9%E6%B3%95.png"></li>
<li>Channel的生命周期：ChannelUnregistered已创建但是没有注册到EventLoop中；已注册ChannelRegistered；ChannelActive处于活跃状态，已经连接到远程节点， ChannelInactive 没有连接到远程给节点。</li>
</ul>
</li>
<li>内置的传输<ol>
<li>NIO 非阻塞-&gt;基于选择器 <img src="/2024/03/30/44/Selector.png"><ul>
<li><img src="/2024/03/30/44/Selector%E6%B5%81%E7%A8%8B.png"></li>
</ul>
</li>
<li>Epoll -&gt; 基于JNI驱动的，速度更快，完全非阻塞的<ul>
<li>使用：EpollEventLoopGroup 和EpollServerSocketChannel.class</li>
</ul>
</li>
<li>OIO -&gt;阻塞流</li>
<li>Local-&gt;在VM内部通过管道进行本地传输</li>
<li>Embedded 测试ChannelHandler使用</li>
</ol>
</li>
<li>ByteBuf<ol>
<li>使用两个索引：readIndex和writerIndex，开始时，两个都位于开头。也就是队列</li>
<li>ByteBufHolder接口用来存储各种属性值。</li>
<li>Netty提供了两种ByteBufAllocator的实现：PooledByteBufAllocator和UnpooledByteBufAllocator。前者池化了ByteBuf的实例以提高性能并最大限度地减少内存碎片。后者不池化。</li>
<li>Unpooled缓冲区：静态工具类来创建未池化的ByteBuf实例<img src="/2024/03/30/44/Unpooled.png"></li>
<li></li>
</ol>
</li>
<li>RPC框架的调用流程<br><img src="/2024/03/30/44/RPC%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B.png"></li>
<li>解码器：ByteToMessageDecoder 编码器：MessageToByteEncoder实际上这两个实现了Handler</li>
<li>协议的支持，自己去看数，Netty实战</li>
</ul>
<h3 id="EventLoopGroup-事件调度层"><a href="#EventLoopGroup-事件调度层" class="headerlink" title="EventLoopGroup 事件调度层"></a>EventLoopGroup 事件调度层</h3><ul>
<li><input disabled type="checkbox"> 如何使用自定义线程池，如何确定线程池的参数<br>EventLoopGroup是一个线程池，负责接受I/O请求并分配线程执行处理请求。<br><img src="/2024/03/30/44/EventLoop%E5%92%8CChannel.png"></li>
</ul>
<ol>
<li>EventLoopGroup包含多个EventLoop</li>
<li>EventLoop用于处理Channel生命周期内的所有I/O事件</li>
<li>EventLoop同一时间只会与一个线程绑定，每个EventLoop处理多个Channel</li>
<li>Channel在生命周期内可以对EventLoop进行多次绑定和解绑</li>
</ol>
<h3 id="服务编排层"><a href="#服务编排层" class="headerlink" title="服务编排层"></a>服务编排层</h3><ul>
<li>ChannelPipeline<br>负责组装各种ChannelHandler，内部通过双向链表将不同的ChannelHandler链接起来，依次调用，对Channel中的数据进行拦截和处理。<br>ChannelPipeline是线程安全的，因为一个新的Channel都会绑定一个新的ChannelPipeline，一个ChannelPipeline关联一个EventLoop，然后一个EventLoop绑定一个线程<img src="/2024/03/30/44/%E8%BF%9B%E5%87%BA%E7%AB%99.png"></li>
<li>ChannelHandler &amp; ChannelHandlerContext<br><img src="/2024/03/30/44/ChannelHandler.png"><br>ChannelHandlerContext用于保存ChannelHanler的上下文，可以实现ChannelHandler之间的交互。<br>同时包含了ChannelHandler生命周期的所有事件。<br>使用方式：</li>
</ul>
<p>#todo </p>
<ul>
<li><input disabled type="checkbox"> 如何做，搜搜<br>如果ChannelHandler有一些通用的逻辑需要实现，那么就可以放在这里。</li>
</ul>
<h3 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h3><h2 id="Netty实现的一些有特色"><a href="#Netty实现的一些有特色" class="headerlink" title="Netty实现的一些有特色"></a>Netty实现的一些有特色</h2><h3 id="FastThreadLocal"><a href="#FastThreadLocal" class="headerlink" title="FastThreadLocal"></a>FastThreadLocal</h3><p>使用Object数组替代Entry数据，<code>Object[0]</code>存储的是一个<code>Set&lt;FastThreadLocal&lt;?&gt;&gt;</code>集合，1以后都是存value的数据，而不是使用键值对的方式实现。<br>set方法：</p>
<ol>
<li>找到index位置，设置新的value</li>
<li>将<strong>FastThreadLocal对象保存到待清理的Set中</strong><br>优点：</li>
<li>高效查找：可以直接通过数组下标获取，而且扩容不需要进行rehash</li>
<li>安全性更高：ThreadLocal有可能会造成内存泄漏，只能等待线程销毁，但是的线程池下只能主动检测，而FastThreadLocal则封装了FastThreadLocalRunnable，任务执行完成之后一定会执行<code>FastThreadLocal.removeAll()</code>，从而将Set中所有的对象都销毁。</li>
</ol>
<p>#todo </p>
<ul>
<li><input disabled type="checkbox"> 以下内容是新开的文章《深入浅出Netty：原理与源码解读》记得新开一篇文章</li>
<li><input disabled type="checkbox"> 看看能不能写个爬虫把这个文章爬下来，或者自己复制下来<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/grey-wolf/p/12017818.html">曹工杂谈：Spring boot应用，自己动手用Netty替换底层Tomcat容器 - 三国梦回 - 博客园 (cnblogs.com)</a><br><a target="_blank" rel="noopener" href="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Netty%20%e6%a0%b8%e5%bf%83%e5%8e%9f%e7%90%86%e5%89%96%e6%9e%90%e4%b8%8e%20RPC%20%e5%ae%9e%e8%b7%b5-%e5%ae%8c/00%20%e5%ad%a6%e5%a5%bd%20Netty%ef%bc%8c%e6%98%af%e4%bd%a0%e4%bf%ae%e7%82%bc%20Java%20%e5%86%85%e5%8a%9f%e7%9a%84%e5%bf%85%e7%bb%8f%e4%b9%8b%e8%b7%af.md">00 学好 Netty，是你修炼 Java 内功的必经之路 (lianglianglee.com)</a></li>
</ul>
<h1 id="深入和源码解读"><a href="#深入和源码解读" class="headerlink" title="深入和源码解读"></a>深入和源码解读</h1><h2 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h2><h3 id="单线程模型"><a href="#单线程模型" class="headerlink" title="单线程模型"></a>单线程模型</h3><p>所有的I/O操作都由一个线程完成，会造成积压</p>
<h3 id="多线程模型"><a href="#多线程模型" class="headerlink" title="多线程模型"></a>多线程模型</h3><p>业务逻辑交给多个线程进行处理</p>
<h3 id="主从多线程模型"><a href="#主从多线程模型" class="headerlink" title="主从多线程模型"></a>主从多线程模型</h3><p>MainReactor负责处理客户端的连接，SubReactor分配线程池中的线程处理连接生命周期内的所有的I/O模型</p>
<h2 id="Netty内部的逻辑流程"><a href="#Netty内部的逻辑流程" class="headerlink" title="Netty内部的逻辑流程"></a>Netty内部的逻辑流程</h2><p><img src="/2024/03/30/44/%E9%80%BB%E8%BE%91%E6%B5%81%E7%A8%8B.png"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">QingQiu</p>
  <div class="site-description" itemprop="description">个人网站，学习记录，面试记录和经验总结、互联网中一块属于自己的小窝</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">52</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">26</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Zuofw/zuofw-rpc" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Zuofw&#x2F;zuofw-rpc" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2022 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">QingQiu</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="站点总字数">438k</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  















  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
