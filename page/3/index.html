<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"zuofw.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":true,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="个人网站，学习记录，面试记录和经验总结、互联网中一块属于自己的小窝">
<meta property="og:type" content="website">
<meta property="og:title" content="QingQiu&#39;Blog">
<meta property="og:url" content="https://zuofw.github.io/page/3/index.html">
<meta property="og:site_name" content="QingQiu&#39;Blog">
<meta property="og:description" content="个人网站，学习记录，面试记录和经验总结、互联网中一块属于自己的小窝">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="QingQiu">
<meta property="article:tag" content="博客，学习，成长">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://zuofw.github.io/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>QingQiu'Blog - 清秋的小窝</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>


<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">QingQiu'Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">清秋的小窝</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zuofw.github.io/2024/03/06/408/os/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="QingQiu">
      <meta itemprop="description" content="个人网站，学习记录，面试记录和经验总结、互联网中一块属于自己的小窝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="QingQiu'Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/03/06/408/os/" class="post-title-link" itemprop="url">os</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-03-06 14:14:38" itemprop="dateCreated datePublished" datetime="2024-03-06T14:14:38+08:00">2024-03-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-03-29 21:21:30" itemprop="dateModified" datetime="2024-03-29T21:21:30+08:00">2024-03-29</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><blockquote>
<p>&nbsp;<strong>OOM</strong> OOM Killer 机制会根据算法选择一个占用物理内存较高的进程，然后将其杀死，以便释放内存资源，如果物理内存依然不足，OOM Killer 会继续杀死占用物理内存较高的进程，直到释放足够的内存位置。<br>带宽：又叫频宽，是指在固定的的时间可传输的资料数量，亦即在传输管道中可以传递数据的能力。<br>内存管理单元（MMU）<br>位宽 ：位宽就是内存或显存一次能传输的数据量。简单地讲就是一次能传递的数据宽度，就像公路的车道宽度，双向四车道、双向六车道，当然车道越多一次能通过的汽车就越大，所以位宽越大，一次性能舆的数据就越多,对显卡来说对性能的提高很明显。<br>PSW：**<em>包含中断是否开放，处理机执行态等状态的寄存器，叫做处理机状态字 PSW</em>**<br>PCB: 进程控制块<br>TCB: 线程控制模块<br>寄存器分类：CS 代码段寄存器， IP 指令指针寄存器,<br>PC 程序计数器寄存器， PS描述CPU执行状态，主要包含理机当前运行态，处理及优先级，屏蔽外中断等状态<br>shell不是操作系统的一部分，而是终端与操作系统的接口<br>硬件驱动：是一个软件，用于驱动硬件<br>磁道:每个磁头可以读取一段唤醒区域，就是磁道<br>柱面： 所有的磁道合并就是一个柱面<br>上下文切换：由一个程序切换到另一个程序<br>I/O设备：包括设备控制器和设备本身，<br>文件：抽象磁盘空间<br>文件描述符：如果访问文件权限许可，则返回一个小整数，若禁止访问，系统将返回一个错误码<br>管道：一种需文件，可以链接两个进程，进程A要给进程B 发送数据时，要先把它写在管道上，相当于一个输出文件，之后进程B从上面读入并处理<br>PID 进程识别符<br>线程切换要切换栈，否则会弹栈错误<br><strong>切换栈实质就是切换寄存器</strong><br>基本输入输出系统 <strong>BIOS</strong>(Basic Input Output System)</p>
<ol>
<li><p>每台计算机上有一块双亲板，上面有一个叫做 基本输入输出系统 <strong>BIOS</strong>(Basic Input Output System),在BIOS里面有底层I/O软件</p>
</li>
<li><p>设备启动，BIOS启动，检测RAM 的数量和基本硬件的是否已经安装并且响应，</p>
</li>
<li><p>之后通过储存在CMOS存储器中的设备清单决定启动设备</p>
</li>
<li><p>之后操作系统来询问BIOS ，以获得配置信息<br><strong>多路复用：实现时间和空间的复用</strong></p>
</li>
</ol>
</blockquote>
<h1 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h1><h2 id="什么是操作系统"><a href="#什么是操作系统" class="headerlink" title="什么是操作系统"></a>什么是操作系统</h2><ul>
<li><p>操作系统是一种系统软件，是软、硬件资源的控制中心，</p>
</li>
<li><p>操作系统提供一个资源集的抽象，并管理这些硬件资源</p>
</li>
<li><p><strong>主要任务是隐藏硬件，呈现给程序的抽象</strong></p>
</li>
<li><p>记录哪个程序在使用什么资源，对资源请求进行评估代价，并且为不同的程序和用户调解互相冲突的资源冲突</p>
</li>
</ul>
<h4 id="功能-："><a href="#功能-：" class="headerlink" title="功能 ："></a>功能 ：</h4><ol>
<li>进程和线程的创建以及管理:创建，撤销，阻塞，唤醒，通信</li>
<li>存储管理：内存和外存的分配管理</li>
<li>文件管理：读写，创建删除</li>
<li>设备管理：完成设备请求和释放，还有启动</li>
<li>网络管理：</li>
<li>安全管理：用户认证，控制访问，文件加密等</li>
</ol>
<h3 id="。。"><a href="#。。" class="headerlink" title="。。"></a>。。</h3><p>线程：<br>jvm中线程崩溃不会导致进程崩溃，原因是什么<br><em><strong>因为JVM自定义了自己的信号处理函数，拦截了SIGSEGV信号</strong></em></p>
<ul>
<li>用户态和内核态的转换：<ol>
<li>系统调用</li>
<li>中断</li>
<li>异常</li>
</ol>
</li>
<li>死锁的解除：<ol>
<li>立刻结束所有进程</li>
<li>结束涉及死锁的所有进程</li>
<li>逐个撤销涉及死锁的进程</li>
<li>抢占资源</li>
</ol>
</li>
<li>内存管理：<ol>
<li>分配回收</li>
<li>地址转换</li>
<li>扩充</li>
<li>映射</li>
<li>优化</li>
<li>安全</li>
</ol>
</li>
<li>inode：索引节点，用于存储文件的元信息，包括文件被分为几块，权限，所有者等，每个文件拥有唯一的inode。inode的数量是固定的</li>
<li>PCB通过列表的方式组织，相同状态的进程链接在一起</li>
<li>进程和线程的对比：<ol>
<li>进程时资源分配的单位和CPU调度的单位</li>
<li>线程只享有部分资源，如寄存器和栈</li>
<li>线程可以享受进程的公共资源</li>
<li>线程切换开销少：<ul>
<li>线程不涉及资源管理信息</li>
<li>线程释放的资源比进程少</li>
<li>同一个进程中的线程切换比进程快，因为线程共享想用的地址空间，在一个进程中的所以后线程都构想一个页表。切换时不需要切换表。</li>
</ul>
</li>
</ol>
</li>
<li>TCP线程控制块</li>
<li>线程分类： <ol>
<li>用户线程：在用户空间实现的线程,由用户态的线程库来管理</li>
<li>内核线程：在内核中实现的线程，由内核管理</li>
<li>轻量级线程：在内核中来支持用户线程</li>
</ol>
</li>
<li>进程调度：<ul>
<li>调度时机: 就绪态-&gt;运行态，运行态-&gt;阻塞态,运行态-&gt;结束态</li>
<li>调度算法：<ul>
<li>非抢占式调度算法 : 进程阻塞或者结束时才会调用另一个进程</li>
<li>抢占式调度算法：对于一个进程，给予一段时间去运行，时间结束后仍然在运行时，将其挂起，会发生时钟中断</li>
</ul>
<ol>
<li>FCFS 先来先服务</li>
<li>SJF 最短作业优先</li>
<li>高响应比优先调度算法</li>
<li>时间片轮转</li>
</ol>
</li>
</ul>
</li>
<li>进程之间的通信方式：<ol>
<li>pipe    linux中 | 会创建两个子进程共同使用一个pipe</li>
<li>消息队列：进程发送消息后就可以继续做工作，另一个进程读取到消息进行处理，消息队列是保存在内核中的消息链表，缺点是：通信不及时，附件大小有限制</li>
<li>共享内存:拿出一块虚拟地址空间，将其映射到相同的物理内存中，即可做到消除拷贝过程、<ul>
<li>缺点：多个进程共同修改共享地址会出现冲突</li>
<li><img src="/2024/03/06/408/os/%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98.png"></li>
</ul>
</li>
<li>信号量：P V 操作 初始量为1时，是互斥操作， 为0时是同步操作</li>
<li>信号： 信号 ≠ 信号量，用于处理异常状态下的工作状态</li>
<li>锁：<ul>
<li>忙等待锁(自旋锁)：当获取不到锁时，线程会一直等待，不做别的事情，直至得到锁。</li>
<li>互斥锁：加锁失败后会释放cpud</li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="DMA"><a href="#DMA" class="headerlink" title="DMA"></a>DMA</h3><ul>
<li>用户进程调用 read 方法，向操作系统发出 I/O 请求，请求读取数据到自己的内存缓冲区中，进程进入阻塞状态；</li>
<li>操作系统收到请求后，进一步将 I/O 请求发送 DMA，然后让 CPU 执行其他任务；</li>
<li>DMA 进一步将 I/O 请求发送给磁盘；</li>
<li>磁盘收到 DMA 的 I/O 请求，把数据从磁盘读取到磁盘控制器的缓冲区中，当磁盘控制器的缓冲区被读满后，向 DMA 发起中断信号，告知自己缓冲区已满；</li>
<li><strong>DMA 收到磁盘的信号，将磁盘控制器缓冲区中的数据拷贝到内核缓冲区中，此时不占用 CPU，CPU 可以执行其他任务</strong>；</li>
<li>当 DMA 读取了足够多的数据，就会发送中断信号给 CPU；</li>
<li>CPU 收到 DMA 的信号，知道数据已经准备好，于是将数据从内核拷贝到用户空间，系统调用返回；</li>
<li>一致哈希算法也用了取模运算，但与哈希算法不同的是，哈希算法是对节点的数量进行取模运算，而<strong>一致哈希算法是对 2^32 进行取模运算，是一个固定的值</strong>。</li>
</ul>
<p>我们可以把一致哈希算法是对 2^32 进行取模运算的结果值组织成一个圆环，就像钟表一样，钟表的圆可以理解成由 60 个点组成的圆，而此处我们把这个圆想象成由 2^32 个点组成的圆，这个圆环被称为<strong>哈希环</strong>，如下图：</p>
<p><img src="https://cdn.xiaolincoding.com//mysql/other/0ea3960fef48d4cbaeb4bec4345301e7.png"></p>
<h3 id="内核"><a href="#内核" class="headerlink" title="内核"></a>内核</h3><p>现代操作系统，内核一般会提供 4 个基本能力：</p>
<ul>
<li>管理进程、线程，决定哪个进程、线程使用 CPU，也就是进程调度的能力；</li>
<li>管理内存，决定内存的分配和回收，也就是内存管理的能力；</li>
<li>管理硬件设备，为进程与硬件设备之间提供通信能力，也就是硬件通信能力；</li>
<li>提供系统调用，如果应用程序要运行更高权限运行的服务，那么就需要有系统调用，它是用户程序与操作系统之间的接口。<br><em>宏内核</em> ： 内核的所有模块都在内核态<br>微内核：内核只保留基本能力，进程调度，中断等，剩下的放在用户空间<br>混合内核，是宏内核和微内核的结合体，内核中抽象出了微内核的概念，也就是内核中会有一个小型的内核，其他模块就在这个基础上搭建，整个内核是个完整的程序；</li>
</ul>
<h2 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h2><h3 id="寄存器："><a href="#寄存器：" class="headerlink" title="寄存器："></a>寄存器：</h3><ul>
<li>通用寄存器：存放要运算的数据</li>
<li>程序寄存器： 来存储下一条要执行的指令所在的内存第</li>
<li>指令寄存器：存放指令本身</li>
</ul>
<h3 id="总线："><a href="#总线：" class="headerlink" title="总线："></a>总线：</h3><ul>
<li>地址总线： 指定CPU要操作的内存地址</li>
<li>数据总线：读写内存的数据</li>
<li>控制总线 ： 发送和接受信号，中断，设备复位等，CPU响应也需要控制总线</li>
</ul>
<h3 id="调度"><a href="#调度" class="headerlink" title="调度"></a><a target="_blank" rel="noopener" href="https://xiaolincoding.com/os/1_hardware/how_cpu_deal_task.html#%E5%AE%8C%E5%85%A8%E5%85%AC%E5%B9%B3%E8%B0%83%E5%BA%A6">调度</a></h3><h2 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h2><ul>
<li>寄存器；</li>
<li>CPU Cache：使用SRAM 静态存储器，断电丢失数据</li>
<li><img src="/2024/03/06/408/os/Cache%E5%88%86%E7%B1%BB.png"><ol>
<li>L1-Cache；&nbsp;L1 高速缓存通常分成<strong>指令缓存</strong>和<strong>数据缓存</strong>。速度几乎和寄存器一样快。每个核心都拥有一个</li>
<li>L2-Cache；比L2离CPU远，大小更大，每一个核心都有</li>
<li>L3-Cahce；多核心公用</li>
<li>写入策略：<ul>
<li>写直达（_Write Through_）</li>
<li>写回（_Write Back_）只有当Cache 中的数据被替换时，写入内存</li>
</ul>
</li>
<li><h2 id="Cache一致性-第一点，某个-CPU-核心里的-Cache-数据更新时，必须要传播到其他核心的-Cache，这个称为写传播（-Write-Propagation-）；使用锁-第二点，某个-CPU-核心里对数据的操作顺序，必须在其他核心看起来顺序是一样的，这个称为事务的串行化（-Transaction-Serialization-）。-使用基于总线嗅探的MESI模型-伪共享：-多个线程同时读写同一个-Cache-Line-的不同变量时，而导致-CPU-Cache-失效的现象称为伪共享（-False-Sharing-）-解决：尽量避免这些数据刚好在同一个Cache-Line-将他们变成对齐的情况。-应用层面解决："><a href="#Cache一致性-第一点，某个-CPU-核心里的-Cache-数据更新时，必须要传播到其他核心的-Cache，这个称为写传播（-Write-Propagation-）；使用锁-第二点，某个-CPU-核心里对数据的操作顺序，必须在其他核心看起来顺序是一样的，这个称为事务的串行化（-Transaction-Serialization-）。-使用基于总线嗅探的MESI模型-伪共享：-多个线程同时读写同一个-Cache-Line-的不同变量时，而导致-CPU-Cache-失效的现象称为伪共享（-False-Sharing-）-解决：尽量避免这些数据刚好在同一个Cache-Line-将他们变成对齐的情况。-应用层面解决：" class="headerlink" title="Cache一致性- - 第一点，某个 CPU 核心里的 Cache 数据更新时，必须要传播到其他核心的 Cache，这个称为写传播（_Write Propagation_）；使用锁 - 第二点，某个 CPU 核心里对数据的操作顺序，必须在其他核心看起来顺序是一样的，这个称为事务的串行化（_Transaction Serialization_）。 - 使用基于总线嗅探的MESI模型 -  -  - 伪共享： 多个线程同时读写同一个 Cache Line 的不同变量时，而导致 CPU Cache 失效的现象称为伪共享（_False Sharing_） - 解决：尽量避免这些数据刚好在同一个Cache Line,将他们变成对齐的情况。 - 应用层面解决："></a>Cache一致性-<br> - 第一点，某个 CPU 核心里的 Cache 数据更新时，必须要传播到其他核心的 Cache，这个称为<strong>写传播（_Write Propagation_）</strong>；使用锁<br> - 第二点，某个 CPU 核心里对数据的操作顺序，必须在其他核心看起来顺序是一样的，这个称为<strong>事务的串行化（_Transaction Serialization_）</strong>。<br> - 使用基于总线嗅探的MESI模型<br> - <img src="/2024/03/06/408/os/%E7%8A%B6%E6%80%81%E5%9B%BE.png"><br> - <img src="/2024/03/06/408/os/MESI.png"><br> - 伪共享： 多个线程同时读写同一个 Cache Line 的不同变量时，而导致 CPU Cache 失效的现象称为<strong>伪共享（_False Sharing_）</strong><br> - 解决：尽量避免这些数据刚好在同一个Cache Line,将他们变成对齐的情况。<br> - 应用层面解决：<img src="/2024/03/06/408/os/%E5%BA%94%E7%94%A8%E5%B1%82%E9%9D%A2%E8%A7%A3%E5%86%B3.png"></h2></li>
</ol>
</li>
<li>内存；DRAM 不断刷新，数据才能被存储起来。</li>
<li>SSD/HDD 硬盘： SSD:固态硬盘，HDD机械硬盘</li>
</ul>
<h3 id="伙伴系统："><a href="#伙伴系统：" class="headerlink" title="伙伴系统："></a>伙伴系统：</h3><p>当可分配内存比所需要内存的二倍还大，那么就将其划分为两个大小为一半一半的空闲分区，重复划分，<strong>直到比二倍小就分配给他</strong></p>
<h3 id="分页，分段"><a href="#分页，分段" class="headerlink" title="分页，分段"></a>分页，分段</h3><ol>
<li><p><strong>分段（Segmentation）</strong>： 不连续，不等长，相当于是一小段逻辑的程序</p>
<ul>
<li>分段将内存划分为若干段（segments），每个段具有不同的大小和含义。</li>
<li>每个段都有自己的基地址和长度。段可以包含代码、数据、堆栈等不同类型的信息。</li>
<li>分段允许程序员以逻辑上独立的方式编写程序，并且使得程序的结构更清晰。</li>
<li>分段的缺点是会导致内存碎片化，难以管理。</li>
</ul>
</li>
<li><p><strong>分页（Paging）</strong>： 连续等长</p>
<ul>
<li>分页将内存划分为固定大小的页面（pages），通常为4KB或者更大。</li>
<li>操作系统将进程的虚拟地址空间划分为与页面大小相同的块，称为虚拟页面（virtual pages）。</li>
<li>虚拟页面和物理页面（physical pages）之间建立映射关系，操作系统负责管理这些映射。</li>
<li>分页的优点是可以更有效地利用内存空间，减少内存碎片化，并且实现了更好的内存保护和共享。</li>
<li>解决了外部碎片，但是仍然存在内部碎片</li>
</ul>
</li>
</ol>
<ul>
<li>页帧：把**物理地址间_**划分为大小相同的基本分配单元</li>
<li>页面：把<strong>逻辑地址空间</strong>也划分为相同大小，基本分配单元</li>
<li>页面置换算法：</li>
<li><strong>最佳页面置换算法（OPT，Optimal）</strong>：优先选择淘汰的页面是以后永不使用的，或者是在最长时间内不再被访问的页面，这样可以保证获得最低的缺页率。但由于人们目前无法预知进程在内存下的若干页面中哪个是未来最长时间内不再被访问的，因而该算法无法实现，只是理论最优的页面置换算法，可以作为衡量其他置换算法优劣的标准。</li>
<li><strong>先进先出页面置换算法（FIFO，First In First Out）</strong> : 最简单的一种页面置换算法，总是淘汰最先进入内存的页面，即选择在内存中驻留时间最久的页面进行淘汰。该算法易于实现和理解，一般只需要通过一个 FIFO 队列即可需求。不过，它的性能并不是很好。</li>
<li><strong>最近最久未使用页面置换算法（LRU ，Least Recently Used）</strong>：LRU 算法赋予每个页面一个访问字段，用来记录一个页面自上次被访问以来所经历的时间 T，当须淘汰一个页面时，选择现有页面中其 T 值最大的，即最近最久未使用的页面予以淘汰。LRU 算法是根据各页之前的访问情况来实现，因此是易于实现的。OPT 算法是根据各页未来的访问情况来实现，因此是不可实现的。</li>
</ul>
<h5 id="LRU算法的弊端："><a href="#LRU算法的弊端：" class="headerlink" title="LRU算法的弊端："></a><em>LRU算法的弊端：</em></h5><p>使用链表：最近使用的数据如果存在，就将其放在头部，如果不存在，就读取数据并放入头部，并删除尾部数据。<br>预读机制：读入数据时，会把相邻的数据一起读入(空间局限性)</p>
<ol>
<li>缓存失效：被预读的数据没有访问，而且把尾部的数据删除，降低了命中率。 解决：实现两个链表，分别存储热数据和冷数据，分别进行LRU算法。预读部分放入冷数据链表，当真正访问时，放入热数据链表</li>
<li>缓存污染：当批量读取数据时，大量数据被放入热数据LRU链表，会导致之前的热点数据失效。解决：提高进入活跃LRU链表的门槛</li>
</ol>
<ul>
<li><p><strong>最少使用页面置换算法（LFU，Least Frequently Used）</strong> : 和 LRU 算法比较像，不过该置换算法选择的是之前一段时间内使用最少的页面作为淘汰页。</p>
</li>
<li><p><strong>时钟页面置换算法（Clock）</strong>：可以认为是一种最近未使用算法，即逐出的页面都是最近没有使用的那个。</p>
<p><strong>局部性原理</strong>是指在程序执行过程中，数据和指令的访问存在一定的空间和时间上的局部性特点。其中，时间局部性是指一个数据项或指令在一段时间内被反复使用的特点，空间局部性是指一个数据项或指令在一段时间内与其相邻的数据项或指令被反复使用的特点。</p>
</li>
</ul>
<h3 id="虚拟内存的作用"><a href="#虚拟内存的作用" class="headerlink" title="虚拟内存的作用"></a>虚拟内存的作用</h3><ol>
<li>使得进程对云翔内存超过物理内存大小，可以把不经常使用的内存换到物理内存之外</li>
<li>每一个进程有自己的页表，所以每个进程的虚拟内存空间时相互独立 的，解决了多进程之间的地址冲突</li>
<li>页表中还存在着一些标记属性的bit，如控制一个页的读写权限，为操作系统提供更好的安全性<br><em>如果没有空闲的物理内存，那么内核就会开始进行<strong>回收内存</strong>的工作，回收的方式主要是两种：直接内存回收和后台内存回收。</em></li>
</ol>
<ul>
<li><strong>后台内存回收</strong>（kswapd）：在物理内存紧张的时候，会唤醒 kswapd 内核线程来回收内存，这个回收内存的过程<strong>异步</strong>的，不会阻塞进程的执行。</li>
<li><strong>直接内存回收</strong>（direct reclaim）：如果后台异步回收跟不上进程内存申请的速度，就会开始直接回收，这个回收内存的过程是<strong>同步</strong>的，会阻塞进程的执行。</li>
<li>OOM 选择一个占用物理内存高的进程，将其杀死，如果不够，重复杀死<ol>
<li>文件页：脏页将其写回磁盘中，再释放， 干净页直接回收内存</li>
<li>匿名页：没有实际载体的文件，将其不常访问写回磁盘</li>
</ol>
</li>
</ul>
<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>进程控制块 PCB Process Control Block</p>
<p>描述了进程的标识，空间运行状态，资源使用等信息</p>
<p>PCB是进程存在的唯一标志</p>
<p>每个进程都在操作系统中有一个对应的PCB</p>
<p>操作系统建立一个表格用于描述该进程的存在和状态，这个表格就叫做进程控制块</p>
<ul>
<li>PCB 使用链表和索引表</li>
<li>同一个状态的进程进入一个链表</li>
<li>索引表指向PCB</li>
</ul>
<h4 id="PCB的使用"><a href="#PCB的使用" class="headerlink" title="PCB的使用"></a>PCB的使用</h4><p>进程创建：生成该进程的PCB<br>进程终止：回收它的PCB</p>
<h3 id="进程的状态："><a href="#进程的状态：" class="headerlink" title="进程的状态："></a>进程的状态：</h3><p>创建状态、运行态、就绪态、阻塞态、结束状态<br><img src="/2024/03/06/408/os/%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2.png" alt="进程状态转换"><br>需要一个新的状态，来<strong>描述进程没有占用实际的物理内存空间的情况，这个状态就是挂起状态</strong>。</p>
<ul>
<li>阻塞挂起状态：进程在外存（硬盘）并等待某个事件的出现；</li>
<li>就绪挂起状态：进程在外存（硬盘），但只要进入内存，即刻立刻运行；<br><img src="/2024/03/06/408/os/%E6%8C%82%E8%B5%B7.png"></li>
</ul>
<h4 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a>进程创建</h4><h3 id="主要的事件：系统初始化，正在运行的程序执行了创建进程的系统调用，用户请求创建一个进程，一个批处理作业的初始化"><a href="#主要的事件：系统初始化，正在运行的程序执行了创建进程的系统调用，用户请求创建一个进程，一个批处理作业的初始化" class="headerlink" title="主要的事件：系统初始化，正在运行的程序执行了创建进程的系统调用，用户请求创建一个进程，一个批处理作业的初始化"></a>主要的事件：系统初始化，正在运行的程序执行了创建进程的系统调用，用户请求创建一个进程，一个批处理作业的初始化</h3><p>进程执行</p>
<p>进程等待</p>
<p>进程抢占</p>
<p>进程唤醒</p>
<p>进程结束</p>
<p>核心状态：运行状态，就绪状态，等待状态，创建状态，结束状态<br>进程挂起：</p>
<ol>
<li><p>处于挂起状态的进程映射在磁盘上，目的是减少进程占用内存</p>
</li>
<li><p>等待挂起状态等待挂起状态</p>
</li>
<li><p>就绪挂起状态 进程在外存，但只要进入内存即可运行</p>
</li>
</ol>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>概念：线程是进程的一部分，描述指令流执行状态。是进程中指令执行流的最小单元，是CPU 调度的基本单位<br>线程 = 进程 - 共享资源<br>进程 = 资源+多组线程</p>
<ul>
<li>优点： 1. 一个进程可以有多个线程2.各个线程之间 2.线程之间可以并发。3. 线程之间可以共享地址和文件资源</li>
<li>缺点：一个线程崩溃 会导致所属的进程的所有线程崩溃</li>
</ul>
<h4 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h4><p>为了避免由于中断处理程序执行时间过长，而影响正常进程的调度，Linux 将中断处理程序分为上半部和下半部：</p>
<ul>
<li>上半部，对应硬中断，由硬件触发中断，用来快速处理中断；</li>
<li>下半部，对应软中断，由内核触发中断，用来异步处理上半部未完成的工作；<br>优点：</li>
</ul>
<ol>
<li>提高CPU效率</li>
<li>实时处理</li>
<li>故障处理</li>
<li>实现分时擦欧总<br>中断的来源是外设，异常是应用程序请求的，属于系统调用</li>
</ol>
<h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><p>每一个系统调用都需要切换堆栈，系统调用是操作系统提供给用户态程序的接口，用于调用内核。<br>自陷指令： 能够产生异常的指令</p>
<h4 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行:"></a>并发与并行:</h4><p>并行：两个进程一起进行，单核处理器中不能够并行，多核才可以</p>
<p>并发：单核处理器合理的处理任务的操作，也就是多线程，并不能同时进行多个任务</p>
<p>进程之间的关系：相互独立和相互制约<br>制约： 同步和互斥</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zuofw.github.io/2024/03/05/hou-duan/wei-fu-wu-he-fen-bu-shi/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="QingQiu">
      <meta itemprop="description" content="个人网站，学习记录，面试记录和经验总结、互联网中一块属于自己的小窝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="QingQiu'Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/03/05/hou-duan/wei-fu-wu-he-fen-bu-shi/" class="post-title-link" itemprop="url">微服务</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-03-05 17:45:33" itemprop="dateCreated datePublished" datetime="2024-03-05T17:45:33+08:00">2024-03-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-06-17 15:04:51" itemprop="dateModified" datetime="2024-06-17T15:04:51+08:00">2024-06-17</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Quarkus"><a href="#Quarkus" class="headerlink" title="Quarkus"></a>Quarkus</h2><ul>
<li>GreetingResourceTest是在jvm中测试</li>
</ul>
<h2 id="面试常问"><a href="#面试常问" class="headerlink" title="面试常问"></a>面试常问</h2><p><a target="_blank" rel="noopener" href="https://ticknet-studio.feishu.cn/docx/TNCGdBx2vodggwxqLcCcK3hTnpc">微服务面试</a></p>
<ul>
<li><p>CAP理论：任何一个分布式系统都无法做到一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance）全部满足。</p>
<ul>
<li>C数据一致</li>
<li>A读写操作必须都能成功</li>
<li>P分区容错，当分布式系统节点之间出现网络故障导致节点之间无法通信，导致出现了分区 必须要满足的</li>
</ul>
</li>
<li><p>BASE理论：<img src="/2024/03/05/hou-duan/wei-fu-wu-he-fen-bu-shi/BASE.png" class="lazyload" data-srcset="/2024/03/05/hou-duan/wei-fu-wu-he-fen-bu-shi/BASE.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p>
<ul>
<li>基于BASE理论的柔性事务，不同于ACID的刚性事务，通过一些新的方案，只要保证最终一致性即可</li>
</ul>
</li>
<li><p>AP：无需锁定数据，实现最终一致即可</p>
</li>
<li><p>CP：各个子事务执行后不要提交，锁定资源，不允许其他人访问。</p>
</li>
<li><p>SpringCloud </p>
</li>
<li><p>分布式事务：</p>
<ul>
<li>接口幂等性：接口的幂等性是指一次和多次请求某一个资源应该具有同样的副作用。</li>
<li>XA/两阶段提交：<ul>
<li>第一阶段：存在一个负责协调各个本地资源管理的事务管理器，事务管理器在第一阶段询问各个资源管理器是否就绪，如果收到的没辙资源的回复都是yes，在在第二阶段提交事务时，任意一个回复no就回滚事务</li>
<li>第二阶段：事务管理器根据所有本地资源管理器的返回，通知所有本地资源管理器，步调一致的在所有分支上提交或者回滚事务</li>
<li>缺点：<ul>
<li>同步阻塞：当参与事务者存在占用公共资源的情况，齐总一个占用了资源，其他参与者只能等待资源释放，处于阻塞装填。</li>
<li>单点故障：一旦事务管理器故障，整个系统都不可用了</li>
<li>数据不一致：在阶段二如果事务管理器只发送了部分commit消息，如果出现网络异常，那么只有部分参与者会提交事务</li>
<li>不确定性：当协事务管理器发送 commit 之后，并且此时只有一个参与者收到了 commit，那么当该参与者与事务管理器同时宕机之后，重新选举的事务管理器无法确定该条消息是否提交成功。</li>
</ul>
</li>
</ul>
</li>
<li>TCC Try-Confirm-Cancel <img src="/2024/03/05/hou-duan/wei-fu-wu-he-fen-bu-shi/TCC%E4%BC%98%E7%82%B9.png" class="lazyload" data-srcset="/2024/03/05/hou-duan/wei-fu-wu-he-fen-bu-shi/TCC%E4%BC%98%E7%82%B9.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="><ol>
<li>Try 阶段：尝试执行，完成所有业务检查（一致性）, 预留必须业务资源（准隔离性）  </li>
<li>Confirm 阶段：确认执行真正执行业务，不作任何业务检查，只使用 Try 阶段预留的业务资源，Confirm 操作满足幂等性。要求具备幂等设计，Confirm 失败后需要进行重试。  </li>
<li>Cancel 阶段：取消执行，释放 Try 阶段预留的业务资源 Cancel 操作满足幂等性 Cancel 阶段的异常和 Confirm 阶段异常处理方案基本上一致。</li>
</ol>
</li>
<li>本地消息表：依靠MQ实现<img src="/2024/03/05/hou-duan/wei-fu-wu-he-fen-bu-shi/%E6%9C%AC%E5%9C%B0%E6%B6%88%E6%81%AF%E8%A1%A8.png" class="lazyload" data-srcset="/2024/03/05/hou-duan/wei-fu-wu-he-fen-bu-shi/%E6%9C%AC%E5%9C%B0%E6%B6%88%E6%81%AF%E8%A1%A8.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="> <img src="/2024/03/05/hou-duan/wei-fu-wu-he-fen-bu-shi/%E6%B6%88%E6%81%AF%E7%9A%84%E6%9C%80%E7%BB%88%E4%B8%80%E8%87%B4%E6%80%A7.png" class="lazyload" data-srcset="/2024/03/05/hou-duan/wei-fu-wu-he-fen-bu-shi/%E6%B6%88%E6%81%AF%E7%9A%84%E6%9C%80%E7%BB%88%E4%B8%80%E8%87%B4%E6%80%A7.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="|500"></li>
</ul>
</li>
<li><p>路由：</p>
<ul>
<li>gateway<ul>
<li>配置<ul>
<li><code>id</code>：路由的唯一标示</li>
<li><code>predicates</code>：路由断言，其实就是匹配条件</li>
<li><code>filters</code>：路由过滤条件，后面讲</li>
<li><code>uri</code>：路由目标地址，<code>lb://</code>代表负载均衡，从注册中心获取目标微服务的实例列表，并且负载均衡选择一个访问。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Nacos:</p>
<ul>
<li>namespace：用于环境隔离 <img src="/2024/03/05/hou-duan/wei-fu-wu-he-fen-bu-shi/namespace.png" class="lazyload" data-srcset="/2024/03/05/hou-duan/wei-fu-wu-he-fen-bu-shi/namespace.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="|500"></li>
<li>分级模型：<img src="/2024/03/05/hou-duan/wei-fu-wu-he-fen-bu-shi/Nacos%E5%88%86%E7%BA%A7%E6%A8%A1%E5%9E%8B.png" class="lazyload" data-srcset="/2024/03/05/hou-duan/wei-fu-wu-he-fen-bu-shi/Nacos%E5%88%86%E7%BA%A7%E6%A8%A1%E5%9E%8B.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="><img src="/2024/03/05/hou-duan/wei-fu-wu-he-fen-bu-shi/Nacos%E5%88%86%E7%BA%A7%E6%A8%A1%E5%9E%8B%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86.png" class="lazyload" data-srcset="/2024/03/05/hou-duan/wei-fu-wu-he-fen-bu-shi/Nacos%E5%88%86%E7%BA%A7%E6%A8%A1%E5%9E%8B%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="><ul>
<li>namespace 命名空间<ul>
<li>group分组<ul>
<li>服务service<ul>
<li>集群cluster 对应不同的机房/ip<ul>
<li>实例instance：</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Nacos挂了能不能正常访问：答案是能，Nacos会把注册的服务的地址推送给他们，他们各自维护一个列表，所以Nacos挂了也不影响调用</li>
<li>nacos和eureka的区别：<ul>
<li>Nacos支持服务端主动检测提供者状态：临时实例采用心跳模式，非临时实例采用主动检测模式</li>
<li>临时实例心跳不正常会被删除，非临时实例不会呗删除</li>
<li>Nacos支持服务列表变更的消息推送模式，服务列表更新更及时</li>
<li>Nacos默认使用AP方式，</li>
</ul>
</li>
<li>nacos读取配置的流程<img src="/2024/03/05/hou-duan/wei-fu-wu-he-fen-bu-shi/nacos%E8%AF%BB%E5%85%A5%E9%85%8D%E7%BD%AE%E7%9A%84%E6%B5%81%E7%A8%8B.png" class="lazyload" data-srcset="/2024/03/05/hou-duan/wei-fu-wu-he-fen-bu-shi/nacos%E8%AF%BB%E5%85%A5%E9%85%8D%E7%BD%AE%E7%9A%84%E6%B5%81%E7%A8%8B.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></li>
<li>配置热更新：<ul>
<li><h2 id="动态路由：-需要实现Nacos动态监听配置接口-引入配置"><a href="#动态路由：-需要实现Nacos动态监听配置接口-引入配置" class="headerlink" title="动态路由：  - 需要实现Nacos动态监听配置接口  - 引入配置"></a>动态路由：<br>  - 需要实现Nacos动态监听配置接口<br>  - 引入配置</h2></li>
</ul>
</li>
</ul>
</li>
<li><p>OpenFeign：</p>
<ul>
<li>执行过程：<img src="/2024/03/05/hou-duan/wei-fu-wu-he-fen-bu-shi/OpenFeign%E6%89%A7%E8%A1%8C%E9%80%BB%E8%BE%91.png" class="lazyload" data-srcset="/2024/03/05/hou-duan/wei-fu-wu-he-fen-bu-shi/OpenFeign%E6%89%A7%E8%A1%8C%E9%80%BB%E8%BE%91.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="><ol>
<li>获取请求中的serviceId</li>
<li>根据serviceId负载均衡，找到一个可用的服务实例</li>
<li>利用服务实例ip和port信息重构url</li>
<li>向真正的url发起请求</li>
</ol>
</li>
</ul>
</li>
<li><p>负载均衡：</p>
<ul>
<li>使用LoadBalancer实现负载均衡</li>
<li>使用Ribbon组件实现：发起远程调用时，ribbon先从注册中心拉取服务地址列表，然后按照一定的路由策略选择一个发起远程调用，</li>
<li>Ribbon发负载均衡策略： 已经被集成到Eureka-client和Nacos-Discovery中，后来被废弃，使用LoadBalancer了，OpenFeign也整合了LoadBalancer<ul>
<li>轮询，根据权重选择，随机选择一个可用的，</li>
<li>区域敏感策略，以区域可用的服务器为基础进行服务器的选择。使用Zone对服务器进行分类，这个Zone可以理解为一个机房、一个机架等。而后再对Zone内的多个服务做轮询(默认)</li>
</ul>
</li>
</ul>
</li>
<li><p>服务保护</p>
<ul>
<li>Sentinel：<ul>
<li>线程隔离：<ol>
<li>线程池隔离：给每个服务调用业务分配一个线程池，利用线程池本身进行隔离<ul>
<li>支持主动超时，支持异步调用</li>
<li>缺点是线程的额外开销较大</li>
<li>使用场景低扇出</li>
</ul>
</li>
<li>信号量隔离：不创建线程池而是使用计数器模式，记录业务使用的线程数量，打到信号量上限时，禁止新的请求<ul>
<li>优点：轻量级，无额外开销</li>
<li>缺点：不支持主动超时，不支持异步调用</li>
<li>适合高频调用高扇出(一个服务需要调用其他许多服务，那么我们就可以说这个服务有高扇出)</li>
</ul>
</li>
</ol>
</li>
<li>限流：<ul>
<li>滑动窗口算法：</li>
<li>令牌桶算法：<ul>
<li>固定速率生成令牌，桶满了就舍弃，每个请求必须向桶中获取令牌才能被处理，没有获得令牌的请求等待或者丢弃</li>
<li>一般情况下每秒产生的令牌数量就是QPS上限，但是当前这一秒没有请求进入，下一半秒涌入了超过2N个请求，然后这一秒生成了N个令牌，所以放行了2N个请求，超过了阈值，所以要预留一定的波动空间</li>
</ul>
</li>
<li>漏桶算法：请求放入队列中，以固定的速率去取出并处理请求。</li>
</ul>
</li>
</ul>
</li>
<li>限流：<ul>
<li>使用nginx基于漏桶实现限流</li>
<li>使用gateway 的令牌桶算法，根据ip或者路径进行限流</li>
<li>Feign整合sentinel，在配置文件中开启即可</li>
</ul>
</li>
<li>熔断：对于超过QPS上限的请求或者延迟较高的请求，对其进行熔断，同时设置一个降级处理逻辑。<ul>
<li><img src="/2024/03/05/hou-duan/wei-fu-wu-he-fen-bu-shi/%E6%96%AD%E8%B7%AF%E5%99%A8%E7%8A%B6%E6%80%81%E6%9C%BA.png" class="lazyload" data-srcset="/2024/03/05/hou-duan/wei-fu-wu-he-fen-bu-shi/%E6%96%AD%E8%B7%AF%E5%99%A8%E7%8A%B6%E6%80%81%E6%9C%BA.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="断路器的工作状态机|475"><ol>
<li>closed关闭装填，放行所有请求，并开始统计异常比例、满请求比例，超过阈值切换到open</li>
<li>open服务调用被熔断，访问这个被熔断的请求会被拒绝，快速失败，走降级逻辑。持续一段时间之后转到half-open</li>
<li>half-open 半开模式，放行一次请求，根据执行结果来判断接下来的操作<ul>
<li>请求成功：切换到closed状态</li>
<li>请求失败：切换到open状态</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li><p>分布式事务：</p>
<ul>
<li>使用seata解决分布式事务：<ul>
<li>seata有三个重要角色：<img src="/2024/03/05/hou-duan/wei-fu-wu-he-fen-bu-shi/seata%E6%9E%B6%E6%9E%84.png" class="lazyload" data-srcset="/2024/03/05/hou-duan/wei-fu-wu-he-fen-bu-shi/seata%E6%9E%B6%E6%9E%84.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="|500"><ul>
<li>TC 事务协调者：维护全局和分支失物的状态，协调全局事务的</li>
<li>TM 事务管理器：定义全局事务的范围，开始全局事务，提交或回滚全局事务</li>
<li>RM 资源管理器：管理分支事务，与TC交谈以注册分之十五和报告分支事务的状态，并驱动分支事务的提交和回滚</li>
</ul>
</li>
<li>xa模式：<ul>
<li>RM一阶段工作：<ol>
<li>注册分支事务到TC</li>
<li>执行分支事务sql但不提交</li>
<li>报告执行状态到TC</li>
</ol>
</li>
<li>TC二阶段工作：<ul>
<li>TC检测各分支事务执行状态<ul>
<li>如果都成功则通知所有RM提交事务</li>
<li>如果都失败则通知所有RM回滚事务</li>
</ul>
</li>
</ul>
</li>
<li>RM二阶段工作：<ul>
<li>接收TC指令，提交或回滚事务</li>
</ul>
</li>
<li>优点：强一致性，没有代码侵入</li>
<li>缺点：一阶段需要锁定数据库资源，等待二阶段结束才释放，性能差</li>
<li>依赖关系型数据库实现事务</li>
</ul>
</li>
<li>at模式：<ol>
<li>阶段一RM：<img src="/2024/03/05/hou-duan/wei-fu-wu-he-fen-bu-shi/AT%E4%B8%80%E9%98%B6%E6%AE%B5.png" class="lazyload" data-srcset="/2024/03/05/hou-duan/wei-fu-wu-he-fen-bu-shi/AT%E4%B8%80%E9%98%B6%E6%AE%B5.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="|525"><ul>
<li>注册分支事务，</li>
<li>记录undo-log 快照数据</li>
<li>执行业务sql并提交</li>
<li>报告事务状态</li>
</ul>
</li>
</ol>
<ul>
<li>二阶段<img src="/2024/03/05/hou-duan/wei-fu-wu-he-fen-bu-shi/AT%E4%BA%8C%E9%98%B6%E6%AE%B5.png" class="lazyload" data-srcset="/2024/03/05/hou-duan/wei-fu-wu-he-fen-bu-shi/AT%E4%BA%8C%E9%98%B6%E6%AE%B5.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="|500"><ol>
<li>阶段而提交时RM工作：删除undo-log</li>
<li>回滚时，RM工作：根据undo-log恢复数据到更新前</li>
</ol>
</li>
</ul>
</li>
<li>两者区别：<ul>
<li>XA一阶段不提交事务，锁定资源，AT一阶段提交事务，不锁定资源</li>
<li>XA模式伊利数据库实现回滚，AT模式利用数据快照实现数据回滚</li>
<li>XA模式强一致性，AT模式最终一致</li>
</ul>
</li>
<li>TCC模式：TCC模式与AT模式非常相似，每阶段都是独立事务，不同的是TCC通过人工编码来实现数据恢复。需要实现三个方法：<img src="/2024/03/05/hou-duan/wei-fu-wu-he-fen-bu-shi/TCC%E6%A8%A1%E5%BC%8F.png" class="lazyload" data-srcset="/2024/03/05/hou-duan/wei-fu-wu-he-fen-bu-shi/TCC%E6%A8%A1%E5%BC%8F.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="><ul>
<li><code>try</code>：资源的检测和预留；</li>
<li><code>confirm</code>：完成资源操作业务；要求 <code>try</code> 成功 <code>confirm</code> 一定要能成功。</li>
<li><code>cancel</code>：预留资源释放，可以理解为try的反向操作。</li>
<li>优点：一阶段完成直接提交事务，释放资源，无需快照，无需依赖数据库事务，可用于关系型数据库</li>
<li>缺点：代码侵入严重，软状态，事务最终一致</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>接口幂等性：</p>
<ul>
<li>使用token+redis实现接口幂等性，第二次请求之后每次请求都会携带之前的token，后台先对redis进行验证，如果存在token则执行业务，同时删除token，如果不存再则直接返回，保证了幂等性，保证了同一个token只处理一次业务</li>
</ul>
</li>
<li><h2 id="MQ：-组成-producer消息的生产者-broker-消息的保存-consumer-消息的消费者-选择："><a href="#MQ：-组成-producer消息的生产者-broker-消息的保存-consumer-消息的消费者-选择：" class="headerlink" title="MQ：  - 组成      - producer消息的生产者      - broker 消息的保存      - consumer 消息的消费者  - 选择："></a>MQ：<br>  - 组成<br>      - producer消息的生产者<br>      - broker 消息的保存<br>      - consumer 消息的消费者<br>  - 选择：<img src="/2024/03/05/hou-duan/wei-fu-wu-he-fen-bu-shi/MQ%E7%9A%84%E9%80%89%E6%8B%A9.png" class="lazyload" data-srcset="/2024/03/05/hou-duan/wei-fu-wu-he-fen-bu-shi/MQ%E7%9A%84%E9%80%89%E6%8B%A9.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></h2></li>
</ul>
<h3 id="Kafka面试题"><a href="#Kafka面试题" class="headerlink" title="Kafka面试题"></a>Kafka面试题</h3><ul>
<li>如何保证消息不丢失：<ol>
<li>producer时，可以使用异步回调发送，如果消息发送失败，我们可以通过回调获取失败后的消息信息，可以重试或者记录日志，也可以后续进行不成</li>
<li>broker中消息丢失，通过kafka的复制机制来保证消息不丢失，在生产者发送消息的时候，可以设置一个acks的参数位all，这样就会在broker的leader和foller分区都保存确认，只有所有的副本都确认之后才算是成功过发送了消息</li>
</ol>
</li>
<li>consumer时使用pull，还是push：<ul>
<li>Kafka使用了pull模式，consumer可以自主决定是否批量从broker拉取数据。push为了避免consumer崩溃而采用较低的推送速率，到一次只推送较少的消息造成浪费，pull模式下，consumer可以根据自己的消费能力而去决定如何拉取消息</li>
<li>缺点：如果broker没有提供可消费的消息，将导致consumer不断循环中轮询，直到最新消息到达。</li>
<li>Kafka可以有个参数可以让consumer阻塞知道新消息的到达，或者阻塞直到消息的数量到达某个特定的量就可以批量发送。</li>
</ul>
</li>
<li>Kafka将Topic分成了若干分区，每个分区同一时间只能被有一个consumer消费，意味着每个分区被消费的消息在日志中的位置仅仅是有一个简单的整数：offset ，consumer可以把offset调成一个较老的值，从而重新消费老消息</li>
<li>主从复制：一个topic可以有多个副本<ul>
<li>主节点将消息写入本地日志，从节点从主节点拉取信息，写入本地日志，之后向主节点发送确认消息，如果主节点收到所有从节点的确认消息，该消息就会被认为是已提交的，主节点会更新自己的高水位，消费者只能消费已提交的消息</li>
<li>优点：保证了主节点崩溃消息也不会丢失</li>
</ul>
</li>
<li>脑裂问题：<ul>
<li>只有领导者负责处理生产者和消费者的读写请求，追随者只能从领导者那里复制数据</li>
<li>Kafka的选举是由ZooKeeper协调的，ZooKeeper可以保证在任何时候只有一个领导者被选举出来</li>
<li>Zookeeper是如何做到的？<ul>
<li>当Zookeeper启动或者领导者崩溃时，所有的Zookeeper节点都会进入选举状态</li>
<li>投票阶段：每个节点会将自己作为领导者后端，然后发送投票信息给其他节点，当一个节点收到其他节点的投票信息是，如果ZXID更大，也就是收到的消息更，会更新自己的投票信息，并将新的投票信息发送给其他节点</li>
<li>确定阶段：当一个节点收到超过半数节点的相同投票信息中，他就认为选举结束，选举出的领导者就是投票信息中的候选节点，然后将结果发送给其他节点。</li>
</ul>
</li>
</ul>
</li>
<li>消息重复消费如何解决<ul>
<li>kafka都是按照offset进行标记消费的，消费者默认是自动按期提交已经消费的偏移量，如果出现重复消费的问题，我们需要禁用自动提交offset，改为手动提交，消费成功后报告给broker，为了维护消息的幂等性，我们可以设置唯一主键进行区分，或者是枷锁，数据库的锁或者是Redis的分布式锁都能解决幂等问题。</li>
</ul>
</li>
<li>如何保证消息的顺序性：<ol>
<li>将消息都存储在同一个分区下</li>
<li>发送消息时按照相同的业务设置相同的key，默认的分区是通过key的hashcode值来选择分区的，如果hash值一样，分区也是一样的。</li>
</ol>
</li>
<li>高可用：<ul>
<li>集群：多个broker，即使一台宕机，其他可以继续服务<ul>
<li>broker如何实现消息同步？<ul>
<li>主从同步，Leader Broker接受消息后，将消息写入本地日志，Follower拉取消息，写入本地日志，当所欲的ISR(同步复制保存的follower)都完成，Leader就会向生产者发送确认消息。</li>
</ul>
</li>
<li>通过过程中Leader宕机了，该怎么办？<ul>
<li>Kafka回从ISR列表中选择一个新的Leader，ISR列表中的都是已经同步最新数据的副本，当Follower同步完成后，会重新加入到ISR列表中。</li>
</ul>
</li>
</ul>
</li>
<li>数据清洗：<ul>
<li>日志清洗：<ul>
<li>根据消息保留时间，超过指定时间触发清洗，默认是168小时</li>
<li>根据topic存储的数据大小，大于一定法制，开始删除最久的消息，默认关闭。</li>
</ul>
</li>
</ul>
</li>
<li>高性能设计：<ul>
<li>消息分区：不受单台服务器限制，处理更多数据</li>
<li>顺序读写：顺序读写，提高读写效率</li>
<li>页缓存：磁盘中的数据缓存到内存，把磁盘的访问变为对内存的访问</li>
<li>零拷贝：减少上下文切换及数据拷贝</li>
<li>消息压缩：减少磁盘IO和网络IO</li>
<li>分批发送：分批发送，将消息打包批量发送，减少网络开销</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="SpringCloud"><a href="#SpringCloud" class="headerlink" title="SpringCloud"></a>SpringCloud</h2><h3 id="注册中心"><a href="#注册中心" class="headerlink" title="注册中心"></a>注册中心</h3><ol>
<li>方便更改微服务的ip和 端口号</li>
<li>如果存在多个服务，可以配置负载均衡</li>
<li>方便维护<br>服务注册中心：实现微服务之间的动态注册与发现<br><img src="/2024/03/05/hou-duan/wei-fu-wu-he-fen-bu-shi/%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E7%9A%84%E4%BD%9C%E7%94%A8.png" class="lazyload" data-srcset="/2024/03/05/hou-duan/wei-fu-wu-he-fen-bu-shi/%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E7%9A%84%E4%BD%9C%E7%94%A8.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></li>
</ol>
<h3 id="consul"><a href="#consul" class="headerlink" title="consul"></a>consul</h3><p>功能：</p>
<ol>
<li>服务发现 支持 http和dns</li>
<li>健康监测</li>
<li>KV存储 配置</li>
<li>多数据中心</li>
<li>可视化Web界面<br>在main方法上使用 @EnableDiscoveryClient<br>controller 层上<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> <span class="token class-name">PaymentSrv_URL</span> <span class="token operator">=</span> <span class="token string">"http://cloud-payment-service"</span><span class="token punctuation">;</span><span class="token comment">//服务注册中心上的微服务名称</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<pre class="line-numbers language-cssx" data-language="cssx"><code class="language-cssx">consul agent -dev 进入开发者模式 localhost:8500<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!--SpringCloud consul discovery --&gt;</span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-cloud-starter-consul-discovery<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-css" data-language="css"><code class="language-css">  <span class="token selector">####Spring Cloud Consul for Service Discovery
spring:
    cloud: # 服务注册
      consul: # consul注册中心
        host: localhost # consul地址
        port: 8500 # consul端口
        discovery: # 服务发现
          service-name: $</span><span class="token punctuation">{</span>spring.application.name<span class="token punctuation">}</span> # 服务名称<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
RestTemplate提供了多种便捷访问远程Http服务的方法，</li>
</ol>
<p>&nbsp;</p>
<p>是一种简单便捷的访问restful服务模板类，是Spring提供的用于访问Rest服务的客户端模板工具集</p>
<blockquote>
<p>applicaiton.yml是用户级的资源配置项</p>
</blockquote>
<p>bootstrap.yml是系统级的，优先级更加高</p>
<p>Spring Cloud会创建一个“Bootstrap Context”，作为Spring应用的<code>Application Context</code>的父上下文。初始化的时候，<code>Bootstrap Context</code>负责从外部源加载配置属性并解析配置。这两个上下文共享一个从外部获取的<code>Environment</code>。</p>
<p><code>Bootstrap</code>属性有高优先级，默认情况下，它们不会被本地配置覆盖。 <code>Bootstrap context</code>和<code>Application Context</code>有着不同的约定，所以新增了一个<code>bootstrap.yml</code>文件，保证<code>Bootstrap Context</code>和<code>Application Context</code>配置的分离。</p>
<pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">spring:
  application:
    name: cloud-payment-service
    ####Spring Cloud Consul for Service Discovery
  cloud:
    consul:
      host: localhost
      port: 8500
      discovery:
        service-name: $</span><span class="token punctuation">{</span>spring.application.name<span class="token punctuation">}</span>
      <span class="token property">config</span><span class="token punctuation">:</span>
        <span class="token property">profile-separator</span><span class="token punctuation">:</span> <span class="token string">'-'</span> # default value is <span class="token string">","</span>，we update <span class="token string">'-'</span>
        <span class="token property">format</span><span class="token punctuation">:</span> YAML

# config/cloud-payment-service/data
#       /cloud-payment-service-dev/data
#       /cloud-payment-service-prod/data<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>&nbsp;application.yml文件改为bootstrap.yml,这是很关键的或者两者共存<br>因为bootstrap.yml是比application.yml先加载的。bootstrap.yml优先级高于application.yml </p>
<ul>
<li>consul kv写法</li>
<li>config/配置文件/data  里面写配置</li>
<li>动态刷新：在main上写 : @RefreshScope<br>问题: 重启consul之后，配置丢失，如何持久化配置？</li>
</ul>
<h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><ul>
<li>客户端负载和服务器负载<br>loadbalancer本地负载均衡客户端 VS Nginx服务端负载均衡区别</li>
</ul>
<p>Nginx是服务器负载均衡，客户端所有请求都会交给nginx，然后由nginx实现转发请求，即负载均衡是由服务端实现的。</p>
<p>loadbalancer本地负载均衡，在调用微服务接口时候，会在注册中心上获取注册信息服务列表之后缓存到JVM本地，从而在本地实现RPC远程服务调用技术。</p>
<ul>
<li>LoadBalancer 在工作时分成两步：</li>
</ul>
<p><strong>第一步</strong>，先选择ConsulServer从服务端查询并拉取服务列表，知道了它有多个服务(上图3个服务)，这3个实现是完全一样的，</p>
<p>默认轮询调用谁都可以正常执行。类似生活中求医挂号，某个科室今日出诊的全部医生，客户端你自己选一个。</p>
<p><strong>第二步</strong>，按照指定的负载均衡策略从server取到的服务注册列表中由客户端自己选择一个地址，所以LoadBalancer是一个<strong>客户端的</strong>负载均衡器。</p>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!--loadbalancer--&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-cloud-starter-loadbalancer<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>访问时即可在多个服务器中切换<br>均衡算法默认为轮询：<br>可以切换为随机算法：<br>修改RestTemplateConfig:</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span>
<span class="token annotation punctuation">@LoadBalancerClient</span><span class="token punctuation">(</span>
        <span class="token comment">//下面的value值大小写一定要和consul里面的名字一样，必须一样</span>
        value <span class="token operator">=</span> <span class="token string">"cloud-payment-service"</span><span class="token punctuation">,</span>configuration <span class="token operator">=</span> <span class="token class-name">RestTemplateConfig</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RestTemplateConfig</span>
<span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Bean</span>
    <span class="token annotation punctuation">@LoadBalanced</span> <span class="token comment">//使用@LoadBalanced注解赋予RestTemplate负载均衡的能力</span>
    <span class="token keyword">public</span> <span class="token class-name">RestTemplate</span> <span class="token function">restTemplate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">RestTemplate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Bean</span>
    <span class="token class-name">ReactorLoadBalancer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ServiceInstance</span><span class="token punctuation">&gt;</span></span> <span class="token function">randomLoadBalancer</span><span class="token punctuation">(</span><span class="token class-name">Environment</span> environment<span class="token punctuation">,</span>
                                                            <span class="token class-name">LoadBalancerClientFactory</span> loadBalancerClientFactory<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">String</span> name <span class="token operator">=</span> environment<span class="token punctuation">.</span><span class="token function">getProperty</span><span class="token punctuation">(</span><span class="token class-name">LoadBalancerClientFactory</span><span class="token punctuation">.</span><span class="token constant">PROPERTY_NAME</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">RandomLoadBalancer</span><span class="token punctuation">(</span>loadBalancerClientFactory<span class="token punctuation">.</span><span class="token function">getLazyProvider</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token class-name">ServiceInstanceListSupplier</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="OpenFeign"><a href="#OpenFeign" class="headerlink" title="OpenFeign"></a>OpenFeign</h2><p>Feign是一个<strong>声明性web服务客户端</strong>。它使编写web服务客户端变得更容易。使用Feign创建一个接口并对其进行注释。它具有可插入的注释支持，包括Feign注释和JAX-RS注释。Feign还支持可插拔编码器和解码器。Spring Cloud添加了对Spring MVC注释的支持，以及对使用Spring Web中默认使用的HttpMessageConverter的支持。Spring Cloud集成了Eureka、Spring Cloud CircuitBreaker以及Spring Cloud LoadBalancer，以便在使用Feign时提供负载平衡的http客户端。</p>
<p>OpenFeign能干什么</p>
<p>前面在使用<strong>SpringCloud LoadBalancer</strong>+RestTemplate时，利用RestTemplate对http请求的封装处理形成了一套模版化的调用方法。**<em>但是在实际开发中，</em>**</p>
<p>由于对服务依赖的调用可能不止一处，往往一个接口会被多处调用，所以通常都会针对每个微服务自行封装一些客户端类来包装这些依赖服务的调用。所以，OpenFeign在此基础上做了进一步封装，由他来帮助我们定义和实现依赖服务接口的定义。在OpenFeign的实现下，我们只需创建一个接口并使用注解的方式来配置它(在一个微服务接口上面标注一个**_@FeignClient_**注解即可)，即可完成对服务提供方的接口绑定，统一对外暴露可以被调用的接口方法，大大简化和降低了调用客户端的开发量，也即由服务提供者给出调用接口清单，消费者直接通过OpenFeign调用即可，O(∩_∩)O。</p>
<p>OpenFeign同时还集成SpringCloud LoadBalancer</p>
<p>可以在使用OpenFeign时提供Http客户端的负载均衡，也可以集成阿里巴巴Sentinel来提供熔断、降级等功能。而与SpringCloud LoadBalancer不同的是，通过OpenFeign只需要定义服务绑定接口且以声明式的方法，优雅而简单的实现了服务调用。</p>
<ul>
<li>引入依赖:<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!--openfeign--&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-cloud-starter-openfeign<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li>配置文件<pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">server:
  port: 80

spring:
  application:
    name: cloud-consumer-openfeign-order
  ####Spring Cloud Consul for Service Discovery
  cloud:
    consul:
      host: localhost
      port: 8500
      discovery:
        prefer-ip-address: true #优先使用服务ip进行注册
        service-name: $</span><span class="token punctuation">{</span>spring.application.name<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
main函数上使用<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@EnableDiscoveryClient</span> <span class="token comment">//该注解用于向使用consul为注册中心时注册服务</span>
<span class="token annotation punctuation">@EnableFeignClients</span><span class="token comment">//启用feign客户端,定义服务+绑定接口，以声明式的方法优雅而简单的实现服务调用</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
api接口上使用:<br>@FeignClient(value = “xxx”)</li>
<li>超时控制<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">sspring</span><span class="token punctuation">:</span>
  <span class="token key atrule">cloud</span><span class="token punctuation">:</span>
    <span class="token key atrule">openfeign</span><span class="token punctuation">:</span>
      <span class="token key atrule">client</span><span class="token punctuation">:</span>
        <span class="token key atrule">config</span><span class="token punctuation">:</span>

          <span class="token comment"># default 设置的全局超时时间，指定服务名称可以设置单个服务的超时时间</span>
          <span class="token key atrule">default</span><span class="token punctuation">:</span>
             <span class="token comment">#连接超时时间</span>
             <span class="token key atrule">connectTimeout</span><span class="token punctuation">:</span> <span class="token number">4000</span>
             <span class="token comment">#读取超时时间</span>
             <span class="token key atrule">readTimeout</span><span class="token punctuation">:</span> <span class="token number">4000</span>

          <span class="token comment"># 为serviceC这个服务单独配置超时时间，单个配置的超时时间将会覆盖全局配置</span>

          <span class="token key atrule">serviceC</span><span class="token punctuation">:</span>
             <span class="token comment">#连接超时时间</span>
             <span class="token key atrule">connectTimeout</span><span class="token punctuation">:</span> <span class="token number">2000</span>
             <span class="token comment">#读取超时时间</span>
             <span class="token key atrule">readTimeout</span><span class="token punctuation">:</span> <span class="token number">2000</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
<p><strong>服务雪崩</strong></p>
<p>多个微服务之间调用的时候，假设微服务A调用微服务B和微服务C，微服务B和微服务C又调用其它的微服务，这就是所谓的“扇出”。如果扇出的链路上某个微服务的调用响应时间过长或者不可用，对微服务A的调用就会占用越来越多的系统资源，进而引起系统崩溃，所谓的“雪崩效应”.</p>
<p>对于高流量的应用来说，单一的后端依赖可能会导致所有服务器上的所有资源都在几秒钟内饱和。比失败更糟糕的是，这些应用程序还可能导致服务之间的延迟增加，备份队列，线程和其他系统资源紧张，导致整个系统发生更多的级联故障。这些都表示需要对故障和延迟进行隔离和管理，以便单个依赖关系的失败，不能取消整个应用程序或系统。</p>
<p>所以，</p>
<p>通常当你发现一个模块下的某个实例失败后，这时候这个模块依然还会接收流量，然后这个有问题的模块还调用了其他的模块，这样就会发生级联故障，或者叫雪崩。</p>
<h2 id="CircuitBreaker-断路器"><a href="#CircuitBreaker-断路器" class="headerlink" title="CircuitBreaker  断路器"></a>CircuitBreaker  断路器</h2><p>配置参考<br><img src="/2024/03/05/hou-duan/wei-fu-wu-he-fen-bu-shi/%E6%96%AD%E8%B7%AF%E5%99%A8%E9%85%8D%E7%BD%AE.png" class="lazyload" data-srcset="/2024/03/05/hou-duan/wei-fu-wu-he-fen-bu-shi/%E6%96%AD%E8%B7%AF%E5%99%A8%E9%85%8D%E7%BD%AE.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="断路器配置"></p>
<p>断路器的状态：</p>
<ol>
<li>CLOSED</li>
<li>OPEN</li>
<li>HALF_OPEN 半开<br><img src="/2024/03/05/hou-duan/wei-fu-wu-he-fen-bu-shi/%E7%8A%B6%E6%80%81.png" class="lazyload" data-srcset="/2024/03/05/hou-duan/wei-fu-wu-he-fen-bu-shi/%E7%8A%B6%E6%80%81.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="><br>pox<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!--resilience4j-circuitbreaker--&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-cloud-starter-circuitbreaker-resilience4j<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>
<span class="token comment">&lt;!-- 由于断路保护等需要AOP实现，所以必须导入AOP包 --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-boot-starter-aop<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<img src="/2024/03/05/hou-duan/wei-fu-wu-he-fen-bu-shi/%E5%8E%9F%E7%90%86.png" class="lazyload" data-srcset="/2024/03/05/hou-duan/wei-fu-wu-he-fen-bu-shi/%E5%8E%9F%E7%90%86.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></li>
</ol>
<h2 id="分布式链路追踪"><a href="#分布式链路追踪" class="headerlink" title="分布式链路追踪"></a>分布式链路追踪</h2><p>原因:<br><img src="/2024/03/05/hou-duan/wei-fu-wu-he-fen-bu-shi/%E5%8E%9F%E5%9B%A0.png" class="lazyload" data-srcset="/2024/03/05/hou-duan/wei-fu-wu-he-fen-bu-shi/%E5%8E%9F%E5%9B%A0.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="原因"><br><strong>ZipKin概述</strong></p>
<p>Zipkin是一种分布式链路跟踪系统图形化的工具，Zipkin 是 Twitter 开源的分布式跟踪系统，能够收集微服务运行过程中的实时调用链路信息，并能够将这些调用链路信息展示到Web图形化界面上供开发人员分析，开发人员能够从ZipKin中分析出调用链路中的性能瓶颈，识别出存在问题的应用程序，进而定位问题和解决问题<br>运行: java -jar zipkin-server-3.0.0-rc0-exec.jar</p>
<h2 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h2><p><img src="/2024/03/05/hou-duan/wei-fu-wu-he-fen-bu-shi/%E7%BD%91%E5%85%B3.png" class="lazyload" data-srcset="/2024/03/05/hou-duan/wei-fu-wu-he-fen-bu-shi/%E7%BD%91%E5%85%B3.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="网关"></p>
<h3 id="执行流程："><a href="#执行流程：" class="headerlink" title="执行流程："></a>执行流程：</h3><ol>
<li>路由判断：用户端的请求到达网关之后，根据Gateway Handler Mapping 处理，会进行断言判断</li>
<li>路由过滤：很多Handler 组成的Fileter Chain</li>
<li>服务处理：后端服务会对请求进行处理</li>
<li>响应过滤：返回给-Gateway的过滤器会再次进行处理，逻辑上可以乘坐Post-Filters</li>
<li>响应返回：响应经过过处理之后，返回给客户端</li>
</ol>
<ul>
<li>作用<ol>
<li>反向代理</li>
<li>鉴权</li>
<li>流量控制</li>
<li>熔断</li>
<li>日志监控</li>
</ol>
</li>
</ul>
<h3 id="Spring-Cloud-Gateway如何实现动态路由"><a href="#Spring-Cloud-Gateway如何实现动态路由" class="headerlink" title="Spring Cloud Gateway如何实现动态路由"></a>Spring Cloud Gateway如何实现动态路由</h3><p>可以使用Nacos作为注册中心去动态更改<br>配置的路由断言类型</p>
<h3 id="Gateway过滤器的类型"><a href="#Gateway过滤器的类型" class="headerlink" title="Gateway过滤器的类型"></a>Gateway过滤器的类型</h3><ul>
<li>Pre类型：在请求被转发到微服务之前及逆行拦截和修改</li>
<li>Post ： 微服务处理请求之后，返回响应给网关，网关可以再次进行处理，例如修改相应内容或者响应头，日志输出，流量监控<br>或者</li>
<li>GatewayFilter：局部过滤器，应用在单个路由或者一组路由上的过滤器</li>
<li>GlobalFilter：全局过滤器<br>pom<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!--gateway--&gt;</span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>
          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>
          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-cloud-starter-gateway<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
yml<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">server</span><span class="token punctuation">:</span>
  <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">9527</span>

<span class="token key atrule">spring</span><span class="token punctuation">:</span>
  <span class="token key atrule">application</span><span class="token punctuation">:</span>
    <span class="token key atrule">name</span><span class="token punctuation">:</span> cloud<span class="token punctuation">-</span>gateway <span class="token comment">#以微服务注册进consul或nacos服务列表内</span>
  <span class="token key atrule">cloud</span><span class="token punctuation">:</span>
    <span class="token key atrule">consul</span><span class="token punctuation">:</span> <span class="token comment">#配置consul地址</span>
      <span class="token key atrule">host</span><span class="token punctuation">:</span> localhost
      <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">8500</span>
      <span class="token key atrule">discovery</span><span class="token punctuation">:</span>
        <span class="token key atrule">prefer-ip-address</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>
        <span class="token key atrule">service-name</span><span class="token punctuation">:</span> $<span class="token punctuation">{</span>spring.application.name<span class="token punctuation">}</span>
	<span class="token key atrule">gateway</span><span class="token punctuation">:</span>
      <span class="token key atrule">routes</span><span class="token punctuation">:</span>
        <span class="token punctuation">-</span> <span class="token key atrule">id</span><span class="token punctuation">:</span> pay_routh1 <span class="token comment">#pay_routh1                #路由的ID(类似mysql主键ID)，没有固定规则但要求唯一，建议配合服务名</span>
          <span class="token key atrule">uri</span><span class="token punctuation">:</span> http<span class="token punctuation">:</span>//localhost<span class="token punctuation">:</span><span class="token number">8001</span>                <span class="token comment">#匹配后提供服务的路由地址</span>
          <span class="token key atrule">predicates</span><span class="token punctuation">:</span>
            <span class="token punctuation">-</span> Path=/pay/gateway/get/<span class="token important">**</span>              <span class="token comment"># 断言，路径相匹配的进行路由id: pay_routh2 #pay_routh2                #路由的ID(类似mysql主键ID)，没有固定规则但要求唯一，建议配合服务名</span>
          <span class="token key atrule">uri</span><span class="token punctuation">:</span> http<span class="token punctuation">:</span>//localhost<span class="token punctuation">:</span><span class="token number">8001</span>                <span class="token comment">#匹配后提供服务的路由地址</span>
          <span class="token key atrule">predicates</span><span class="token punctuation">:</span>
            <span class="token punctuation">-</span> Path=/pay/gateway/info/<span class="token important">**</span>              <span class="token comment"># 断言，路径相匹配的进行路由      </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
<h2 id="SpringCloud-1"><a href="#SpringCloud-1" class="headerlink" title="SpringCloud"></a>SpringCloud</h2><p><img src="/2024/03/05/hou-duan/wei-fu-wu-he-fen-bu-shi/alibaba.png" class="lazyload" data-srcset="/2024/03/05/hou-duan/wei-fu-wu-he-fen-bu-shi/alibaba.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="阿里巴巴"></p>
<ul>
<li>功能<br><img src="/2024/03/05/hou-duan/wei-fu-wu-he-fen-bu-shi/%E5%8A%9F%E8%83%BD.png" class="lazyload" data-srcset="/2024/03/05/hou-duan/wei-fu-wu-he-fen-bu-shi/%E5%8A%9F%E8%83%BD.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="功能"></li>
<li>组件<br><img src="/2024/03/05/hou-duan/wei-fu-wu-he-fen-bu-shi/%E7%BB%84%E4%BB%B6.png" class="lazyload" data-srcset="/2024/03/05/hou-duan/wei-fu-wu-he-fen-bu-shi/%E7%BB%84%E4%BB%B6.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="组件"></li>
</ul>
<h3 id="服务注册-Nacos-x3D-x3D-consul"><a href="#服务注册-Nacos-x3D-x3D-consul" class="headerlink" title="服务注册 Nacos == consul"></a>服务注册 Nacos == consul</h3><p><strong>注意是根据ID来区分的不是根据名字来区分命名空间的，所以ID要填自己想填的</strong></p>
<p><img src="/2024/03/05/hou-duan/wei-fu-wu-he-fen-bu-shi/%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E5%AF%B9%E6%AF%94.png" class="lazyload" data-srcset="/2024/03/05/hou-duan/wei-fu-wu-he-fen-bu-shi/%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E5%AF%B9%E6%AF%94.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="对比"></p>
<ul>
<li><p>命令行</p>
<pre class="line-numbers language-css" data-language="css"><code class="language-css">startup.cmd -m standalone<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
<li><p>服务提供者<br>pom:</p>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>  
	<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>com.alibaba.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>  
	<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-cloud-starter-alibaba-nacos-discovery<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>  
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>yml</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">server</span><span class="token punctuation">:</span>
  <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">9001</span>

<span class="token key atrule">spring</span><span class="token punctuation">:</span>
  <span class="token key atrule">application</span><span class="token punctuation">:</span>
    <span class="token key atrule">name</span><span class="token punctuation">:</span> nacos<span class="token punctuation">-</span>payment<span class="token punctuation">-</span>provider
  <span class="token key atrule">cloud</span><span class="token punctuation">:</span>
    <span class="token key atrule">nacos</span><span class="token punctuation">:</span>
      <span class="token key atrule">discovery</span><span class="token punctuation">:</span>
        <span class="token key atrule">server-addr</span><span class="token punctuation">:</span> localhost<span class="token punctuation">:</span><span class="token number">8848</span> <span class="token comment">#配置Nacos地址</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>main函数上使用@EnableDiscoveryClient<br>业务类示范<br><img src="/2024/03/05/hou-duan/wei-fu-wu-he-fen-bu-shi/controller%E7%A4%BA%E8%8C%83.png" class="lazyload" data-srcset="/2024/03/05/hou-duan/wei-fu-wu-he-fen-bu-shi/controller%E7%A4%BA%E8%8C%83.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="示范"></p>
</li>
<li><p>消费者<br>pom</p>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!--nacos-discovery--&gt;</span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>
           <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>com.alibaba.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>
           <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-cloud-starter-alibaba-nacos-discovery<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>
       <span class="token comment">&lt;!--loadbalancer--&gt;</span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>
           <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>
           <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-cloud-starter-loadbalancer<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>xml</p>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">
server:
  port: 83

spring:
  application:
    name: nacos-order-consumer
  cloud:
    nacos:
      discovery:
        server-addr: localhost:8848
#消费者将要去访问的微服务名称(nacos微服务提供者叫什么你写什么)
service-url:
  nacos-user-service: http://nacos-payment-provider<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>main上也使用@EnableDiscoveryClient</p>
</li>
</ul>
<p>restTemplate配置</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">ackage com<span class="token punctuation">.</span>atguigu<span class="token punctuation">.</span>cloud<span class="token punctuation">.</span>config<span class="token punctuation">;</span>

<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>cloud<span class="token punctuation">.</span>client<span class="token punctuation">.</span>loadbalancer<span class="token punctuation">.</span></span><span class="token class-name">LoadBalanced</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>context<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">Bean</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>context<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">Configuration</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>client<span class="token punctuation">.</span></span><span class="token class-name">RestTemplate</span></span><span class="token punctuation">;</span>

<span class="token comment">/**
 * @auther zzyy
 * @create 2023-11-23 17:20
 */</span>
<span class="token annotation punctuation">@Configuration</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RestTemplateConfig</span>
<span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Bean</span>
    <span class="token annotation punctuation">@LoadBalanced</span> <span class="token comment">//赋予RestTemplate负载均衡的能力</span>
    <span class="token keyword">public</span> <span class="token class-name">RestTemplate</span> <span class="token function">restTemplate</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">RestTemplate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>Nacos作为配置中心，进行动态配置<br>导入pom<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!--bootstrap--&gt;</span>
     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>
         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>
         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-cloud-starter-bootstrap<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>
     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>
     <span class="token comment">&lt;!--nacos-config--&gt;</span>
     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>
         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>com.alibaba.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>
         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-cloud-starter-alibaba-nacos-config<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>
     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
为什么进行两个配置？ bootstrap和application?<br>Nacos同Consul一样，在项目初始化时，要保证先从配置中心进行配置拉取，<br>拉取配置之后，才能保证项目的正常启动，为了满足动态刷新和全局广播通知<br>springboot中配置文件的加载是存在优先级顺序的，bootstrap优先级高于application<br>bootstrap<pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector"># nacos配置
spring:
  application:
    name: nacos-config-client
  cloud:
    nacos:
      discovery:
        server-addr: localhost:8848 #Nacos服务注册中心地址
      config:
        server-addr: localhost:8848 #Nacos作为配置中心地址
        file-extension: yaml #指定yaml格式的配置

# nacos端配置文件DataId的命名规则是：
# $</span><span class="token punctuation">{</span>spring.application.name<span class="token punctuation">}</span><span class="token selector">-$</span><span class="token punctuation">{</span>spring.profile.active<span class="token punctuation">}</span><span class="token selector">.$</span><span class="token punctuation">{</span>spring.cloud.nacos.config.file-extension<span class="token punctuation">}</span>
# <span class="token property">本案例的DataID是</span><span class="token punctuation">:</span>nacos-config-client-dev.yaml<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
application<pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token property">server</span><span class="token punctuation">:</span>
  <span class="token property">port</span><span class="token punctuation">:</span> 3377

<span class="token property">spring</span><span class="token punctuation">:</span>
  <span class="token property">profiles</span><span class="token punctuation">:</span>
    <span class="token property">active</span><span class="token punctuation">:</span> dev # 表示开发环境
      #<span class="token property">active</span><span class="token punctuation">:</span> prod # 表示生产环境
    #<span class="token property">active</span><span class="token punctuation">:</span> test # 表示测试环境<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
controller层上使用@RefreshScope //在控制器类加入@RefreshScope注解使当前类下的配置支持Nacos的动态刷新功能。</li>
</ul>
<p><em><strong>问题1：</strong></em></p>
<p>实际开发中，通常一个系统会准备</p>
<p>dev开发环境</p>
<p>test测试环境</p>
<p>prod生产环境。</p>
<p>如何保证指定环境启动时服务能正确读取到Nacos上相应环境的配置文件呢？</p>
<p><em><strong>问题2:</strong></em></p>
<p>一个大型分布式微服务系统会有很多微服务子项目，</p>
<p>每个微服务项目又都会有相应的开发环境、测试环境、预发环境、正式环境……</p>
<p>那怎么对这些微服务配置进行分组和命名空间管理呢？</p>
<p><img src="/2024/03/05/hou-duan/wei-fu-wu-he-fen-bu-shi/model.png" class="lazyload" data-srcset="/2024/03/05/hou-duan/wei-fu-wu-he-fen-bu-shi/model.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="model"></p>
<h2 id="Sentinel-等价于-Circuit-Breaker-自己去官网看"><a href="#Sentinel-等价于-Circuit-Breaker-自己去官网看" class="headerlink" title="Sentinel 等价于 Circuit Breaker 自己去官网看"></a>Sentinel 等价于 Circuit Breaker 自己去官网看</h2><p><img src="/2024/03/05/hou-duan/wei-fu-wu-he-fen-bu-shi/%E9%9B%AA%E5%B4%A9.png" class="lazyload" data-srcset="/2024/03/05/hou-duan/wei-fu-wu-he-fen-bu-shi/%E9%9B%AA%E5%B4%A9.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="><br><img src="/2024/03/05/hou-duan/wei-fu-wu-he-fen-bu-shi/%E9%99%8D%E7%BA%A7.png" class="lazyload" data-srcset="/2024/03/05/hou-duan/wei-fu-wu-he-fen-bu-shi/%E9%99%8D%E7%BA%A7.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="><br><img src="/2024/03/05/hou-duan/wei-fu-wu-he-fen-bu-shi/%E7%86%94%E6%96%AD.png" class="lazyload" data-srcset="/2024/03/05/hou-duan/wei-fu-wu-he-fen-bu-shi/%E7%86%94%E6%96%AD.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="><br><img src="/2024/03/05/hou-duan/wei-fu-wu-he-fen-bu-shi/%E9%99%90%E6%B5%81.png" class="lazyload" data-srcset="/2024/03/05/hou-duan/wei-fu-wu-he-fen-bu-shi/%E9%99%90%E6%B5%81.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="><br><img src="/2024/03/05/hou-duan/wei-fu-wu-he-fen-bu-shi/%E9%9A%94%E7%A6%BB.png" class="lazyload" data-srcset="/2024/03/05/hou-duan/wei-fu-wu-he-fen-bu-shi/%E9%9A%94%E7%A6%BB.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="><br><img src="/2024/03/05/hou-duan/wei-fu-wu-he-fen-bu-shi/%E9%9A%94%E7%A6%BB.png" class="lazyload" data-srcset="/2024/03/05/hou-duan/wei-fu-wu-he-fen-bu-shi/%E9%9A%94%E7%A6%BB.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="><br><img src="/2024/03/05/hou-duan/wei-fu-wu-he-fen-bu-shi/%E8%B6%85%E6%97%B6.png" class="lazyload" data-srcset="/2024/03/05/hou-duan/wei-fu-wu-he-fen-bu-shi/%E8%B6%85%E6%97%B6.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p>
<p>pom</p>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!--SpringCloud alibaba sentinel --&gt;</span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>
           <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>com.alibaba.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>
           <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-cloud-starter-alibaba-sentinel<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>yml</p>
<pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token property">server</span><span class="token punctuation">:</span>
  <span class="token property">port</span><span class="token punctuation">:</span> 8401

<span class="token property">spring</span><span class="token punctuation">:</span>
  <span class="token property">application</span><span class="token punctuation">:</span>
    <span class="token property">name</span><span class="token punctuation">:</span> cloudalibaba-sentinel-service
  <span class="token property">cloud</span><span class="token punctuation">:</span>
    <span class="token property">nacos</span><span class="token punctuation">:</span>
      <span class="token property">discovery</span><span class="token punctuation">:</span>
        <span class="token property">server-addr</span><span class="token punctuation">:</span> <span class="token property">localhost</span><span class="token punctuation">:</span>8848         #Nacos服务注册中心地址
    <span class="token property">sentinel</span><span class="token punctuation">:</span>
      <span class="token property">transport</span><span class="token punctuation">:</span>
        <span class="token property">dashboard</span><span class="token punctuation">:</span> <span class="token property">localhost</span><span class="token punctuation">:</span>8080 #配置Sentinel dashboard控制台服务地址
        <span class="token property">port</span><span class="token punctuation">:</span> 8719 #默认8719端口，假如被占用会自动从8719开始依次+1扫描<span class="token punctuation">,</span>直至找到未被占用的端口<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="/2024/03/05/hou-duan/wei-fu-wu-he-fen-bu-shi/%E6%87%92%E5%8A%A0%E8%BD%BD.png" class="lazyload" data-srcset="/2024/03/05/hou-duan/wei-fu-wu-he-fen-bu-shi/%E6%87%92%E5%8A%A0%E8%BD%BD.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="懒加载"></p>
<ul>
<li>流控规则<br><img src="/2024/03/05/hou-duan/wei-fu-wu-he-fen-bu-shi/%E6%B5%81%E6%8E%A7%E8%A7%84%E5%88%99.png" class="lazyload" data-srcset="/2024/03/05/hou-duan/wei-fu-wu-he-fen-bu-shi/%E6%B5%81%E6%8E%A7%E8%A7%84%E5%88%99.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></li>
<li>熔断降级<br>Sentinel 熔断降级会在调用链路中某个资源出现不稳定状态时（例如调用超时或异常比例升高），对这个资源的调用进行限制，</li>
</ul>
<p>让请求快速失败，避免影响到其它的资源而导致级联错误。当资源被降级后，在接下来的降级时间窗口之内，对该资源的调用都自动熔断（默认行为是抛出 DegradeException）。、</p>
<h3 id="如何处理分布式-事务"><a href="#如何处理分布式-事务" class="headerlink" title="如何处理分布式 事务"></a>如何处理分布式 事务</h3><h2 id="Seata"><a href="#Seata" class="headerlink" title="Seata"></a>Seata</h2><p><img src="/2024/03/05/hou-duan/wei-fu-wu-he-fen-bu-shi/senta.png" class="lazyload" data-srcset="/2024/03/05/hou-duan/wei-fu-wu-he-fen-bu-shi/senta.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="senta"></p>
<p>去官网看</p>
<p>面试题：<br><img src="/2024/03/05/hou-duan/wei-fu-wu-he-fen-bu-shi/AT%E9%9D%A2%E8%AF%95%E9%A2%98.png" class="lazyload" data-srcset="/2024/03/05/hou-duan/wei-fu-wu-he-fen-bu-shi/AT%E9%9D%A2%E8%AF%95%E9%A2%98.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="><br><img src="/2024/03/05/hou-duan/wei-fu-wu-he-fen-bu-shi/AT%E9%9D%A2%E8%AF%95%E9%A2%981.png" class="lazyload" data-srcset="/2024/03/05/hou-duan/wei-fu-wu-he-fen-bu-shi/AT%E9%9D%A2%E8%AF%95%E9%A2%981.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p>
<p><img src="/2024/03/05/hou-duan/wei-fu-wu-he-fen-bu-shi/%E6%8F%90%E4%BA%A4.png" class="lazyload" data-srcset="/2024/03/05/hou-duan/wei-fu-wu-he-fen-bu-shi/%E6%8F%90%E4%BA%A4.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="><br><img src="/2024/03/05/hou-duan/wei-fu-wu-he-fen-bu-shi/%E5%9B%9E%E6%BB%9A.png" class="lazyload" data-srcset="/2024/03/05/hou-duan/wei-fu-wu-he-fen-bu-shi/%E5%9B%9E%E6%BB%9A.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p>
<h2 id="分布式详细"><a href="#分布式详细" class="headerlink" title="分布式详细"></a>分布式详细</h2><h3 id="分布式ID-分布式ID-https-javaguide-cn-distributed-system-distributed-id-design-html"><a href="#分布式ID-分布式ID-https-javaguide-cn-distributed-system-distributed-id-design-html" class="headerlink" title="[分布式ID](### 分布式ID https://javaguide.cn/distributed-system/distributed-id-design.html)"></a>[分布式ID](### 分布式ID <a target="_blank" rel="noopener" href="https://javaguide.cn/distributed-system/distributed-id-design.html">https://javaguide.cn/distributed-system/distributed-id-design.html</a>)</h3><h4 id="需求："><a href="#需求：" class="headerlink" title="需求："></a>需求：</h4><ol>
<li>全局唯一</li>
<li>高可用</li>
<li>高性能</li>
<li>安全</li>
<li>方便易用</li>
</ol>
<h4 id="解决方式："><a href="#解决方式：" class="headerlink" title="解决方式："></a>解决方式：</h4><p>推荐使用雪花算法</p>
<h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><h4 id="Redis实现"><a href="#Redis实现" class="headerlink" title="Redis实现"></a>Redis实现</h4><h5 id="setnx"><a href="#setnx" class="headerlink" title="setnx"></a>setnx</h5><h6 id="Redisson"><a href="#Redisson" class="headerlink" title="Redisson"></a>Redisson</h6><h4 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h4><p>一个线程中可以多次获取同一把锁，例如，方法又调用了另一个需要相同锁的方法。<br>可以使用红锁</p>
<h4 id="ZooKeeper"><a href="#ZooKeeper" class="headerlink" title="ZooKeeper"></a><a target="_blank" rel="noopener" href="https://javaguide.cn/distributed-system/distributed-lock-implementations.html#%E5%9F%BA%E4%BA%8E-zookeeper-%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81">ZooKeeper</a></h4><p><a target="_blank" rel="noopener" href="https://javaguide.cn/distributed-system/distributed-process-coordination/zookeeper/zookeeper-intro.html">https://javaguide.cn/distributed-system/distributed-process-coordination/zookeeper/zookeeper-intro.html</a><br>Redis的性能更好，但是Zookeeper的可靠性更高。<br>推荐使用 Curator 来实现 ZooKeeper 分布式锁。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zuofw.github.io/2024/02/27/ai/python-and-web-or-ai/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="QingQiu">
      <meta itemprop="description" content="个人网站，学习记录，面试记录和经验总结、互联网中一块属于自己的小窝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="QingQiu'Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/02/27/ai/python-and-web-or-ai/" class="post-title-link" itemprop="url">python and web or ai</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-02-27 19:23:04" itemprop="dateCreated datePublished" datetime="2024-02-27T19:23:04+08:00">2024-02-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-03-01 20:12:49" itemprop="dateModified" datetime="2024-03-01T20:12:49+08:00">2024-03-01</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><h2 id="web"><a href="#web" class="headerlink" title="web"></a>web</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python">pip install beautifulsoup4 <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="Scrapy框架"><a href="#Scrapy框架" class="headerlink" title="Scrapy框架"></a>Scrapy框架</h2><p>项目结构:</p>
<pre class="line-numbers language-css" data-language="css"><code class="language-css">scrapy.cfg 配置文件
setting.py 定义爬虫的相关配置信息
items.py 定义待爬页面数据的结构
pipelines.py 定义存储爬到的数据的方式
middlewares.py 定义随机切换ip等逻辑
Spiders 在目录里，存放爬虫代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">scrapy startproject projectName 新建一个项目
1.在items模块中定义待爬取内容的数据结构
2.在spiders文件中
scrapy genspider name xxx.com 新建一个爬虫文件
3.pipelines中定义存储方式
4.settings中加入
ITEM_PIPELINES =</span> <span class="token punctuation">{</span>

    <span class="token string">"cnblogPrj.pipelines.CnblogprjPipeline"</span><span class="token punctuation">:</span> 300<span class="token punctuation">,</span>

<span class="token punctuation">}</span>

# 禁用cookies

COOKIES_ENABLED = False<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-none"><code class="language-none">x = float(input() )

y = float(input())

print("{:.3f} + {:.3f} = {:.3f}".format(x, y, x + y))

print("{:.3f} - {:.3f} = {:.3f}" .format (x, y, x - y))

print("{:.3f} * {:.3f} = {:.3f}" .format (x, y, x * y))

print("{:.3f} / {:.3f} = {:.3f}" .format (x, y, x / &nbsp;y))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zuofw.github.io/2023/10/23/408/ji-wang/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="QingQiu">
      <meta itemprop="description" content="个人网站，学习记录，面试记录和经验总结、互联网中一块属于自己的小窝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="QingQiu'Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/10/23/408/ji-wang/" class="post-title-link" itemprop="url">计网</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-10-23 20:01:46" itemprop="dateCreated datePublished" datetime="2023-10-23T20:01:46+08:00">2023-10-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-05-02 10:57:32" itemprop="dateModified" datetime="2024-05-02T10:57:32+08:00">2024-05-02</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="计网"><a href="#计网" class="headerlink" title="计网"></a>计网</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>MTU:网络中一次可以传输的最大数据包的大小<br>MSS:TCP中除去TCP和IP的头部，能够传输的最大的数据量<br>SDU，Service Data Unit，服务数据单元。<br>ISP 是 Internet Service Provider 的缩写，翻译为互联网服务提供商。<br>协议<br>Telnet 客户端登录协议，属于应用层<br>TLD 是 Top-Level Domain 的缩写，翻译为顶级域名<br>GBN (Go-Back-N)  退回<br>SR 选择性重传<br>mask 子网掩码<br>SDN 是指软件定义网络（Software-Defined Networking）<br>OSPF（Open Shortest Path First）是一种开放式的链路状态路由协议，用于计算机网络中的动态路由。<br>Secure sockets layer (SSL)<br>MSL:报文最大生存时间<br>TTL:经过的路由跳数<br>序列号：在建立连接时由内核生成的随机数作为其初始值，通过 SYN 报文传给接收端主机，每发送一次数据，就「累加」一次该「数据字节数」的大小。用来解决网络包乱序问题。<br>确认号：指下一次「期望」收到的数据的序列号，发送端收到接收方发来的 ACK 确认报文以后，就可以认为在这个序号以前的数据都已经被正常接收。用来解决丢包的问题。<br><strong>控制位：</strong> 用来标识 TCP 报文是什么类型的报文，比如是 SYN 报文、数据报文、ACK 报文，FIN 报文等。</p>
<h1 id="面试常问"><a href="#面试常问" class="headerlink" title="面试常问"></a>面试常问</h1><ul>
<li>UDP是面向报文的：发送方不会对报文进行拆分，所以一个报文就是一个完整的消息，接收方使用队列来区分不同报文</li>
<li>TCP是面向字节流的：粘包问题：TCP报文会拆分成多个，取决于<strong>发送窗口、拥塞窗口以及当前发送缓冲区的大小等条件</strong>，所以不容易知道一个用户消息的边界<ul>
<li><img src="/2023/10/23/408/ji-wang/TcpHeader.png"></li>
<li>控制位是单独的留出来的几个位置</li>
<li>TCP面向字节流的，发送的是一个个连续的字节，而UDP是面向数据报的，一个UDP数据报就是一个完整的消息</li>
<li>重传机制：1.超时重传，重传时间最好略大于包的往返时间，2.快速重传3.SACK重传，选择性确认&nbsp;TCP 头部「选项」字段里加一个&nbsp;<code>SACK</code>&nbsp;的东西，它<strong>可以将已收到的数据的信息发送给「发送方」</strong>，这样发送方就可以知道哪些数据收到了，哪些数据没收到，知道了这些信息，就可以<strong>只重传丢失的数据</strong>。4.   Duplicate SACK,只告诉对方有哪些数据被重复接受了</li>
<li>滑动窗口：<strong>无需等待确认应答，而可以继续发送数据的最大值</strong></li>
<li><strong>拥塞窗口 cwnd</strong>是发送方维护的一个的状态变量，它会根据<strong>网络的拥塞程度动态变化的</strong>。 网络没出现拥塞，cwnd增加，出现拥塞cwnd减少</li>
</ul>
</li>
<li>HTTP：最常使用的是HTTP/1.1 <ul>
<li>优化 HTTP/1.1<ol>
<li>减少请求次数：1.使用客户端缓存，2.减少重定向次数，3.合并请求，4.延迟发送，只发送一部分内容</li>
<li>减少响应数据大小：使用压缩方式</li>
</ol>
</li>
</ul>
<ol>
<li>Keep-Alive：用于保持长连接，keepalive，TCP中的保活机制,HTTP1.1默认是开启的，在请求头中使用<code>Connection: Keep-Alive</code></li>
<li>强制缓存：服务器直接要求使用浏览器缓存的数据， 协商缓存：服务器会对比缓存过期时间，决定是否过期，返回给浏览器决定是否使用浏览器的缓存</li>
<li>队头阻塞：服务端在处理请求时耗时较长导致后面的请求无法即使发送，解决方式 ：使用管道：客户端可以直接发送多个请求，服务端根据发送顺序来解决，但是管道技术基本 <strong>没人使用</strong></li>
</ol>
<ul>
<li>演进过程：<ol>
<li>1.1 使用长连接改善短链接的性能开销，使用管道进传输，改善了队头阻塞。缺点是：header未压缩，只能压缩body,只能从客户端开始发送请求，没有请求优先级</li>
<li>2 头部压缩，当同时发送多个请求，如果请求头是一样或者相似的就把重复发部分消除，基于HTTPS的，头部全部使用二进制格式取代原来的纯文本，使用Stream,一个Stream可以包含多个Message,Message中可以包含多个Frame,Frame中包含Headers和Body,Stream都跑在同一个TCP上，客户端收到后会根据相同的Stream ID 有序组装成HTTP消息，Stream流用于多路复用TCP<ul>
<li>缺点是：由于TCP的是基于字节流的，必须保证收到的字节数据是完整且恋雪的才能将数据返回给应用层</li>
</ul>
</li>
<li>HTTP/3 使用UDP协议来解决响应的队头阻塞。<ol>
<li>使用基于UDP的QUIC协议，保证类似的可靠传输</li>
<li>QUIC 有自己的一套机制可以保证传输的可靠性的。当某个流发生丢包时，只会阻塞这个流，其他流不会受到影响，因此不存在队头阻塞问题。这与 HTTP/2 不同，HTTP/2 只要某个流中的数据包丢失了，其他流也会因此受影响。</li>
<li>当某个流丢包时，只会阻塞这个流，其他流不会阻塞，不存在队头阻塞问题</li>
<li><a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/2_http/https_rsa.html#tls-%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B">RSA算法</a>不支持前向加密，只要获取浏览器的私钥，即可破解</li>
<li></li>
</ol>
</li>
</ol>
</li>
</ul>
</li>
<li>HTTPS: <ol>
<li>使用混合加密：通信建立前使用非对称加密来交换会话密钥， 通信过程中使用对称加密的会话密钥来进行通信</li>
<li>公钥运算出的结果，只有使用私钥来进行逆运算得到结果。 发送时，发送者使用接收者的公钥，公钥是可知的，解决了密钥交换的问题，接收者使用自己的私钥进行解密。</li>
<li>公钥加密，私钥解密：保证传输过程中内容的加密</li>
<li>私钥加密，公钥解密：保证消息不会被篡改。—&gt;数字签名算法</li>
<li>使用权威机构CA(数字证书认证机构)来保存数字证书：个人信息+公钥+数字签名</li>
</ol>
</li>
<li>TCP<ul>
<li>三次握手的过程<ol>
<li>客户端发送带有SYN(同步序列)SEQ(序列号) = x  标志的数据包，客户端进入SYN_SEND状态</li>
<li>服务端发送带有SYN(SEQ = y) + ACK (ACK = x + 1) 标志的数据包，进入SYN_RECV状态</li>
<li>客户端发送 带有ACK(ACK = y + 1) 标志的数据包，二者进入ESTABLISHED状态</li>
</ol>
<ul>
<li>为什么要第二次传回SYN 用于表明所收到的是对应的客户端发送的信号</li>
</ul>
</li>
<li>四次挥手:<ol>
<li>客户端发送FIN(SEQ = x) ，进入FIN-WAIT-1状态</li>
<li>服务端发送ACK(ACK=x+1) 进入CLOSE-WAIT状态，客户端进入FIN-WAIT-2</li>
<li>服务端发送FIN(SEQ=y) 请求关闭,进入LAST-ACK</li>
<li>客户端发送，ACK(ACK=y+1) ，客户端进入TIME-WAIT，服务端接收后进入CLOSE，客户端等待一段时间之后如果没有收到回复，就关闭客户端。</li>
</ol>
</li>
<li>可不可以把ACK和FIN合并起来变成三次挥手： 不行，因为服务器收到断开请求时，可能还有一些数据没有传输完成，所以先发送ACK表明收到请求，等待所有数据发送完成之后发送FIN断开连接</li>
</ul>
</li>
<li>IP<ul>
<li>DNS:域名解析：</li>
<li>DHCP（动态主机配置协议）是一个网络协议，用于自动分配 IP 地址和其他相关配置信息给网络中的设备。这使得设备可以在加入网络时自动获取网络配置，无需手动设置。</li>
<li>ARP工作原理：广播问询，单播响应<ul>
<li>一个局域网中<ol>
<li>维护一个ARP表 &lt;IP,MAC,TTL&gt;</li>
<li>查询ARP表，如果不存在，则构造一个ARP查询分组，将其广播到局域网中，MAC地址为广播地址，然后希望收到的是IP地址</li>
<li>设备接收后查询是否为自己的IP，如果不是则丢弃，如果是，则构造ARP响应分组，发送给查询主机，并在自己的表中构造一条查询主机的IP-MAC映射表，使用的是单播，不再广播</li>
<li>查询的主机接受后，将其加入ARP表中</li>
</ol>
</li>
<li>不在一个局域网中：通过路由器转发查询</li>
</ul>
</li>
<li>NAT:同一个场景下将私有IP转化为共有IP地址</li>
<li>ICMP：互联网控制报文协议，确认Ip包是否<ul>
<li>ping：基于ICMP协议工作的，使用的ICMP类型中0和8，也就是回送应答和会送请求，根据这个来判断是否到达IP地址，如果路由器中间没有找到对应的接收端IP就会往发送端IP发送ICMP报文，8是源主机向目标主机的发送的请求，0是目标主机的回应</li>
<li>各种本地IP代指的区别：<ol>
<li>localhost 默认就是同于127.0.0.1，但是可以修改，是属于域名</li>
<li>0.0.0.0 IPv4中是无效地址，代指的是广播，监听本地的0.0.0.0时，代表的监听本机上所有的IPv4地址</li>
<li>127.0.0.1是回环地址</li>
</ol>
</li>
</ul>
</li>
<li>IGMP：Internet组管理协议，工作哎主机和最后一跳的路由之间。</li>
<li>为何断网了也能ping通127.0.0.1? 因为会把消息交给本地网卡，本地网卡直接把消息发送到本机接受到的消息链表中并触发软中断，由内核线程来传递给上层应用程序</li>
</ul>
</li>
</ul>
<h2 id="网络核心"><a href="#网络核心" class="headerlink" title="网络核心"></a>网络核心</h2><p>概念：路由器的网状网络<br>提问： 数据怎么通过网络进行传输？</p>
<ul>
<li>电路电路交换：  不可共享资源，会造成资源浪费，不适合计算机之间的通讯，计算机通信的特点： 突发性，耗时短</li>
<li>分组交换： 存储 – 转发  ， 数据转发过程中使用所有的资源，而不是使用一部分pieces，会将所有的的分组都存储之后再进行转发，方便共享的实现</li>
</ul>
<h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><ol>
<li>应用架构<ul>
<li>CS体系 客户-服务器:<ul>
<li>服务器： 一直运行，固定ip和周知的端口号，扩展性差</li>
<li>客户端： 主动与服务器通信，可能是动态ip，不直接与其他客户端通信</li>
</ul>
</li>
<li>P2P 每个端都可以作为服务器，点对点</li>
<li>混合体 c/s + P2P</li>
</ul>
</li>
<li>TCP socket ：对于面向连接服务（TCP) 的应用而言，socket是四元组的一个具有本地意义的标示,相当于一个记录特定会话的指针，只需要用socket就可以指定这个应用<ul>
<li>socket 其实是应用层和传输层之间的，使得允许应用能发起通信，与其他主机上的应用进程进行通信</li>
<li>4元组  源IP 源port 目标IP 目标port</li>
<li>唯一指定了一个会话</li>
<li>应用使用这个标示，与远程的应用进程进行通讯</li>
<li>不必在每一个报文中都指定这四元组</li>
<li>udp 只提供源主机的ip 和 port</li>
</ul>
</li>
<li>WebSocket 工作过程：<ol>
<li>客户端发送一个HTTP请求，包含升级字段</li>
<li>服务器接收之后,进行协议升级，如果支持，会返回一个101状态码，包含一些对应响应头</li>
<li>进行双向通信，数据以帧的方式传送。</li>
<li>其中一方发送一个关闭帧，二者关闭TCP连接</li>
<li>通过心跳机制保证WebSocket的稳定性和活跃性</li>
</ol>
</li>
<li>UDP socket<br> UDP 两个进程之间的通信之前不需要建立连接，每个报文独立传输，前后报文可能给不同的分布式进程<br> udp socket 记录本IP 本port 但是传输报文时，需要提供对方ip， port ,接收报文时传输层需要上传对方IP port<br> 二元组： 源IP  源port</li>
</ol>
<p>TCP 服务：</p>
<ul>
<li><p>可靠的传输服务</p>
</li>
<li><p>流量控制：发送方不会淹</p>
</li>
</ul>
<p>没接受方</p>
<ul>
<li>拥塞控制：当网络出现拥</li>
</ul>
<p>塞时，能抑制发送方</p>
<ul>
<li><p>不能提供的服务：时间保证、最小吞吐保证和安全</p>
</li>
<li><p>面向连接：要求在客户端进程和服务器进程之间建立连接</p>
</li>
</ul>
<p>UDP 服务：</p>
<ul>
<li><p>不可靠数据传输</p>
</li>
<li><p>不提供的服务：可靠，流量控制、拥塞控制、时间、带宽保证、建立连接<br>UDP存在的必要性</p>
</li>
<li><p>能够区分不同的进程，而IP服务不能</p>
</li>
<li><p>在IP提供的主机到主机端到端功能的基础上，区分了主机的</p>
</li>
</ul>
<p>应用进程</p>
<ul>
<li>无需建立连接，省去了建立连接时间，适合事务性的</li>
</ul>
<p>应用</p>
<ul>
<li>不做可靠性的工作，例如检错重发，适合那些对实时</li>
</ul>
<p>性要求比较高而对正确性要求不高的应用</p>
<ul>
<li>因为为了实现可靠性（准确性、保序等），必须付出时间代</li>
</ul>
<p>价（检错重发）</p>
<ul>
<li>没有拥塞控制和流量控制，应用能够按照设定的速度</li>
</ul>
<p>发送数据</p>
<ul>
<li>而在TCP上面的应用，应用发送数据的速度和主机向网络发送</li>
</ul>
<p>的实际速度是不一致的，因为有流量控制和拥塞控制</p>
<ul>
<li>安全TCP<br>  TCP和UDP都没有加密，明文传输<br>  使用SSL协议来实现加密，在TCP的基础上实现，提供加密的TCP，私密性，数据完整性，段堆到端的鉴别<br>  SSL socket API 应用通过API将铭文交给socket，SSL将其加密<br>URL : 访问协议 + 用户名 + 口令字 + 端口等</li>
</ul>
<h3 id="常见的应用层协议"><a href="#常见的应用层协议" class="headerlink" title="常见的应用层协议"></a>常见的应用层协议</h3><h2 id="HTTP面试常问-状态码：-1-200-2-204-No-Content-响应头没有body数据-3-206-Partial-Content-表示返回的body数据不是资源的全部，只是一部分-4-301-Moved-Permanently-永久重定向，请求的资源已经不存在的-5-302-Found-表示临时重定向，301，302都会在响应头中使用字段Location指明后续要跳转URL-浏览器会自动重定向到新的URL-6-304：Not-Modified-告诉客户端可以接着使用缓存资源-7-400Bad-Request-报文有错-8-403-Forbidden-禁止访问-9-404-Not-Found-资源不存在或者没找到-10-500-Internal-Server-Error-服务器内部错误-11-501-Not-Implemented-客户端请求还不支持-12-502-Bad-Gateway-通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。-13-03-Service-Unavailable-服务器忙，暂时无法响应-缓存技术：把请求-响应的数据存到本地，下一次直接都本地数据，不需要等待服务器的想用了-1-强制缓存-Cache-Control，-是一个相对时间；-Expires，是一个绝对时间；-2-协商缓存-在强制缓存未命中时，服务器第一次请求资源时，会在Response头部加上ETag唯一表示-当浏览器再次请求访问服务器中的资源时，先检查缓存是否过期，如果没有过期直接使用本地缓存，如果过期了会在Request头部上加上If-None-Match紫萼段-服务器再次收到请求之后，会根据请求中的If-None-Match值是否与当前请求的资源生成的唯一标识比较-如果值相等，返回304-Not-Modified-不会返回资源-如果不相等，则返回-200-状态码和返回资源，并在-Response-头部加上新的-ETag-唯一标识；-浏览器收到304响应码，会从本地加载资源否则更新资源。-HTTP-x2F-1-1-的优点：简单灵活、应用广泛-缺点是：无状态一方面可以不需要服务器使用额外的资源来记录状态信息-坏处是：进行关联性操作时，需要每次都验证一次身份-解决方法：使用Cookie"><a href="#HTTP面试常问-状态码：-1-200-2-204-No-Content-响应头没有body数据-3-206-Partial-Content-表示返回的body数据不是资源的全部，只是一部分-4-301-Moved-Permanently-永久重定向，请求的资源已经不存在的-5-302-Found-表示临时重定向，301，302都会在响应头中使用字段Location指明后续要跳转URL-浏览器会自动重定向到新的URL-6-304：Not-Modified-告诉客户端可以接着使用缓存资源-7-400Bad-Request-报文有错-8-403-Forbidden-禁止访问-9-404-Not-Found-资源不存在或者没找到-10-500-Internal-Server-Error-服务器内部错误-11-501-Not-Implemented-客户端请求还不支持-12-502-Bad-Gateway-通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。-13-03-Service-Unavailable-服务器忙，暂时无法响应-缓存技术：把请求-响应的数据存到本地，下一次直接都本地数据，不需要等待服务器的想用了-1-强制缓存-Cache-Control，-是一个相对时间；-Expires，是一个绝对时间；-2-协商缓存-在强制缓存未命中时，服务器第一次请求资源时，会在Response头部加上ETag唯一表示-当浏览器再次请求访问服务器中的资源时，先检查缓存是否过期，如果没有过期直接使用本地缓存，如果过期了会在Request头部上加上If-None-Match紫萼段-服务器再次收到请求之后，会根据请求中的If-None-Match值是否与当前请求的资源生成的唯一标识比较-如果值相等，返回304-Not-Modified-不会返回资源-如果不相等，则返回-200-状态码和返回资源，并在-Response-头部加上新的-ETag-唯一标识；-浏览器收到304响应码，会从本地加载资源否则更新资源。-HTTP-x2F-1-1-的优点：简单灵活、应用广泛-缺点是：无状态一方面可以不需要服务器使用额外的资源来记录状态信息-坏处是：进行关联性操作时，需要每次都验证一次身份-解决方法：使用Cookie" class="headerlink" title="#HTTP面试常问- 状态码：    1. 200    2. 204 No Content 响应头没有body数据    3. 206 &nbsp;Partial Content 表示返回的body数据不是资源的全部，只是一部分    4. 301 Moved Permanently 永久重定向，请求的资源已经不存在的    5. 302: Found: 表示临时重定向，301，302都会在响应头中使用字段Location指明后续要跳转URL,浏览器会自动重定向到新的URL    6. 304：Not Modified 告诉客户端可以接着使用缓存资源    7. 400Bad Request 报文有错    8. 403 Forbidden 禁止访问    9. 404 Not Found 资源不存在或者没找到    10. 500 Internal Server Error 服务器内部错误    11. 501 Not Implemented 客户端请求还不支持    12. 502 Bad Gateway 通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。    13. 03 Service Unavailable 服务器忙，暂时无法响应- 缓存技术：把请求-响应的数据存到本地，下一次直接都本地数据，不需要等待服务器的想用了    1. 强制缓存        - Cache-Control， 是一个相对时间；        - Expires，是一个绝对时间；    2. 协商缓存        - 在强制缓存未命中时，服务器第一次请求资源时，会在Response头部加上ETag唯一表示        - 当浏览器再次请求访问服务器中的资源时，先检查缓存是否过期，如果没有过期直接使用本地缓存，如果过期了会在Request头部上加上If-None-Match紫萼段        - 服务器再次收到请求之后，会根据请求中的If-None-Match值是否与当前请求的资源生成的唯一标识比较            - 如果值相等，返回304 Not Modified 不会返回资源            - 如果不相等，则返回 200 状态码和返回资源，并在 Response 头部加上新的 ETag 唯一标识；        - 浏览器收到304响应码，会从本地加载资源否则更新资源。- HTTP/1.1 的优点：简单灵活、应用广泛    - 缺点是：无状态一方面可以不需要服务器使用额外的资源来记录状态信息    - 坏处是：进行关联性操作时，需要每次都验证一次身份    - 解决方法：使用Cookie"></a>#HTTP面试常问<br>- 状态码：<br>    1. 200<br>    2. 204 No Content 响应头没有body数据<br>    3. 206 &nbsp;<strong>Partial Content</strong> 表示返回的body数据不是资源的全部，只是一部分<br>    4. 301 <strong>Moved Permanently</strong> 永久重定向，请求的资源已经不存在的<br>    5. 302: Found: 表示临时重定向，301，302都会在响应头中使用字段Location指明后续要跳转URL,浏览器会自动重定向到新的URL<br>    6. 304：<strong>Not Modified</strong> 告诉客户端可以接着使用缓存资源<br>    7. 400<strong>Bad Request</strong> 报文有错<br>    8. 403 <strong>Forbidden</strong> 禁止访问<br>    9. 404 <strong>Not Found</strong> 资源不存在或者没找到<br>    10. 500 <strong>Internal Server Error</strong> 服务器内部错误<br>    11. <strong>501 Not Implemented</strong> 客户端请求还不支持<br>    12. <strong>502 Bad Gateway</strong> 通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。<br>    13. <strong>03 Service Unavailable</strong> 服务器忙，暂时无法响应<br>- 缓存技术：把请求-响应的数据存到本地，下一次直接都本地数据，不需要等待服务器的想用了<br>    1. 强制缓存<br>        - <code>Cache-Control</code>， 是一个相对时间；<br>        - <code>Expires</code>，是一个绝对时间；<br>    2. 协商缓存<br>        - 在强制缓存未命中时，服务器第一次请求资源时，会在Response头部加上ETag唯一表示<br>        - 当浏览器再次请求访问服务器中的资源时，先检查缓存是否过期，如果没有过期直接使用本地缓存，如果过期了会在Request头部上加上If-None-Match紫萼段<br>        - 服务器再次收到请求之后，会根据请求中的If-None-Match值是否与当前请求的资源生成的唯一标识比较<br>            - 如果值相等，返回304 Not Modified 不会返回资源<br>            - 如果不相等，则返回 200 状态码和返回资源，并在 Response 头部加上新的 ETag 唯一标识；<br>        - 浏览器收到304响应码，会从本地加载资源否则更新资源。<br>- HTTP/1.1 的优点：简单灵活、应用广泛<br>    - 缺点是：无状态一方面可以不需要服务器使用额外的资源来记录状态信息<br>    - 坏处是：进行关联性操作时，需要每次都验证一次身份<br>    - 解决方法：使用Cookie</h2><ul>
<li><p>HTTP：超文本传输协议 HTTP默认80 HTTPS默认 443</p>
<ul>
<li>流程： 1. 客户发起一个与服务器的TCP连接，(建立socket) 2. 服务器接受TCP 连接 3. 浏览器和web服务器之间交换HTTP报文 4. TCP连接关闭 </li>
<li>HTTP 是无状态的连接，不会维护任何和客户有关的信息，这时候就需要websocket了</li>
<li>HTTP/1.1 之后默认使用持久连接，保证了多个u第项可以在一个TCP连接上传输 ，非持久连接下载多个文件需要及案例多个TCP连接<br> 响应时间<br> 往返时间 RTT round - trip - time： 一个小的分组从客户端到服务器，再回到客户端的时间，传输时间忽略不计<br> 响应时间为： 2RTT + 传输时间<br> 1. 一个RTT 用来发起TCP请求<br> 2. 一个用来HTTP请求和等待响应<br> 3. 文件传输时间<br> <strong>持久HTTP</strong> ： 一个TCP连接建立之后，不会断开然后进行多个HTTP请求<br> 服务器在发送响应之后仍然保持TCP连接<br> 在相同客户端和服务器之间的后续请求和响应报文通过相同的连接进行传送<br> 客户端，在遇到一个引用对象的时候就可以尽快的发送该对象的请求，<br> 1. 每个对象要两个RTT<br> 2. 操作系统必须为每一个TCP连接分配资源，但是浏览器通常并行打开TPC连接，以获得引用对象<br> 两种方式：<br>     1. 非流线方式的持久HTTP，客户端只能在前一个HTTP请求响应之后才能发送新的请求，每个引用对象花费一个RTT<br>     2. 流水线方式：客户端遇到一个引用对象（一个小的ui所指的资源）之后就立即产生一个请<br>     3. 所有(小)的引用对象只花费一个RTT是有可能的<br> HTTP 报文格式 ： 请求行 + 请求头 + (request body)<br> tips : PUT 请求是将实体对象中文件载到URL指定的路径(一般是更新资源)<br> POST 不需要在URL 中指定资源位置，一般用于创建资源<ul>
<li>缓存：命中率(h)： 百分之多少的请求可以在缓存中满足</li>
<li>接入链路的利用率:  (1-h) *  请求速率 / 带宽</li>
</ul>
</li>
</ul>
</li>
<li><p>FTP 文件传输协议(基于TCP)<br> ftp服务器端口号默认为 21，需要建立两个TCP连接，一个用于控制，一个用于传输</p>
</li>
<li><p>SMIT 电子邮件的邮件传输协议 (默认端口25)<br>  用于上传邮件，和HTTP的区别，HTTP的每个对象封装在各自的响应报文中，SMIT可以将多个 引用对象封装在一个报文中<br>  报文格式：<br>  HEAD<br>  To :<br>  From :<br>  Subject:<br>  BODY:<br>  报文</p>
<ul>
<li>MIME 多媒体邮件扩展</li>
<li>POP 邮局访问协议 用户确认身份(代理 &lt;–&gt;服务器)并下载<ul>
<li>POP3 不保留会话状态 本地管理文件夹</li>
</ul>
</li>
<li>IMAP Internet 邮件访问协议，保留用户状态 远程管理文件夹</li>
</ul>
</li>
<li><p><em>DNS</em> Domain Name System 建立IP 地址和 对应域名之间的映射<br>  <strong><em>DNS默认默认端口是53</em></strong><br>  主要思路：分层，基于域的命名机制，在若干分布式的数据库上完成转换<br>  也可以做到负载均衡<br>  域名结构：使用层次树状结构来进行命名<br>  域名结构：从本域开始往上直至树根，域严格遵循组织界限，而不是物理网络<br>  DNS 记录格式<br>  RP格式: (name,value,type , ttl)<br>  type=A  时， name 为主机 value 为IP<br>  =CNAME  Name 为规范名字的别名<br>  =NS           Name 为域名 (foo.com) value 为该域名的权威服务器的域名<br>  =MX          Value 为name对应邮件服务器名字</p>
<ul>
<li>应用调用 解析器(resolver)</li>
<li>解析器作为客户 向Name Server发出查询报文（封装在UDP段中）</li>
<li>Name Server返回响应报文(name/ip)</li>
<li>本地名字服务器 Local Name Server 起到代理的作用，将查询转发到DNS服务器<ul>
<li>不严格属于层次结构，每个ISP 都有一个本地DNS，优先去本地DNS服务器中查询</li>
<li>递归查询：本地LNS 无，<strong>直接</strong> 去找权威服务器，然后从权威服务器往下开始查询，只需要向一个服务器去请求，然后由这个服务器去查询或者去向其他服务器来进行查找，最终由这个服务器来返回结果</li>
<li>迭代查询：转发到服务器，如果这个服务器没有就告诉发起请求的服务器要去查询下个一个服务器，由请求服务器去接着请求其他服务器，最终由能查询到的服务器来返回结果，就可以降低根服务器的负荷了</li>
</ul>
</li>
<li>缓存，一旦名字服务器得到了一个映射，就将该映射缓存起来，根服务器一般在本地服务器中缓存着，使用TTL (Time to Live)</li>
<li>攻击DNS的方法： <ul>
<li>DDoS攻击：对根服务器进行流量轰炸，发送大量的ping</li>
<li>向TLD(权威，顶级域名)攻击</li>
<li>重定向攻击：</li>
</ul>
</li>
</ul>
</li>
<li><p>CDN 内容分发网络：在CDN节点中存储内容的多个拷贝，用户请求重定向到最近的一个CDN节点</p>
</li>
</ul>
<h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><p>提供服务：为运行在不同主机上应用程序提供逻辑通信<br>数据元为报文段<br>与网络层的区别：网络层提供不同主机之间的逻辑通信，传输层提供的应用程序之间的通讯<br>tips：TCP和UDP都不提供延时保证和带宽保证，都支持多路复用和解复用，TCP额外提供拥塞控制和流量控制，以及建立连接</p>
<ul>
<li>多路复用/解复用：多路复用指的是许多个信号或数据流共享同一物理通信通道，解复用指的是根据报文段的头背部信息中的IP地址和端口号将接受的报文段发给正确的socket</li>
<li>为何要有UDP ： <ol>
<li>不建立连接(会增加延时)</li>
<li>简单：在发送端和接收端没有连接状态</li>
<li>报文段的头部很小(开销小)</li>
<li>无阻塞控制和流量控制可以保证UDP尽快的发送报文段，应用-&gt; 传输速率 = 主机 -&gt; 网络的速率</li>
<li><u>UDP也会进行校验，但是只是通过校验和的方式来检测是否遭到篡改</u></li>
</ol>
</li>
<li>RDT 是一种模型: RDT（Reliable Data Transfer）是一种可靠的数据传输协议，用于在不可靠的通信信道上实现可靠的数据传输。<ol>
<li>RDT 1.0（停等协议）：相信信道可靠<ul>
<li>发送方只发送一次数据，不进行重传。</li>
<li>接收方只接受一次数据，不进行重传请求。</li>
<li>适用于理想化的通信信道，不考虑错误和丢失。</li>
</ul>
</li>
<li>RDT 2.0（回退N协议）： 相信会出现bits errors<ul>
<li>使用checksum 来进行错误检验</li>
<li>引入了有限状态自动机，来切换来指定发送者和接收者</li>
<li>发送方发送数据帧，并等待接收方的确认帧。</li>
<li>接收方接收数据帧，发送确认帧。</li>
<li>如果发送方未收到确认帧，它将重传数据帧。</li>
<li>接收方可能收到重复的数据帧，但通过带有序号的数据帧来排除重复。</li>
<li>问题：如果ACK或者NCK传错了，就会重复</li>
</ul>
</li>
<li>RDT 3.0 <ul>
<li>机制：在超过合理时间之后进行重传</li>
<li><ul>
<li>如果package（或ACK）只是被延迟了：</li>
<li>重传将会导致数据重复，但利用序列号已经可以处理这个问题</li>
<li>接收方必须指明被正确接收的序列号</li>
</ul>
</li>
</ul>
</li>
</ol>
<ul>
<li>需要一个倒计数定时器<ol>
<li>停等协议：发送方发送一个分组，然后等待接收方的应答</li>
<li>ACK NAK   NAK 是negative ACK</li>
</ol>
</li>
</ul>
</li>
<li>TCP:<ul>
<li>点对点：一个发送方，一个接收方 </li>
<li>可靠的、按顺序的字节流：没有报文边界 </li>
<li>管道化：TCP拥塞控制和流量控制设置窗口的大小</li>
<li>面向连接：交换数据之前，通过握手来初始化双方的状态变量</li>
<li>流量控制：发送方不会淹没接收方</li>
<li><img src="/2023/10/23/408/ji-wang/tcp%E6%8A%A5%E6%96%87.png" alt="tcp报文"></li>
<li>序号：报文段首字节在字节流的编号</li>
<li>确认号：期望从另一方收到的下一个字节的序号</li>
<li>TCP超时时间= EstimatedRTT + 安全边界时间</li>
<li>。。。。待续</li>
</ul>
</li>
</ul>
<h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><p>DU 为 数据包</p>
<ul>
<li>服务：在发送和接收主机之间传送段</li>
<li>功能：<ul>
<li>转发：将分组从路由器的输入接口转发到合适的输出接口上</li>
<li>路由：使用路由算法来决定分组从发送主机到目标接收主机的路径</li>
</ul>
</li>
<li>数据平面：转发</li>
<li>控制平面：路径</li>
<li>路由器的结构：<ul>
<li>路由：运行路由选择算法生成路由表</li>
<li>转发：从输入到输出链路交换数据报，根据路由表进行分组的转发</li>
</ul>
</li>
<li>查表方式： <ul>
<li>最长前缀匹配</li>
</ul>
</li>
<li>交换结构：<ul>
<li>通过内存交换，在cpu的直接控制下进行交换</li>
<li>使用总线进行交换： 数据报通过共享总线进行转发，交换速度受限于总线带宽</li>
<li>使用互联网络进行交换</li>
</ul>
</li>
<li>调度机制： 调度指的是选择下一个要通过链路交换的分组<ul>
<li>FIFO</li>
<li>优先权调度</li>
<li>轮询</li>
</ul>
</li>
<li>IP<ul>
<li>IP地址是对主机或者路由器的接口进行编址</li>
<li>接口指的是 主机/路由器 和 物理链路的连接处</li>
<li>关系是1 : 1</li>
<li><strong>子网</strong>：<ol>
<li>一个子网内的节点，他们IP地址的高位部分都相同，这些节点叫做子网</li>
<li>无需路由器介入，子网内的个主机在物理上是可以直接打到</li>
<li>将子网掩码转为二进制，则为1的部分代表着IP地址中的这一部分是网络中的地址，为0的部分是标识子网中的主机</li>
</ol>
</li>
<li>分类：根据第一个8位bit来进行分类<ul>
<li>A 类 最高位固定为0：也就是 1 - 126  7 位网络  24 位主机</li>
<li>B : 10  128 - 191 14位 网络 16主机</li>
<li>C : 110 192 - 223  21位 网络  8位主机</li>
<li>D : 224 - 239 用于多播</li>
<li>E : 240 - 255 保留用于实验和研究目的</li>
</ul>
</li>
<li>CIDR Classless InterDomain Routing 无类域间路由<ul>
<li>也就是 a.b.c.d/x x是子网掩码(mask)</li>
</ul>
</li>
<li>NAT 网络地址转换 <ul>
<li>将私有网络中的内部IP映射到公共网络中的单个IP地址</li>
</ul>
<ol>
<li><p>节省IP地址：NAT允许多个内部设备共享一个公共IP地址，因此可以延长IPv4地址池的使用寿命。</p>
</li>
<li><p>增强网络安全性：因为内部设备的私有IP地址不直接暴露在互联网上，NAT提供了一层基本的安全性，可以隐藏内部网络结构。</p>
</li>
<li><p>简化网络管理：NAT可以使网络管理员更轻松地管理多台设备，而无需为每个设备分配唯一的公共IP地址。</p>
</li>
</ol>
</li>
</ul>
</li>
<li>IPv6 <ul>
<li>IPv4和IPv6通信方式：隧道 Tunneling， 在IPv4路由器之间传输的IPv4报文中携带PIv6的报文</li>
</ul>
</li>
<li>SDN</li>
<li>OpenFlow</li>
<li>route 路由，按照某种指标找到一条从源节点到目标节点的较好路径<ul>
<li>路由算法分为 全局和 分布式</li>
<li>全局：<ul>
<li>所有边都拥有完整(所有的拓扑)的拓扑和边的代价的信息</li>
<li>link state  LS  链路状态路由选择算法</li>
</ul>
</li>
<li>分布式: <ul>
<li>路由器只知道与它物理连接关系的邻居路由器和到响应邻居路由器的代价</li>
<li>迭代的与邻居路由器交换路由信息，计算路由信息</li>
<li>distance vector DV算法  距离矢量路由选择算法</li>
</ul>
</li>
</ul>
</li>
<li>RIP（Routing Information Protocol）是一种用于计算机网络中的距离矢量路由协议</li>
<li>OSP</li>
<li>DNS 主机向要访问-&gt;向DNS查询IP地址-&gt;所查询的DNS服务器未知要查询的IP地址-&gt;向根域名服务器查询-&gt;根域名服务器收录了这个地址 -&gt;返回地址给客户端-&gt;客户端建立通信<br>网络层解决一个两个网络之间的问题，链路层要解决点对点传输的问题</li>
<li><strong>ARP</strong>:以目标IP地址为线索，来定位下一个应该接受数据分包的网络设备的MAC地址，沟通IP和MAC地址 **IP-&gt;MAC **数据元为 frame 帧，帧的头部时使用MAC地址来标示源和目的地<ul>
<li>ARP记录一个&lt;IP,MAC,TTL&gt; 的表，TTL是生存周期</li>
</ul>
</li>
<li><strong>RARP</strong> MAC-&gt;IP<br>实现是在适配器上实现的，例如以太网卡</li>
<li>WAN 广域网 网络形式采用点到点链路</li>
<li>LAN 局域网 一般采用多点连接的方式</li>
<li>奇偶校验<ul>
<li>单bit奇偶校验只能检测单个bit级别的错误，不能纠错</li>
<li>二维奇偶校验可以检测和纠正单个bit错误</li>
<li>checksum </li>
<li>CRC 循环冗余校验</li>
</ul>
</li>
</ul>
<h3 id="网络接口层：等价数据链路层，使用mac地址"><a href="#网络接口层：等价数据链路层，使用mac地址" class="headerlink" title="网络接口层：等价数据链路层，使用mac地址"></a>网络接口层：等价数据链路层，使用mac地址</h3><ul>
<li><p>NIC的驱动程序</p>
</li>
<li><p>NIC 是网络适配器，也就是网卡</p>
</li>
<li><p>PPP也属于数据链路层</p>
</li>
</ul>
<h2 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h2><h4 id="OSI参考模型-有七个分层"><a href="#OSI参考模型-有七个分层" class="headerlink" title="OSI参考模型 有七个分层"></a>OSI参考模型 有七个分层</h4><p>自上而下 每一层的功能和作用由协议规定，协议的内容是规范</p>
<ol>
<li><p><strong>应用层</strong></p>
<ul>
<li>针对特定应用的协议</li>
</ul>
</li>
<li><p><strong>表示层</strong></p>
<ul>
<li>设备固有数据格式和网络标准数据格式 比如：接受不同表现形式的信息</li>
</ul>
</li>
<li><p><em>会话层</em></p>
<ul>
<li>负责通信管理，负责建立连接和断开，管理传输层以下的分层</li>
</ul>
</li>
<li><p><strong>传输层</strong></p>
<ul>
<li>管理两个节点之间的数据传输，负责可靠传输</li>
</ul>
</li>
<li><p><strong>网络层</strong></p>
<ul>
<li>路由选择与地址管理</li>
</ul>
</li>
<li><p><strong>数据链路层</strong></p>
<ul>
<li>互连设备之间传送，和 识别数据帧</li>
</ul>
</li>
<li><p><strong>物理层</strong></p>
<ul>
<li>界定连接器和网线的规格，比特流和电子信号转换</li>
</ul>
</li>
</ol>
<h2 id="网络安全"><a href="#网络安全" class="headerlink" title="网络安全"></a>网络安全</h2><ul>
<li>对称加密：发送方和接收方的密钥相同</li>
<li>公开密钥加密：发送方使用接收方的公钥进行加密，接收方使用自己的私钥进行解密</li>
<li>数字签名：</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zuofw.github.io/2023/10/21/xiang-mu-jian-li-shi-xi/jian-li/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="QingQiu">
      <meta itemprop="description" content="个人网站，学习记录，面试记录和经验总结、互联网中一块属于自己的小窝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="QingQiu'Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/10/21/xiang-mu-jian-li-shi-xi/jian-li/" class="post-title-link" itemprop="url">简历</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-10-21 10:10:39" itemprop="dateCreated datePublished" datetime="2023-10-21T10:10:39+08:00">2023-10-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-11-03 17:38:35" itemprop="dateModified" datetime="2023-11-03T17:38:35+08:00">2023-11-03</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>国外的那些课的实验是可以写在简历上的比如 15445<br>苍穹外卖项目 + 服务器部署</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zuofw.github.io/2023/10/16/hou-duan/ji-zu/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="QingQiu">
      <meta itemprop="description" content="个人网站，学习记录，面试记录和经验总结、互联网中一块属于自己的小窝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="QingQiu'Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/10/16/hou-duan/ji-zu/" class="post-title-link" itemprop="url">计组</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-10-16 19:11:48" itemprop="dateCreated datePublished" datetime="2023-10-16T19:11:48+08:00">2023-10-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-12-24 20:43:08" itemprop="dateModified" datetime="2023-12-24T20:43:08+08:00">2023-12-24</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>海明码:<a target="_blank" rel="noopener" href="https://www.cnblogs.com/godoforange/p/12003676.html">https://www.cnblogs.com/godoforange/p/12003676.html</a><br><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1t4411e7LH?p=38&amp;spm_id_from=pageDriver&amp;vd_source=603b67fa519e58ee792d9e969a3ad8a1">https://www.bilibili.com/video/BV1t4411e7LH?p=38&amp;spm_id_from=pageDriver&amp;vd_source=603b67fa519e58ee792d9e969a3ad8a1</a></p>
<h2 id="基本名词解释"><a href="#基本名词解释" class="headerlink" title="基本名词解释"></a>基本名词解释</h2><p>PC 程序计数器<br>IR 指令寄存器，存放当前正在执行的指令，<br>MAR<br>CU 控制单元，为控制器的核心部件，其功能是产生微操作命令序列。<br>ALU：Arithmetic Logic Unit，算术逻辑运算单元，为运算器的核心部件，其功能是进行算术、逻辑运算。<br>ACC：Accumulator，累加器，是运算器中既能存放运算前的操作数，又能存放运算结果的寄存器。<br>MQ：Multiplier-Quotient Register，乘商寄存器，乘法运算时存放乘数、除法时存放商的寄存器。<br>MAR：Memory Address Register，存储器地址寄存器，在主存中用来存放欲访问的存储单元的地址。<br>MDR：Memory Data Register，存储器数据缓冲寄存器，在主存中用来存放从某单元读出、或要写入某存储单元的数据。<br>I/O：Input/Output equipment，输入/输出设备，为输入设备和输出设备的总称，用于计算机内部和外界信息的转换与传送。</p>
<p>MIPS：Million Instruction Per Second，每秒执行百万条指令数，为计算机运算速度指标的一种计量单位。</p>
<p>CPI：执行一条指令所需的时钟周期（机器主频的倒数)。</p>
<p>FLOPS：浮点运算次数每秒。</p>
<h2 id="主存储器"><a href="#主存储器" class="headerlink" title="主存储器"></a>主存储器</h2><ul>
<li>汉明码</li>
</ul>
<ol>
<li>汉明码要添加 检测位要满足 2 ^k &gt;= n + k +1 k位检测位 ， n为总位数</li>
<li>检测位放在 2 ^i  次方处 i = 0 , 1 , ……</li>
</ol>
<h2 id="进制字母表示"><a href="#进制字母表示" class="headerlink" title="进制字母表示"></a>进制字母表示</h2><p>十进制数用D表示，二进制用B表示，十六进制数用H表示，八进制用O表示。</p>
<h2 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h2><p>命中率： 访问成功次数 / 总访问次数<br>命中率与Cache 的容量和块长有关<br>访问效率 = 访问Cache 的时间 / 平均访问时间   * 100 %<br>e 访问效率 ， h 命中率， 访问Cache 时间为tc 访问主存时间为tm<br>则 e = tc / h * tc   + ( 1 - h) * t    * 100%<br>访问时间 / 命中的时间 + 未命中的时间</p>
<ul>
<li>读写操作 <ul>
<li>写 ： 1. 写直达法 ： 写时同时写入Cache和主存</li>
<li><ol start="2">
<li>写回法： 只写入Cache 不写入内存，当Cache数据被替换出去的时候才写会主存，会导致Cache和主存的不一致</li>
</ol>
</li>
</ul>
</li>
<li>地址映射<ol>
<li>直接映射 Cache任意一块可以放在</li>
<li>全相联映射  主存任何一块可以放在Cache任意一块中</li>
<li></li>
</ol>
</li>
</ul>
<h2 id="DMA"><a href="#DMA" class="headerlink" title="DMA"></a>DMA</h2><ol start="3">
<li>DMA和 CPU交替访问<br> CPU工作周期  C1 专供DMA访存，C2专攻CPU访存</li>
</ol>
<ul>
<li>功能：<ol>
<li>向CPU申请DMA传送</li>
<li>处理总线控制权的转交</li>
<li>管理系统总线，控制数据传输</li>
<li>确定数据传送的首地址和长度，修正传送过程中的数据和长度</li>
<li>DMA传送结束时，给出操作完成的信号</li>
</ol>
</li>
</ul>
<h2 id="数"><a href="#数" class="headerlink" title="数"></a>数</h2><p>浮点数： 阶码组成为 阶符 + 数值部分   尾数由数符和数值组成<br>阶码是用二进制来表示的比如<br>2 ^15<br>就是 2 ^1111<br>即可，所以要用四位二进制来表示</p>
<ul>
<li>规格化<br>基数为<br>2  要求尾数最高位为 1  2 ^1<br>4                 最高2位为1  2 ^2</li>
</ul>
<p>8                 最高3位为 1  2 ^3</p>
<p>左规，数据左移，尾数变大<br>小数转二进制，直接把分子写成二进制，然后根据分母是2的多少次方，移动小数点就行了</p>
<ul>
<li><p>IEEE 754标准<br>数符 + 阶码(含阶符) 尾数<br>尾数使用规格化表示，非 0 的有效位最高位为1</p>
</li>
<li><p>运算<br>补码 左移时，后面加0 ， 右移时前面加 1<br>定点数运算：</p>
</li>
</ul>
<ol>
<li>补码加减运算，直接 A + B  mod 2 ^n+1</li>
<li>小数 就mod 2</li>
</ol>
<h2 id="指令系统"><a href="#指令系统" class="headerlink" title="指令系统"></a>指令系统</h2><ul>
<li>指令格式 ： 操作码 + 地址码+寻址方式<br>指令字长分为可变和固定字长<br>RISC 精简指令系统<br>长度可变的指令：操作码分散在指令字的不同字段中</li>
<li>地址码</li>
</ul>
<ol>
<li>四地址    op + A1 + A2 + A3 + A4  分别是第一操作数地址，第二操作数地址，结果地址，下一条指令地址  (A1) OP(A2) –&gt; A3</li>
<li>三地址  OP A1 A2 A3   </li>
<li>二地址   OP A1 A2    (A1) OP (A2) –&gt; A1 或者 (A1) OP(A2) -&gt; A2</li>
<li>一地址 OP A1     (ACC) OP (A1) -&gt; A1  ACC暂存</li>
<li>零地址，对ACC中的数据进行操作<br>可以使用寄存器地址来替代指令地址字段，因为寄存器很少，占用的位数少</li>
</ol>
<ul>
<li>指令寻址<br>顺序 PC + 1 -&gt; PC<br>跳跃 由转移指令给出<br>数据寻址： 操作码 + 寻址特征+ 形式地址A<br>形式地址 是指令字中的地址，有效地址是操作数的真实地址</li>
</ul>
<ol>
<li>立即寻址： 形式地址A就是操作数，OP # A   # 为立寻址标志 A 使用补码</li>
<li>直接寻址，EA = A 有效地址由形式地址给出，无偏移量</li>
<li>隐含寻址 间接寻址 有效地址由形式地址简介提供，A提供的是EA 的地址，需要去寻址，EA 的地址才是指向真实的数据</li>
<li>寄存器寻址，EA = Ri 有效地址为寄存器的编号</li>
<li>寄存器间接寻址： EA = (Ri) 有效地址在寄存器中</li>
</ol>
<ul>
<li>基址寻址<ol>
<li>使用专用寄存器作为基址寄存器<br> EA = (BR) + A BR 为基址寄存器，也就是 物理地址 = 逻辑地址 + 基址地址</li>
</ol>
</li>
</ul>
<h2 id="CPU-组成"><a href="#CPU-组成" class="headerlink" title="CPU 组成"></a>CPU 组成</h2><ul>
<li>寄存器<ol>
<li>通用寄存器 ： 存放操作数，可作为某中寻址方式的专用寄存器</li>
<li>数据寄存器：存放操作数，两个寄存器拼接放双倍字长的数据</li>
<li>地址寄存器： 存放地址</li>
<li>条件码寄存器： 存放条件码，可作为程序分支的依据，正负,0，溢出等</li>
<li>控制和状态寄存器： <ul>
<li>控制寄存器 PC -&gt; MAR -&gt; M -&gt; MDR -&gt; IR</li>
<li>PC用户可见</li>
<li>状态寄存器 存放条件码</li>
<li>PSW 存放程序状态字</li>
</ul>
</li>
</ol>
</li>
<li>指令周期 ： 取出并执行一条指令所需的全部时间</li>
<li>包括 取指，分析 =&gt; 取指周期  执行=&gt;执行周期</li>
</ul>
<p>流水线</p>
<ul>
<li>吞吐率： 单位时间内流水线所完成执行或输出结果的数量</li>
<li>最大吞吐率: Tpmax = 1 / Δt Δt为m段流水线各段时间</li>
<li>加速比 ： <ul>
<li>使用流水线的方式完成n条指令在m段流水线上共需 T = m * t + (n-1) * t   </li>
<li>使用等效的非流水线共需： T =  nmt</li>
<li>加速比等于  不使用 / 使用</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zuofw.github.io/2023/10/11/xiang-mu-jian-li-shi-xi/ren-shi/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="QingQiu">
      <meta itemprop="description" content="个人网站，学习记录，面试记录和经验总结、互联网中一块属于自己的小窝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="QingQiu'Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/10/11/xiang-mu-jian-li-shi-xi/ren-shi/" class="post-title-link" itemprop="url">人事</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-10-11 14:29:58" itemprop="dateCreated datePublished" datetime="2023-10-11T14:29:58+08:00">2023-10-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-11-16 09:01:22" itemprop="dateModified" datetime="2023-11-16T09:01:22+08:00">2023-11-16</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="简单的增删改查练习"><a href="#简单的增删改查练习" class="headerlink" title="简单的增删改查练习"></a>简单的增删改查练习</h1><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><pre class="line-numbers language-none"><code class="language-none">## 服务器
给nginx设置负载均衡即可
## 具体编码
1. BeanUtils的使用
2. DigestUtils md5加密



- 一些借鉴
jwt拦截器,md5加密，全局错误处理，ThreadLocal 进行线程内部传递变量

PageHelper分页
```java
//设置分页和分页大小
    PageHelper.startPage(employeePageQueryDTO.getPage(), employeePageQueryDTO.getPageSize());
//进行查询
    Page&lt;Employee&gt; page = employeeMapper.pageQuery(employeePageQueryDTO);//后续定义
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>xml中的mapper示例:</p>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>pageQuery<span class="token punctuation">"</span></span> <span class="token attr-name">resultType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.sky.entity.Employee<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
        select * from employee
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>where</span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>if</span> <span class="token attr-name">test</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>name != null and name != ''<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
                and name like concat('%',#{name},'%')
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>if</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>where</span><span class="token punctuation">&gt;</span></span>
        order by create_time desc
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>对于时间格式的全局管理，在mvcconfig中</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">extendMessageConverters</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">HttpMessageConverter</span><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> converters<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"扩展消息转换器..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//创建一个消息转换器对象</span>
    <span class="token class-name">MappingJackson2HttpMessageConverter</span> converter <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MappingJackson2HttpMessageConverter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//需要为消息转换器设置一个对象转换器，对象转换器可以将Java对象序列化为json数据</span>
    converter<span class="token punctuation">.</span><span class="token function">setObjectMapper</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">JacksonObjectMapper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//将自己的消息转化器加入容器中</span>
    converters<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span>converter<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li><p>aop</p>
</li>
<li><p>Apache POI 来进行文件格式转换，导出为excel</p>
</li>
<li><p>Apache ECharts 可视化图表</p>
</li>
<li><p><strong>Spring Task</strong> 定时任务</p>
</li>
<li><p>HttpClient<br><strong>HttpClient的核心API：</strong></p>
</li>
<li><p>HttpClient：Http客户端对象类型，使用该类型对象可发起Http请求。</p>
</li>
<li><p>HttpClients：可认为是构建器，可创建HttpClient对象。</p>
</li>
<li><p>CloseableHttpClient：实现类，实现了HttpClient接口。</p>
</li>
<li><p>HttpGet：Get方式请求类型。</p>
</li>
<li><p>HttpPost：Post方式请求类型。</p>
</li>
</ul>
<p><strong>HttpClient发送请求步骤：</strong></p>
<ul>
<li><p>创建HttpClient对象</p>
</li>
<li><p>创建Http请求对象</p>
</li>
<li><p>调用HttpClient的execute方法发送请求</p>
</li>
</ul>
<h1 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h1><p>学生管理系统</p>
<p>一．功能要求</p>
<ul>
<li><p>添加学生功能：姓名、学号、性别、出生年月日。（学号自动生成且唯一）</p>
</li>
<li><p>添加学生成绩功能：每个人都有数学、Java、英语、体育四门课，可分课程输入成绩。</p>
</li>
<li><p>根据学生学号查找学生成绩功能：在界面上显示姓名、学号和成绩，学号不存在的能给出提示信息。</p>
</li>
<li><p>根据学生姓名（支持模糊匹配）查找学生成绩功能：并在界面上显示姓名、学号和成绩，如果有多个相同姓名学生存在，一起显示出来，姓名不存在的给出提示信息。</p>
</li>
<li><p>支持对单个学生各科成绩画出柱状分布图。</p>
</li>
<li><p>学生信息的修改与删除功能：不能修改学号。</p>
</li>
<li><p>生成学生学习情况报表功能：报表包含学号、姓名、各科目成绩及对应的该科目班级平均值，总成绩以及班级总成绩平均值，并将该排序结果输出至excel文件。</p>
</li>
</ul>
<h2 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h2><ol>
<li>admin<pre class="line-numbers language-css" data-language="css"><code class="language-css">id
username 
password<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li>
<li>student<pre class="line-numbers language-css" data-language="css"><code class="language-css">id <span class="token punctuation">(</span>学号自动生成且唯一<span class="token punctuation">)</span>
name
birthday<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li>
<li>score<pre class="line-numbers language-css" data-language="css"><code class="language-css">id
Math
Java
English
PE<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
sql设计</li>
</ol>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">DATABASE</span> management<span class="token punctuation">;</span>
<span class="token keyword">USE</span> management<span class="token punctuation">;</span>
<span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> admin<span class="token punctuation">(</span>
    Id <span class="token keyword">INT</span> <span class="token keyword">AUTO_INCREMENT</span> <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span><span class="token punctuation">,</span>
    Username <span class="token keyword">char</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
    Password <span class="token keyword">char</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span>
<span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8<span class="token punctuation">;</span>

<span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> student<span class="token punctuation">(</span>
    Id <span class="token keyword">INT</span> <span class="token keyword">AUTO_INCREMENT</span> <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span><span class="token punctuation">,</span>
    StudentId <span class="token keyword">char</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">UNIQUE</span><span class="token punctuation">,</span>
    StudentName <span class="token keyword">char</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
    Birthday <span class="token keyword">date</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> score<span class="token punctuation">(</span>
    Id <span class="token keyword">INT</span> <span class="token keyword">AUTO_INCREMENT</span> <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span><span class="token punctuation">,</span>
    Math <span class="token keyword">DOUBLE</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
    Java <span class="token keyword">DOUBLE</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
    English <span class="token keyword">DOUBLE</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
    PE <span class="token keyword">DOUBLE</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>ps: 使用方式 mysql -u username -p  &lt;  xxx.sql ，之后输入密码即可</p>
<p>xml配置<br>druid<br>knife4j生成接口文档</p>
<ul>
<li>部署<br>服务器配置:<br>mysql<br>将服务器上的mysql配置文件修改<pre class="line-numbers language-css" data-language="css"><code class="language-css">vim /etc/mysql/mysql.conf.d/mysqld.cnf
将bind-address 的127.0.0.1 改为  0.0.0.0 
服务器开放端口 3306<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
redis<br>1.打开redis的配置文件“redis.conf”。</li>
</ul>
<p>2.将“bind 127.0.0.1”注释掉。</p>
<p>3.将“protected-mode yes”改成“protected-mode no”。</p>
<p>4.添加以下一行代码。</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">daemonize no<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>复制</p>
<p>5.重启redis服务即可<br><code>sudo service redis restart</code></p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>knif4j注意设置好扫描的包</p>
<h2 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h2><ol>
<li>common module<ol>
<li>返回类封装Result</li>
<li>pageHelper所需的分页参数</li>
</ol>
</li>
<li></li>
</ol>
<h1 id="苍穹外卖项目"><a href="#苍穹外卖项目" class="headerlink" title="苍穹外卖项目"></a>苍穹外卖项目</h1><p>仓库： 已完成 <a target="_blank" rel="noopener" href="https://github.com/qiuEly/sky-take-out">https://github.com/qiuEly/sky-take-out</a></p>
<h2 id="知识"><a href="#知识" class="headerlink" title="知识"></a>知识</h2><ol>
<li>当前端传输的数据与实体类差距比较大时使用DTO来封装</li>
<li><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93/2987565?fromModule=lemma_inlink">数据传输</a>对象（DTO）(Data Transfer Object)，是一种<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/1212549?fromModule=lemma_inlink">设计模式</a>之间传输数据的软件<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F/56497111?fromModule=lemma_inlink">应用系统</a>。数据传输目标往往是<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE%E5%AF%B9%E8%B1%A1/3351868?fromModule=lemma_inlink">数据访问对象</a>从数据库中检索数据。数据传输对象与数据交互对象或数据访问对象之间的差异是一个以不具有任何行为除了存储和检索的数据（访问和存取器）。</li>
<li>ThreadLocal 不是一个线程，但是可以用于保存Thread的一个变量，相当于设置线程内部的变量，可以用来存token和cookie</li>
<li>mybatis-plus 分页插件的使用，并且配合queryWrapper来封装自定义查询</li>
<li>使用配置jackson和java格式互相转化器</li>
<li>‘ALTER TABLE table_name AUTO_INCREMENT = value;’  记得删除没有用的数据之后并且让value大于当前的行数</li>
<li>mp 实现递增需要在配置文件中加上 ‘mybatis-plus:<br>global-config:<br>db-config:<br>id-type: auto’</li>
<li>自定义注解： <ol>
<li><p><strong><code>@Target</code> 注解</strong>：</p>
<p> @Target注解：</p>
<ul>
<li>作用：<code>@Target</code> 注解用于指定可以将注解应用到的元素类型。它决定了注解可以用于标记哪些程序元素，例如类、方法、字段等。</li>
<li>参数：<code>@Target</code> 的参数是一个 <code>ElementType</code> 枚举数组，你可以在其中指定一个或多个目标元素类型。对于 <code>@ComponentScan</code> 来说，<code>@Target(ElementType.TYPE)</code> 表示该注解可以用于标记类。</li>
</ul>
</li>
<li><p><strong><code>@Retention</code> 注解</strong>：</p>
<ul>
<li>作用：<code>@Retention</code> 注解用于指定注解在编译后是否保留到运行时，并且是否可以通过反射访问注解。有三个可能的 <code>RetentionPolicy</code> 值：<code>SOURCE</code>、<code>CLASS</code> 和 <code>RUNTIME</code>。</li>
<li>参数：<code>@Retention</code> 的参数是一个 <code>RetentionPolicy</code> 枚举值。<code>@Retention(RetentionPolicy.RUNTIME)</code> 表示注解会在运行时保留，并可以通过反射访问。</li>
</ul>
</li>
<li><p><strong><code>@Documented</code> 注解</strong>：</p>
<ul>
<li>作用：<code>@Documented</code> 注解用于指示该注解应该包含在生成的文档中。如果你想要将注解的信息包含在 Java 文档中，可以使用 <code>@Documented</code> 注解。</li>
<li>参数：<code>@Documented</code> 注解没有参数，它只是一个标记注解，用于指示文档工具要包括注解信息。</li>
</ul>
</li>
</ol>
</li>
<li>阿里云oss使用，主要使用的是spring 中的MultipartFile </li>
<li>Redis的使用</li>
<li>通过给RestController设置标识名来防止依赖注入无法识别相同名称的Bean</li>
<li>vivo50<blockquote>
<p><strong>HttpClient的核心API：</strong></p>
</blockquote>
</li>
</ol>
<ul>
<li><p>HttpClient：Http客户端对象类型，使用该类型对象可发起Http请求。</p>
</li>
<li><p>HttpClients：可认为是构建器，可创建HttpClient对象。</p>
</li>
<li><p>CloseableHttpClient：实现类，实现了HttpClient接口。</p>
</li>
<li><p>HttpGet：Get方式请求类型。</p>
</li>
<li><p>HttpPost：Post方式请求类型。</p>
</li>
</ul>
<p><strong>HttpClient发送请求步骤：</strong></p>
<ul>
<li><p>创建HttpClient对象</p>
</li>
<li><p>创建Http请求对象</p>
</li>
<li><p>调用HttpClient的execute方法发送请求<br>用例：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>sky<span class="token punctuation">.</span>test</span><span class="token punctuation">;</span>

<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>http<span class="token punctuation">.</span></span><span class="token class-name">HttpEntity</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>http<span class="token punctuation">.</span>client<span class="token punctuation">.</span>methods<span class="token punctuation">.</span></span><span class="token class-name">CloseableHttpResponse</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>http<span class="token punctuation">.</span>client<span class="token punctuation">.</span>methods<span class="token punctuation">.</span></span><span class="token class-name">HttpGet</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>http<span class="token punctuation">.</span>impl<span class="token punctuation">.</span>client<span class="token punctuation">.</span></span><span class="token class-name">CloseableHttpClient</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>http<span class="token punctuation">.</span>impl<span class="token punctuation">.</span>client<span class="token punctuation">.</span></span><span class="token class-name">HttpClients</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>http<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">EntityUtils</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>junit<span class="token punctuation">.</span>jupiter<span class="token punctuation">.</span>api<span class="token punctuation">.</span></span><span class="token class-name">Test</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>test<span class="token punctuation">.</span>context<span class="token punctuation">.</span></span><span class="token class-name">SpringBootTest</span></span><span class="token punctuation">;</span>

<span class="token annotation punctuation">@SpringBootTest</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HttpClientTest</span> <span class="token punctuation">{</span>

    <span class="token comment">/**
     * 测试通过httpclient发送GET方式的请求
     */</span>
    <span class="token annotation punctuation">@Test</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testGET</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span><span class="token punctuation">{</span>
        <span class="token comment">//创建httpclient对象</span>
        <span class="token class-name">CloseableHttpClient</span> httpClient <span class="token operator">=</span> <span class="token class-name">HttpClients</span><span class="token punctuation">.</span><span class="token function">createDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">//创建请求对象</span>
        <span class="token class-name">HttpGet</span> httpGet <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HttpGet</span><span class="token punctuation">(</span><span class="token string">"http://localhost:8080/user/shop/status"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">//发送请求，接受响应结果</span>
        <span class="token class-name">CloseableHttpResponse</span> response <span class="token operator">=</span> httpClient<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>httpGet<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">//获取服务端返回的状态码</span>
        <span class="token keyword">int</span> statusCode <span class="token operator">=</span> response<span class="token punctuation">.</span><span class="token function">getStatusLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getStatusCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"服务端返回的状态码为："</span> <span class="token operator">+</span> statusCode<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">HttpEntity</span> entity <span class="token operator">=</span> response<span class="token punctuation">.</span><span class="token function">getEntity</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">String</span> body <span class="token operator">=</span> <span class="token class-name">EntityUtils</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>entity<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"服务端返回的数据为："</span> <span class="token operator">+</span> body<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">//关闭资源</span>
        response<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        httpClient<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
<ol start="13">
<li>spring cache<br>在SpringCache中提供了很多缓存操作的注解，常见的是以下的几个：</li>
</ol>
<table>
<thead>
<tr>
<th><strong>注解</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>@EnableCaching</td>
<td>开启缓存注解功能，通常加在启动类上</td>
</tr>
<tr>
<td>@Cacheable</td>
<td>在方法执行前先查询缓存中是否有数据，如果有数据，则直接返回缓存数据；如果没有缓存数据，调用方法并将方法返回值放到缓存中</td>
</tr>
<tr>
<td>@CachePut</td>
<td>将方法的返回值放到缓存中</td>
</tr>
<tr>
<td>@CacheEvict</td>
<td>将一条或多条数据从缓存中删除</td>
</tr>
</tbody></table>
<p>在spring boot项目中，使用缓存技术只需在项目中导入相关缓存技术的依赖包，并在启动类上使用@EnableCaching开启缓存支持即可。</p>
<ol start="14">
<li>spring task 定时任务</li>
<li>websocket<br>WebSocket 是基于 TCP 的一种新的<strong>网络协议</strong>。它实现了浏览器与服务器全双工通信——浏览器和服务器只需要完成一次握手，两者之间就可以创建<strong>持久性</strong>的连接， 并进行<strong>双向</strong>数据传输。</li>
</ol>
<p><strong>HTTP协议和WebSocket协议对比：</strong></p>
<ul>
<li><p>HTTP是<strong>短连接</strong></p>
</li>
<li><p>WebSocket是<strong>长连接</strong></p>
</li>
<li><p>HTTP通信是<strong>单向</strong>的，基于请求响应模式</p>
</li>
<li><p>WebSocket支持<strong>双向</strong>通信</p>
</li>
<li><p>HTTP和WebSocket底层都是TCP连接</p>
</li>
</ul>
<ol start="16">
<li>Apache ECharts</li>
<li>Apache POI</li>
<li>部署！！！</li>
</ol>
<ul>
<li>build过程中出现检测问题 <a target="_blank" rel="noopener" href="https://www.cnblogs.com/SparkMore/p/15919302.html">https://www.cnblogs.com/SparkMore/p/15919302.html</a></li>
</ul>
<ol start="19">
<li>当springboot项目不识别application配置文件时，右键resource -&gt; Mark Directory as &gt; Resources Root</li>
</ol>
<h2 id="修改建议Todo"><a href="#修改建议Todo" class="headerlink" title="修改建议Todo:"></a>修改建议Todo:</h2><ol>
<li>密码加密 使用 security + jwt ，前端保存session</li>
<li>微信小程序开发 + 前端 vue </li>
<li>docker环境下使用</li>
</ol>
<h1 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h1><ol>
<li>admin 界面来管理</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zuofw.github.io/2023/09/30/qian-duan/blog-da-jian/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="QingQiu">
      <meta itemprop="description" content="个人网站，学习记录，面试记录和经验总结、互联网中一块属于自己的小窝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="QingQiu'Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/09/30/qian-duan/blog-da-jian/" class="post-title-link" itemprop="url">blog搭建</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-09-30 10:45:23 / 修改时间：10:49:16" itemprop="dateCreated datePublished" datetime="2023-09-30T10:45:23+08:00">2023-09-30</time>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h1><p>一次自己blog手动搭建记录<br>技术栈：</p>
<ul>
<li>前端：vue</li>
<li>后端:   express redis</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zuofw.github.io/2023/09/29/qian-duan/qian-duan-xue-xi/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="QingQiu">
      <meta itemprop="description" content="个人网站，学习记录，面试记录和经验总结、互联网中一块属于自己的小窝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="QingQiu'Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/09/29/qian-duan/qian-duan-xue-xi/" class="post-title-link" itemprop="url">前端学习</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-09-29 20:52:36" itemprop="dateCreated datePublished" datetime="2023-09-29T20:52:36+08:00">2023-09-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-04-14 16:35:32" itemprop="dateModified" datetime="2024-04-14T16:35:32+08:00">2024-04-14</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><ul>
<li>head中的<ul>
<li>meta的使用，description可以用来记录文章主要内容，方便搜索引擎使用</li>
<li><code>&lt;link rel="icon" href="./favicon.ico"&gt;</code> 引入ico</li>
</ul>
</li>
</ul>
<h1 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h1><p>文件结构:</p>
<ul>
<li>api 存放封装了Ajax的请求文件</li>
<li>components 公共组件存放目录</li>
<li>views 视图组件</li>
<li>App.vue 主组件，入口文件</li>
<li>main.ts 项目的路口文件</li>
<li>router.ts路由文件</li>
</ul>
<h2 id="打包部署在nginx上"><a href="#打包部署在nginx上" class="headerlink" title="打包部署在nginx上"></a>打包部署在nginx上</h2><p>使用npm run build 进行打包，将dist包放在/usr/share/nginx/html<br>即可，然后root路径要写全<br>本地使用vue，基于脚手架安装</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> create vue@latest
<span class="token builtin class-name">cd</span> xxx
<span class="token function">npm</span> <span class="token function">install</span>
<span class="token function">npm</span> run dev<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>基础语法:</li>
<li>v-bind:xxx 绑定语法，可简写为:xxx 如果绑定的是多个值，比如是一个json数组，那么可以把xxx省略留下 v-bind: = aaa</li>
<li>v-on 监听事件 简写为 @xxx 动态绑定事件 <code>@[事件列表] = "事件函数"</code></li>
<li><code>&lt;template&gt;</code> 不会被渲染，一般作为v-if根</li>
<li>第三个参数表示位置索引：<pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;li v-for="(value, key, index) in myObject"&gt;
  {{ index }}. {{ key }}: {{ value }}
&lt;/li&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li>
<li>setup是在建立渲染之前就会调用</li>
<li>想要使用变量就必须要把变量return 出来即可</li>
<li>使用语法糖可以简化代码，不需要一个个return了<pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;script setup&gt;  
   const msg = 'Hello Vite + Vue 3!'  
&lt;/script&gt;  
&lt;template&gt;  
  &lt;div id="app"&gt;  
    &lt;h1&gt;{{msg}}&lt;/h1&gt;  
  &lt;/div&gt;&lt;/template&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li>使用reactive函数来返回一个响应式对象<pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;script setup&gt;  
   import {reactive} from "vue";  
   const state = reactive({  
     msg: "hell world"  
   })  
   const setState = ()=&gt;{  
     state.msg = "hello vite"  
   }  
&lt;/script&gt;  
&lt;template&gt;  
  {{state.msg}}  
  &lt;button @click="setState"&gt;click&lt;/button&gt;  
&lt;/template&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li>使用ref来返回一个简单响应式对象<pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;script setup&gt;  
    import {ref} from "vue";  
    const msg = ref(0);  
&lt;/script&gt;  
&lt;template&gt;  
  &lt;div id="app"&gt;  
    &lt;button @click="msg++"&gt;count is: {{ msg }}&lt;/button&gt;  
  &lt;/div&gt;&lt;/template&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li>computed对象函数，里面传进去计算逻辑<pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;script setup&gt;  
import {computed, ref} from "vue";  
  const list = ref([1,2,3,4,5]);  
  const filterlist = computed(()=&gt;{  
    return list.value.filter(item=&gt;item&gt;3)  
  })  
&lt;/script&gt;  
&lt;template&gt;  
  &lt;div&gt;    &lt;ul&gt;      &lt;li v-for="item in filterlist" :key="item"&gt;{{item}}&lt;/li&gt;  
    &lt;/ul&gt;  &lt;/div&gt;&lt;/template&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li>watch 监听数据的变化，如果数据变化就执行回调函数，剩下两个参数，immediate 控制立刻执行，deep开启深度监听<ul>
<li>监听一个  <pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">	&lt;script setup&gt;  
import {ref, watch} from "vue";  
const count = ref(0);  
watch(count,(newCount, oldCount) =&gt; {  
  console.log(`new count is: ${newCount}, old count is: ${oldCount}`)  
})  
const increment = () =&gt; {  
  count.value++;  
}  
&lt;/script&gt;  
&lt;template&gt;  
&lt;button @click="increment"&gt;count is: {{count}}&lt;/button&gt;  
&lt;/template&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li>监听多个数据，只需要把参数化成数组即可<pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">watch([count, name], ([newCount, newName],[oldCount,oldName])=&gt;</span><span class="token punctuation">{</span>
  console.<span class="token function">log</span><span class="token punctuation">(</span>`count或者name变化了，[newCount<span class="token punctuation">,</span> newName]<span class="token punctuation">,</span>[oldCount<span class="token punctuation">,</span>oldName]<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li>
</ul>
</li>
<li>immediate 在创建时立刻出发<pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">watch(count, (newValue, oldValue)=&gt;</span><span class="token punctuation">{</span>
   <span class="token selector">console.log(`count发生了变化，老值为$</span><span class="token punctuation">{</span>oldValue<span class="token punctuation">}</span><span class="token selector">,新值为$</span><span class="token punctuation">{</span>newValue<span class="token punctuation">}</span>`<span class="token punctuation">)</span>
 <span class="token punctuation">}</span><span class="token selector">,</span><span class="token punctuation">{</span>
   <span class="token property">immediate</span><span class="token punctuation">:</span> true
 <span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li>deep通过watch监听的ref对象是浅层监听的，直接修改嵌套的对象属性是不会回调的，但是开启之后就可以回调了<pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;script setup&gt;
  // 1. 导入watch
  import { ref, watch } from 'vue'
  const state = ref({ count: 0 })
  // 2. 监听对象state
  watch(state, ()=&gt;{
    console.log('数据变化了')
  })
  const changeStateByCount = ()=&gt;{
    // 直接修改不会引发回调执行
    state.value.count++
  }
&lt;/script&gt;

&lt;script setup&gt;
  // 1. 导入watch
  import { ref, watch } from 'vue'
  const state = ref({ count: 0 })
  // 2. 监听对象state 并开启deep
  watch(state, ()=&gt;{
    console.log('数据变化了')
  },{deep:true})
  const changeStateByCount = ()=&gt;{
    // 此时修改可以触发回调
    state.value.count++
  }
&lt;/script&gt;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li>父组件传值给子组件: 1.引入子组件，使用子组件并绑定子组件中props中的属性 2. 子组件使用defineProps来接受父组件的传值<pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">父组件
&lt;script setup&gt;  
import son from './components/money.vue'  
&lt;/script&gt;  
  
&lt;template&gt;  
  &lt;son  message="hello world"/&gt;  
&lt;/template&gt;
&lt;!--子组件--&gt;
&lt;script setup&gt;  
const props =  defineProps({  
  message : String  
})  
&lt;/script&gt;  
&lt;template&gt;  
  {{message}}  
&lt;/template&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li>子组件传值给父组件: 1.子组件通过defineEmits来生成emit方法 2.子组件使用emit定义事件，并传递参数 3.父组件使用绑定子组件的事件，并绑定自己的函数，定义自己的函数使用传递的值<pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">子组件
&lt;script setup&gt;  
const props =  defineProps({  
  message : String  
})  
const emit = defineEmits(['say']) //事件列表  
const hh = ()=&gt;{  
  emit('say','hello world')  
}  
&lt;/script&gt;  
&lt;template&gt;  
  {{message}}  
  &lt;button @click="hh"&gt;click&lt;/button&gt;  
&lt;/template&gt;
父组件
&lt;script setup&gt;  
import son from './components/money.vue'  
const func = (msg,num)=&gt;{  
  console.log(msg,num)  
}  
&lt;/script&gt;  
&lt;template&gt;  
  &lt;son  messoage="hello world" @say="func"/&gt;  
&lt;/template&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li>模板使用 新建一个ref 然后在 html 中的ref来进行绑定这个ref即可获得dom元素，但是会在onmounted之后才能访问</li>
<li>父组件默认不会获得子组件的dom因为有setup 所以可以使用<pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">defineExpose({
	需要暴漏的属性和方法名或者一个匿名函数
})<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li>
<li>通过provide和inject来跨层传递<pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">顶层
provide('key',value) value可以是函数等
底层
const value = inject('key')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li>
<li>v-text 来更新文本内容，v-html来更新html元素</li>
</ul>
<h1 id="Express"><a href="#Express" class="headerlink" title="Express"></a>Express</h1><p>支持前后端分离的简单框架</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> express-generator <span class="token parameter variable">-g</span>
express --no-view server 新建项目
<span class="token builtin class-name">cd</span> server
<span class="token function">npm</span> <span class="token function">install</span>
ET DEBUG <span class="token operator">=</span> server:* <span class="token operator">&amp;</span> <span class="token function">npm</span> start 开启服务<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">user www-data<span class="token punctuation">;</span>
worker_processes auto<span class="token punctuation">;</span>
pid /run/nginx.pid<span class="token punctuation">;</span>
include /etc/nginx/modules-enabled/*.conf<span class="token punctuation">;</span>

events <span class="token punctuation">{</span>
        worker_connections <span class="token number">768</span><span class="token punctuation">;</span>
        <span class="token comment"># multi_accept on;</span>


        <span class="token comment">##自定义服务列表</span>

<span class="token punctuation">}</span>
http <span class="token punctuation">{</span>
        <span class="token comment">##</span>

        sendfile on<span class="token punctuation">;</span>
        tcp_nopush on<span class="token punctuation">;</span>
        types_hash_max_size <span class="token number">2048</span><span class="token punctuation">;</span>
        <span class="token comment"># server_tokens off;</span>

        <span class="token comment"># server_names_hash_bucket_size 64;</span>
        <span class="token comment"># server_name_in_redirect off;</span>

        include /etc/nginx/mime.types<span class="token punctuation">;</span>
        default_type application/octet-stream<span class="token punctuation">;</span><span class="token builtin class-name">.</span>
         ssl_protocols TLSv1 TLSv1.1 TLSv1.2 TLSv1.3<span class="token punctuation">;</span> <span class="token comment"># Dropping SSLv3, ref: POODLE</span>
        ssl_prefer_server_ciphers on<span class="token punctuation">;</span>

        <span class="token comment">##</span>
        <span class="token comment"># Logging Settings</span>
        <span class="token comment">##</span>

        access_log /var/log/nginx/access.log<span class="token punctuation">;</span>
        error_log /var/log/nginx/error.log<span class="token punctuation">;</span>

        <span class="token comment">##</span>
        <span class="token comment"># Gzip Settings</span>
        <span class="token comment">##</span>

        <span class="token function">gzip</span> on<span class="token punctuation">;</span>

        <span class="token comment"># gzip_vary on;</span>
        <span class="token comment"># gzip_proxied any;</span>
        <span class="token comment"># gzip_comp_level 6;</span>
        <span class="token comment"># gzip_buffers 16 8k;</span>
        <span class="token comment"># gzip_http_version 1.1;</span>
        <span class="token comment"># gzip_types text/plain text/css application/json application/javascript text/xml application/xml application/xml+rss text/javascript;</span>

        <span class="token comment">##</span>
        <span class="token comment"># Virtual Host Configs</span>
        <span class="token comment">##</span>
          include /etc/nginx/conf.d/*.conf<span class="token punctuation">;</span>
        include /etc/nginx/sites-enabled/*<span class="token punctuation">;</span>



<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h1><ul>
<li><p>进度条</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> ProgressBar <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'progress'</span><span class="token punctuation">)</span>  
<span class="token keyword">const</span> bar <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ProgressBar</span><span class="token punctuation">(</span><span class="token string">':bar'</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token literal-property property">total</span><span class="token operator">:</span><span class="token number">100</span><span class="token punctuation">}</span><span class="token punctuation">)</span>  
<span class="token keyword">const</span> timer <span class="token operator">=</span>  <span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>  
    bar<span class="token punctuation">.</span><span class="token function">tick</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  
    <span class="token keyword">if</span> <span class="token punctuation">(</span>bar<span class="token punctuation">.</span>complete<span class="token punctuation">)</span><span class="token punctuation">{</span>  
        <span class="token function">clearInterval</span><span class="token punctuation">(</span>timer<span class="token punctuation">)</span>  
    <span class="token punctuation">}</span>  
<span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token number">100</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><p>文件操作  require(‘fs’)</p>
</li>
<li><p>网络开发</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> net <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'net'</span><span class="token punctuation">)</span>  
<span class="token keyword">const</span> server <span class="token operator">=</span> net<span class="token punctuation">.</span><span class="token function">createServer</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">c</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>  
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'客户端已连接'</span><span class="token punctuation">)</span>  
    c<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'end'</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>  
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'断开连接'</span><span class="token punctuation">)</span>  
    <span class="token punctuation">}</span><span class="token punctuation">)</span>  
<span class="token punctuation">}</span><span class="token punctuation">)</span>  
server<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'error'</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token parameter">err</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>  
    <span class="token keyword">throw</span> err  
<span class="token punctuation">}</span><span class="token punctuation">)</span>  
server<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">8124</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>  
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'服务器已启动'</span><span class="token punctuation">)</span>  
<span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>on来绑定事件</p>
</li>
<li><p>udp 使用dgram模块</p>
</li>
<li><p>WebSocket 使用 ws模块，是对socket的具体实现</p>
</li>
<li><p>socket.io框架</p>
</li>
<li><p>常用api<br><img src="/2023/09/29/qian-duan/qian-duan-xue-xi/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/2.jpg"><br><img src="/2023/09/29/qian-duan/qian-duan-xue-xi/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/1.jpg"></p>
</li>
<li><p>express框架</p>
</li>
<li><p>koa框架</p>
</li>
<li><p>mongoose</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zuofw.github.io/2023/09/19/xiang-mu-jian-li-shi-xi/ruan-kao/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="QingQiu">
      <meta itemprop="description" content="个人网站，学习记录，面试记录和经验总结、互联网中一块属于自己的小窝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="QingQiu'Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/09/19/xiang-mu-jian-li-shi-xi/ruan-kao/" class="post-title-link" itemprop="url">软考</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-09-19 20:46:11" itemprop="dateCreated datePublished" datetime="2023-09-19T20:46:11+08:00">2023-09-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-03-20 14:58:42" itemprop="dateModified" datetime="2024-03-20T14:58:42+08:00">2024-03-20</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="软件工程"><a href="#软件工程" class="headerlink" title="软件工程"></a>软件工程</h1><p>描述软件需求的方法：</p>
<p>功能层次模型：一般来讲就是系统的功能图，模块分布图等描述整个系统的功能的分布和功能的层次结构；</p>
<p>数据流模型：就是以数据流为着眼点的分析方法得到的模型，主要通过数据在整个系统的流动情况来确定系统的主要功能主线和流程；</p>
<p>控制流模型：通过了解和界定系统中控制线，通过控制流的走向和控制的对象来确定系统的功能分布和控制与被控制的关系；</p>
<p><strong>结构化分析（SA)</strong> 方法是一种面向数据流的需求分析方法，它适用于分析大型数据处理系统。结构化分析方法的基本思想是自顶向下逐层分解，这样做可以把一个大问题分解成若干个小问题，经过多次逐层分解，每个最底层的问题都是足够简单、容易解决的，这个过程就是分解的过程。</p>
<p>结构化方法的分析结果由数据流图DFD、数据词典和加工逻辑说明几个部分组成。其中，DFD的基本成分有数据流（data flow）、加工（process）、文件（file）和源/宿（source/sink）。</p>
<p><strong>结构化设计（SD)</strong> 方法是一种面向数据流的设计方法，它可以与SA方法衔接。</p>
<p>结构化设计采用<strong>结构图（SC）</strong> 来描述程序的结构。其基本成分有模块、调用和输入/输出数据。</p>
<p>结构图：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml32068\wps1.jpg">　 <img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml32068\wps2.jpg"></td>
<td></td>
</tr>
<tr>
<td></td>
<td><img src="file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml32068\wps3.jpg"></td>
</tr>
</tbody></table>
<p>条件调用&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;循环调用</p>
<p>&nbsp;&nbsp;&nbsp;在需求分析阶段用SA方法产生了<strong>数据流图（DFD）</strong> 。面向数据流的设计可以方便的将DFD转换成程序结构图。DFD从系统的输入数据流到系统的输出数据流的一连串连续变换形成一条信息流。DFD的信息流大体可分为两种类型：变换流和事务流。与之对应的也存在两种分析，变换分析和事务分析。变换分析是从变换流型的DFD导出程序结构图，而事务分析则是从事务流行型的DFD导出程序结构图。</p>
<p>SD方法的具体设计步骤为：</p>
<p>Ø&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 复查并精化数据流图</p>
<p>Ø&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 确定DFD的信息流类型</p>
<p>Ø&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 根据信息流类型分别将变换流或事务流转换成程序结构图</p>
<p>Ø&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 根据软件设计的原则对程序结构图作改进</p>
<ul>
<li>测试</li>
</ul>
<p>白盒测试是根据程序的内部逻辑来设计测试用例，常用的技术是逻辑覆盖，即考察用例测试数据运行被测程序时对程序逻辑的覆盖程度。主要的覆盖标准有6种： </p>
<p>黑盒测试</p>
<p>黑盒测试时根据规格说明所规定的功能来设计测试用例，它不考虑程序的内部结构和处理过程。常用的黑盒测试技术有：</p>
<p>Ø&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 等价类划分</p>
<p>Ø&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 边值划分</p>
<p>Ø&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 错误猜测</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zuofw.github.io/2023/09/17/hou-duan/ssm-practice/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="QingQiu">
      <meta itemprop="description" content="个人网站，学习记录，面试记录和经验总结、互联网中一块属于自己的小窝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="QingQiu'Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/09/17/hou-duan/ssm-practice/" class="post-title-link" itemprop="url">ssm-practice</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-09-17 09:00:02" itemprop="dateCreated datePublished" datetime="2023-09-17T09:00:02+08:00">2023-09-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-06-18 19:43:09" itemprop="dateModified" datetime="2024-06-18T19:43:09+08:00">2024-06-18</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Springboot练习"><a href="#Springboot练习" class="headerlink" title="Springboot练习"></a>Springboot练习</h1><p>通过atguigu的今日头条项目进行项目驱动式学习<br>前端已准备</p>
<h2 id="后端开发"><a href="#后端开发" class="headerlink" title="后端开发"></a>后端开发</h2><p>要求：后端使用springboot整合mybatis和springmvc来进行简单的增删改查</p>
<ol>
<li>导入依赖:<ul>
<li>springboot启动包，springboot-web项目启动包，mybatis插件，数据库配置启动器springboot-starter-jdbc，druid启动器，mysql驱动类，lombok，aop,test,打包插件</li>
</ul>
</li>
<li>编写配置类:<br>mybatis的配置类可以使用yaml格式或者是properties格式的文件，推荐使用yaml格式的文件，有分层的效果<br>[[Tools#yaml|查看Tools中的yaml]]<br><a target="_blank" rel="noopener" href="https://www.runoob.com/w3cnote/yaml-intro.html">菜鸟教程</a><br><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/current/reference/html/application-properties.html#appendix.application-properties">具体配置</a><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token comment"># server配置</span>
<span class="token key atrule">server</span><span class="token punctuation">:</span>
  <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">8080</span>
  <span class="token key atrule">servlet</span><span class="token punctuation">:</span>
    <span class="token key atrule">context-path</span><span class="token punctuation">:</span> / <span class="token comment">#默认的根路径</span>

<span class="token comment"># 连接池配置</span>
<span class="token key atrule">spring</span><span class="token punctuation">:</span>
  <span class="token key atrule">datasource</span><span class="token punctuation">:</span>
    <span class="token key atrule">type</span><span class="token punctuation">:</span> com.alibaba.druid.pool.DruidDataSource
    <span class="token key atrule">druid</span><span class="token punctuation">:</span>
      <span class="token key atrule">url</span><span class="token punctuation">:</span> jdbc<span class="token punctuation">:</span>mysql<span class="token punctuation">:</span>///sm_db1
      <span class="token key atrule">username</span><span class="token punctuation">:</span> root
      <span class="token key atrule">password</span><span class="token punctuation">:</span> root
      <span class="token key atrule">driver-class-name</span><span class="token punctuation">:</span> com.mysql.cj.jdbc.Driver

<span class="token comment"># mybatis-plus的配置</span>
<span class="token key atrule">mybatis-plus</span><span class="token punctuation">:</span>
  <span class="token key atrule">type-aliases-package</span><span class="token punctuation">:</span> com.atguigu.pojo
  <span class="token key atrule">global-config</span><span class="token punctuation">:</span>
    <span class="token key atrule">db-config</span><span class="token punctuation">:</span>
      <span class="token key atrule">logic-delete-field</span><span class="token punctuation">:</span> isDeleted  <span class="token comment">#全局逻辑删除</span>
      <span class="token key atrule">id-type</span><span class="token punctuation">:</span> auto <span class="token comment">#直接使用springboot来进行配置，就不需要再加上这个注解了</span>
      <span class="token key atrule">table-prefix</span><span class="token punctuation">:</span> news_ <span class="token comment"># 设置表的前缀</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li>druid兼容文件<pre class="line-numbers language-none"><code class="language-none">文件名:
org.springframework.boot.autoconfigure.AutoConfiguration.imports
内容:
com.alibaba.druid.spring.boot3.autoconfigure.DruidDataSourceAutoConfigure<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li>
<li>编写启动类main<br><strong>疑问： 什么是乐观锁和悲观锁</strong><br>配置使用的插件 [[java#^f13de1]]<br><a target="_blank" rel="noopener" href="https://baomidou.com/pages/2976a3/#%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98-sql-%E8%A7%A3%E6%9E%90">教程</a><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@SpringBootApplication</span>
<span class="token annotation punctuation">@MapperScan</span><span class="token punctuation">(</span><span class="token string">"com.atguigu.mapper"</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">SpringApplication</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token class-name">Main</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">//配置mybatis-plus插件</span>
    <span class="token annotation punctuation">@Bean</span>
    <span class="token keyword">public</span> <span class="token class-name">MybatisPlusInterceptor</span> <span class="token function">mybatisPlusInterceptor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">MybatisPlusInterceptor</span> interceptor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MybatisPlusInterceptor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        interceptor<span class="token punctuation">.</span><span class="token function">addInnerInterceptor</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">PaginationInnerInterceptor</span><span class="token punctuation">(</span><span class="token class-name">DbType</span><span class="token punctuation">.</span><span class="token constant">MYSQL</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//分页</span>
        interceptor<span class="token punctuation">.</span><span class="token function">addInnerInterceptor</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">OptimisticLockerInnerInterceptor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//乐观锁</span>
        interceptor<span class="token punctuation">.</span><span class="token function">addInnerInterceptor</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">BlockAttackInnerInterceptor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//防全局修改和删除</span>
        <span class="token keyword">return</span> interceptor<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li>工具类封装:主要是统一返回结果的类<br> 结果封装类</li>
</ol>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/**
 * 全局统一返回结果类
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Result</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span> <span class="token comment">//T是要使用的泛型，要在这里声明</span>
    <span class="token comment">// 返回码</span>
    <span class="token keyword">private</span> <span class="token class-name">Integer</span> code<span class="token punctuation">;</span>
    <span class="token comment">// 返回消息</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> message<span class="token punctuation">;</span>
    <span class="token comment">// 返回数据</span>
    <span class="token keyword">private</span> <span class="token class-name">T</span> data<span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token class-name">Result</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token comment">// 返回数据</span>
    <span class="token comment">//泛型方法，要将 要使用的泛型在返回类型之前进行声明</span>
    <span class="token keyword">protected</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">Result</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token function">build</span><span class="token punctuation">(</span><span class="token class-name">T</span> data<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Result</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Result</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>data <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
            result<span class="token punctuation">.</span><span class="token function">setData</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> result<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">Result</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token function">build</span><span class="token punctuation">(</span><span class="token class-name">T</span> body<span class="token punctuation">,</span> <span class="token class-name">Integer</span> code<span class="token punctuation">,</span> <span class="token class-name">String</span> message<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Result</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> result <span class="token operator">=</span> <span class="token function">build</span><span class="token punctuation">(</span>body<span class="token punctuation">)</span><span class="token punctuation">;</span>
        result<span class="token punctuation">.</span><span class="token function">setCode</span><span class="token punctuation">(</span>code<span class="token punctuation">)</span><span class="token punctuation">;</span>
        result<span class="token punctuation">.</span><span class="token function">setMessage</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> result<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">Result</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token function">build</span><span class="token punctuation">(</span><span class="token class-name">T</span> body<span class="token punctuation">,</span> <span class="token class-name">ResultCodeEnum</span> resultCodeEnum<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Result</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> result <span class="token operator">=</span> <span class="token function">build</span><span class="token punctuation">(</span>body<span class="token punctuation">)</span><span class="token punctuation">;</span>
        result<span class="token punctuation">.</span><span class="token function">setCode</span><span class="token punctuation">(</span>resultCodeEnum<span class="token punctuation">.</span><span class="token function">getCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        result<span class="token punctuation">.</span><span class="token function">setMessage</span><span class="token punctuation">(</span>resultCodeEnum<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> result<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">/**
     * 操作成功
     * @param data  baseCategory1List
     * @param &lt;T&gt;
     * @return
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">Result</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token function">ok</span><span class="token punctuation">(</span><span class="token class-name">T</span> data<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token class-name">Result</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> result <span class="token operator">=</span> <span class="token function">build</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token function">build</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token class-name">ResultCodeEnum</span><span class="token punctuation">.</span><span class="token constant">SUCCESS</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token class-name">Result</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token function">message</span><span class="token punctuation">(</span><span class="token class-name">String</span> msg<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setMessage</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token class-name">Result</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token function">code</span><span class="token punctuation">(</span><span class="token class-name">Integer</span> code<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setCode</span><span class="token punctuation">(</span>code<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token class-name">Integer</span> <span class="token function">getCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> code<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setCode</span><span class="token punctuation">(</span><span class="token class-name">Integer</span> code<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>code <span class="token operator">=</span> code<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> message<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setMessage</span><span class="token punctuation">(</span><span class="token class-name">String</span> message<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>message <span class="token operator">=</span> message<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token class-name">T</span> <span class="token function">getData</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> data<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setData</span><span class="token punctuation">(</span><span class="token class-name">T</span> data<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>data <span class="token operator">=</span> data<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>解决枚举类<br>枚举类可以使用 常量(具体的常量内容来进行枚举)</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/**
 * 统一返回结果状态信息类
 *
 */</span>
<span class="token keyword">public</span> <span class="token keyword">enum</span> <span class="token class-name">ResultCodeEnum</span> <span class="token punctuation">{</span>

    <span class="token function">SUCCESS</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">,</span><span class="token string">"success"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token function">USERNAME_ERROR</span><span class="token punctuation">(</span><span class="token number">501</span><span class="token punctuation">,</span><span class="token string">"usernameError"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token function">PASSWORD_ERROR</span><span class="token punctuation">(</span><span class="token number">503</span><span class="token punctuation">,</span><span class="token string">"passwordError"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token function">NOTLOGIN</span><span class="token punctuation">(</span><span class="token number">504</span><span class="token punctuation">,</span><span class="token string">"notLogin"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token function">USERNAME_USED</span><span class="token punctuation">(</span><span class="token number">505</span><span class="token punctuation">,</span><span class="token string">"userNameUsed"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">private</span> <span class="token class-name">Integer</span> code<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> message<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">ResultCodeEnum</span><span class="token punctuation">(</span><span class="token class-name">Integer</span> code<span class="token punctuation">,</span> <span class="token class-name">String</span> message<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>code <span class="token operator">=</span> code<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>message <span class="token operator">=</span> message<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token class-name">Integer</span> <span class="token function">getCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> code<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> message<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>MD5加密工具类</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>security<span class="token punctuation">.</span></span><span class="token class-name">MessageDigest</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>security<span class="token punctuation">.</span></span><span class="token class-name">NoSuchAlgorithmException</span></span><span class="token punctuation">;</span>

<span class="token annotation punctuation">@Component</span>
<span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">MD5Util</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">String</span> <span class="token function">encrypt</span><span class="token punctuation">(</span><span class="token class-name">String</span> strSrc<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token keyword">char</span> hexChars<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token char">'0'</span><span class="token punctuation">,</span> <span class="token char">'1'</span><span class="token punctuation">,</span> <span class="token char">'2'</span><span class="token punctuation">,</span> <span class="token char">'3'</span><span class="token punctuation">,</span> <span class="token char">'4'</span><span class="token punctuation">,</span> <span class="token char">'5'</span><span class="token punctuation">,</span> <span class="token char">'6'</span><span class="token punctuation">,</span> <span class="token char">'7'</span><span class="token punctuation">,</span> <span class="token char">'8'</span><span class="token punctuation">,</span>
                    <span class="token char">'9'</span><span class="token punctuation">,</span> <span class="token char">'a'</span><span class="token punctuation">,</span> <span class="token char">'b'</span><span class="token punctuation">,</span> <span class="token char">'c'</span><span class="token punctuation">,</span> <span class="token char">'d'</span><span class="token punctuation">,</span> <span class="token char">'e'</span><span class="token punctuation">,</span> <span class="token char">'f'</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
            <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> bytes <span class="token operator">=</span> strSrc<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//获得m5的实例</span>
            <span class="token class-name">MessageDigest</span> md <span class="token operator">=</span> <span class="token class-name">MessageDigest</span><span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token string">"MD5"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            md<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span>bytes<span class="token punctuation">)</span><span class="token punctuation">;</span>
            bytes <span class="token operator">=</span> md<span class="token punctuation">.</span><span class="token function">digest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">int</span> j <span class="token operator">=</span> bytes<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
            <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> chars <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">char</span><span class="token punctuation">[</span>j <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> bytes<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">byte</span> b <span class="token operator">=</span> bytes<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
                chars<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> hexChars<span class="token punctuation">[</span>b <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">4</span> <span class="token operator">&amp;</span> <span class="token number">0xf</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
                chars<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> hexChars<span class="token punctuation">[</span>b <span class="token operator">&amp;</span> <span class="token number">0xf</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>chars<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">NoSuchAlgorithmException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token string">"MD5加密出错！！+"</span> <span class="token operator">+</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol start="6">
<li>使用mybatisX插件，选中表之后逆向工程生成实体类和接口(注意自己补充和删减一些注释)<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Data</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token keyword">implements</span> <span class="token class-name">Serializable</span> <span class="token punctuation">{</span>
    
    <span class="token annotation punctuation">@TableId</span> <span class="token comment">//主键</span>
    <span class="token keyword">private</span> <span class="token class-name">Integer</span> uid<span class="token punctuation">;</span>

    <span class="token keyword">private</span> <span class="token class-name">String</span> username<span class="token punctuation">;</span>

    <span class="token keyword">private</span> <span class="token class-name">String</span> userPwd<span class="token punctuation">;</span>

    <span class="token keyword">private</span> <span class="token class-name">String</span> nickName<span class="token punctuation">;</span>

    <span class="token annotation punctuation">@Version</span> <span class="token comment">//版本</span>
    <span class="token keyword">private</span> <span class="token class-name">Integer</span> version<span class="token punctuation">;</span>

    <span class="token annotation punctuation">@TableLogic</span> <span class="token comment">//逻辑删除</span>
    <span class="token keyword">private</span> <span class="token class-name">Integer</span> isDeleted<span class="token punctuation">;</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> <span class="token number">1L</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
补充:<br>[[java#^86b436||逻辑删除]]</li>
<li>使用jwt来生成[[Web学习#Token是一种令牌，用来识别访问人员的|Token]]</li>
<li>JSON Web Token JWT由三部分组成: header(头部).payload(载荷).signature(签名)<br>1. 导入依赖</li>
</ol>
<pre><code><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>io.jsonwebtoken<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>jjwt<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>0.9.1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>javax.xml.bind<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>jaxb-api<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>2.3.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</code></pre>
<ol start="2">
<li><p>编写配置</p>
<p> application.yaml</p>
 <pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token comment">#jwt配置</span>
<span class="token key atrule">jwt</span><span class="token punctuation">:</span>
  <span class="token key atrule">token</span><span class="token punctuation">:</span>
    <span class="token key atrule">tokenExpiration</span><span class="token punctuation">:</span> <span class="token number">120</span> <span class="token comment">#有效时间,单位分钟</span>
    <span class="token key atrule">tokenSignKey</span><span class="token punctuation">:</span> headline123456  <span class="token comment">#当前程序签名秘钥 自定义</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>导入工具类</p>
<p> 封装jwt技术工具类</p>
 <pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>atguigu<span class="token punctuation">.</span>utils</span><span class="token punctuation">;</span>

<span class="token keyword">import</span> <span class="token import"><span class="token namespace">com<span class="token punctuation">.</span>alibaba<span class="token punctuation">.</span>druid<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">StringUtils</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">io<span class="token punctuation">.</span>jsonwebtoken<span class="token punctuation">.</span></span><span class="token operator">*</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">lombok<span class="token punctuation">.</span></span><span class="token class-name">Data</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>context<span class="token punctuation">.</span>properties<span class="token punctuation">.</span></span><span class="token class-name">ConfigurationProperties</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>context<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">Configuration</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>stereotype<span class="token punctuation">.</span></span><span class="token class-name">Component</span></span><span class="token punctuation">;</span>

<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Date</span></span><span class="token punctuation">;</span>

<span class="token annotation punctuation">@Data</span>
<span class="token annotation punctuation">@Component</span>
<span class="token annotation punctuation">@ConfigurationProperties</span><span class="token punctuation">(</span>prefix <span class="token operator">=</span> <span class="token string">"jwt.token"</span><span class="token punctuation">)</span> <span class="token comment">//使用这个就可以省略前缀，如果后面的变量名和配置中相同的话就可以自动装配而不用手动装配了</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">JwtHelper</span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span>  <span class="token keyword">long</span> tokenExpiration<span class="token punctuation">;</span> <span class="token comment">//有效时间,单位毫秒 1000毫秒 == 1秒</span>
    <span class="token keyword">private</span>  <span class="token class-name">String</span> tokenSignKey<span class="token punctuation">;</span>  <span class="token comment">//当前程序签名秘钥</span>

    <span class="token comment">//生成token字符串</span>
    <span class="token keyword">public</span>  <span class="token class-name">String</span> <span class="token function">createToken</span><span class="token punctuation">(</span><span class="token class-name">Long</span> userId<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"tokenExpiration = "</span> <span class="token operator">+</span> tokenExpiration<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"tokenSignKey = "</span> <span class="token operator">+</span> tokenSignKey<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">String</span> token <span class="token operator">=</span> <span class="token class-name">Jwts</span><span class="token punctuation">.</span><span class="token function">builder</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

                <span class="token punctuation">.</span><span class="token function">setSubject</span><span class="token punctuation">(</span><span class="token string">"YYGH-USER"</span><span class="token punctuation">)</span>
                <span class="token punctuation">.</span><span class="token function">setExpiration</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> tokenExpiration<span class="token operator">*</span><span class="token number">1000</span><span class="token operator">*</span><span class="token number">60</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//单位分钟</span>
                <span class="token punctuation">.</span><span class="token function">claim</span><span class="token punctuation">(</span><span class="token string">"userId"</span><span class="token punctuation">,</span> userId<span class="token punctuation">)</span>
                <span class="token punctuation">.</span><span class="token function">signWith</span><span class="token punctuation">(</span><span class="token class-name">SignatureAlgorithm</span><span class="token punctuation">.</span><span class="token constant">HS512</span><span class="token punctuation">,</span> tokenSignKey<span class="token punctuation">)</span>
                <span class="token punctuation">.</span><span class="token function">compressWith</span><span class="token punctuation">(</span><span class="token class-name">CompressionCodecs</span><span class="token punctuation">.</span><span class="token constant">GZIP</span><span class="token punctuation">)</span>
                <span class="token punctuation">.</span><span class="token function">compact</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> token<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">//从token字符串获取userid</span>
    <span class="token keyword">public</span>  <span class="token class-name">Long</span> <span class="token function">getUserId</span><span class="token punctuation">(</span><span class="token class-name">String</span> token<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token class-name">StringUtils</span><span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span>token<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token class-name">Jws</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Claims</span><span class="token punctuation">&gt;</span></span> claimsJws <span class="token operator">=</span> <span class="token class-name">Jwts</span><span class="token punctuation">.</span><span class="token function">parser</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setSigningKey</span><span class="token punctuation">(</span>tokenSignKey<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">parseClaimsJws</span><span class="token punctuation">(</span>token<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Claims</span> claims <span class="token operator">=</span> claimsJws<span class="token punctuation">.</span><span class="token function">getBody</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Integer</span> userId <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Integer</span><span class="token punctuation">)</span>claims<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"userId"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> userId<span class="token punctuation">.</span><span class="token function">longValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>



    <span class="token comment">//判断token是否有效</span>
    <span class="token keyword">public</span>  <span class="token keyword">boolean</span> <span class="token function">isExpiration</span><span class="token punctuation">(</span><span class="token class-name">String</span> token<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token keyword">boolean</span> isExpire <span class="token operator">=</span> <span class="token class-name">Jwts</span><span class="token punctuation">.</span><span class="token function">parser</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
                    <span class="token punctuation">.</span><span class="token function">setSigningKey</span><span class="token punctuation">(</span>tokenSignKey<span class="token punctuation">)</span>
                    <span class="token punctuation">.</span><span class="token function">parseClaimsJws</span><span class="token punctuation">(</span>token<span class="token punctuation">)</span>
                    <span class="token punctuation">.</span><span class="token function">getBody</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
                    <span class="token punctuation">.</span><span class="token function">getExpiration</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">before</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">//没有过期，有效，返回false</span>
            <span class="token keyword">return</span> isExpire<span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">//过期出现异常，返回true</span>
            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><p>编写controller<br>知识点：跨域: 例如从不同的服务器或域名获取信息。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
</ol>
<h2 id="时间格式解决"><a href="#时间格式解决" class="headerlink" title="时间格式解决"></a>时间格式解决</h2><p><img src="/2023/09/17/hou-duan/ssm-practice/timeFormat.png" class="lazyload" data-srcset="/2023/09/17/hou-duan/ssm-practice/timeFormat.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="timeformat"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zuofw.github.io/2023/09/09/hou-duan/xue-suan-fa/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="QingQiu">
      <meta itemprop="description" content="个人网站，学习记录，面试记录和经验总结、互联网中一块属于自己的小窝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="QingQiu'Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/09/09/hou-duan/xue-suan-fa/" class="post-title-link" itemprop="url">学算法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-09-09 20:35:34" itemprop="dateCreated datePublished" datetime="2023-09-09T20:35:34+08:00">2023-09-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-04-21 13:01:14" itemprop="dateModified" datetime="2024-04-21T13:01:14+08:00">2024-04-21</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="JAVA-快写"><a href="#JAVA-快写" class="headerlink" title="JAVA 快写"></a>JAVA 快写</h2><h2 id="最短路与具体的路径记录问题"><a href="#最短路与具体的路径记录问题" class="headerlink" title="最短路与具体的路径记录问题"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-edges-in-shortest-paths/description/">最短路与具体的路径记录问题</a></h2><h2 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">TreeMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
map<span class="token punctuation">.</span><span class="token function">getOrDefault</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span> 获得这个数，如果为空<span class="token punctuation">,</span>返回默认值，可以自己设定
k <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">higherKey</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span> 获得下一个顺序的键<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h2 id="把toCharArray向右移动一位"><a href="#把toCharArray向右移动一位" class="headerlink" title="把toCharArray向右移动一位"></a>把toCharArray向右移动一位</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"> a <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token char">' '</span><span class="token operator">+</span> re<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="a-z-之间偏移量确认"><a href="#a-z-之间偏移量确认" class="headerlink" title="a ~ z 之间偏移量确认"></a>a ~ z 之间偏移量确认</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token char">'a'</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> offset <span class="token operator">-</span> <span class="token char">'a'</span><span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">26</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="看到唯一解，且是难以做的图形题，可以考虑转化为方程"><a href="#看到唯一解，且是难以做的图形题，可以考虑转化为方程" class="headerlink" title="看到唯一解，且是难以做的图形题，可以考虑转化为方程"></a>看到唯一解，且是难以做的图形题，可以考虑转化为方程</h2><p><a target="_blank" rel="noopener" href="https://www.lanqiao.cn/problems/17160/learning/?contest_id=179">https://www.lanqiao.cn/problems/17160/learning/?contest_id=179</a></p>
<h3 id="卡特兰数问题-：h-n-x3D-C-2n-n-−C-2n-n−1-n-x3D-0-1-2-…-组合数C不解释了；-C是组合数"><a href="#卡特兰数问题-：h-n-x3D-C-2n-n-−C-2n-n−1-n-x3D-0-1-2-…-组合数C不解释了；-C是组合数" class="headerlink" title="卡特兰数问题 ：h[n]=C[2n,n]−C [2n,n−1] (n=0,1,2,…)&nbsp;组合数C不解释了； C是组合数"></a>卡特兰数问题 ：h[n]=C[2n,n]−C [2n,n−1] (n=0,1,2,…)&nbsp;组合数C不解释了； C是组合数</h3><ol>
<li>出栈顺序问题 假设有N个数字依次入栈：1,2,3,…,n，试问有多少种出栈顺序？这里为表述简便，下文用+1表示一个元素入栈，用-1表示一个元素出栈</li>
<li>问题描述：有n对()括号，试问可以组成多少种合法正确的括号序列？</li>
</ol>
<h2 id="树是无向边"><a href="#树是无向边" class="headerlink" title="树是无向边"></a>树是无向边</h2><h2 id="Java日期"><a href="#Java日期" class="headerlink" title="Java日期"></a>Java日期</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">LocalDate</span> d1 <span class="token operator">=</span> <span class="token class-name">LocalDate</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span><span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>time<span class="token punctuation">.</span>format<span class="token punctuation">.</span></span>DateTimeFormatter</span><span class="token punctuation">.</span><span class="token constant">BASIC_ISO_DATE</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		s <span class="token operator">=</span> reader<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token class-name">LocalDate</span> d2 <span class="token operator">=</span> <span class="token class-name">LocalDate</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span><span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>time<span class="token punctuation">.</span>format<span class="token punctuation">.</span></span>DateTimeFormatter</span><span class="token punctuation">.</span><span class="token constant">BASIC_ISO_DATE</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">long</span> diff <span class="token operator">=</span> <span class="token class-name">ChronoUnit</span><span class="token punctuation">.</span><span class="token constant">DAYS</span><span class="token punctuation">.</span><span class="token function">between</span><span class="token punctuation">(</span>d1<span class="token punctuation">,</span> d2<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">abs</span><span class="token punctuation">(</span>diff<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">BufferedWriter</span> writer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedWriter</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">OutputStreamWriter</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
writer<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 才会写<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h2 id="JAVA更快更强的读入和写-https-www-luogu-com-cn-problem-P2367"><a href="#JAVA更快更强的读入和写-https-www-luogu-com-cn-problem-P2367" class="headerlink" title="JAVA更快更强的读入和写 https://www.luogu.com.cn/problem/P2367"></a>JAVA更快更强的读入和写 <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P2367">https://www.luogu.com.cn/problem/P2367</a></h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"> <span class="token class-name">StreamTokenizer</span> reader <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StreamTokenizer</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

reader<span class="token punctuation">.</span><span class="token function">nextToken</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
n <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> reader<span class="token punctuation">.</span>nval<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="取余数的小技巧"><a href="#取余数的小技巧" class="headerlink" title="取余数的小技巧"></a>取余数的小技巧</h2><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token punctuation">(</span>x + n<span class="token punctuation">)</span> % n 可以保证不会出现负数<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>先思考再做题，前几个题大概率时模拟题，所以别急着用算法</p>
<h2 id="常用算法"><a href="#常用算法" class="headerlink" title="常用算法"></a>常用算法</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">next_permutation</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>a<span class="token operator">+</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span> 对数组的前n个数进行全排列，并存储在这个数组中
<span class="token keyword">char</span> a<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span>
<span class="token function">puts</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> 可以直接输出一行，如果不是最后一行还会输出换行符
求 q<span class="token operator">^</span><span class="token number">0</span> <span class="token operator">+</span> q<span class="token operator">^</span><span class="token number">1</span> <span class="token operator">+</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token operator">+</span> q<span class="token operator">^</span>n
<span class="token keyword">long</span> <span class="token keyword">long</span> t <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token keyword">while</span><span class="token punctuation">(</span>n<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">//秦九zhao算法</span>
    t <span class="token operator">=</span> <span class="token punctuation">(</span>t <span class="token operator">*</span>q <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span>mod<span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>整数划分</strong><a target="_blank" rel="noopener" href="https://ac.nowcoder.com/acm/problem/252724">https://ac.nowcoder.com/acm/problem/252724</a></p>
<p>accumulate 求和</p>
<p>快乐的模板：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits/stdc++.h&gt;  
#define ll long long   
#define pii pair&lt;int,int&gt;  
using namespace std;  
void solve(){  
 &nbsp; &nbsp;return ;  
}  
int main(){  
 &nbsp; &nbsp;ios::sync_with_stdio(false);  
 &nbsp; &nbsp;cin.tie(nullptr);  
 &nbsp; &nbsp;int T;  
 &nbsp; &nbsp;cin &gt;&gt; T;  
 &nbsp; &nbsp;while (T--) solve();  
 &nbsp; &nbsp;return 0;  
}  
​```


## 小TIPS：

做题思路：

1. 从小数据，小范围推大范围
    
2. 划分，以及反证，如果要求全部满足一个性质，那么只要有部分不满足我们已经推出来的条件即可不满足所有性质
    

&gt; 1. 数组和字符串比较字典序是可以直接用大于号小于号比较的
&gt;     
&gt; 2. 字典序是指在ASCII码中出现的顺序所以 也就是 a b c 0 1 2 3 ABC 等z
&gt;     
&gt; 3. vector &lt;&gt; 可以直接赋值
&gt;     

## 牛顿迭代法：

求平方根

例子： f(x)=m,可转化为 g(x)=f(x)-m=0;

迭代公式：_x_n+1 = _x_n − _g_ (_x_n)/ _g_ ′ (_x_n)

例题：[力扣（LeetCode）官网 - 全球极客挚爱的技术成长平台](https://leetcode.cn/problems/sqrtx/submissions/431189596/)
```c++
//f (x) = x2 − a = 0  
int mySqrt(int a) {  
long x = a;  
while (x * x &gt; a) {  
x = (x + a / x) / 2;  
}  
return x;  
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="stl和一些内置函数"><a href="#stl和一些内置函数" class="headerlink" title="stl和一些内置函数"></a>stl和一些内置函数</h3><p>accumulate(num.begin(),num.end(),0); //第三个参数是初始化要返回的东西 </p>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="快速排序模板-根据数来分治"><a href="#快速排序模板-根据数来分治" class="headerlink" title="快速排序模板 根据数来分治"></a>快速排序模板 根据数来分治</h3><p>先找数字中的中位数，然后递归<br><strong>注意：</strong> while中先递归的左边，那么最后递归的时候就要以j来为界限，递归的顺序无所谓</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void quick_sort(int q[], int l, int r)
{
    if (l &gt;= r) return;
    int x = q[rand()% (r-l+1)+l]; // 随机取
    int i = l - 1, j = r + 1; 
    while (i &lt; j) {
        do i++; while (q[i] &lt; x);
        do j--; while (q[j] &gt; x);
        if (i &lt; j) swap(q[i], q[j]);    //如果i与j没有相遇，就交换一下
    }

    quick_sort(q, l, j);    //递归处理左右两边
    quick_sort(q, j + 1, r);
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="归并排序模板-分治-根据中间两个数为分界线"><a href="#归并排序模板-分治-根据中间两个数为分界线" class="headerlink" title="归并排序模板 分治 根据中间两个数为分界线"></a>归并排序模板 分治 根据中间两个数为分界线</h3><ol>
<li><p>确定分界点， mid=(l+r)/2</p>
</li>
<li><p>递归排序 left，right</p>
</li>
<li><p>归并 合二为一</p>
</li>
</ol>
<p>模板</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">
void msort(int a[], int l, int r) {  
    if (l &gt;= r) return;  
    //确定分界  
    int mid = l + r &gt;&gt; 1;  
    //递归  
    msort(a, l, mid); msort(a, mid + 1, r);  
    //归并  
    int k = 0, i = l, j = mid + 1;  
      
    while (i &lt;=mid &amp;&amp; j &lt;= r) {//左右比较，小的放在辅助数组里，直到有一个指针到达边界  
        if (a[i] &lt;= a[j]) tmp[k++] = a[i++];  
        else tmp[k++] = a[j++];  
    }  
    //这里继续把另一个没到边界的指针赋值给辅助数组  
    while (i &lt;= mid) tmp[k++] = a[i++];  
    while (j &lt;= r)tmp[k++] = a[j++];  
    //最后把辅助数组的元素还回去  
    for (int i = l, j = 0; i &lt;= r; i++, j++) a[i] = tmp[j];  
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="二分法-二分要保证有解"><a href="#二分法-二分要保证有解" class="headerlink" title="二分法 二分要保证有解"></a>二分法 二分要保证有解</h2><h3 id="整数二分"><a href="#整数二分" class="headerlink" title="整数二分"></a>整数二分</h3><p>一分为二，一边满足性质，一半不满足，可以来用来寻找性质的边界</p>
<p>两种模板：一种去检查满足的一半，另一种去检查不满足性质的的一半</p>
<p>考虑边界是否会包括进去</p>
<ol>
<li><p>先写出 mid=r+l&gt;&gt;1</p>
</li>
<li><p>二分要检查的性质</p>
</li>
<li><p>画图考虑，直线图</p>
</li>
<li><p>思考mid是否会包含</p>
</li>
<li><p>考虑不存在条件时</p>
</li>
</ol>
<h2 id="l-x3D-mid-1-时-输出的是-L-r-x3D-mid-1-时-输出的是r"><a href="#l-x3D-mid-1-时-输出的是-L-r-x3D-mid-1-时-输出的是r" class="headerlink" title="l = mid + 1 时,输出的是 L , r = mid -1 时 输出的是r"></a>l = mid + 1 时,输出的是 L , r = mid -1 时 输出的是r</h2><p>注意死循环，男左女右，查找从右侧往左的时候mid 要 + 1，否则不+1</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">l + (r - l + 1 &gt;&gt; 1); 
​<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">更好的二分模板
<span class="token keyword">while</span><span class="token punctuation">(</span>l<span class="token operator">&lt;=</span>r<span class="token punctuation">)</span><span class="token punctuation">{</span>
	mid <span class="token operator">=</span> <span class="token punctuation">(</span>l <span class="token operator">+</span> r<span class="token punctuation">)</span> <span class="token operator">&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>mid <span class="token operator">&lt;</span> r<span class="token punctuation">)</span> r <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token keyword">else</span>  mid <span class="token operator">=</span> l <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="浮点数二分-不要处理边界"><a href="#浮点数二分-不要处理边界" class="headerlink" title="浮点数二分 不要处理边界"></a>浮点数二分 不要处理边界</h3><p>思路：通过mid来判断，答案落在缩小的区间内，只要近似值</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">bool check(double x) {/* ... */} // 检查x是否满足某种性质  
  
double bsearch_3(double l, double r)  
{  
    const double eps = 1e-6;   // eps 表示精度，取决于题目对精度的要求  
    while (r - l &gt; eps)  
    {  
        double mid = (l + r) / 2;  
        if (check(mid)) r = mid;  
        else l = mid;  
    }  
    //或者直接不管精度，直接循环几百次  
    return l;  
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="高精度"><a href="#高精度" class="headerlink" title="高精度"></a>高精度</h2><h3 id="加法：-注意要把A设为位数更大的那一个，因为最后的位数取决于位数大的那一个，使用vector容器可以更方便的进行计算和进位和确定位数"><a href="#加法：-注意要把A设为位数更大的那一个，因为最后的位数取决于位数大的那一个，使用vector容器可以更方便的进行计算和进位和确定位数" class="headerlink" title="加法： 注意要把A设为位数更大的那一个，因为最后的位数取决于位数大的那一个，使用vector容器可以更方便的进行计算和进位和确定位数"></a>加法： 注意要把A设为位数更大的那一个，因为最后的位数取决于位数大的那一个，使用vector容器可以更方便的进行计算和进位和确定位数</h3><ol>
<li><p>逆序存数的每一位</p>
</li>
<li><p>从低位开始计算，之后计算进位</p>
</li>
<li><p>加完之后检查最后一位是否还有进位</p>
</li>
<li><p>返回数字</p>
</li>
</ol>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">vector&lt;int&gt; add(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B)  
{  
    if (A.size() &lt; B.size()) return add(B, A);  
  
    vector&lt;int&gt; C;  
    int t = 0;  
    for (int i = 0; i &lt; A.size(); i ++ )  
    {  
        t += A[i];  
        if (i &lt; B.size()) t += B[i];  
        C.push_back(t % 10);  
        t /= 10;  
    }  
  
    if (t) C.push_back(1);  
    return C;  
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="减法"><a href="#减法" class="headerlink" title="减法"></a>减法</h3><p>和加法基本一致，只要变进位为借位即可</p>
<p>// C = A - B, 满足A &gt;= B, A &gt;= 0, B &gt;= 0  </p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">vector&lt;int&gt; sub(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B)  
{  
    vector&lt;int&gt; C;  
    for (int i = 0, t = 0; i &lt; A.size(); i ++ )  
    {  
        t = A[i] - t;  
        if (i &lt; B.size()) t -= B[i];  
        C.push_back((t + 10) % 10);  
        if (t &lt; 0) t = 1;  
        else t = 0;  
    }  
  
    while (C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back();  
    return C;  
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="乘法"><a href="#乘法" class="headerlink" title="乘法"></a>乘法</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">vector&lt;int&gt; mul(vector&lt;int&gt;&amp;A,int b){  
 &nbsp; vector&lt;int&gt;C;  
 &nbsp; int t=0;  
 &nbsp; for(int i=0;i&lt;A.size()||t;i++){//出现进位  
 &nbsp; &nbsp; &nbsp;if(i&lt;A.size()) t+=A[i]*b;  
 &nbsp; &nbsp; &nbsp;C.push_back(t%10);  
 &nbsp; &nbsp; &nbsp;t/=10;  
 &nbsp; }  
 &nbsp; while(C.size()&gt;1&amp;&amp;C.back()==0) C.pop_back();  
 &nbsp; //去除前导零  
 &nbsp; return C;  
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">### 除法

vector&lt;int&gt; div(vector&lt;int&gt;&amp;A,int b){  
 &nbsp; vector&lt;int&gt;C;  
 &nbsp; int t=0;  
 &nbsp; for(int i=0;i&lt;A.size();i++){  
 &nbsp; &nbsp; &nbsp;t=t*10+A[i];  
 &nbsp; &nbsp; &nbsp;C.push_back(t/b);  
 &nbsp; &nbsp; &nbsp;t %= b;  
 &nbsp; }  
 &nbsp; //这里是清除前置零，不是后置零
 &nbsp; reverse(C.begin(),C.end());  
 &nbsp; while(C.size()&gt;1&amp;&amp;C.back()==0) C.pop_back();  
 &nbsp; return C;  
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="前缀和和差分"><a href="#前缀和和差分" class="headerlink" title="前缀和和差分"></a>前缀和和差分</h2><p><strong>构造差分可以用一个空数组，一直执行插入操作即可</strong></p>
<p>前缀和一般初始化为0到n但是只用1到n</p>
<p>二维</p>
<p>S[i, j] = 第i行j列格子左上部分所有元素的和<br>以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：<br>S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]</p>
<p>二维差分： 差分的前缀和就是原数组</p>
<p>给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：<br>S[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c//注意是x2+1,y2+1不是x2,y2</p>
<h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int x;  
int * p1 = &amp;x; // 指针可以被修改，值也可以被修改  
const int * p2 = &amp;x; // 指针可以被修改，值不可以被修改（const int）  
int * const p3 = &amp;x; // 指针不可以被修改（* const），值可以被修改  
const int * const p4 = &amp;x; // 指针不可以被修改，值也不可以被修改

for (int i = 0, j = 0; i &lt; n; i ++ )  
{  
    while (j &lt; i &amp;&amp; check(i, j)) j ++ ;  
  
    // 具体问题的逻辑  
}  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>常见问题分类：<br>    (1) 对于一个序列，用两个指针维护一段区间<br>    (2) 对于两个序列，维护某种次序，比如归并排序中合并两个有序序列的操作</p>
<h3 id="Floyd判圈法-龟兔赛跑法-用于判断链表有无环和求出环的长度"><a href="#Floyd判圈法-龟兔赛跑法-用于判断链表有无环和求出环的长度" class="headerlink" title="Floyd判圈法 龟兔赛跑法 用于判断链表有无环和求出环的长度"></a>Floyd判圈法 龟兔赛跑法 用于判断链表有无环和求出环的长度</h3><p>两个指针fast slow 都从起始位置出发，fast 一次走2步，slow一次走1步，如果能相遇，则存在环</p>
<p>计算环的长度</p>
<p>让其中一个指针停在环的起点不动，另一个一步一步向前走并记录步数，再次相遇时步数即为环的长度。</p>
<p>寻找环的起点</p>
<p>其中一个指针在环的起点不动，另一个放到起点，两个指针同时一步一步移动，则两指针将会在循环节的起点相遇。</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/linked-list-cycle-ii/description/">142. 环形链表 II - 力扣（Leetcode）</a></p>
<p>/**  </p>
<ul>
<li>Definition for singly-linked list.  </li>
<li>struct ListNode {  </li>
<li><pre><code>int val;  
</code></pre>
</li>
<li><pre><code>ListNode *next;  
</code></pre>
</li>
<li><pre><code>ListNode(int x) : val(x), next(NULL) {}  
</code></pre>
</li>
<li>};<br> */<br>class Solution {<br>public:<br> ListNode *detectCycle(ListNode *head) {<br>ListNode *fast=head,*slow=head;<br>   do{<br>   if(!fast||!fast-&gt;next) return NULL;//如果能到达末尾，则不存在环<br>   fast=fast-&gt;next-&gt;next;<br>   slow=slow-&gt;next;<br>   }while(fast!=slow);<br>   fast=head;<br>   while(fast!=slow){<br>   fast=fast-&gt;next;<br>   slow=slow-&gt;next;<br>   }<br>   return slow;<br> }<br>};</li>
</ul>
<h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><p>思路：</p>
<p>n的第k位是什么？ n&gt;&gt;k&amp;1 右移k位与1与得到是0就是0，反之就是1</p>
<ol>
<li><p>先把要判断的位置移到最左边</p>
</li>
<li><p>判断</p>
</li>
</ol>
<h3 id="lowbit"><a href="#lowbit" class="headerlink" title="lowbit"></a>lowbit</h3><p>解释：cpp的负数使用的补码表示的所以，-x就等于 ~x+1 反码+1</p>
<p>用法：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/93795692">树状数组</a>和求1的个数</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">

<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Scanner</span></span><span class="token punctuation">;</span>
<span class="token comment">// 1:无需package</span>
<span class="token comment">// 2: 类名必须Main, 不可修改</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>
    <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token class-name">N</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token number">1e5</span> <span class="token operator">+</span> <span class="token number">10</span><span class="token punctuation">;</span>
    <span class="token keyword">static</span> <span class="token keyword">long</span><span class="token punctuation">[</span><span class="token punctuation">]</span> tree <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">long</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">static</span> <span class="token keyword">int</span> n <span class="token punctuation">;</span>
    <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">lowbit</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    	<span class="token keyword">return</span> x <span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token operator">-</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">update</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token punctuation">,</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> pos <span class="token operator">=</span> i <span class="token punctuation">;</span> pos <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> pos <span class="token operator">+=</span> <span class="token function">lowbit</span><span class="token punctuation">(</span>pos<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    		tree<span class="token punctuation">[</span>pos<span class="token punctuation">]</span> <span class="token operator">+=</span> x<span class="token punctuation">;</span>
    	<span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">static</span> <span class="token keyword">long</span> <span class="token function">query</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    	<span class="token keyword">long</span> sum <span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
    	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> pos <span class="token operator">=</span> x<span class="token punctuation">;</span> pos <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">;</span> pos<span class="token operator">-=</span><span class="token function">lowbit</span><span class="token punctuation">(</span>pos<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    		sum <span class="token operator">+=</span>tree<span class="token punctuation">[</span>pos<span class="token punctuation">]</span><span class="token punctuation">;</span>
    	<span class="token punctuation">}</span>
    	<span class="token keyword">return</span> sum<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">static</span> <span class="token keyword">long</span> <span class="token function">ask</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span><span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    	<span class="token keyword">return</span> <span class="token function">query</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token function">query</span><span class="token punctuation">(</span>a<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Scanner</span> scan <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Scanner</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span>
        n <span class="token operator">=</span> scan<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> m <span class="token operator">=</span>scan<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        	<span class="token keyword">int</span> x <span class="token operator">=</span> scan<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        	<span class="token function">update</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>m<span class="token operator">--</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        	<span class="token keyword">int</span> k <span class="token operator">=</span> scan<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        	<span class="token keyword">int</span> a <span class="token operator">=</span> scan<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        	<span class="token keyword">int</span> b <span class="token operator">=</span> scan<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        	<span class="token keyword">if</span><span class="token punctuation">(</span>k <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        		<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token function">ask</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        	<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        		<span class="token function">update</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
        	<span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        scan<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="树状数组：对差分和前缀和的利用："><a href="#树状数组：对差分和前缀和的利用：" class="headerlink" title="树状数组：对差分和前缀和的利用："></a>树状数组：对差分和前缀和的利用：</h1><h3 id="使用情况："><a href="#使用情况：" class="headerlink" title="使用情况："></a>使用情况：</h3><ol>
<li><p>数组不变求区间和</p>
</li>
<li><p>多次修改某个区间，求区间和</p>
</li>
<li><p>将某个区间变为同一个数求区间和</p>
</li>
<li><p>多次修改区间，寻找定点值</p>
</li>
</ol>
<h2 id="模板："><a href="#模板：" class="headerlink" title="模板："></a>模板：</h2><p>说明：lowbit()奇妙用法…..</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define low
```bit(x) (-x)&amp;x  
///或者 int lowbit(int x) {return -x&amp;x;}  
int tree[length];//树状数组，长度和原数组相等  
//区间修改  
void update(int x,int val)  
{  
    while(x){  
        tree[x]+=val;  
        x+=lowbit(x);  
    }  
}  
//区间求和  
int sum(int l,int r){  
    int ans=0;  
    while(r){  
        ans+=tree[r];  
        r-=lowbit(r);  
    }  
    l--;//  
    while(l){  
        ans-=tree[l];  
        l-=lowbit(l);  
    }  
    return ans;  
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="使用方式："><a href="#使用方式：" class="headerlink" title="使用方式："></a>使用方式：</h2><ol>
<li><p>正常的顶点修改，区间求和直接用</p>
</li>
<li><p><strong>区间修改，求单独一个数</strong> <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3368">P3368 【模板】树状数组 2 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>
<ul>
<li><p>树状数组是保存的每一个下标为位置的前缀和</p>
</li>
<li><p>想要求指定位置的数值需要用到差分,差分的前缀和就是每一个位置的数据大小</p>
</li>
<li><p>修改时只需要修改 update(l,val),update(r+1,-val)</p>
</li>
<li><p>初始化时，要插入的是差分</p>
  <pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;  
#include &lt;algorithm&gt;  
#define ll long long  
#define lowbit(x) (x&amp;(-x))  
using namespace std;  
const int mx = 10e5 + 5;  
int t[mx], m, n;  
int add(int x, int k) {  
	while (x &lt;= n) {  
		t[x] += k;  
		x += lowbit(x);  
	}  
}  
int query(int x){  
	ll ans=0;  
	while(x){  
		ans+=t[x];  
		x-=lowbit(x);  
	}  
	return ans;  
}  
//用差分来的前缀和来表示每一位置上的数字，  
//第一个数字之后，每次把差分加入，再求前缀和就能得到每一个位置上的数字是多少了  
//修改时只需要修改x和y+1两个位置的差分，但是我们用的tree是前缀和，所以依然要用把和lowbit有关的都修改 了   
int main() {  
	cin &gt;&gt; n &gt;&gt; m;  
	int cf=0;   
	for (int i = 1; i &lt;= n; i++) {  
		int num;  
		scanf("%d", &amp;num);  
		add(i,num-cf);  
		cf=num;  
	}  
	  
	for (int i = 1; i &lt;= m; i++) {  
		int ch, x, y,k;  
		scanf("%d", &amp;ch);  
		if (ch == 1){  
			scanf("%d %d %d", &amp;x, &amp;y, &amp;k);  
			add(x,k);  
			add(y+1,-k);  
		}  
		else {  
			int s;  
			scanf("%d", &amp;s);  
			printf("%d\n", query(s));  
		}  
	}  
	return 0;  
}  
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
</li>
<li><p>用指定数据替换某个数据，然后求和 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/range-sum-query-mutable/submissions/429237767/">307. 区域和检索 - 数组可修改 - 力扣（Leetcode）</a></p>
<ul>
<li><p>更换数据也是用到了差分，新的数据-原数据==要更新的val</p>
</li>
<li><p>然后更新之后，原数组指定位置也要更新，方便下次修改同一位置</p>
</li>
<li><p>其他正常食用即可</p>
  <pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class NumArray {  
    int []t;  
    int n;  
    int []nums;  
    int lowbit(int x){return x&amp;(-x);}  
    public NumArray(int[] nums) {  
        this.nums=nums;  
        n=nums.length;  
        t=new int[n+1];  
        int i=1;  
        for (int num:nums  
             ) {  
            add(i++,num);  
        }  
    }  
    void add(int index,int val){  
        while(index&lt;=n){  
            t[index]+=val;  
            index+=lowbit(index);  
        }  
    }  
    public void update(int index, int val) {  
        add(index+1,val-nums[index]);  
        nums[index]=val;  
    }  
      
    public int sumRange(int left, int right) {  
        int ans=0;  
        right++;  
        while(right&gt;0){  
            ans+=t[right];  
            right-=lowbit(right);  
        }  
  
        while(left&gt;0){  
            ans-=t[left];  
            left-=lowbit(left);  
        }  
        return ans;  
    }  
}  
  
/**  
 * Your NumArray object will be instantiated and called as such:  
 * NumArray obj = new NumArray(nums);  
 * obj.update(index,val);  
 * int param_2 = obj.sumRange(left,right);  
 */<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
</li>
</ol>
<p>求1的个数</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;algorithm&gt;  
#include &lt;vector&gt;  
#include &lt;iostream&gt;  
#define lowbit(x) (-x)&amp;x  
using namespace std;  
int main(){  
 &nbsp; &nbsp;int n,ans=0;  
 &nbsp; &nbsp;cin&gt;&gt;n;  
 &nbsp; &nbsp;while(n){  
 &nbsp; &nbsp; &nbsp; &nbsp;ans++;  
 &nbsp; &nbsp; &nbsp; &nbsp;n-=lowbit(n);  
 &nbsp;  }  
 &nbsp; &nbsp;cout&lt;&lt;ans&lt;&lt;endl;  
 &nbsp; &nbsp;return 0;  
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="离散化"><a href="#离散化" class="headerlink" title="离散化"></a>离散化</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">unique 返回的是下下标
vector&lt;int&gt; alls; // 存储所有待离散化的值  
sort(alls.begin(), alls.end()); // 将所有值排序  
alls.erase(unique(alls.begin(), alls.end()), alls.end()); &nbsp; // 去掉重复元素  
//配合erase 即可把放在后面的重复元素删除  
/*  
该函数的作用是“去除”容器或者数组中相邻元素的重复出现的元素  
(1) 这里的去除并非真正意义的erase，而是将重复的元素放到容器的末尾，返回值是去重之后的尾地址。   
(2) unique针对的是相邻元素，所以对于顺序顺序错乱的数组成员，或者容器成员，需要先进行排序，可以调用std::sort()函数  
// 二分求出x对应的离散化的值*/  
int find(int x) // 找到第一个大于等于x的位置  
{  
 &nbsp; &nbsp;int l = 0, r = alls.size() - 1;  
 &nbsp; &nbsp;while (l &lt; r)  
 &nbsp;  {  
 &nbsp; &nbsp; &nbsp; &nbsp;int mid = l + r &gt;&gt; 1;  
 &nbsp; &nbsp; &nbsp; &nbsp;if (alls[mid] &gt;= x) r = mid;  
 &nbsp; &nbsp; &nbsp; &nbsp;else l = mid + 1;  
 &nbsp;  }  
 &nbsp; &nbsp;return r + 1; // 映射到1, 2, ...n  
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="区间和并"><a href="#区间和并" class="headerlink" title="区间和并"></a>区间和并</h2><p>每次维护一个右端点</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">// 将所有存在交集的区间合并  
void merge(vector&lt;PII&gt; &amp;segs)  
{  
    vector&lt;PII&gt; res;  
  
    sort(segs.begin(), segs.end());//根据first进行排序，默认的就是这样的不需要进行自定义  
  
    int st = -2e9, ed = -2e9;  
    for (auto seg : segs)  
        if (ed &lt; seg.first)  
        {  
            //当起点的值大于右端点的时候，一段区间结束，可以继续下一段区间了  
            if (st != -2e9) res.push_back({st, ed});  
            st = seg.first, ed = seg.second;  
        }  g
        else ed = max(ed, seg.second);//如果左没大于右端点，那么右端点每次更新完为最大值  
  
    if (st != -2e9) res.push_back({st, ed});  
    segs = res;  
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="数组模拟链表"><a href="#数组模拟链表" class="headerlink" title="数组模拟链表"></a>数组模拟链表</h2><h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">
int head,e[N],ne[N],idx;  
void init(){  
    head=-1;  
    idx=0;  
}  
//头插  
//head 也是指针,e[idx] 新节点  
void add_head(int x){  
    e[idx]=x;//插入数据  
    ne[idx]=head;//idx 当前的位置的指针指向head指向的位置 -1  
    head=idx;//head 指针指向idx   
    idx++;  
}  
//插入任意位置  
void insert_linkedlist(int k,int x){  
    e[idx]=x;//建立新节点  
    ne[idx]=ne[k];//新节点指向k的下一个节点  
    ne[k]=ne[idx]; //k指向idx这个结点  
    idx++;  
}  
void delete_linkedlist(int k){  
    ne[k]=ne[ne[k]];  
}  
int main(){  
    int k,x,m;  
    char op;  
    cin&gt;&gt;m;  
    init();  
    while(m--){  
        cin&gt;&gt;op;  
        if(op=='h'){  
            cin&gt;&gt;x;  
            add_head(x);  
        }  
        else if(op=='d'){  
            cin&gt;&gt;k;  
            delete_linkedlist(k-1);  
        }  
        else {  
            cin&gt;&gt;k&gt;&gt;x;  
            insert_linkedlist(k-1,x);  
        }  
    }  
    for(int i=head;i!=-1;i=ne[i]){cout&lt;&lt;e[i]&lt;&lt;' ';}  
    return 0;  
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">// e[]表示节点的值，l[]表示节点的左指针，r[]表示节点的右指针，idx表示当前用到了哪个节点  
int e[N], l[N], r[N], idx;  
  
// 初始化  
void init()  
{  
    //0是左端点，1是右端点  
    r[0] = 1, l[1] = 0;  
    idx = 2;  
}  
  
// 在节点a的右边插入一个数x  
void insert(int a, int x)  
{  
    e[idx] = x;  
    l[idx] = a, r[idx] = r[a];  
    l[r[a]] = idx, r[a] = idx ++ ;  
}  
  
// 删除节点a  
void remove(int a)  
{  
    l[r[a]] = l[a];  
    r[l[a]] = r[a];  
}  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">// tt表示栈顶  
int stk[N], tt = 0;  
  
// 向栈顶插入一个数  
stk[ ++ tt] = x;  
  
// 从栈顶弹出一个数  
tt -- ;  
  
// 栈顶的值  
stk[tt];  
  
// 判断栈是否为空，如果 tt &gt; 0，则表示不为空  
if (tt &gt; 0)  
{  
  
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h2><p>注意这个题目要的是结果的下标不是具体的数据</p>
<p>用栈暴力模拟一遍，然后再考虑哪些元素没有用处，就可以排除</p>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P5788">P5788 【模板】单调栈 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;  
#include &lt;cstdio&gt;  
#define ll long long   
using namespace std;  
const ll N=3*1000000+1;  
ll stk[N],a[N],ans[N];  
int tt=0;  
int main(){  
    int n;  
    cin&gt;&gt;n;  
    for(int i=1;i&lt;=n;i++){  
        scanf("%lld",&amp;a[i]);  
    }  
    for(int i=n;i&gt;0;i--){  
        while(tt!=0&amp;&amp;a[i]&gt;=a[stk[tt]]) tt--;  
        ans[i]= tt==0?0:stk[tt];  
        stk[++tt]=i;  
    }  
    for(int i=1;i&lt;=n;i++)printf("%lld ",ans[i]);  
    return 0;  
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">// hh 表示队头，tt表示队尾  
int q[N], hh = 0, tt = -1;  
  
// 向队尾插入一个数  
q[ ++ tt] = x;  
  
// 从队头弹出一个数  
hh ++ ;  
  
// 队头的值  
q[hh];  
  
// 判断队列是否为空，如果 hh &lt;= tt，则表示不为空  
if (hh &lt;= tt)  
{  
  
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h1 id="单调队列-（好东西）"><a href="#单调队列-（好东西）" class="headerlink" title="单调队列 （好东西）"></a>单调队列 （好东西）</h1><p><strong>几个点：</strong></p>
<ul>
<li><p>初始化时，hh=0,tt=-1 使得队列为空</p>
</li>
<li><p>比较的是队尾元素与当前元素</p>
</li>
<li><p>注意队列长度为0时不要输出</p>
</li>
</ul>
<p>常见模型：找出滑动窗口中的最大值/最小值  </p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int hh = 0, tt = -1;  
for (int i = 0; i &lt; n; i ++ )  
{  
    while (hh &lt;= tt &amp;&amp; check_out(q[hh])) hh ++ ;  // 判断队头是否滑出窗口  
    while (hh &lt;= tt &amp;&amp; check(q[tt], i)) tt -- ;  
    q[ ++ tt] = i;  
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>例题</p>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1886">P1886 滑动窗口 /【模板】单调队列 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;  
#include &lt;cstdio&gt;  
#define ll long long   
using namespace std;  
const int N=1000000+2;  
int n,k,a[N],q[N],ans,hh,tt;  
  
int main(){  
    cin&gt;&gt;n&gt;&gt;k;  
    for(int i=0;i&lt;n;i++){  
        scanf("%d",&amp;a[i]);  
    }  
    //队列存的是下标  
    //最小值  
    hh=0;tt=-1;//目的是让队列初始化为空  
    for(int i=0;i&lt;n;i++){  
        //判断队列是否为空  
        if(hh&lt;=tt&amp;&amp;i-k+1&gt;q[hh]) hh++;  
        //目的是把最小的元素放在队头  
        while(hh&lt;=tt&amp;&amp;a[q[tt]]&gt;=a[i]) tt--;//从队尾删除，因为经过我们的处理，已经是严格单调递增的了，所以如果第一个都大于这个元素的话，那么后面几个都大于，所以要删除  
        q[++tt]=i;  
        if(i&gt;=k-1)  
        printf("%d ",a[q[hh]]);  
    }  
    cout&lt;&lt;endl;  
    //最大值  
      hh=0;tt=-1;  
    for(int i=0;i&lt;n;i++){  
        //判断队列是否为空  
        if(hh&lt;=tt&amp;&amp;i-k+1&gt;q[hh]) hh++;  
        //目的是把最大的元素放在队头  
        while(hh&lt;=tt&amp;&amp;a[q[tt]]&lt;=a[i]) tt--;  
        q[++tt]=i;  
        if(i&gt;=k-1)  
        printf("%d ",a[q[hh]]);  
    }  
      
    return 0;  
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h2><p>对称的 ,以j这个点为中点的前后缀是相同的，所以可以直接变成next[ j ]<br><img src="file://D:/typora%E7%94%A8%E5%9B%BE/Screenshots/image-20230511171657614.png?lastModify=1694256669" alt="image-20230511171657614"></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">s从1开始，p从0开始

// s[]是长文本，p[]是模式串，n是s的长度，m是p的长度  
求模式串的Next数组：ne[1]=0  ,一开始就错了肯定从零开始
for (int i = 2, j = 0; i &lt;= m; i ++ )  
{  
    while (j &amp;&amp; p[i] != p[j + 1]) j = ne[j];  
    if (p[i] == p[j + 1]) j ++ ;  
    ne[i] = j;  
}  
  
// 匹配  
for (int i = 1, j = 0; i &lt;= n; i ++ )  
{  
    while (j &amp;&amp; s[i] != p[j + 1]) j = ne[j];  
    if (s[i] == p[j + 1]) j ++ ;  
    if (j == m)  
    {  
        j = ne[j];  
        // 匹配成功后的逻辑  
    }  
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>例题</strong></p>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3375">P3375 【模板】KMP字符串匹配 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">
#include &lt;iostream&gt;  
#include &lt;cstring&gt;  
#define N 1000010  
using namespace std;  
char s[N],p[N];  
int ls,lp,ne[N];  
int main(){  
    cin&gt;&gt;s+1&gt;&gt;p+1;  
    ls=strlen(s+1);  
    lp=strlen(p+1);  
    for(int i=2,j=0;i&lt;=lp;i++){  
        while(j&amp;&amp;p[i]!=p[j+1]) j=ne[j];  
        if(p[j+1]==p[i]) j++;  
        ne[i]=j;  
    }  
     for(int i=1,j=0;i&lt;=ls;i++){  
        while(j&amp;&amp;s[i]!=p[j+1]) j=ne[j];  
        if(s[i]==p[j+1]) j++;  
        if(j==lp){  
            cout&lt;&lt;i-lp+1&lt;&lt;endl;  
            j=ne[j];  
        }  
    }  
    for(int i=1;i&lt;=lp;i++){  
        cout&lt;&lt;ne[i]&lt;&lt;" ";  
    }  
    return 0;  
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="Trie树-高效存储和查找字符串"><a href="#Trie树-高效存储和查找字符串" class="headerlink" title="Trie树 高效存储和查找字符串"></a>Trie树 高效存储和查找字符串</h2><p>集合的数据结构</p>
<p>将字符串分解为一个一个单独的字符然后存储，然后查询这个字符串是否出现过，</p>
<p>出现过几次</p>
<h4 id="更全面-的映射"><a href="#更全面-的映射" class="headerlink" title="更全面 的映射"></a>更全面 的映射</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int getnum(char x){  
    if(x&gt;='A'&amp;&amp;x&lt;='Z')  
        return x-'A';  
    else if(x&gt;='a'&amp;&amp;x&lt;='z')  
        return x -'a'+26;  
    else  
        return x-'0'+52;  
} 

#include&lt;iostream&gt;  
#include &lt;algorithm&gt;  
#include &lt;cstdio&gt;  
using namespace std;  
const int N=100010;  
int son[N][26],cnt[N],idx;//子子节点的个数，只包含26个 小写字母 cnt是以这个字母为结尾的单词出现了福哦少个  
//idx 当前用到哪了  
//插入操作  
char str[N];  
void insert(char str[]){  
 &nbsp; &nbsp;int p=0;//当前的结点  
 &nbsp; &nbsp;for(int i=0;str[i];i++){  
 &nbsp; &nbsp; &nbsp; &nbsp;int u=str[i]-'a';//将26个小写字母映射为数字  
 &nbsp; &nbsp; &nbsp; &nbsp;if(!son[p][u]) son[p][u]=++idx;  
 &nbsp; &nbsp; &nbsp; &nbsp;p=son[p][u];  
 &nbsp;  }  
 &nbsp; &nbsp;cnt[p]++;  
}  
int query(char str[]){  
 &nbsp; &nbsp;int p=0;  
 &nbsp; &nbsp;for(int i=0;str[i];i++){  
 &nbsp; &nbsp; &nbsp; &nbsp;int u=str[i]-'a';  
 &nbsp; &nbsp; &nbsp; &nbsp;if(!son[p][u]) return 0;  
 &nbsp; &nbsp; &nbsp; &nbsp;p=son[p][u];  
 &nbsp;  }  
 &nbsp; &nbsp;return cnt[p];  
}  
int main(){  
 &nbsp; &nbsp;int n;  
 &nbsp; &nbsp;cin&gt;&gt;n;  
 &nbsp; &nbsp;while(n--){  
 &nbsp; &nbsp; &nbsp; char op[2];  
 &nbsp; &nbsp; &nbsp; cin&gt;&gt;op&gt;&gt;str;  
 &nbsp; &nbsp; &nbsp; if(op[0]=='i') insert(str);  
 &nbsp; &nbsp; &nbsp; else cout&lt;&lt;query(str)&lt;&lt;endl;  
 &nbsp;  }  
 &nbsp; &nbsp;return 0;  
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P8306">P8306 【模板】字典树 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;  
#include &lt;algorithm&gt;  
#include &lt;cstdio&gt;  
#include &lt;cstring&gt;  
using namespace std;  
const int N=3000005;  
int son[N][65],cnt[N],idx;//子子节点的个数，只包含26个 小写字母 cnt是以这个字母位借位的单词出现了福哦少个  
//idx 当前用到哪了  
//插入操作  
 int n,m,t;  
char str[N];  
int hashs(char x){  
    if(x&gt;='A'&amp;&amp;x&lt;='Z')  
        return x-'A';  
    else if(x&gt;='a'&amp;&amp;x&lt;='z')  
        return x-'a'+26;  
    else  
        return x-'0'+52;  
}  
void insert(char str[]){  
    int p=0;//当前的结点  
    int l=strlen(str);  
    for(int i=0;i&lt;l;i++){  
        int u=hashs(str[i]);//将26个小写字母映射为数字  
        if(!son[p][u]) son[p][u]=++idx;  
        p=son[p][u];  
        cnt[p]++;  
    }  
      
}  
int query(char str[]){  
    int p=0;//当前的结点  
    int l=strlen(str);  
    for(int i=0;i&lt;l;i++){  
        int u =hashs(str[i]);  
        if(!son[p][u]) return 0;  
        p=son[p][u];  
    }  
    return cnt[p];  
}  
int main(){  
     
    cin&gt;&gt;t;  
    while(t--){  
          for(int i=0;i&lt;=idx;i++){  
            for(int j=0;j&lt;=122;j++){  
                son[i][j]=0;  
            }  
          }  
          for(int i=0;i&lt;=idx;i++)  
            cnt[i]=0;  
        idx=0;  
       scanf("%d%d",&amp;n,&amp;m);  
        while(n--){  
            scanf("%s",str);  
            insert(str);  
        }  
        while(m--){  
             scanf("%s",str);  
            printf("%d\n",query(str));  
        }  
    }  
    return 0;  
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><p>用法：</p>
<h3 id="某些点或者数据是否处于一个连通块中"><a href="#某些点或者数据是否处于一个连通块中" class="headerlink" title="某些点或者数据是否处于一个连通块中"></a>某些点或者数据是否处于一个连通块中</h3><ol>
<li><p>将两个集合合并</p>
</li>
<li><p>询问两个元素是否在一个集合中</p>
</li>
</ol>
<p>基本原理：每个集合用一个树来表示，树根的编号就是整个集合的编号，</p>
<p>每一个结点表示他的父节点p[x] 表示x的父节点</p>
<ul>
<li><p>判断树根: if（p[x]==x）</p>
</li>
<li><p>如何集合的编号： while(p[x]!=x) x=p[x];</p>
</li>
<li><p>如何合并两个集合直接让其中一个的根节点的父节点为另一个集合的根节点就行</p>
</li>
<li><p>如何优化，查询一次后，将将所经过的路径的父节点全都修改为根节点</p>
</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;  
#include &lt;algorithm&gt;  
#include &lt;cstdio&gt;  
#include &lt;cstring&gt;  
using namespace std;  
const int N=10010;  
int p[N];  
//初始每个点都是一个单独的集合  
void init(int n){  
    for(int i=1;i&lt;=n;i++){  
        p[i]=i;  
    }  
}  
int find(int x){  
    if(p[x]!=x) p[x]=find(p[x]);  
    return p[x];  
}  
  
int main(){  
    int n,m;  
    cin&gt;&gt;n&gt;&gt;m;  
    init(n);  
    char op[2];  
    while(m--){  
        int a,b;  
        cin&gt;&gt;op&gt;&gt;a&gt;&gt;b;  
        //合并两个集合,路径压缩  
        if(op[0]=='i') p[find(a)]=find(b);//让a的父节点等于b的父节点，即可合并  
        else {  
            //查询  
            if(find(a)==find(b)) cout&lt;&lt;"yes"&lt;&lt;endl;  
            else cout&lt;&lt;"no"&lt;&lt;endl;  
        }  
    }  
    return 0;  
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3367">P3367 【模板】并查集 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>
<p>维护点的数量：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;  
#include &lt;algorithm&gt;  
#include &lt;cstdio&gt;  
#include &lt;cstring&gt;  
using namespace std;  
const int N=10010;  
int p[N],sizes[N];//每个集合中点的数量  
//初始每个点都是一个单独的集合  
void init(int n){  
    for(int i=1;i&lt;=n;i++){  
        p[i]=i;  
        sizes[i]=1;  
    }  
}  
int find(int x){  
    if(p[x]!=x) p[x]=find(p[x]);  
    return p[x];  
}  
  
int main(){  
    int n,m;  
    cin&gt;&gt;n&gt;&gt;m;  
    init(n);  
    int op;  
    while(m--){  
        int a,b;  
        cin&gt;&gt;op;  
        //合并两个集合,路径压缩  
        if(op==1){  
            cin&gt;&gt;a&gt;&gt;b;  
            if(find(a)==find(b)) continue;  
            sizes[find(b)]+=sizes[find(a)];  
            p[find(a)]=find(b);//让a的父节点等于b的父节点，即可合并  
      
        }  
        else if(op==2){  
            //查询  
            cin&gt;&gt;a&gt;&gt;b;  
            if(find(a)==find(b)) cout&lt;&lt;"Y"&lt;&lt;endl;  
            else cout&lt;&lt;"N"&lt;&lt;endl;  
        }  
        else {  
            //询问某个集合中点的数量  
            cin&gt;&gt;n;  
            cout&lt;&lt;sizes[find(a)]&lt;&lt;endl;  
        }  
    }  
    return 0;  
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="堆-只能保证堆顶是最值，保证不了左右两边的大小关系"><a href="#堆-只能保证堆顶是最值，保证不了左右两边的大小关系" class="headerlink" title="堆 只能保证堆顶是最值，保证不了左右两边的大小关系"></a>堆 只能保证堆顶是最值，保证不了左右两边的大小关系</h2><p>操作：down 和up 把元素向下或向上走，使用的是一维数组，x的左儿子2x,右儿子2x+1</p>
<p>size 表示数组的最后一个位置</p>
<ol>
<li><p>插入一个元素： heap[++size]=x up(size)</p>
</li>
<li><p>求最小值 heap[1]</p>
</li>
<li><p>删除最小值 数组尾部好删除，所以用最后一个元素覆盖数组的头，然后执行down，</p>
<p> 再删除尾部，head[k]=heap[size];size–; down(k)||up(k)</p>
</li>
<li><p>修改 heap[k]=k; down(k)||up(k);</p>
</li>
</ol>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">// h[N]存储堆中的值, h[1]是堆顶，x的左儿子是2x, 右儿子是2x + 1  
// ph[k]存储第k个插入的点在堆中的位置  
// hp[k]存储堆中下标是k的点是第几个插入的  
int h[N], ph[N], hp[N], size;  
  
// 交换两个点，及其映射关系  
void heap_swap(int a, int b)  
{  
    swap(ph[hp[a]],ph[hp[b]]);  
    swap(hp[a], hp[b]);  
    swap(h[a], h[b]);  
}  
  
void down(int u)  
{  
    int t = u;  
    //查找到三个结点中的最小值  
    if (u * 2 &lt;= size &amp;&amp; h[u * 2] &lt; h[t]) t = u * 2;  
    if (u * 2 + 1 &lt;= size &amp;&amp; h[u * 2 + 1] &lt; h[t]) t = u * 2 + 1;  
    if (u != t)  
    {  
        heap_swap(u, t);  
        down(t);  
    }  
}  
  
void up(int u)  
{  
    while (u / 2 &amp;&amp; h[u] &lt; h[u / 2])//父节点存在且当前结点小于父节点   
    {  
        heap_swap(u, u / 2);  
        u &gt;&gt;= 1;//下一个父节点  
    }  
}  
  
// O(n)建堆  
for (int i = n / 2; i; i -- ) down(i);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3378">P3378 【模板】堆 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits/stdc++.h&gt;  
using namespace std;  
const int N=1000001;  
int h[N],s;  
void down(int u){  
    int t=u;  
    if(u*2&lt;=s&amp;&amp;h[u*2]&lt;h[t]) t=u*2;  
    if(u*2+1&lt;=s&amp;&amp;h[u*2+1]&lt;h[t]) t=u*2+1;  
    if(u!=t){  
        swap(h[u],h[t]);  
        down(t);  
    }  
}  
void up(int u){  
    while(u/2&amp;&amp;h[u]&lt;h[u/2]){  
        swap(h[u],h[u/2]);  
        u&gt;&gt;=1;  
    }  
}  
int main(){  
    int n,op;  
    cin&gt;&gt;n;  
    for(int i=n/2;i;i--){  
        down(i);  
    }  
    while(n--){  
        scanf("%d",&amp;op);  
        if(op==1) {  
            int x;  
            scanf("%d",&amp;x);  
            h[++s]=x;  
            up(s);  
        }  
        else if(op==2){  
            printf("%d\n",h[1]);  
        }  
        else {  
            //最后一个换到第一个  
            swap(h[1],h[s]);  
            s--;//删除最后一个  
            down(1);  
        }  
    }  
  
}
			<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h2><p>删除的话打个标记<br>(1) 拉链法 </p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int h[N], e[N], ne[N], idx;  
  
// 向哈希表中插入一个数  
void insert(int x)  
{  
    int k = (x % N + N) % N;  
    e[idx] = x;  
    ne[idx] = h[k];  
    h[k] = idx ++ ;  
}  
  
// 在哈希表中查询某个数是否存在  
bool find(int x)  
{  
    int k = (x % N + N) % N;  
    for (int i = h[k]; i != -1; i = ne[i])  
        if (e[i] == x)  
            return true;  
  
    return false;  
}  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>开放寻址法，遇到冲突的话直接往后找没用的节点</p>
<p>数组要开比原来数据范围大2~3倍</p>
<p>//只要开一个h数组就可以了，不需要e和ne了，找一个不在数据范围内的数据来表示当前位置为空<br>(2) 开放寻址法  </p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">   int h[N];  
const int null =xxx;  
   // 如果x在哈希表中，返回x的下标；如果x不在哈希表中，返回x应该插入的位置  
   int find(int x)  
   {  
       int t = (x % N + N) % N;  
       while (h[t] != null &amp;&amp; h[t] != x)  
       {  
           t ++ ;  
           if (t == N) t = 0;  
       }  
       return t;  
   }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="字符串哈希"><a href="#字符串哈希" class="headerlink" title="字符串哈希"></a>字符串哈希</h3><p>快速判断两个字符串是否相等</p>
<p>核心思想：将字符串看成P进制数，P的经验值是131或13331，取这两个值的冲突概率低<br>小技巧：取模的数用2^64，这样直接用unsigned long long存储，溢出的结果就是取模的结果  </p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">typedef unsigned long long ULL;  
ULL h[N], p[N]; // h[k]存储字符串前k个字母的哈希值, p[k]存储 P^k mod 2^64  
  
// 初始化  
p[0] = 1;  
for (int i = 1; i &lt;= n; i ++ )  
{  
    h[i] = h[i - 1] * P + str[i];  
    p[i] = p[i - 1] * P;//P存储的是每一位的基数值  
}  
  
// 计算子串 str[l ~ r] 的哈希值  
ULL get(int l, int r)  
{  
    return h[r] - h[l - 1] * p[r - l + 1];  
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="STL常用"><a href="#STL常用" class="headerlink" title="STL常用"></a>STL常用</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">vector, 变长数组，倍增的思想 &nbsp;优化思路：减少申请空间的次数  
 &nbsp; &nbsp;size() &nbsp;返回元素个数  
 &nbsp; &nbsp;empty() &nbsp;返回是否为空  
 &nbsp; &nbsp;clear() &nbsp;清空  
 &nbsp; &nbsp;front()/back()  
 &nbsp; &nbsp;push_back()/pop_back()  
 &nbsp; &nbsp;begin()/end()  
 &nbsp;  []  
 &nbsp; &nbsp;支持比较运算，按字典序  
 &nbsp; &nbsp;vector&lt;int&gt; a(1,2),b(3,4);  
printf(a&lt;b) == 0  
​  
pair&lt;int, int&gt;  
 &nbsp; &nbsp;first, 第一个元素  
 &nbsp; &nbsp;second, 第二个元素  
 &nbsp; &nbsp;支持比较运算，以first为第一关键字，以second为第二关键字（字典序）  
​  
string，字符串  
 &nbsp; &nbsp;size()/length() &nbsp;返回字符串长度  
 &nbsp; &nbsp;empty()  
 &nbsp; &nbsp;clear()  
 &nbsp; &nbsp;substr(起始下标，(子串长度)) &nbsp;返回子串  
 &nbsp; &nbsp;c_str() &nbsp;返回字符串所在字符数组的起始地址  
​  
queue, 队列  
 &nbsp; &nbsp;size()  
 &nbsp; &nbsp;empty()  
 &nbsp; &nbsp;push() &nbsp;向队尾插入一个元素  
 &nbsp; &nbsp;front() &nbsp;返回队头元素  
 &nbsp; &nbsp;back() &nbsp;返回队尾元素  
 &nbsp; &nbsp;pop() &nbsp;弹出队头元素  
​  
priority_queue, 优先队列，默认是大根堆  
 &nbsp; &nbsp;size()  
 &nbsp; &nbsp;empty()  
 &nbsp; &nbsp;push() &nbsp;插入一个元素  
 &nbsp; &nbsp;top() &nbsp;返回堆顶元素  
 &nbsp; &nbsp;pop() &nbsp;弹出堆顶元素  
 &nbsp; &nbsp;定义成小根堆的方式：priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; q;  
​  
stack, 栈  
 &nbsp; &nbsp;size()  
 &nbsp; &nbsp;empty()  
 &nbsp; &nbsp;push() &nbsp;向栈顶插入一个元素  
 &nbsp; &nbsp;top() &nbsp;返回栈顶元素  
 &nbsp; &nbsp;pop() &nbsp;弹出栈顶元素  
​  
deque, 双端队列  
 &nbsp; &nbsp;size()  
 &nbsp; &nbsp;empty()  
 &nbsp; &nbsp;clear()  
 &nbsp; &nbsp;front()/back()  
 &nbsp; &nbsp;push_back()/pop_back()  
 &nbsp; &nbsp;push_front()/pop_front()  
 &nbsp; &nbsp;begin()/end()  
 &nbsp;  []  
​  
set, map, multiset, multimap, 基于平衡二叉树（红黑树），动态维护有序序列  
 &nbsp; &nbsp;size()  
 &nbsp; &nbsp;empty()  
 &nbsp; &nbsp;clear()  
 &nbsp; &nbsp;begin()/end()  
 &nbsp; &nbsp;++, -- 返回前驱和后继，时间复杂度 O(logn)  
​  
 &nbsp; &nbsp;set/multiset  
 &nbsp; &nbsp; &nbsp; &nbsp;insert() &nbsp;插入一个数  
 &nbsp; &nbsp; &nbsp; &nbsp;find() &nbsp;查找一个数  
 &nbsp; &nbsp; &nbsp; &nbsp;count() &nbsp;返回某一个数的个数  
 &nbsp; &nbsp; &nbsp; &nbsp;erase()  
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  (1) 输入是一个数x，删除所有x &nbsp; O(k + logn)  
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  (2) 输入一个迭代器，删除这个迭代器  
 &nbsp; &nbsp; &nbsp; &nbsp;lower_bound()/upper_bound()  
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;lower_bound(x) &nbsp;返回大于等于x的最小的数的迭代器  
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;upper_bound(x) &nbsp;返回大于x的最小的数的迭代器  
 &nbsp; &nbsp;map/multimap  
 &nbsp; &nbsp; &nbsp; &nbsp;insert() &nbsp;插入的数是一个pair  
 &nbsp; &nbsp; &nbsp; &nbsp;erase() &nbsp;输入的参数是pair或者迭代器  
 &nbsp; &nbsp; &nbsp; &nbsp;find()  
 &nbsp; &nbsp; &nbsp;  [] &nbsp;注意multimap不支持此操作。 时间复杂度是 O(logn)  
 &nbsp; &nbsp; &nbsp; &nbsp;lower_bound()/upper_bound()  
​  
unordered_set, unordered_map, unordered_multiset, unordered_multimap, 哈希表  
 &nbsp; &nbsp;和上面类似，增删改查的时间复杂度是 O(1)  
 &nbsp; &nbsp;不支持 lower_bound()/upper_bound()， 迭代器的++，--  
​  
bitset, 圧位 省空间 &nbsp; &nbsp;  
 &nbsp; &nbsp;bitset&lt;10000&gt; s; &nbsp;//&lt; &gt;里面是个数, 可以用来替代bool 数组  
    //以下操作都支持  
    ~, &amp;, |, ^  
 &nbsp; &nbsp;&gt;&gt;, &lt;&lt;  
 &nbsp; &nbsp;==, !=  
 &nbsp;  []  
​  
 &nbsp; &nbsp;count() &nbsp;返回有多少个1  
​  
 &nbsp; &nbsp;any() &nbsp;判断是否至少有一个1  
 &nbsp; &nbsp;none() &nbsp;判断是否全为0  
​  
 &nbsp; &nbsp;set() &nbsp;把所有位置成1  
 &nbsp; &nbsp;set(k, v) &nbsp;将第k位变成v  
 &nbsp; &nbsp;reset() &nbsp;把所有位变成0  
 &nbsp; &nbsp;flip() &nbsp;等价于~  
 &nbsp; &nbsp;flip(k) 把第k位取反  
​<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="图论背思路"><a href="#图论背思路" class="headerlink" title="图论背思路"></a>图论背思路</h2><h2 id="BFS和DFS"><a href="#BFS和DFS" class="headerlink" title="BFS和DFS"></a>BFS和DFS</h2><h3 id="非常完美的一道dfs-并查集-https-www-luogu-com-cn-problem-P1127"><a href="#非常完美的一道dfs-并查集-https-www-luogu-com-cn-problem-P1127" class="headerlink" title="非常完美的一道dfs + 并查集 https://www.luogu.com.cn/problem/P1127"></a>非常完美的一道dfs + 并查集 <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1127">https://www.luogu.com.cn/problem/P1127</a></h3><p><u>还原现场很重要</u> </p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span> start<span class="token punctuation">,</span><span class="token keyword">int</span> num<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>num <span class="token operator">==</span> n<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
		<span class="token comment">//开始搜索</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			<span class="token comment">//找start这个开头的string</span>
			<span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token char">'a'</span> <span class="token operator">==</span> start <span class="token operator">&amp;&amp;</span> st<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
				<span class="token comment">//标记</span>
				st<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
				ans<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">dfs</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token char">'a'</span><span class="token punctuation">,</span>num<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
				<span class="token comment">//还原现场</span>
				st<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
				ans<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>ans<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			
		<span class="token punctuation">}</span>
		<span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="DFS-回溯的时候记得回复现场"><a href="#DFS-回溯的时候记得回复现场" class="headerlink" title="DFS 回溯的时候记得回复现场"></a>DFS 回溯的时候记得回复现场</h3><h3 id="邻接矩阵：-p-a-b-a-gt-b-适合稠密图"><a href="#邻接矩阵：-p-a-b-a-gt-b-适合稠密图" class="headerlink" title="邻接矩阵： p[ a] [ b ] a -> b 适合稠密图"></a>邻接矩阵： p[ a] [ b ] a -&gt; b 适合稠密图</h3><h3 id="邻接表：-稀疏图"><a href="#邻接表：-稀疏图" class="headerlink" title="邻接表： 稀疏图"></a>邻接表： 稀疏图</h3><p>和哈希表思路一样</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">// 对于每个点k，开一个单链表，存储k所有可以走到的点。h[k]存储这个单链表的头结点  
int h[N], e[N], ne[N], idx; //e是终点end  
  
// 添加一条边a-&gt;b  
void add(int a, int b)  
{  
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;  
}   
// 初始化  
idx = 0;  
memset(h, -1, sizeof h);  
//遍历图  
for(int i = h[t] ; i != -1 ; i = ne[i] )

## 另一种使用结构体的邻接表存法

int idx=0,n;  
int h[N] , dis[N] , vis[N];  
struct Edge{  
    int ne,to,dis;  
}ed[N];  
//添加， 从 1 开始  
void add(int a,int b ,int c){  
    ed[++idx].ne = h[a];  
    ed[idx].to = b;  
    ed[idx].dis = c;  
    h[a] = idx;  
}
//遍历图  
for(int i = h[t] ; i ; i = ed[i].ne)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="BFS-可用于解决权值相等的最短路径问题"><a href="#BFS-可用于解决权值相等的最短路径问题" class="headerlink" title="BFS 可用于解决权值相等的最短路径问题"></a>BFS 可用于解决权值相等的最短路径问题</h3><h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><p>必须是又向无环</p>
<p>排完后，所有的起点都在终点之前</p>
<ol>
<li><p>统计每一个节点的入度和出度</p>
</li>
<li><p>每一次将入读相同的点放入queue</p>
</li>
<li><p>枚举队头的出边，删掉 出边,这条边的终点的入度-1</p>
</li>
<li><p>如果某个点的入度为0 放入队列</p>
</li>
</ol>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">bool topsort()  
{  
    int hh = 0, tt = -1;  
  
    // d[i] 存储点i的入度  
    for (int i = 1; i &lt;= n; i ++ )  
        if (!d[i])  
            q[ ++ tt] = i;//把每个入度为0的点加入队列  
  
    while (hh &lt;= tt)  
    {  
        int t = q[hh ++ ];//取出队头  
		//从队头开始找路径  
        for (int i = h[t]; i != -1; i = ne[i])  
        {  
            int j = e[i];  
            if (-- d[j] == 0)  
                q[ ++ tt] = j;  
        }  
    }  
  
    // 如果所有点都入队了，说明存在拓扑序列；否则不存在拓扑序列。  
    return tt == n - 1;  
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="最短路问题："><a href="#最短路问题：" class="headerlink" title="最短路问题："></a>最短路问题：</h2><h2 id="分层最短路-，适用于乘车路线和免费次数。"><a href="#分层最短路-，适用于乘车路线和免费次数。" class="headerlink" title="_分层最短路_，适用于乘车路线和免费次数。"></a>_分层最短路_，适用于乘车路线和免费次数。</h2><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P4568#submit">飞机路线</a></p>
<h3 id="单源最短路-一个点-x2F-到其他所有点的最短路"><a href="#单源最短路-一个点-x2F-到其他所有点的最短路" class="headerlink" title="单源最短路 一个点./.到其他所有点的最短路"></a>单源最短路 一个点./.到其他所有点的最短路</h3><ul>
<li><p>所有边的权都是正数</p>
<ol>
<li>朴素Dijkstra O(n^2) n为点的数量 稠密图 边很多 外部迭代n-1 次 <pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int g[N][N];  // 存储每条边  权值  
int dist[N];  // 存储1号点到每个点的最短距离  
bool st[N];   // 存储每个点的最短路是否已经确定  
  
// 求1号点到n号点的最短路，如果不存在则返回-1  
int dijkstra()  
{  
    memset(dist, 0x3f, sizeof dist);  
    dist[1] = 0;  
  
    for (int i = 0; i &lt; n - 1; i ++ )//迭代n-1 次，因为上来选中了一个点  
    {  
        int t = -1;     // 在还未确定最短路的点中，寻找距离最小的点  
        for (int j = 1; j &lt;= n; j ++ )  
            if (!st[j] &amp;&amp; (t == -1 || dist[t] &gt; dist[j]))  
                t = j;  
  
        // 用t更新其他点的距离  
        for (int j = 1; j &lt;= n; j ++ )  
            dist[j] = min(dist[j], dist[t] + g[t][j]);  
  
        st[t] = true;  
    }  
  
    if (dist[n] == 0x3f3f3f3f) return -1;  
    return dist[n];  
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li>堆优化版的 O(mlogn) 稀疏图  <pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">typedef pair&lt;int, int&gt; PII;  
  
int n;      // 点的数量  
int h[N], w[N], e[N], ne[N], idx;       // 邻接表存储所有边  
int dist[N];        // 存储所有点到1号点的距离  
bool st[N];     // 存储每个点的最短距离是否已确定  
  
// 求1号点到n号点的最短距离，如果不存在，则返回-1  
int dijkstra()  
{  
    memset(dist, 0x3f, sizeof dist);  
    dist[1] = 0;  
    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;  
    heap.push({0, 1});      // first存储距离，second存储节点编号  
  
    while (heap.size())  
    {  
        auto t = heap.top();  
        heap.pop();  
  
        int ver = t.second, distance = t.first;  
  
        if (st[ver]) continue;  
        st[ver] = true;  
  
        for (int i = h[ver]; i != -1; i = ne[i])  
        {  
            int j = e[i];  
            if (dist[j] &gt; distance + w[i])  
            {  
                dist[j] = distance + w[i];  
                heap.push({dist[j], j});  
            }  
        }  
    }  
  
    if (dist[n] == 0x3f3f3f3f) return -1;  
    return dist[n];  
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ol>
</li>
<li><p>存在负权边</p>
<ol>
<li><p>Bellman -Ford O(nm) <strong>奇妙的存图方式</strong> 无负权回路 经过路径有次数限制的话只能用这个了，外面限制的是经过i的点的个数，然后每次遍历边即可。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int n, m;       // n表示点数，m表示边数  
int dist[N];        // dist[x]存储1到x的最短路距离  
  
struct Edge     // 边，a表示出点，b表示入点，w表示边的权重  
{  
    int a, b, w;  
}edges[M];  
  
// 求1到n的最短路距离，如果无法从1走到n，则返回-1。  
int bellman_ford()  
{  
    memset(dist, 0x3f, sizeof dist);  
    dist[1] = 0;  
	//不需要进行收录顶点  
    // 如果第n次迭代仍然会松弛三角不等式，就说明存在一条长度是n+1的最短路径，由抽屉原理，路径中至少存在两个相同的点，说明图中存在负权回路。  
    for (int i = 0; i &lt; n; i ++ )//这个n是指的是最多不经过 多少次经过同一条边  
    {  
        for (int j = 0; j &lt; m; j ++ )  
        {  
            int a = edges[j].a, b = edges[j].b, w = edges[j].w;  
            if (dist[b] &gt; dist[a] + w)  
                dist[b] = dist[a] + w;  
        }  
    }  
  
    if (dist[n] &gt; 0x3f3f3f3f / 2) return -1;  
    return dist[n];  
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><p>SPFA 一般： O（m) 最坏O（nm） 不存在负权环才能使用 99%都没有负环比较好用</p>
<p> 优化思路：只有更新过点才对后面的点更新有影响</p>
<p> 要从 1 开始存比较好 ，e 是end 也就是一条边的终点</p>
 <pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int n;      // 总点数  
int h[N], w[N], e[N], ne[N], idx;       // 邻接表存储所有边  
int dist[N];        // 存储每个点到1号点的最短距离  
bool st[N];     // 存储每个点是否在队列中  
  
  
// 求x号点到n号点的最短路距离，如果从1号点无法走到n号点则返回-1  
int spfa(int x)  
{  
    memset(dist, 0x3f, sizeof dist);//初始化要根据题目来  
      
    dist[x] = 0;  
/*或者  
for(int i = 1 ; i &lt;= n ; i ++){  
        dis[i] = INT_MAX;  
    }*/	  
    queue&lt;int&gt; q;  
    q.push(x);  
  
    while (q.size())//不为空，即为还有更新的点  
    {  
        auto t = q.front();  
        q.pop();  
  
        st[t] = false;//这里不要忘记  
       //遍历所以能到达的顶点，进行更新  
        for (int i = h[t]; i != -1; i = ne[i])  
        {  
            int j = e[i];  
            if (dist[j] &gt; dist[t] + w[i])  
            {  
                dist[j] = dist[t] + w[i];  
                if (!st[j])     // 如果队列中已存在j，则不需要将j重复插入  
                {  
                    q.push(j);//这里是j  
                    st[j] = true;//这里是j  
                }  
            }  
        }  
    }  
  
    if (dist[n] == 0x3f3f3f3f) return -1;  
    return dist[n];  
}  
//初始化和存图  
void add(int a, int b , int c){  
    w[idx] = c;  
    ne[idx] = h[a];   
    en[idx] =  b;    
    h[a] = idx++;  
}  
void init(){  
    idx = 1;  
    memset(h , -1 ,sizeof h);  
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="模板题："><a href="#模板题：" class="headerlink" title="模板题："></a>模板题：</h4><p> <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3371">P3371 【模板】单源最短路径（弱化版） - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>
</li>
</ol>
</li>
</ul>
<h2 id="x3D-x3D-判断有无负环-用cnt-来记录当前最短路的边数"><a href="#x3D-x3D-判断有无负环-用cnt-来记录当前最短路的边数" class="headerlink" title="==判断有无负环 用cnt 来记录当前最短路的边数"></a>==<strong>判断有无负环 用cnt 来记录当前最短路的边数</strong></h2><p>例题： <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3385">负环路</a></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int n;      // 总点数  
int h[N], w[N], e[N], ne[N], idx;       // 邻接表存储所有边  
int dist[N], cnt[N];        // dist[x]存储1号点到x的最短距离，cnt[x]存储1到x的最短路中经过的点数  
bool st[N];     // 存储每个点是否在队列中  
  
// 如果存在负环，则返回true，否则返回false。  
bool spfa()  
{  
    // 不需要初始化dist数组  
    // 原理：如果某条最短路径上有n个点（除了自己），那么加上自己之后一共有n+1个点，由抽屉原理一定有两个点相同，所以存在环。  
  
    queue&lt;int&gt; q;  
    for (int i = 1; i &lt;= n; i ++ )  
    {  
        q.push(i);  
        st[i] = true;  
    }  
  
    while (q.size())  
    {  
        auto t = q.front();  
        q.pop();  
  
        st[t] = false;  
  
        for (int i = h[t]; i != -1; i = ne[i])  
        {  
            int j = e[i];  
            if (dist[j] &gt; dist[t] + w[i])  
            {  
                dist[j] = dist[t] + w[i];  
                cnt[j] = cnt[t] + 1;  
                if (cnt[j] &gt;= n) return true;       // 如果从1号点到x的最短路中包含至少n个点（不包括自己），则说明存在环  
                if (!st[j])  
                {  
                    q.push(j);  
                    st[j] = true;  
                }  
            }  
        }  
    }  
  
    return false;  
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="多源汇最短路-起点终点都不确定"><a href="#多源汇最短路-起点终点都不确定" class="headerlink" title="多源汇最短路 起点终点都不确定"></a>多源汇最短路 起点终点都不确定</h3><p>Floyd O(n^3)</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">初始化：  
 &nbsp; &nbsp;for (int i = 1; i &lt;= n; i ++ )  
 &nbsp; &nbsp; &nbsp; &nbsp;for (int j = 1; j &lt;= n; j ++ )  
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if (i == j) d[i][j] = 0;  
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;else d[i][j] = INF;  
​  
// 算法结束后，d[a][b]表示a到b的最短距离  
void floyd()  
{  
 &nbsp; &nbsp;for (int k = 1; k &lt;= n; k ++ )  
 &nbsp; &nbsp; &nbsp; &nbsp;for (int i = 1; i &lt;= n; i ++ )  
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;for (int j = 1; j &lt;= n; j ++ )  
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;d[i][j] = min(d[i][j], d[i][k] + d[k][j]);// i经过k 点到达j   
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><h3 id="普利姆算法-Prim-思路和Dijsktra算法相似-外部迭代-n-次，因为没有提前选中一个点"><a href="#普利姆算法-Prim-思路和Dijsktra算法相似-外部迭代-n-次，因为没有提前选中一个点" class="headerlink" title="普利姆算法 Prim 思路和Dijsktra算法相似 外部迭代 n 次，因为没有提前选中一个点"></a>普利姆算法 Prim 思路和Dijsktra算法相似 外部迭代 n 次，因为没有提前选中一个点</h3><h3 id="迭代n次因为没有提前选中一个点-枚举所有点"><a href="#迭代n次因为没有提前选中一个点-枚举所有点" class="headerlink" title="迭代n次因为没有提前选中一个点 枚举所有点"></a>迭代n次因为没有提前选中一个点 枚举所有点</h3><ol>
<li><p>朴素Prim算法 稠密图 每次找到未收录的距离最近的点，收录并进行更新其他点到<strong>集合</strong>的距离</p>
</li>
<li><p>找这个点是否与集合内部相连</p>
</li>
<li><p>某个点到这个集合的距离为某个点到这个集合当中的点的距离最短的边</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int n; &nbsp; &nbsp; &nbsp;// n表示点数  
int g[N][N]; &nbsp; &nbsp; &nbsp; &nbsp;// 邻接矩阵，存储所有边  
int dist[N]; &nbsp; &nbsp; &nbsp; &nbsp;// 存储其他点到当前最小生成树的距离  
bool st[N]; &nbsp; &nbsp; // 存储每个点是否已经在生成树中  
​  
​  
// 如果图不连通，则返回INF(值是0x3f3f3f3f), 否则返回最小生成树的树边权重之和  
int prim()  
{  
 &nbsp; &nbsp;memset(dist, 0x3f, sizeof dist);  
​  
 &nbsp; &nbsp;int res = 0;  
 &nbsp; &nbsp;for (int i = 0; i &lt; n; i ++ )  
 &nbsp;  {  
 &nbsp; &nbsp; &nbsp; &nbsp;int t = -1;  
 &nbsp; &nbsp; &nbsp; &nbsp;for (int j = 1; j &lt;= n; j ++ )  
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if (!st[j] &amp;&amp; (t == -1 || dist[t] &gt; dist[j]))  
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;t = j;  
​  
 &nbsp; &nbsp; &nbsp; &nbsp;if (i &amp;&amp; dist[t] == INF) return INF;  
​  
 &nbsp; &nbsp; &nbsp; &nbsp;if (i) res += dist[t];  
 &nbsp; &nbsp; &nbsp; &nbsp;st[t] = true;  
​  
 &nbsp; &nbsp; &nbsp; &nbsp;for (int j = 1; j &lt;= n; j ++ ) dist[j] = min(dist[j], g[t][j]);  
 &nbsp; &nbsp; &nbsp; &nbsp;//不是相加  
 &nbsp;  }  
​  
 &nbsp; &nbsp;return res;  
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>堆优化版的Prim 稀疏图 不常用</p>
</li>
</ol>
<h3 id="克鲁斯卡尔算法-Kruskal-先对边进行排序-稀疏图-可以用并查集-枚举所有边"><a href="#克鲁斯卡尔算法-Kruskal-先对边进行排序-稀疏图-可以用并查集-枚举所有边" class="headerlink" title="克鲁斯卡尔算法 Kruskal 先对边进行排序 稀疏图 可以用并查集 枚举所有边"></a>克鲁斯卡尔算法 Kruskal 先对边进行排序 稀疏图 可以用并查集 枚举所有边</h3><p>java版本:</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">bronya</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token operator">*</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>math<span class="token punctuation">.</span></span><span class="token class-name">BigInteger</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token operator">*</span></span><span class="token punctuation">;</span>


<span class="token keyword">class</span> <span class="token class-name">Edge</span> <span class="token punctuation">{</span>
	<span class="token keyword">int</span> a <span class="token punctuation">,</span> b <span class="token punctuation">,</span> w<span class="token punctuation">;</span>
	<span class="token keyword">public</span> <span class="token class-name">Edge</span><span class="token punctuation">(</span><span class="token keyword">int</span> a <span class="token punctuation">,</span> <span class="token keyword">int</span> b <span class="token punctuation">,</span> <span class="token keyword">int</span> w<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">this</span><span class="token punctuation">.</span>a <span class="token operator">=</span> a<span class="token punctuation">;</span>
		<span class="token keyword">this</span><span class="token punctuation">.</span>b <span class="token operator">=</span> b<span class="token punctuation">;</span>
		<span class="token keyword">this</span><span class="token punctuation">.</span>w <span class="token operator">=</span> w<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span><span class="token punctuation">{</span>

	<span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token class-name">N</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token number">2</span> <span class="token operator">*</span> <span class="token number">1e5</span> <span class="token operator">+</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">static</span> <span class="token keyword">int</span> n <span class="token punctuation">,</span> m <span class="token punctuation">;</span>
	<span class="token keyword">static</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token keyword">static</span> <span class="token class-name">Edge</span><span class="token punctuation">[</span><span class="token punctuation">]</span> ed <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Edge</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token keyword">static</span> <span class="token keyword">long</span> ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>x <span class="token operator">!=</span> p<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">)</span> p<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>p<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span> p<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">check</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n <span class="token punctuation">;</span>  i <span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			p<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>ed<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>m<span class="token punctuation">,</span><span class="token punctuation">(</span>e1<span class="token punctuation">,</span>e2<span class="token punctuation">)</span><span class="token operator">-&gt;</span>e1<span class="token punctuation">.</span>w <span class="token operator">-</span> e2<span class="token punctuation">.</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">int</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
		<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m <span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			<span class="token keyword">int</span> a <span class="token operator">=</span> ed<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>a<span class="token punctuation">;</span>
			<span class="token keyword">int</span> b <span class="token operator">=</span> ed<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>b<span class="token punctuation">;</span>
			<span class="token keyword">int</span> w <span class="token operator">=</span> ed<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>w<span class="token punctuation">;</span>
			a <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
			b <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">if</span><span class="token punctuation">(</span>a <span class="token operator">!=</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
				p<span class="token punctuation">[</span>a<span class="token punctuation">]</span> <span class="token operator">=</span> b<span class="token punctuation">;</span>
				ans <span class="token operator">+=</span> w<span class="token punctuation">;</span>
				cnt <span class="token operator">++</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>cnt <span class="token operator">&lt;</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
		<span class="token keyword">else</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">{</span>
		<span class="token class-name">BufferedReader</span> re <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> s <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		n <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		m <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span>  i <span class="token operator">&lt;</span> m <span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			s <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">int</span> w <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			ed<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Edge</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> w<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">boolean</span> f <span class="token operator">=</span> <span class="token function">check</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>ans<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">else</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"orz"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3366">P3366 【模板】最小生成树 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>
<ol>
<li><p>所有边按权重从小到大排序</p>
</li>
<li><p>枚举每条边a,b权重c if a,b不连通， 将这条边加入集合中</p>
</li>
</ol>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int n, m;       // n是点数，m是边数  
int p[N];       // 并查集的父节点数组  
  
struct Edge     // 存储边  
{  
    int a, b, w;  
  
    bool operator&lt; (const Edge &amp;W)const // 重载了 &lt;   
    {  
        return w &lt; W.w;  
    }  
}edges[M];  
  
int find(int x)     // 并查集核心操作  
{  
    if (p[x] != x) p[x] = find(p[x]);  
    return p[x];  
}  
  
int kruskal()  
{  
    sort(edges, edges + m);  
  
    for (int i = 1; i &lt;= n; i ++ ) p[i] = i;    // 初始化并查集  
  
    int res = 0, cnt = 0;  
    for (int i = 0; i &lt; m; i ++ )  
    {  
        int a = edges[i].a, b = edges[i].b, w = edges[i].w;  
  
        a = find(a), b = find(b);  
        if (a != b)     // 如果两个连通块不连通，则将这两个连通块合并  
        {  
            p[a] = b;  
            res += w;  
            cnt ++ ;  
        }  
    }  
  
    if (cnt &lt; n - 1) return INF;  
    return res;  
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="二分图-当且仅当图中没有奇数环"><a href="#二分图-当且仅当图中没有奇数环" class="headerlink" title="二分图 当且仅当图中没有奇数环"></a>二分图 当且仅当图中没有奇数环</h2><h3 id="染色法-O-n-m-判断是否是二分图"><a href="#染色法-O-n-m-判断是否是二分图" class="headerlink" title="染色法 O(n+m) 判断是否是二分图"></a>染色法 O(n+m) 判断是否是二分图</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int n;      // n表示点数  
int h[N], e[M], ne[M], idx;     // 邻接表存储图  
int color[N];       // 表示每个点的颜色，-1表示未染色，0表示白色，1表示黑色  
  
// 参数：u表示当前节点，c表示当前点的颜色  
bool dfs(int u, int c)  
{  
    color[u] = c;  
    for (int i = h[u]; i != -1; i = ne[i])  
    {  
        int j = e[i];  
        if (color[j] == -1)//未染色  
        {  
            if (!dfs(j, !c)) return false;//比如两种颜色， 0，1表示，那么这里就可以用 3- c,也就是用另一种颜色去染色  
        }  
        else if (color[j] == c) return false;  
    }  
  
    return true;  
}  
  
bool check()  
{  
    memset(color, -1, sizeof color);  
    bool flag = true;  
    //枚举所有点，去染色  
    for (int i = 1; i &lt;= n; i ++ )  
        if (color[i] == -1)  
            if (!dfs(i, 0))  
            {  
                flag = false;  
                break;  
            }  
    return flag;  
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="匈牙利算法-O-mn-实际运行时间一般小于这个值-稠密图不适合用邻接表，推荐使用临界矩阵"><a href="#匈牙利算法-O-mn-实际运行时间一般小于这个值-稠密图不适合用邻接表，推荐使用临界矩阵" class="headerlink" title="匈牙利算法 O(mn) 实际运行时间一般小于这个值 稠密图不适合用邻接表，推荐使用临界矩阵"></a>匈牙利算法 O(mn) 实际运行时间一般小于这个值 稠密图不适合用邻接表，推荐使用临界矩阵</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int n1, n2; &nbsp; &nbsp; // n1表示第一个集合中的点数，n2表示第二个集合中的点数  
int h[N], e[M], ne[M], idx; &nbsp; &nbsp; // 邻接表存储所有边，匈牙利算法中只会用到从第一个集合指向第二个集合的边，所以这里只用存一个方向的边  
int match[N]; &nbsp; &nbsp; &nbsp; // 存储第二个集合中的每个点当前匹配的第一个集合中的点是哪个  
bool st[N]; &nbsp; &nbsp; // 表示第二个集合中的每个点是否已经被遍历过  
​  
bool find(int x)  
{  
 &nbsp; &nbsp;for (int i = h[x]; i != -1; i = ne[i])  
 &nbsp;  {  
 &nbsp; &nbsp; &nbsp; &nbsp;int j = e[i];  
 &nbsp; &nbsp; &nbsp; &nbsp;if (!st[j])  
 &nbsp; &nbsp; &nbsp;  {  
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;st[j] = true;  
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if (match[j] == 0 || find(match[j]))//第二个集合的点未匹配，或者是可以为已经 匹配的第一个集合中的点找到别的集合二中的点  
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  {  
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;match[j] = x;  
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return true;  
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  }  
 &nbsp; &nbsp; &nbsp;  }  
 &nbsp;  }  
​  
 &nbsp; &nbsp;return false;  
}  
​  
// 求最大匹配数，依次枚举第一个集合中的每个点能否匹配第二个集合中的点  
int res = 0;  
for (int i = 1; i &lt;= n1; i ++ )  
{  
 &nbsp; &nbsp;memset(st, false, sizeof st);  
 &nbsp; &nbsp;if (find(i)) res ++ ;  
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>例题：<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3386">P3386 【模板】二分图最大匹配 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></strong></p>
<h2 id="邻接表的写法-稠密图会超时"><a href="#邻接表的写法-稠密图会超时" class="headerlink" title="邻接表的写法(稠密图会超时)"></a>邻接表的写法(稠密图会超时)</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits/stdc++.h&gt;  
using namespace std;  
const int N  = 505;  
int n1,n2,ed;//需要两个集合  
int h[N] , ne[N] , e[N] , idx;  
int match[N] ;  
bool vis[N];  
void init(){  
    memset(h,-1,sizeof h);  
    idx = 0;  
}  
void add(int a, int b){  
    e[idx] = b ;  
    ne[idx] = h[a];  
    h[a] = idx++;  
}  
bool find(int x){  
    for (int i = h[x] ; i != -1 ; i =ne[i]){  
        int j = e[i];  
        if(!vis[j]){  
            vis[j] = true;  
            if(match[j] == 0 || find(match[j])){  
                //如果终边的点未匹配，或者是可以为以匹配的起点找到另一个终点  
                match[j] = x;  
                return true;  
            }  
        }  
    }  
    return false;  
}  
int main(){  
    ios::sync_with_stdio(false);  
    cin.tie(nullptr);  
    cin &gt;&gt; n1 &gt;&gt; n2 &gt;&gt;ed;  
    init();  
    int u ,v;  
    for (int i = 1 ; i &lt;= ed ; i++){  
        cin &gt;&gt; u &gt;&gt; v;  
        if(v &lt;= n2){  
            add(u , v);  
        }  
         
    }  
    int ans = 0;  
    for (int i = 1 ; i &lt;= n1 ; i++){  
        memset(vis, false ,sizeof vis);  
        if(find(i)) ans++;  
    }  
    cout &lt;&lt; ans &lt;&lt;endl ;  
    return 0;  
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="邻接矩阵的写法："><a href="#邻接矩阵的写法：" class="headerlink" title="邻接矩阵的写法："></a>邻接矩阵的写法：</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits/stdc++.h&gt;  
using namespace std;  
const int N  = 505;  
int n1,n2,ed;//需要两个集合  
bool a[N][N];  
int match[N];  
bool vis[N];  
bool find(int x){  
    //枚举终边  
    for (int i = 1 ; i &lt;= n2 ; i ++){  
        if(!vis[i] &amp;&amp; a[x][i]){  
            vis[i] = true;  
            if(match[i] == 0 || find(match[i])){  
                //如果终边的点未匹配，或者是可以为以匹配的起点找到另一个终点  
                match[i] = x;  
                return true;  
            }  
        }  
    }  
    return false;  
}  
int main(){  
    ios::sync_with_stdio(false);  
    cin.tie(nullptr);  
    cin &gt;&gt; n1 &gt;&gt; n2 &gt;&gt;ed;  
    int u ,v;  
    for (int i = 1 ; i &lt;= ed ; i++){  
        cin &gt;&gt; u &gt;&gt; v;  
        if(v &lt;= n2){  
            a[u][v] = 1;  
        }  
         
    }  
    int ans = 0;  
    for (int i = 1 ; i &lt;= n1 ; i++){  
        ans+=find(i); // 这里不一样哦  
        memset(vis, false ,sizeof vis);  
    }  
    cout &lt;&lt; ans &lt;&lt;endl ;  
    return 0;  
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="数学知识"><a href="#数学知识" class="headerlink" title="数学知识"></a>数学知识</h2><blockquote>
<p>[!NOTE]</p>
<h2 id="当看见-0-的个数时考虑将结果分成-2-，-5-的个数-并且，末尾的0的个数一定是由5的个数决定的"><a href="#当看见-0-的个数时考虑将结果分成-2-，-5-的个数-并且，末尾的0的个数一定是由5的个数决定的" class="headerlink" title="当看见 0 的个数时考虑将结果分成 2 ， 5 的个数,并且，末尾的0的个数一定是由5的个数决定的"></a>当看见 0 的个数时考虑将结果分成 2 ， 5 的个数,并且，末尾的0的个数一定是由5的个数决定的</h2></blockquote>
<p><a target="_blank" rel="noopener" href="https://ac.nowcoder.com/acm/contest/57683/E">E-Kevin喜欢零(困难版本)_牛客小白月赛73 (nowcoder.com)</a></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits/stdc++.h&gt;  
​  
void solve() {#include &lt;bits/stdc++.h&gt;  
​  
void solve() {  
 &nbsp; &nbsp;int n, k;  
 &nbsp; &nbsp;std::cin &gt;&gt; n &gt;&gt; k;  
​  
 &nbsp; &nbsp;int64_t ans = 0;  
 &nbsp; &nbsp;std::unordered_map&lt;int, std::vector&lt;int&gt;&gt; tp, fp;  
 &nbsp; &nbsp;//tp 记录5的个数，fp记录2的个数  
 &nbsp; &nbsp;//两个是互补的  
 &nbsp; &nbsp;tp[0].push_back(0);  
 &nbsp; &nbsp;fp[0].push_back(0);  
​  
 &nbsp; &nbsp;for (int i = 0, t = 0, f = 0; i &lt; n; i++) {  
 &nbsp; &nbsp; &nbsp; &nbsp;int x;  
 &nbsp; &nbsp; &nbsp; &nbsp;std::cin &gt;&gt; x;  
 &nbsp; &nbsp; &nbsp; &nbsp;for (; x &amp;&amp; x % 2 == 0; x /= 2, t++) {  
 &nbsp; &nbsp; &nbsp;  }  
 &nbsp; &nbsp; &nbsp; &nbsp;for (; x &amp;&amp; x % 5 == 0; x /= 5, f++) {  
 &nbsp; &nbsp; &nbsp;  }  
 &nbsp; &nbsp; &nbsp; &nbsp;ans += std::max(  
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//需要 2^k &nbsp; * 5^k 即可满足 10^k 所以是动态规划  
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//每次计算出当前数据含有的2 和  5 的数量 和仍然需要 k  - 当前数量 &nbsp; 这一行的去更新  
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//因为同一个状态有可能对应多个数据， 所以只要找到第一个满足能凑出另一个2或者5的即可   
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//map不能使用upper_bound 但是 内部的vector 是可以使用的  
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;std::upper_bound(tp[t - k].begin(), tp[t - k].end(), f - k) - tp[t - k].begin(),  
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;std::upper_bound(fp[f - k].begin(), fp[f - k].end(), t - k) - fp[f - k].begin()  
 &nbsp; &nbsp; &nbsp;  );  
 &nbsp; &nbsp; &nbsp; &nbsp;tp[t].push_back(f);  
 &nbsp; &nbsp; &nbsp; &nbsp;fp[f].push_back(t);  
 &nbsp;  }  
​  
 &nbsp; &nbsp;std::cout &lt;&lt; ans &lt;&lt; "\n";  
}  
​  
int main() {  
 &nbsp; &nbsp;std::ios::sync_with_stdio(false);  
 &nbsp; &nbsp;std::cin.tie(nullptr);  
​  
 &nbsp; &nbsp;int t;  
 &nbsp; &nbsp;std::cin &gt;&gt; t;  
​  
 &nbsp; &nbsp;while (t--) {  
 &nbsp; &nbsp; &nbsp; &nbsp;solve();  
 &nbsp;  }  
​  
 &nbsp; &nbsp;return 0;  
}  
​  
 &nbsp; &nbsp;int n, k;  
 &nbsp; &nbsp;std::cin &gt;&gt; n &gt;&gt; k;  
​  
 &nbsp; &nbsp;int64_t ans = 0;  
 &nbsp; &nbsp;std::unordered_map&lt;int, std::vector&lt;int&gt;&gt; tp, fp;  
 &nbsp; &nbsp;//tp 记录5的个数，fp记录2的个数  
 &nbsp; &nbsp;//两个是互补的  
 &nbsp; &nbsp;tp[0].push_back(0);  
 &nbsp; &nbsp;fp[0].push_back(0);  
​  
 &nbsp; &nbsp;for (int i = 0, t = 0, f = 0; i &lt; n; i++) {  
 &nbsp; &nbsp; &nbsp; &nbsp;int x;  
 &nbsp; &nbsp; &nbsp; &nbsp;std::cin &gt;&gt; x;  
 &nbsp; &nbsp; &nbsp; &nbsp;for (; x &amp;&amp; x % 2 == 0; x /= 2, t++) {  
 &nbsp; &nbsp; &nbsp;  }  
 &nbsp; &nbsp; &nbsp; &nbsp;for (; x &amp;&amp; x % 5 == 0; x /= 5, f++) {  
 &nbsp; &nbsp; &nbsp;  }  
 &nbsp; &nbsp; &nbsp; &nbsp;ans += std::max(  
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//需要 2^k &nbsp; * 5^k 即可满足 10^k 所以是动态规划  
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//每次计算出当前数据含有的2 和  5 的数量 和仍然需要 k  - 当前数量 &nbsp; 这一行的去更新  
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//因为同一个状态有可能对应多个数据， 所以只要找到第一个满足能凑出另一个2或者5的即可   
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;std::upper_bound(tp[t - k].begin(), tp[t - k].end(), f - k) - tp[t - k].begin(),  
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;std::upper_bound(fp[f - k].begin(), fp[f - k].end(), t - k) - fp[f - k].begin()  
 &nbsp; &nbsp; &nbsp;  );  
 &nbsp; &nbsp; &nbsp; &nbsp;tp[t].push_back(f);  
 &nbsp; &nbsp; &nbsp; &nbsp;fp[f].push_back(t);  
 &nbsp;  }  
​  
 &nbsp; &nbsp;std::cout &lt;&lt; ans &lt;&lt; "\n";  
}  
​  
int main() {  
 &nbsp; &nbsp;std::ios::sync_with_stdio(false);  
 &nbsp; &nbsp;std::cin.tie(nullptr);  
​  
 &nbsp; &nbsp;int t;  
 &nbsp; &nbsp;std::cin &gt;&gt; t;  
​  
 &nbsp; &nbsp;while (t--) {  
 &nbsp; &nbsp; &nbsp; &nbsp;solve();  
 &nbsp;  }  
​  
 &nbsp; &nbsp;return 0;  
}  
​
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="数论"><a href="#数论" class="headerlink" title="数论"></a>数论</h1><ol>
<li><p>质数</p>
<ul>
<li><p>试除法判定质数，只枚举 d*d&lt;=n 即可`</p>
  <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token operator">/</span>i<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  
<span class="token comment">//不要担心	数据超过int  </span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>试除法分解质因子，质因数 ,求约数</p>
<ul>
<li>从小到大枚举所有的约数,n中最多只存在一个大于风雨根号n的质因子</li>
</ul>
</li>
</ul>
</li>
</ol>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">            <span class="token keyword">void</span> <span class="token function">divide</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span>  
            <span class="token punctuation">{</span>  
                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> x <span class="token operator">/</span> i<span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span>  
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">%</span> i <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>  
                    <span class="token punctuation">{</span>  
                        <span class="token keyword">int</span> s <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  
                        <span class="token keyword">while</span> <span class="token punctuation">(</span>x <span class="token operator">%</span> i <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> x <span class="token operator">/=</span> i<span class="token punctuation">,</span> s <span class="token operator">++</span> <span class="token punctuation">;</span>  
                        cout <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> <span class="token char">' '</span> <span class="token operator">&lt;&lt;</span> s <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>  
                    <span class="token punctuation">}</span>  
                <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span> cout <span class="token operator">&lt;&lt;</span> x <span class="token operator">&lt;&lt;</span> <span class="token char">' '</span> <span class="token operator">&lt;&lt;</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>  
                cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>  
            <span class="token punctuation">}</span>
            
```            

# 埃氏筛法： 枚举所有数据，然后把每个数的倍数筛去，留下的就是质数 <span class="token operator">*</span><span class="token operator">*</span>思想比较好<span class="token operator">*</span><span class="token operator">*</span> 思想太好了
``` cpp
	   <span class="token keyword">void</span> <span class="token function">get_primes</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>  
        	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  
        		<span class="token keyword">if</span><span class="token punctuation">(</span>st<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>  
                <span class="token comment">//删除所有质数的倍数  </span>
        		primes<span class="token punctuation">[</span>cnt<span class="token operator">++</span><span class="token punctuation">]</span><span class="token operator">=</span>i<span class="token punctuation">;</span>  
        		<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span>i<span class="token operator">+</span>i<span class="token punctuation">;</span>j<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>j<span class="token operator">+=</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>  
        			st<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span><span class="token boolean">true</span><span class="token punctuation">;</span>  
        		<span class="token punctuation">}</span>  
        	<span class="token punctuation">}</span>	  
        <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="线性筛法：-如果质数，把这个数加入集合中-最常用"><a href="#线性筛法：-如果质数，把这个数加入集合中-最常用" class="headerlink" title="线性筛法： 如果质数，把这个数加入集合中 最常用"></a><strong>线性筛法： 如果质数，把这个数加入集合中</strong> 最常用</h3> <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> primes<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span> cnt<span class="token punctuation">;</span>     <span class="token comment">// primes[]存储所有素数  </span>
<span class="token keyword">bool</span> st<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>         <span class="token comment">// st[x]存储x是否被筛掉  </span>
  
<span class="token keyword">void</span> <span class="token function">get_primes</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span>  
<span class="token punctuation">{</span>  
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span>  
    <span class="token punctuation">{</span>  
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>st<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> primes<span class="token punctuation">[</span>cnt <span class="token operator">++</span> <span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>  
        <span class="token comment">//枚举已有的质数，删除它的倍数  </span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> primes<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> n <span class="token operator">/</span> i<span class="token punctuation">;</span> j <span class="token operator">++</span> <span class="token punctuation">)</span>  
        <span class="token punctuation">{</span>  
            st<span class="token punctuation">[</span>primes<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">*</span> i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>  
            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">%</span> primes<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>  
        <span class="token punctuation">}</span>  
    <span class="token punctuation">}</span>  
<span class="token punctuation">}</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol start="2">
<li><p>约数</p>
<ul>
<li><p>试除法求所有约数</p>
<ul>
<li>只枚举较小的约数，较大的约数可以直接算出</li>
</ul>
</li>
</ul>
</li>
</ol>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>  
	vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> ans<span class="token punctuation">;</span>  
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token operator">/</span>i<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  
		<span class="token keyword">if</span><span class="token punctuation">(</span>n<span class="token operator">%</span>i<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  
			<span class="token comment">//从小到大枚举所有约数，并把n/i 得到的约数加入即可  </span>
			ans<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>  
			<span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">!=</span>n<span class="token operator">/</span>i<span class="token punctuation">)</span> ans<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>n<span class="token operator">/</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>  
		<span class="token punctuation">}</span>  
	<span class="token punctuation">}</span>  
	<span class="token function">sort</span><span class="token punctuation">(</span>ans<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>ans<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
	<span class="token keyword">return</span> ans<span class="token punctuation">;</span>  
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>约数个数,约数之和<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">        如果 N <span class="token operator">=</span> p1<span class="token operator">^</span>c1 <span class="token operator">*</span> p2<span class="token operator">^</span>c2 <span class="token operator">*</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token operator">*</span>pk<span class="token operator">^</span>ck  
        约数个数： <span class="token punctuation">(</span>c1 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>c2 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token operator">*</span> <span class="token punctuation">(</span>ck <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>  
        约数之和： <span class="token punctuation">(</span>p1<span class="token operator">^</span><span class="token number">0</span> <span class="token operator">+</span> p1<span class="token operator">^</span><span class="token number">1</span> <span class="token operator">+</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token operator">+</span> p1<span class="token operator">^</span>c1<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token operator">*</span> <span class="token punctuation">(</span>pk<span class="token operator">^</span><span class="token number">0</span> <span class="token operator">+</span> pk<span class="token operator">^</span><span class="token number">1</span> <span class="token operator">+</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token operator">+</span> pk<span class="token operator">^</span>ck
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;bits/stdc++.h&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
<span class="token keyword">typedef</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">long</span> ULL<span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> mod  <span class="token operator">=</span> <span class="token number">1e9</span> <span class="token operator">+</span> <span class="token number">7</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> n <span class="token punctuation">;</span>
    cin <span class="token operator">&gt;&gt;</span> n<span class="token punctuation">;</span>
    unordered_map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span><span class="token keyword">int</span><span class="token operator">&gt;</span> primes<span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>n<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> x<span class="token punctuation">;</span>
        <span class="token function">scanf</span> <span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> x <span class="token operator">/</span> i <span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">while</span><span class="token punctuation">(</span>x <span class="token operator">%</span> i <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                primes<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">++</span><span class="token punctuation">;</span>
                x <span class="token operator">/=</span> i<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span>  primes<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    ULL cnts <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span>res <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> <span class="token punctuation">[</span>prime<span class="token punctuation">,</span>cnt<span class="token punctuation">]</span><span class="token operator">:</span>primes<span class="token punctuation">)</span>  <span class="token punctuation">{</span>
        cnts <span class="token operator">=</span> <span class="token punctuation">(</span>cnts <span class="token operator">*</span> <span class="token punctuation">(</span>cnt <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">%</span> mod<span class="token punctuation">;</span>
        <span class="token comment">//求和</span>
        ULL t <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>cnt<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token comment">//秦九zhao算法</span>
            t <span class="token operator">=</span> <span class="token punctuation">(</span>t <span class="token operator">*</span>prime <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span>mod<span class="token punctuation">;</span>
        <span class="token punctuation">}</span> 
        res <span class="token operator">=</span> res <span class="token operator">*</span> t <span class="token operator">%</span> mod<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    cout <span class="token operator">&lt;&lt;</span> cnts <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> res<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
<ol start="3">
<li><p>欧几里得算法，辗转相除法，求最大公约数</p>
<ul>
<li>GCD(a,b) = =GCD(a.amodb)<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">        <span class="token keyword">int</span> <span class="token function">gcd</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span>  
        <span class="token punctuation">{</span>  
            <span class="token keyword">return</span> b <span class="token operator">?</span> <span class="token function">gcd</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> a <span class="token operator">%</span> b<span class="token punctuation">)</span> <span class="token operator">:</span> a<span class="token punctuation">;</span>  
        <span class="token punctuation">}</span>
        
```     
    <span class="token operator">-</span> LCM 最小公倍数 将两个数相乘再除以最大公因数即可得到最小公倍数
    ```cpp
        <span class="token keyword">int</span> <span class="token function">lcm</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span><span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">{</span>  
        	<span class="token keyword">return</span> a<span class="token operator">*</span>b<span class="token operator">/</span><span class="token function">gcd</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>  
        <span class="token punctuation">}</span>
        <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li>求ax+by=gcd(a,b)<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">        <span class="token keyword">int</span> <span class="token function">xGCD</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>x<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>y<span class="token punctuation">)</span> <span class="token punctuation">{</span>  
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>b<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//b = 0 时  </span>
                x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> y <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  
                <span class="token keyword">return</span> a<span class="token punctuation">;</span>  
            <span class="token punctuation">}</span>  
            <span class="token keyword">int</span> x1<span class="token punctuation">,</span> y10<span class="token punctuation">,</span> gcd <span class="token operator">=</span> <span class="token function">xGCD</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> a <span class="token operator">%</span> b<span class="token punctuation">,</span> x1<span class="token punctuation">,</span> y1<span class="token punctuation">)</span><span class="token punctuation">;</span>  
            x <span class="token operator">=</span> y1<span class="token punctuation">,</span> y <span class="token operator">=</span> x1 <span class="token operator">-</span> <span class="token punctuation">(</span>a <span class="token operator">/</span> b<span class="token punctuation">)</span> <span class="token operator">*</span> y1<span class="token punctuation">;</span>  
            <span class="token keyword">return</span> gcd<span class="token punctuation">;</span>  
        <span class="token punctuation">}</span>
        
```     
### 欧拉函数：小于x的整数中与x互质的数的个数<span class="token punctuation">]</span>
        
求出单个数的欧拉函数  
<span class="token function">f</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token operator">=</span> `n <span class="token operator">*</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">/</span> p1<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">/</span> p2a<span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>`
```cpp
        <span class="token keyword">int</span> <span class="token function">phi</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">{</span>  
        	<span class="token keyword">int</span> res<span class="token operator">=</span>x<span class="token punctuation">;</span>  
        	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>x<span class="token operator">/</span>i<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  
        		<span class="token keyword">if</span><span class="token punctuation">(</span>x<span class="token operator">%</span>i<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  
        			res<span class="token operator">=</span>res<span class="token operator">/</span>i<span class="token operator">*</span><span class="token punctuation">(</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
        			<span class="token keyword">while</span><span class="token punctuation">(</span>x<span class="token operator">%</span>i<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> x<span class="token operator">/=</span>i<span class="token punctuation">;</span>  
        		<span class="token punctuation">}</span>  
        	<span class="token punctuation">}</span>  
        	<span class="token keyword">if</span><span class="token punctuation">(</span>x<span class="token operator">&gt;</span><span class="token number">1</span><span class="token punctuation">)</span> res<span class="token operator">=</span>res<span class="token operator">/</span>x<span class="token operator">*</span><span class="token punctuation">(</span>x<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
        	<span class="token keyword">return</span> res<span class="token punctuation">;</span>  
        <span class="token punctuation">}</span>
        <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
</li>
</ol>
<p>筛法：求出1-n每个数的欧拉函数，在线性筛法的模板中加上三行</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> primes<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span> cnt<span class="token punctuation">;</span>     <span class="token comment">// primes[]存储所有素数  </span>
<span class="token keyword">int</span> euler<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>           <span class="token comment">// 存储每个数的欧拉函数  </span>
<span class="token keyword">bool</span> st<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>         <span class="token comment">// st[x]存储x是否被筛掉  </span>
  
  
<span class="token keyword">void</span> <span class="token function">get_eulers</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span>  
<span class="token punctuation">{</span>  
    euler<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span>  
    <span class="token punctuation">{</span>  
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>st<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>  
        <span class="token punctuation">{</span>  
            primes<span class="token punctuation">[</span>cnt <span class="token operator">++</span> <span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>  
            euler<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>  
        <span class="token punctuation">}</span>  
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> primes<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> n <span class="token operator">/</span> i<span class="token punctuation">;</span> j <span class="token operator">++</span> <span class="token punctuation">)</span>  
        <span class="token punctuation">{</span>  
            <span class="token keyword">int</span> t <span class="token operator">=</span> primes<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">*</span> i<span class="token punctuation">;</span>  
            st<span class="token punctuation">[</span>t<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>  
            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">%</span> primes<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>  
            <span class="token punctuation">{</span>  
                euler<span class="token punctuation">[</span>t<span class="token punctuation">]</span> <span class="token operator">=</span> euler<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">*</span> primes<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>  
                <span class="token keyword">break</span><span class="token punctuation">;</span>  
            <span class="token punctuation">}</span>  
            euler<span class="token punctuation">[</span>t<span class="token punctuation">]</span> <span class="token operator">=</span> euler<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token punctuation">(</span>primes<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
        <span class="token punctuation">}</span>  
    <span class="token punctuation">}</span>  
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="欧拉定理"><a href="#欧拉定理" class="headerlink" title="欧拉定理"></a>欧拉定理</h3><p>a ^f(n) % n = 1<br>a和n互质</p>
<h3 id="快速幂："><a href="#快速幂：" class="headerlink" title="快速幂："></a>快速幂：</h3>  <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">        把指数转为<span class="token number">2</span>进制就可以看出来有哪些含有了
        
        预处理时每一个结果都是前一个的平方再mod
        
        求 m<span class="token operator">^</span>k mod p，时间复杂度 <span class="token function">O</span><span class="token punctuation">(</span>logk<span class="token punctuation">)</span>。  
        ​  
        <span class="token keyword">int</span> <span class="token function">qmi</span><span class="token punctuation">(</span><span class="token keyword">int</span> m<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">,</span> <span class="token keyword">int</span> p<span class="token punctuation">)</span>  
        <span class="token punctuation">{</span>  
            <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">%</span> p<span class="token punctuation">,</span> t <span class="token operator">=</span> m<span class="token punctuation">;</span>  
            <span class="token keyword">while</span> <span class="token punctuation">(</span>k<span class="token punctuation">)</span>  
            <span class="token punctuation">{</span>  
                <span class="token keyword">if</span> <span class="token punctuation">(</span>k<span class="token operator">&amp;</span><span class="token number">1</span><span class="token punctuation">)</span> res <span class="token operator">=</span> res <span class="token operator">*</span> t <span class="token operator">%</span> p<span class="token punctuation">;</span>  
                t <span class="token operator">=</span> t <span class="token operator">*</span> t <span class="token operator">%</span> p<span class="token punctuation">;</span>  
                k <span class="token operator">&gt;&gt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>  
            <span class="token punctuation">}</span>  
            <span class="token keyword">return</span> res<span class="token punctuation">;</span>  
        <span class="token punctuation">}</span>
        
    
```      
### 快速幂求逆元
```cpp
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;bits/stdc++.h&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
<span class="token keyword">typedef</span> <span class="token keyword">long</span> <span class="token keyword">long</span> LL<span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">quick_mi</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span><span class="token keyword">int</span> b<span class="token punctuation">,</span><span class="token keyword">int</span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">%</span> p<span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>b<span class="token operator">&amp;</span><span class="token number">1</span><span class="token punctuation">)</span> res <span class="token operator">=</span> <span class="token punctuation">(</span>LL<span class="token punctuation">)</span> res<span class="token operator">*</span>a <span class="token operator">%</span>p<span class="token punctuation">;</span>
        b <span class="token operator">&gt;&gt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        a <span class="token operator">=</span> <span class="token punctuation">(</span>LL<span class="token punctuation">)</span> a <span class="token operator">*</span> a <span class="token operator">%</span> p<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> res<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> n<span class="token punctuation">;</span>
    <span class="token function">scanf</span> <span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>n<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> a<span class="token punctuation">,</span>p<span class="token punctuation">;</span>
        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d%d"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>a<span class="token punctuation">,</span><span class="token operator">&amp;</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>a <span class="token operator">%</span> p<span class="token punctuation">)</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span><span class="token function">quick_mi</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>p<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">,</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span> <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"impossible"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="扩展欧几里得算法-不会"><a href="#扩展欧几里得算法-不会" class="headerlink" title="扩展欧几里得算法(不会)"></a>扩展欧几里得算法(不会)</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">    <span class="token comment">// 求x, y，使得ax + by = gcd(a, b)  </span>
    <span class="token keyword">int</span> <span class="token function">exgcd</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>x<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>y<span class="token punctuation">)</span>  
    <span class="token punctuation">{</span>  
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>b<span class="token punctuation">)</span>  
        <span class="token punctuation">{</span>  
            x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> y <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  
            <span class="token keyword">return</span> a<span class="token punctuation">;</span>  
        <span class="token punctuation">}</span>  
        <span class="token keyword">int</span> d <span class="token operator">=</span> <span class="token function">exgcd</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> a <span class="token operator">%</span> b<span class="token punctuation">,</span> y<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>  
        y <span class="token operator">-=</span> <span class="token punctuation">(</span>a<span class="token operator">/</span>b<span class="token punctuation">)</span> <span class="token operator">*</span> x<span class="token punctuation">;</span>  
        <span class="token keyword">return</span> d<span class="token punctuation">;</span>  
    <span class="token punctuation">}</span>
```  
#### 高斯消元求解方程组的解
 ```cpp
	 <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;bits/stdc++.h&gt;</span>  </span>
    <span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>  
    <span class="token keyword">const</span> <span class="token keyword">int</span> N<span class="token operator">=</span><span class="token number">100</span><span class="token punctuation">;</span>  
    <span class="token keyword">int</span> n<span class="token punctuation">;</span>  
    <span class="token keyword">const</span> <span class="token keyword">double</span> eps<span class="token operator">=</span><span class="token number">1e-6</span><span class="token punctuation">;</span>  
    <span class="token keyword">double</span> a<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>  
    <span class="token comment">// a[N][N]是增广矩阵  </span>
    <span class="token comment">// a[N][N]是增广矩阵  </span>
    <span class="token keyword">int</span> <span class="token function">gauss</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  
    <span class="token punctuation">{</span>  
        <span class="token keyword">int</span> c<span class="token punctuation">,</span> r<span class="token punctuation">;</span>  
        <span class="token keyword">for</span> <span class="token punctuation">(</span>c <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> r <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> c <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> c <span class="token operator">++</span> <span class="token punctuation">)</span>  
        <span class="token punctuation">{</span>  
            <span class="token keyword">int</span> t <span class="token operator">=</span> r<span class="token punctuation">;</span>  
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> r<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span>   <span class="token comment">// 找到绝对值最大的行  </span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">fabs</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token function">fabs</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  
                    t <span class="token operator">=</span> i<span class="token punctuation">;</span>  
    ​  
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">fabs</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> eps<span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>  
    ​  
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> c<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token function">swap</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// 将绝对值最大的行换到最顶端  </span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n<span class="token punctuation">;</span> i <span class="token operator">&gt;=</span> c<span class="token punctuation">;</span> i <span class="token operator">--</span> <span class="token punctuation">)</span> a<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">/=</span> a<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">;</span>      <span class="token comment">// 将当前行的首位变成1  </span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> r <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span>       <span class="token comment">// 用当前行将下面所有的列消成0  </span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">fabs</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> eps<span class="token punctuation">)</span>  
                    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> n<span class="token punctuation">;</span> j <span class="token operator">&gt;=</span> c<span class="token punctuation">;</span> j <span class="token operator">--</span> <span class="token punctuation">)</span>  
                        a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">-=</span> a<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">*</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">;</span>  
    ​  
            r <span class="token operator">++</span> <span class="token punctuation">;</span>  
        <span class="token punctuation">}</span>  
    ​  
        <span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token operator">&lt;</span> n<span class="token punctuation">)</span>  
        <span class="token punctuation">{</span>  
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> r<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span>  
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">fabs</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> eps<span class="token punctuation">)</span>  
                    <span class="token keyword">return</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">// 无解  </span>
            <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 有无穷多组解  </span>
        <span class="token punctuation">}</span>  
    ​  
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">--</span> <span class="token punctuation">)</span>  
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j <span class="token operator">++</span> <span class="token punctuation">)</span>  
                a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">-=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">*</span> a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>  
    ​  
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 有唯一解  </span>
    <span class="token punctuation">}</span>  
    <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  
        cin<span class="token operator">&gt;&gt;</span>n<span class="token punctuation">;</span>  
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>  
            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  
                cin<span class="token operator">&gt;&gt;</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>  
            <span class="token punctuation">}</span>  
    ​  
    <span class="token keyword">int</span> t<span class="token operator">=</span><span class="token function">gauss</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
        <span class="token keyword">if</span><span class="token punctuation">(</span>t<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  
            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  
                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%.2lf "</span><span class="token punctuation">,</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
            <span class="token punctuation">}</span>  
        <span class="token punctuation">}</span>  
        <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>t<span class="token operator">==</span><span class="token number">2</span><span class="token punctuation">)</span> cout<span class="token operator">&lt;&lt;</span><span class="token string">"无解"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>  
        <span class="token keyword">else</span> cout<span class="token operator">&lt;&lt;</span><span class="token string">"有无数组解"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>  
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  
    <span class="token punctuation">}</span>
    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="递推求组合数，dp法-适合询问次数-gt-10w"><a href="#递推求组合数，dp法-适合询问次数-gt-10w" class="headerlink" title="递推求组合数，dp法 适合询问次数>10w"></a>递推求组合数，dp法 适合询问次数&gt;10w</h3> <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// c[a][b] 表示从a个苹果中选b个的方案数  </span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span>  
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> i<span class="token punctuation">;</span> j <span class="token operator">++</span> <span class="token punctuation">)</span>  
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>j<span class="token punctuation">)</span> c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  
        <span class="token keyword">else</span> c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>c<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> c<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">%</span> mod<span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="通过预处理逆元的方式求组合数-询问1w"><a href="#通过预处理逆元的方式求组合数-询问1w" class="headerlink" title="通过预处理逆元的方式求组合数 询问1w"></a>通过预处理逆元的方式求组合数 询问1w</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">    首先预处理出所有阶乘取模的余数fact<span class="token punctuation">[</span>N<span class="token punctuation">]</span>，以及所有阶乘取模的逆元infact<span class="token punctuation">[</span>N<span class="token punctuation">]</span>  
    如果取模的数是质数，可以用费马小定理求逆元  
    <span class="token keyword">int</span> <span class="token function">qmi</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">,</span> <span class="token keyword">int</span> p<span class="token punctuation">)</span>    <span class="token comment">// 快速幂模板  </span>
    <span class="token punctuation">{</span>  
        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  
        <span class="token keyword">while</span> <span class="token punctuation">(</span>k<span class="token punctuation">)</span>  
        <span class="token punctuation">{</span>  
            <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">)</span> res <span class="token operator">=</span> <span class="token punctuation">(</span>LL<span class="token punctuation">)</span>res <span class="token operator">*</span> a <span class="token operator">%</span> p<span class="token punctuation">;</span>  
            a <span class="token operator">=</span> <span class="token punctuation">(</span>LL<span class="token punctuation">)</span>a <span class="token operator">*</span> a <span class="token operator">%</span> p<span class="token punctuation">;</span>  
            k <span class="token operator">&gt;&gt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>  
        <span class="token punctuation">}</span>  
        <span class="token keyword">return</span> res<span class="token punctuation">;</span>  
    <span class="token punctuation">}</span>  
    ​  
    <span class="token comment">// 预处理阶乘的余数和阶乘逆元的余数  </span>
    fact<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> infact<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span>  
    <span class="token punctuation">{</span>  
        fact<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>LL<span class="token punctuation">)</span>fact<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">*</span> i <span class="token operator">%</span> mod<span class="token punctuation">;</span>  
        infact<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>LL<span class="token punctuation">)</span>infact<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token function">qmi</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> mod <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">,</span> mod<span class="token punctuation">)</span> <span class="token operator">%</span> mod<span class="token punctuation">;</span>  
    <span class="token punctuation">}</span>  
    ​
```    
### Lucas定理求组合数 <span class="token number">20</span>次询问以下
    
<span class="token operator">!</span><span class="token punctuation">[</span>image<span class="token operator">-</span><span class="token number">20230519193526425</span><span class="token punctuation">]</span><span class="token punctuation">(</span>file<span class="token operator">:</span><span class="token comment">//D:/typora%E7%94%A8%E5%9B%BE/Screenshots/image-20230519193526425.png?lastModify=1694256669)    </span>
```cpp
      <span class="token comment">//若p是质数，则对于任意整数 1 &lt;= m &lt;= n，有：  </span>
      <span class="token comment">//  C(n, m) = C(n % p, m % p) * C(n / p, m / p) (mod p)  </span>
    ​  
    <span class="token keyword">int</span> <span class="token function">qmi</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">,</span> <span class="token keyword">int</span> p<span class="token punctuation">)</span>  <span class="token comment">// 快速幂模板  </span>
    <span class="token punctuation">{</span>  
        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">%</span> p<span class="token punctuation">;</span>  
        <span class="token keyword">while</span> <span class="token punctuation">(</span>k<span class="token punctuation">)</span>  
        <span class="token punctuation">{</span>  
            <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">)</span> res <span class="token operator">=</span> <span class="token punctuation">(</span>LL<span class="token punctuation">)</span>res <span class="token operator">*</span> a <span class="token operator">%</span> p<span class="token punctuation">;</span>  
            a <span class="token operator">=</span> <span class="token punctuation">(</span>LL<span class="token punctuation">)</span>a <span class="token operator">*</span> a <span class="token operator">%</span> p<span class="token punctuation">;</span>  
            k <span class="token operator">&gt;&gt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>  
        <span class="token punctuation">}</span>  
        <span class="token keyword">return</span> res<span class="token punctuation">;</span>  
    <span class="token punctuation">}</span>  
    ​  
    <span class="token keyword">int</span> <span class="token function">C</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">,</span> <span class="token keyword">int</span> p<span class="token punctuation">)</span>  <span class="token comment">// 通过定理求组合数C(a, b)  </span>
    <span class="token punctuation">{</span>  
        <span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">&lt;</span> b<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  
    ​  
        LL x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> y <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">// x是分子，y是分母  </span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> a<span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> b<span class="token punctuation">;</span> i <span class="token operator">--</span><span class="token punctuation">,</span> j <span class="token operator">++</span> <span class="token punctuation">)</span>  
        <span class="token punctuation">{</span>  
            x <span class="token operator">=</span> <span class="token punctuation">(</span>LL<span class="token punctuation">)</span>x <span class="token operator">*</span> i <span class="token operator">%</span> p<span class="token punctuation">;</span>  
            y <span class="token operator">=</span> <span class="token punctuation">(</span>LL<span class="token punctuation">)</span> y <span class="token operator">*</span> j <span class="token operator">%</span> p<span class="token punctuation">;</span>  
        <span class="token punctuation">}</span>  
    ​  
        <span class="token keyword">return</span> x <span class="token operator">*</span> <span class="token punctuation">(</span>LL<span class="token punctuation">)</span><span class="token function">qmi</span><span class="token punctuation">(</span>y<span class="token punctuation">,</span> p <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">,</span> p<span class="token punctuation">)</span> <span class="token operator">%</span> p<span class="token punctuation">;</span>  
    <span class="token punctuation">}</span>  
    ​  
    <span class="token keyword">int</span> <span class="token function">lucas</span><span class="token punctuation">(</span>LL a<span class="token punctuation">,</span> LL b<span class="token punctuation">,</span> <span class="token keyword">int</span> p<span class="token punctuation">)</span>  
    <span class="token punctuation">{</span>  
        <span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">&lt;</span> p <span class="token operator">&amp;&amp;</span> b <span class="token operator">&lt;</span> p<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token function">C</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>  
        <span class="token keyword">return</span> <span class="token punctuation">(</span>LL<span class="token punctuation">)</span><span class="token function">C</span><span class="token punctuation">(</span>a <span class="token operator">%</span> p<span class="token punctuation">,</span> b <span class="token operator">%</span> p<span class="token punctuation">,</span> p<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token function">lucas</span><span class="token punctuation">(</span>a <span class="token operator">/</span> p<span class="token punctuation">,</span> b <span class="token operator">/</span> p<span class="token punctuation">,</span> p<span class="token punctuation">)</span> <span class="token operator">%</span> p<span class="token punctuation">;</span>  
    <span class="token punctuation">}</span>
    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="file://D:/typora%E7%94%A8%E5%9B%BE/Screenshots/image-20230519193254443.png?lastModify=1694256669" alt="image-20230519193254443"></p>
<h3 id="逆元："><a href="#逆元：" class="headerlink" title="逆元："></a>逆元：</h3><p>可以在快速幂中求出</p>
<p>也就是a的p-2次方的</p>
<blockquote>
<p>在模为素数p的情况下，有费马小定理 a^(p-1)=1（mod p） 那么a^(p-2)=a^-1(mod p) 也就是说a的逆元为a^(p-2)</p>
</blockquote>
<h4 id="分解质因数法求组合数"><a href="#分解质因数法求组合数" class="headerlink" title="分解质因数法求组合数"></a>分解质因数法求组合数</h4><p> &nbsp; </p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">    当我们需要求出组合数的真实值，而非对某个数的余数时，分解质因数的方式比较好用：  
        <span class="token number">1.</span> 筛法求出范围内的所有质数  
        <span class="token number">2.</span> 通过 <span class="token function">C</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token operator">=</span> a<span class="token operator">!</span> <span class="token operator">/</span> b<span class="token operator">!</span> <span class="token operator">/</span> <span class="token punctuation">(</span>a <span class="token operator">-</span> b<span class="token punctuation">)</span><span class="token operator">!</span> 这个公式求出每个质因子的次数。 n<span class="token operator">!</span> 中p的次数是 n <span class="token operator">/</span> p <span class="token operator">+</span> n <span class="token operator">/</span> p<span class="token operator">^</span><span class="token number">2</span> <span class="token operator">+</span> n <span class="token operator">/</span> p<span class="token operator">^</span><span class="token number">3</span> <span class="token operator">+</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  
        <span class="token number">3.</span> 用高精度乘法将所有质因子相乘  
      
    <span class="token keyword">int</span> primes<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span> cnt<span class="token punctuation">;</span>     <span class="token comment">// 存储所有质数  </span>
    <span class="token keyword">int</span> sum<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>     <span class="token comment">// 存储每个质数的次数  </span>
    <span class="token keyword">bool</span> st<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>     <span class="token comment">// 存储每个数是否已被筛掉</span>

    <span class="token keyword">void</span> <span class="token function">get_primes</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span>      <span class="token comment">// 线性筛法求素数  </span>
•        <span class="token punctuation">{</span>  
•            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span>  
•            <span class="token punctuation">{</span>  
•                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>st<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> primes<span class="token punctuation">[</span>cnt <span class="token operator">++</span> <span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>  
•                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> primes<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> n <span class="token operator">/</span> i<span class="token punctuation">;</span> j <span class="token operator">++</span> <span class="token punctuation">)</span>  
•                <span class="token punctuation">{</span>  
•                    st<span class="token punctuation">[</span>primes<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">*</span> i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>  
•                    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">%</span> primes<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>  
•                <span class="token punctuation">}</span>  
•            <span class="token punctuation">}</span>  
•        <span class="token punctuation">}</span>  
​  
​  
•          
•        <span class="token keyword">int</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> p<span class="token punctuation">)</span>       <span class="token comment">// 求n！中的次数  </span>
•        <span class="token punctuation">{</span>  
•            <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  
•            <span class="token keyword">while</span> <span class="token punctuation">(</span>n<span class="token punctuation">)</span>  
•            <span class="token punctuation">{</span>  
•                res <span class="token operator">+=</span> n <span class="token operator">/</span> p<span class="token punctuation">;</span>  
•                n <span class="token operator">/=</span> p<span class="token punctuation">;</span>  
•            <span class="token punctuation">}</span>  
•            <span class="token keyword">return</span> res<span class="token punctuation">;</span>  
•        <span class="token punctuation">}</span>  
​  
​  
•          
•        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">mul</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span>       <span class="token comment">// 高精度乘低精度模板  </span>
•        <span class="token punctuation">{</span>  
•            vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> c<span class="token punctuation">;</span>  
•            <span class="token keyword">int</span> t <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  
•            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> a<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span>  
•            <span class="token punctuation">{</span>  
•                t <span class="token operator">+=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">*</span> b<span class="token punctuation">;</span>  
•                c<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>t <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
•                t <span class="token operator">/=</span> <span class="token number">10</span><span class="token punctuation">;</span>  
•            <span class="token punctuation">}</span>  
•          
•            <span class="token keyword">while</span> <span class="token punctuation">(</span>t<span class="token punctuation">)</span>  
•            <span class="token punctuation">{</span>  
•                c<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>t <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
•                t <span class="token operator">/=</span> <span class="token number">10</span><span class="token punctuation">;</span>  
•            <span class="token punctuation">}</span>  
•          
•            <span class="token keyword">return</span> c<span class="token punctuation">;</span>  
•        <span class="token punctuation">}</span>  
•        

    <span class="token function">get_primes</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 预处理范围内的所有质数  </span>
      
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> cnt<span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span>     <span class="token comment">// 求每个质因数的次数  </span>
    <span class="token punctuation">{</span>  
        <span class="token keyword">int</span> p <span class="token operator">=</span> primes<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>  
        sum<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">get</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> p<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token function">get</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> p<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token function">get</span><span class="token punctuation">(</span>a <span class="token operator">-</span> b<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token punctuation">}</span>  
      
    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> res<span class="token punctuation">;</span>  
    res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
      
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> cnt<span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span>     <span class="token comment">// 用高精度乘法将所有质因子相乘  </span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> sum<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> j <span class="token operator">++</span> <span class="token punctuation">)</span>  
            res <span class="token operator">=</span> <span class="token function">mul</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> primes<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p>
<h2 id="动态规划DP"><a href="#动态规划DP" class="headerlink" title="动态规划DP"></a>动态规划DP</h2><p>思路：</p>
<ol>
<li><p>状态表示：需要几维的动态规划</p>
<ul>
<li><p>集合 所有选法</p>
<ol>
<li><p>所有选法</p>
</li>
<li><p>条件</p>
<ul>
<li><p>只从前i个物品中选择</p>
</li>
<li><p>总体积&lt;=j</p>
</li>
</ul>
</li>
</ol>
</li>
<li><p>属性 最大值？最小值?……</p>
</li>
</ul>
</li>
<li><p>状态计算：怎么得到结果</p>
</li>
</ol>
<h3 id="01背包-每个物品只能用一次"><a href="#01背包-每个物品只能用一次" class="headerlink" title="01背包 每个物品只能用一次"></a>01背包 每个物品只能用一次</h3><p>一维优化;</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">///f[N][N] 表示前i个物品，j的容量下的最大值  </span>
进行压缩，因为每次更新i是时只用到了i<span class="token operator">-</span><span class="token number">1</span> 这个位置的数据，所以可以使用滚动数组，实现每次i<span class="token operator">-</span><span class="token number">1</span>到i的更新<span class="token punctuation">;</span>  
所以编成  f<span class="token punctuation">[</span>N<span class="token punctuation">]</span> 表示j的背包容量下的最大值<span class="token punctuation">;</span>  
j<span class="token operator">=</span><span class="token number">0</span>的结果都为<span class="token number">0</span> 所以可以跳过<span class="token punctuation">;</span>i<span class="token operator">=</span><span class="token number">0</span>的结果也都为<span class="token number">0</span><span class="token punctuation">,</span>同时，如果当前的背包容量不足以把当前物品装入也不需要进行更新了，所以小于当前背包容量的就不要考虑了<span class="token punctuation">;</span>  
不能更新也就是f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>f<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> 所以可以直接去掉，变为  f<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>f<span class="token punctuation">[</span>j<span class="token punctuation">]</span>  
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//遍览物品  </span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span>m<span class="token punctuation">;</span>j<span class="token operator">&gt;=</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>j<span class="token operator">--</span><span class="token punctuation">)</span><span class="token comment">//m为最大背包容量  </span>
        f<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span><span class="token function">max</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>f<span class="token punctuation">[</span>j<span class="token operator">-</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">+</span>w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="多状态dp"><a href="#多状态dp" class="headerlink" title="多状态dp"></a>多状态dp</h2><p>示例：<br><a target="_blank" rel="noopener" href="https://www.lanqiao.cn/problems/2223/learning/?subject_code=2&amp;group_code=4&amp;match_num=13&amp;match_flow=2&amp;origin=cup">魔法背包</a><br><a target="_blank" rel="noopener" href="https://www.lanqiao.cn/problems/2224/learning/?subject_code=2&amp;group_code=4&amp;match_num=13&amp;match_flow=2&amp;origin=cup">修路</a><br><a target="_blank" rel="noopener" href="https://www.lanqiao.cn/problems/3542/learning/?subject_code=2&amp;group_code=4&amp;match_num=14&amp;match_flow=1&amp;origin=cup">魔法阵</a><br>存在多个状态，其中每一个状态内的转移是正常转移的，而状态之间是需要满足条件进行转移的。</p>
<h3 id="完全背包-每件物品有无限个"><a href="#完全背包-每件物品有无限个" class="headerlink" title="完全背包 每件物品有无限个"></a>完全背包 每件物品有无限个</h3><p>01背包：从f[i-1]转过来 f[i,h]=max(f[i-1,j],f[i-1,j-v]+w[i]) //优化后:f[j]=max(f[j],f[v-v[i]]+w[i])</p>
<p>完全背包：从f[i]转移 f[i,j]=max(f[i-1,j],f[i,j-v[i]]+w[i])</p>
<p>每次更新：k是每个物品可以有多少个，i是前i个物品，j是当前背包容量</p>
<p>f[i][j]=max(f[i][j],f[i-j][j-v[i]*k]+w[i]*k</p>
<p>优化思路：</p>
<p><img src="file://D:/typora%E7%94%A8%E5%9B%BE/Screenshots/image-20230521084412853.png?lastModify=1694256669" alt="image-20230521084412853"></p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">​  
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span> <span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> m <span class="token punctuation">;</span> j <span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// for (int k = 0 ; k * v[i] &lt;= j ; k ++) {</span>
            <span class="token comment">//     f[i][j] = max(f[i][j],f[i - 1][j - k *v[i]] + k * w[i]);</span>
            <span class="token comment">// }</span>
            <span class="token comment">//f[i][j] = max(f[i-1][j],f[i-1][j-v]+w,f[i-1][j-2v] + 2w , ......)</span>
            <span class="token comment">//f[i][j-v] = max(        ,f[i-1][j-v],f[i-1][j-2v]+2w,....)</span>
            <span class="token comment">//错位相减</span>
            <span class="token comment">// f[i][j] - f[i][j-v] = w</span>
            <span class="token comment">// f[i][j] = f[i][j-v] + w</span>
            <span class="token comment">//所以 </span>
            <span class="token comment">//f[i][j] = max(f[i-1][j],f[i][j-v] + w)</span>
            <span class="token comment">//根据递推，每一个max后面那个数都等于上一个的f[i][j-v] + w</span>
            <span class="token comment">//前提是要大于v[i]等式才成立</span>
            f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> f<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//前一个转移</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">&gt;=</span> v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">+</span>w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

一维优化：删去一维

<span class="token comment">//f[i][j]=f[i-1][j];  f[i]==f[i-1] 直接删去  </span>
​  
<span class="token comment">//if(j&gt;=v[i]){ 只有当前背包容量大于当前的物品时才能装入，采用从v[i]遍历背包容量  </span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>  
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>j<span class="token operator">&lt;=</span>m<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>  
    <span class="token comment">//f[i,j]=max(f[i-1,j],f[i,j-v[i]]+w[i])  </span>
        f<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span><span class="token function">max</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>f<span class="token punctuation">[</span>j<span class="token operator">-</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">+</span>w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
<span class="token comment">//}  </span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>01和完全背包区别：</p>
<p>背包容量的遍历不同</p>
<p>01:</p>
<p> for(int j=m;j&gt;=v[i];j–)//m为最大背包容量<br>        f[j]=max(f[j],f[j-v[i]+w[i]]);</p>
<p>完全：</p>
<p>for(int j=v[i],j&lt;=m;j++)<br>        f[j]=max(f[j],f[j-v[i]]+w[i]);</p>
<h3 id="多重背包问题-优化"><a href="#多重背包问题-优化" class="headerlink" title="多重背包问题 优化"></a>多重背包问题 优化</h3><p>每个物品有个数限制，但不是无限</p>
<ol>
<li><p>状态表示：f[ i ] [ j ]</p>
<ul>
<li><p>集合</p>
</li>
<li><p>属性</p>
</li>
</ul>
</li>
<li><p>状态计算：</p>
<p> f[i][j]=max(f[i-1][j-v[i]*k]+w[i]*k)  k有范围</p>
<p> 优化：将数量打包，比如打包成1个物品一起，2个物品一起……</p>
<p> 之后用01背包做即可</p>
</li>
</ol>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;bits/stdc++.h&gt;</span>  </span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>  
<span class="token keyword">const</span> <span class="token keyword">int</span> N <span class="token operator">=</span> <span class="token number">1001</span><span class="token punctuation">;</span>  
<span class="token keyword">int</span> f<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span>v<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span>w<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>  
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  
    <span class="token keyword">int</span> n<span class="token punctuation">,</span>m<span class="token punctuation">,</span>cnt<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>  
    cin<span class="token operator">&gt;&gt;</span>n<span class="token operator">&gt;&gt;</span>m<span class="token punctuation">;</span>  
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  
        <span class="token keyword">int</span> a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>s<span class="token punctuation">;</span><span class="token comment">//容量，价值  </span>
        cin<span class="token operator">&gt;&gt;</span>a<span class="token operator">&gt;&gt;</span>b<span class="token operator">&gt;&gt;</span>s<span class="token punctuation">;</span>  
        <span class="token keyword">int</span> k<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//用来打包  </span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>k<span class="token operator">&lt;=</span>s<span class="token punctuation">)</span><span class="token punctuation">{</span>  
            cnt<span class="token operator">++</span><span class="token punctuation">;</span>  
            v<span class="token punctuation">[</span>cnt<span class="token punctuation">]</span><span class="token operator">=</span>a<span class="token operator">*</span>k<span class="token punctuation">;</span>  
            w<span class="token punctuation">[</span>cnt<span class="token punctuation">]</span><span class="token operator">=</span>b<span class="token operator">*</span>k<span class="token punctuation">;</span>  
            s<span class="token operator">-=</span>k<span class="token punctuation">;</span>  
            k<span class="token operator">*=</span><span class="token number">2</span><span class="token punctuation">;</span>  
        <span class="token punctuation">}</span>  
        <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token operator">&gt;</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  
            cnt<span class="token operator">++</span><span class="token punctuation">;</span>  
            v<span class="token punctuation">[</span>cnt<span class="token punctuation">]</span><span class="token operator">=</span>a<span class="token operator">*</span>s<span class="token punctuation">;</span>  
            w<span class="token punctuation">[</span>cnt<span class="token punctuation">]</span><span class="token operator">=</span>b<span class="token operator">*</span>s<span class="token punctuation">;</span>  
        <span class="token punctuation">}</span>  
    <span class="token punctuation">}</span>  
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>cnt<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span>m<span class="token punctuation">;</span>j<span class="token operator">&gt;=</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>j<span class="token operator">--</span><span class="token punctuation">)</span>  
        f<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span><span class="token function">max</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>f<span class="token punctuation">[</span>j<span class="token operator">-</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">+</span>w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token punctuation">}</span>  
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="分组背包问题"><a href="#分组背包问题" class="headerlink" title="分组背包问题"></a>分组背包问题</h3><h2 id="线性DP"><a href="#线性DP" class="headerlink" title="线性DP"></a>线性DP</h2><p>递归方程有线性关系，具有求的先后顺序</p>
<p>具体有各种子序列</p>
<p>建议看leetcode101 里面的比较好</p>
<h1 id="数位统计DP"><a href="#数位统计DP" class="headerlink" title="数位统计DP"></a>数位统计DP</h1><p>给出两个数字 a, b</p>
<p>统计a到b 中每一位 的0~9的出现次数</p>
<p>思路：分情况讨论 + 前缀和思想</p>
<p><img src="file://D:/typora%E7%94%A8%E5%9B%BE/Screenshots/image-20230524164849922.png?lastModify=1694256669" alt="image-20230524164849922"></p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">include <span class="token operator">&lt;</span>iostream<span class="token operator">&gt;</span>  
<span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">include</span> <span class="token string">&lt;cmath&gt;</span>  </span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>  
  
<span class="token keyword">int</span> <span class="token function">dgt</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token comment">// 计算整数n有多少位  </span>
<span class="token punctuation">{</span>  
    <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  
    <span class="token keyword">while</span> <span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token operator">++</span> res<span class="token punctuation">,</span> n <span class="token operator">/=</span> <span class="token number">10</span><span class="token punctuation">;</span>  
    <span class="token keyword">return</span> res<span class="token punctuation">;</span>  
<span class="token punctuation">}</span>  
  
<span class="token keyword">int</span> <span class="token function">cnt</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token comment">// 计算从1到n的整数中数字i出现多少次   </span>
<span class="token punctuation">{</span>  
    <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> d <span class="token operator">=</span> <span class="token function">dgt</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> d<span class="token punctuation">;</span> j <span class="token operator">++</span><span class="token punctuation">)</span> <span class="token comment">// 从右到左第j位上数字i出现多少次，所有位上的次数加起来就是i出现的总次数  </span>
    <span class="token punctuation">{</span>  
        <span class="token comment">// l和r是第j位左边和右边的整数 (视频中的abc和efg); dj是第j位的数字  </span>
        <span class="token keyword">int</span> p <span class="token operator">=</span> <span class="token function">pow</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> l <span class="token operator">=</span> n <span class="token operator">/</span> p <span class="token operator">/</span> <span class="token number">10</span><span class="token punctuation">,</span> r <span class="token operator">=</span> n <span class="token operator">%</span> p<span class="token punctuation">,</span> dj <span class="token operator">=</span> n <span class="token operator">/</span> p <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">;</span>  
        <span class="token comment">// 计算第j位左边的整数小于l (视频中xxx = 000 ~ abc - 1)的情况  </span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>i<span class="token punctuation">)</span> res <span class="token operator">+=</span> l <span class="token operator">*</span> p<span class="token punctuation">;</span>   
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>i <span class="token operator">&amp;&amp;</span> l<span class="token punctuation">)</span> res <span class="token operator">+=</span> <span class="token punctuation">(</span>l <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> p<span class="token punctuation">;</span> <span class="token comment">// 如果i = 0, 左边高位不能全为0(视频中xxx = 001 ~ abc - 1)，并且&amp;&amp;l表示这时i也不能在最高位出现。  </span>
        <span class="token comment">// 计算第j位左边的整数等于l (视频中xxx = abc)的情况  </span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token punctuation">(</span>dj <span class="token operator">&gt;</span> i<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>i <span class="token operator">||</span> l<span class="token punctuation">)</span> <span class="token punctuation">)</span> res <span class="token operator">+=</span> p<span class="token punctuation">;</span>  <span class="token comment">//(i || l)表示i=0时，i不能出现在最高位（即l不能为0），因为这种数是不存在的  </span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token punctuation">(</span>dj <span class="token operator">==</span> i<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>i <span class="token operator">||</span> l<span class="token punctuation">)</span> <span class="token punctuation">)</span> res <span class="token operator">+=</span> r <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">//(i || l)表示i=0时，i不能出现在最高位（即l不能为0），因为这种数是不存在的  </span>
    <span class="token punctuation">}</span>  
    <span class="token keyword">return</span> res<span class="token punctuation">;</span>  
<span class="token punctuation">}</span>  
  
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  
<span class="token punctuation">{</span>  
    <span class="token keyword">int</span> a<span class="token punctuation">,</span> b<span class="token punctuation">;</span>  
    <span class="token keyword">while</span> <span class="token punctuation">(</span>cin <span class="token operator">&gt;&gt;</span> a <span class="token operator">&gt;&gt;</span> b <span class="token punctuation">,</span> a<span class="token punctuation">)</span>  
    <span class="token punctuation">{</span>  
        <span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">&gt;</span> b<span class="token punctuation">)</span> <span class="token function">swap</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>  
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">9</span><span class="token punctuation">;</span> <span class="token operator">++</span> i<span class="token punctuation">)</span> cout <span class="token operator">&lt;&lt;</span> <span class="token function">cnt</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> i<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token function">cnt</span><span class="token punctuation">(</span>a <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token char">' '</span><span class="token punctuation">;</span>  
        cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>  
    <span class="token punctuation">}</span>  
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="数位DP-重要"><a href="#数位DP-重要" class="headerlink" title="数位DP(重要)"></a>数位DP(重要)</h1><p>DP时间复杂度：状态个数*转移个数</p>
<p>相当于往空里填数字</p>
<p><strong>知识点1：</strong>mask集合</p>
<blockquote>
<p>集合和数字的替换，使用二进制转化集合来实现某些数字不选择</p>
<p>例： 10011 从高到低依次代表者 4 3 2 1 0 这几个数字选不选，1表示选择，那么，</p>
<p>集合mask &gt;&gt; d &amp; 1 d为这个数字，进行这样的运算就可以判断mask 对应的d数字这个位置上是1还是0</p>
<p>同理 mask|(1&lt;&lt;d) 将1移位到mask上 代表d这个数字的位置，进行或运算，即可将d加入集合中</p>
</blockquote>
<h2 id="模板：-1"><a href="#模板：-1" class="headerlink" title="模板："></a>模板：</h2><p>将问题转化为填数字受限问题：</p>
<blockquote>
<p>递归中的变量：</p>
<p>i 当前下标 当 i == 最大长度时，根据是否满足条件返回 0 或 1</p>
<p>mask 集合 代表着一种状态的记录，比如某位填了哪些数字，或者截止到上一位已经积累的某个要求满足条件的数据是多少，这个一般是变化的</p>
<p>is_limit 前一个位置是否收到原来的数字的限制：123 第一个填1 了后面一定受限，同时如果前面受限了，那么后面所有的都受限</p>
<p>is_num 前一个位置是否填数字，如果前一个没填数字，那么这一位无法填0了，如果填了可以填任意数字，当0对题目没影响时，可以不用这个东西</p>
</blockquote>
<p><strong>模板公式：</strong></p>
<ol>
<li><p>求出最大长度和memo，记忆数组，并初始化为-1 memo数组的一维是长度，二维是能包含所有枚举的最大长度，具体问题具体分析</p>
</li>
<li><p>递归函数</p>
<ul>
<li><p>结束递归条件<code>i == m 返回是否满足 满足为1 满足为0</code></p>
</li>
<li><p>记忆化剪枝：当is_limit 和 is_num 只有一个为真时，后面的数字也是可以任意填的，所以可以剪枝</p>
</li>
<li><p><code>!is_limit &amp;&amp; is_num &amp;&amp; memo[i][mask] != -1 return memo[i][mask]</code></p>
</li>
<li><p>设出res = 0 即为我们要求的答案</p>
</li>
<li><p>(可能不存在这种情况)这一位不填数字：<code>res = (i+1 , mask不改变, false , false)</code></p>
</li>
<li><p>求出这一位数字可以填写的上下界：根据is_limit来求 <code>up = is_limit ? s[i] - '0' : 9</code></p>
</li>
<li><p>枚举这一位数字，进行递归 (条件判断不一定需要)</p>
</li>
<li><p><code>for (int d = 初始 ; d &lt;= up ; d++) if(当前这个数字没使用) 把这个数字加入mask</code></p>
</li>
<li><p>循环内：<code>res = (i+1 , mask 的改变 , is_limit &amp;&amp; d == up , is_num的变化)</code></p>
</li>
<li><p>当is_limit 和 is_num 只有一个为真时将答案加入memo中 <code>if(!is_limit &amp;&amp; is_num) memo[i][mask] = res</code></p>
</li>
<li><p>返回res</p>
</li>
</ul>
</li>
</ol>
<p><strong>例题：</strong></p>
<ol>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/numbers-with-repeated-digits/description/">1012. 至少有 1 位重复的数字 - 力扣（Leetcode）</a></li>
</ol>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>  
<span class="token keyword">public</span><span class="token operator">:</span>  
    <span class="token keyword">int</span> <span class="token function">numDupDigitsAtMostN</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>  
        <span class="token comment">//将n转化为字符串，方便枚举每一位置上的数字  </span>
        <span class="token keyword">auto</span> s <span class="token operator">=</span><span class="token function">to_string</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//使用auto 防止爆int  </span>
        <span class="token comment">//记忆化数组，当dp到相同的情况时直接可以使用以前的的出来的  </span>
        <span class="token comment">//第一维为长度  </span>
        <span class="token comment">//第二位代表可以选择的数字有哪些  </span>
        <span class="token comment">//这题从高到低每一位代表着 9876543210 所以需要移动到第11位，才能出现10个数字都选择的情况  </span>
        <span class="token keyword">int</span> m <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>memo<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  
        <span class="token function">memset</span><span class="token punctuation">(</span>memo<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token punctuation">,</span><span class="token keyword">sizeof</span> memo<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//-1表示没有计算过这种情况  </span>
        <span class="token comment">//递归函数  </span>
        function<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span><span class="token keyword">int</span><span class="token punctuation">,</span><span class="token keyword">bool</span><span class="token punctuation">,</span><span class="token keyword">bool</span><span class="token punctuation">)</span><span class="token operator">&gt;</span> f <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token punctuation">,</span><span class="token keyword">int</span> mask<span class="token punctuation">,</span> <span class="token keyword">bool</span> is_limit <span class="token punctuation">,</span> <span class="token keyword">bool</span> is_num<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token keyword">int</span> <span class="token punctuation">{</span>  
            <span class="token comment">//i 下标  </span>
            <span class="token comment">//mask 是记录当前已经选择数字的集合  </span>
            <span class="token comment">//is_limit 代表当前位置是否受到n这个数字的制约，比如不能超过某个数字  </span>
            <span class="token comment">//is_num 代表前一位是否填数字了，这个是用来判断0是否可填的，如果0可不可填都无所谓就可以不使用这个了  </span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> m<span class="token punctuation">)</span> <span class="token comment">//如果dp到了最后一个位置了，要返回是否得到合法数字了  </span>
                 <span class="token keyword">return</span> is_num<span class="token punctuation">;</span><span class="token comment">//合法数字一定为true，因为长度到了前一个一定要填数字的  </span>
            <span class="token comment">//如果没收到限制或者没收到前一个的填数字的限制，后面可以任意填了，所以必定会有很小重复性的，所以可以直接返回  </span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>is_limit <span class="token operator">&amp;&amp;</span> is_num <span class="token operator">&amp;&amp;</span>memo<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>mask<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> memo<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>mask<span class="token punctuation">]</span><span class="token punctuation">;</span>  
            <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>is_num<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//前一个数字没填，这个数字当然也可以不填  </span>
                res <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span> <span class="token punctuation">,</span> mask <span class="token punctuation">,</span> <span class="token boolean">false</span> <span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
                <span class="token comment">//继续递归  </span>
            <span class="token punctuation">}</span>  
            <span class="token comment">//如果当前数字没收到限制，那么当然可以继续任意填  </span>
            <span class="token comment">//如果收到限制了，那么最多只能填当前这一位置上的数字  </span>
            <span class="token keyword">int</span> up <span class="token operator">=</span> is_limit <span class="token operator">?</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token char">'0'</span> <span class="token operator">:</span> <span class="token number">9</span><span class="token punctuation">;</span>  
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> d <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">-</span> is_num <span class="token punctuation">;</span> d <span class="token operator">&lt;=</span> up <span class="token punctuation">;</span> <span class="token operator">++</span>d<span class="token punctuation">)</span>  
                <span class="token comment">//枚举可以填入的数据，前一位没填数字 ，那么这一位只能从1开始，否则可以从0开始，那么可以填0，如果没被限制，那么要小心是否是第一位了，所以从1开始  </span>
                <span class="token comment">//当d == up 时，  </span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>mask <span class="token operator">&gt;&gt;</span> d <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">// d 不在 mask 中  </span>
                <span class="token comment">//d != up 时，所有的后面的位置都不会受限  </span>
                <span class="token comment">//d == up 时，如果前一位已经受限了，那么后面还会接着受限  </span>
                    res <span class="token operator">+=</span> <span class="token function">f</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> mask <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> d<span class="token punctuation">)</span><span class="token punctuation">,</span> is_limit <span class="token operator">&amp;&amp;</span> d <span class="token operator">==</span> up<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     
              
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>is_limit <span class="token operator">&amp;&amp;</span> is_num<span class="token punctuation">)</span>  
            <span class="token comment">//如果没收到限制或者没收到前一个的填数字的限制，后面可以任意填了  </span>
                memo<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>mask<span class="token punctuation">]</span> <span class="token operator">=</span> res<span class="token punctuation">;</span>  
            <span class="token keyword">return</span> res<span class="token punctuation">;</span>  
        <span class="token punctuation">}</span><span class="token punctuation">;</span>  
        <span class="token keyword">return</span> n <span class="token operator">-</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token number">0</span> <span class="token punctuation">,</span> <span class="token number">0</span> <span class="token punctuation">,</span> <span class="token boolean">true</span> <span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//第一个数字肯定受限了  </span>
    <span class="token punctuation">}</span>  
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token number">2.</span> <span class="token punctuation">[</span><span class="token number">6396.</span> 统计整数数目 <span class="token operator">-</span> 力扣（Leetcode）<span class="token punctuation">]</span><span class="token punctuation">(</span>https<span class="token operator">:</span><span class="token comment">//leetcode.cn/problems/count-of-integers/description/) 一种变形，好好理解</span>
    <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>  
    <span class="token keyword">public</span><span class="token operator">:</span>  
        <span class="token keyword">const</span> <span class="token keyword">int</span> mod <span class="token operator">=</span> <span class="token number">1e9</span> <span class="token operator">+</span> <span class="token number">7</span><span class="token punctuation">;</span>  
        <span class="token keyword">int</span> <span class="token function">cmp</span><span class="token punctuation">(</span>string s <span class="token punctuation">,</span> <span class="token keyword">int</span> min_sum <span class="token punctuation">,</span> <span class="token keyword">int</span> max_sum<span class="token punctuation">)</span><span class="token punctuation">{</span>  
            <span class="token comment">//memo数组最大有 n个9 或者是被迫的这个最大数字 记得 + 1  </span>
            <span class="token keyword">int</span> n <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">,</span> memo<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token function">min</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token operator">*</span>n<span class="token punctuation">,</span>max_sum<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  
            <span class="token function">memset</span><span class="token punctuation">(</span>memo <span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token punctuation">,</span> <span class="token keyword">sizeof</span> memo<span class="token punctuation">)</span><span class="token punctuation">;</span>  
            <span class="token comment">//因为0无影响，所以is_num可以不要了  </span>
            <span class="token comment">//sum 就是mask  </span>
            function <span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token punctuation">,</span><span class="token keyword">int</span> <span class="token punctuation">,</span><span class="token keyword">bool</span><span class="token punctuation">)</span><span class="token operator">&gt;</span> f <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token punctuation">,</span> <span class="token keyword">int</span> sum <span class="token punctuation">,</span> <span class="token keyword">bool</span> is_limit<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token keyword">int</span> <span class="token punctuation">{</span>  
            <span class="token comment">//1.非法情况  </span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>sum <span class="token operator">&gt;</span> max_sum<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//结束递归，sum是一直增加的，后面无法减小的  </span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> n<span class="token punctuation">)</span> <span class="token keyword">return</span> sum <span class="token operator">&gt;=</span> min_sum<span class="token punctuation">;</span><span class="token comment">//结束递归的时候如果数字合法且满足  </span>
            <span class="token comment">//少了一个is_num,只要后面不受限制，那么，后面一定重复  </span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>is_limit <span class="token operator">&amp;&amp;</span> memo<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>sum<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> memo<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>sum<span class="token punctuation">]</span><span class="token punctuation">;</span>  
            <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span> <span class="token comment">//计算所要的答案，也就是计数  </span>
            <span class="token keyword">int</span> up <span class="token operator">=</span> is_limit <span class="token operator">?</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token char">'0'</span> <span class="token operator">:</span> <span class="token number">9</span><span class="token punctuation">;</span><span class="token comment">//上界  </span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> d <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span> d <span class="token operator">&lt;=</span> up <span class="token punctuation">;</span> d<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//枚举位置上的数字  </span>
                <span class="token comment">//d == up的时候，如果前面受限了，后面继续受限，如果前面没受限，那么后面也不受限  </span>
                res <span class="token operator">=</span> <span class="token punctuation">(</span>res <span class="token operator">+</span> <span class="token function">f</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span> <span class="token punctuation">,</span> sum <span class="token operator">+</span> d  <span class="token punctuation">,</span> is_limit <span class="token operator">&amp;&amp;</span> d <span class="token operator">==</span> up<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">%</span> mod<span class="token punctuation">;</span>  
            <span class="token punctuation">}</span>  
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>is_limit<span class="token punctuation">)</span> memo<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>sum<span class="token punctuation">]</span> <span class="token operator">=</span> res <span class="token punctuation">;</span>  <span class="token comment">//与上面保持一致  </span>
            <span class="token keyword">return</span> res <span class="token punctuation">;</span><span class="token comment">//返回答案  </span>
            <span class="token punctuation">}</span><span class="token punctuation">;</span>  
            <span class="token keyword">return</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token number">0</span> <span class="token punctuation">,</span> <span class="token number">0</span> <span class="token punctuation">,</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//初始状态下，一定受限  </span>
        <span class="token punctuation">}</span>  
        <span class="token keyword">int</span> <span class="token function">count</span><span class="token punctuation">(</span>string num1<span class="token punctuation">,</span> string num2<span class="token punctuation">,</span> <span class="token keyword">int</span> min_sum<span class="token punctuation">,</span> <span class="token keyword">int</span> max_sum<span class="token punctuation">)</span> <span class="token punctuation">{</span>  
            <span class="token comment">//转化：  </span>
            <span class="token comment">/*  
                计算 &lt;= num2 的合法数字a和 &lt;= num2 的合法数字b 答案就等于 a - b  
                可以直接计算 &lt;= num1 的合法数字，最后单独判定 num1是否合法  
                套模板： mask 在这里指的是各位数字之和  
                递归结束条件：  
                sum &gt; max_sum 直接返回0 ，不成立，因为sum不能减小，所以继续递归下去也没有用  
                递归到就结束的时候，如果 sum &gt;= min_sum 那么就是满足的，可以直接返回1了  
                前导零对和没有影响，所以isnum可以不用  
                最后：取模运算  
                (a+b)mod m = ((a mod m) + (b mod m )) mod m  
                (a*b)mode m = ((a mod m) * (b mod m )) mod m  
            */</span>  
            <span class="token keyword">int</span> ans <span class="token operator">=</span> <span class="token function">cmp</span><span class="token punctuation">(</span>num2 <span class="token punctuation">,</span> min_sum <span class="token punctuation">,</span>max_sum<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token function">cmp</span><span class="token punctuation">(</span>num1 <span class="token punctuation">,</span> min_sum <span class="token punctuation">,</span>max_sum<span class="token punctuation">)</span><span class="token punctuation">;</span>  
            <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  
            <span class="token comment">//最后一个num1单独判断，因为上面计算的是 num1 &lt; x &lt;= num2的，和前缀和一样  </span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> c <span class="token operator">:</span> num1<span class="token punctuation">)</span> sum <span class="token operator">+=</span> c <span class="token operator">-</span> <span class="token char">'0'</span><span class="token punctuation">;</span>  
            ans <span class="token operator">+=</span> min_sum <span class="token operator">&lt;=</span> sum <span class="token operator">&amp;&amp;</span> sum <span class="token operator">&lt;=</span> max_sum <span class="token punctuation">;</span>  
            <span class="token keyword">return</span> ans <span class="token operator">%</span> mod<span class="token punctuation">;</span>  
        <span class="token punctuation">}</span>  
    <span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="状压DP-状态压缩-动态规划-利用二进制把状态记录成二进制数"><a href="#状压DP-状态压缩-动态规划-利用二进制把状态记录成二进制数" class="headerlink" title="状压DP 状态压缩+动态规划 利用二进制把状态记录成二进制数"></a>状压DP 状态压缩+动态规划 利用二进制把状态记录成二进制数</h2><p>291 91</p>
<pre class="line-numbers language-css" data-language="css"><code class="language-css"><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="树形DP-各层选择取最大值"><a href="#树形DP-各层选择取最大值" class="headerlink" title="树形DP 各层选择取最大值"></a>树形DP 各层选择取最大值</h2><p>将状态分为当前节点选择和不选择</p>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/287/">285. 没有上司的舞会 - AcWing题库</a></p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;bits/stdc++.h&gt;</span>  </span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>  
<span class="token keyword">const</span> <span class="token keyword">int</span> N <span class="token operator">=</span> <span class="token number">6010</span><span class="token punctuation">;</span>  
<span class="token keyword">int</span> happy<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>  
<span class="token keyword">int</span> n<span class="token punctuation">;</span>  
<span class="token keyword">int</span> e<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token comment">/*e存的是编号1*/</span> <span class="token punctuation">,</span> ne<span class="token punctuation">[</span>N<span class="token punctuation">]</span> <span class="token punctuation">,</span> idx <span class="token punctuation">,</span>h<span class="token punctuation">[</span>N<span class="token punctuation">]</span> <span class="token punctuation">,</span> dp<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>  
<span class="token keyword">bool</span> fa<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>  
<span class="token comment">/*  
    状态定义：dp[i][1] dp[i][0] 当前节点选不选  
    状态转移 ： dp[i][0] = sum(子树)   子树有可以分为选与不选  取最大值  
                dp[i][1] = sum(下一层子树不选)    
    属性： 最大值  
   
*/</span>  
<span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  
    idx <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  
    <span class="token function">memset</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token punctuation">,</span> <span class="token keyword">sizeof</span> h<span class="token punctuation">)</span><span class="token punctuation">;</span>  
<span class="token punctuation">}</span>  
<span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">{</span>  
    e<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> b<span class="token punctuation">;</span>  
    ne<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> h<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">;</span>  
    h<span class="token punctuation">[</span>a<span class="token punctuation">]</span> <span class="token operator">=</span> idx<span class="token operator">++</span><span class="token punctuation">;</span>  
<span class="token punctuation">}</span>  
<span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span> u<span class="token punctuation">)</span><span class="token punctuation">{</span>  
        <span class="token comment">//如果当前的节点要选择的话，要初始化数据  </span>
        dp<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> happy<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">;</span>  
        <span class="token comment">//遍历u的子树  </span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> h<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token punctuation">;</span> i <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token punctuation">;</span> i <span class="token operator">=</span> ne<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  
            <span class="token keyword">int</span> j <span class="token operator">=</span> e<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>  
            <span class="token comment">//递归到最低层，实现一层层的求和  </span>
            <span class="token function">dfs</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>  
            <span class="token comment">//当前不选，则是子树的最大值  </span>
            dp<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token punctuation">,</span> dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
            <span class="token comment">//当前选择，那么就是下一层子树不选  </span>
            dp<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+=</span> dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  
        <span class="token punctuation">}</span>  
<span class="token punctuation">}</span>  
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  
    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span> <span class="token punctuation">,</span><span class="token operator">&amp;</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  
        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>happy<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token punctuation">}</span>  
    <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token operator">-</span><span class="token number">1</span> <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  
        <span class="token keyword">int</span> a <span class="token punctuation">,</span> b <span class="token punctuation">;</span>  
        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d%d"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>a<span class="token punctuation">,</span><span class="token operator">&amp;</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>  
        fa<span class="token punctuation">[</span>a<span class="token punctuation">]</span> <span class="token operator">=</span><span class="token boolean">true</span><span class="token punctuation">;</span>  
        <span class="token function">add</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token punctuation">}</span>  
    <span class="token keyword">int</span> root <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  
    <span class="token keyword">while</span><span class="token punctuation">(</span>fa<span class="token punctuation">[</span>root<span class="token punctuation">]</span><span class="token punctuation">)</span> root<span class="token operator">++</span><span class="token punctuation">;</span>  
    <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span><span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>root<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>dp<span class="token punctuation">[</span>root<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="状态机："><a href="#状态机：" class="headerlink" title="状态机："></a>状态机：</h2><blockquote>
<p>通过表示出状态的转换方式即可自动得到答案</p>
</blockquote>
<h2 id="DP行-x2F-列问题"><a href="#DP行-x2F-列问题" class="headerlink" title="DP行/列问题"></a>DP行/列问题</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-strictly-increasing-cells-in-a-matrix/">6456. 矩阵中严格递增的单元格数 - 力扣（Leetcode）</a></p>
<h3 id="例题：股票买卖问题"><a href="#例题：股票买卖问题" class="headerlink" title="例题：股票买卖问题"></a>例题：股票买卖问题</h3><p><strong>含有冷却时间需要用四个状态，正常两个即可，具体问题具体分析</strong></p>
<ol>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/description/">714. 买卖股票的最佳时机含手续费 - 力扣（Leetcode）</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/solutions/2283535/zhuang-tai-ji-dp-by-hardcore-dubinsky348-1qew/">309. 最佳买卖股票时机含冷冻期 - 力扣（Leetcode）</a></p>
</li>
</ol>
<h2 id="通过stoi-和隔板法实现枚举每一个数字的任意子子串"><a href="#通过stoi-和隔板法实现枚举每一个数字的任意子子串" class="headerlink" title="通过stoi 和隔板法实现枚举每一个数字的任意子子串"></a>通过stoi 和隔板法实现枚举每一个数字的任意子子串</h2><p>stoi substr to_string 的妙用</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-the-punishment-number-of-an-integer/">6441. 求一个整数的惩罚数 - 力扣（LeetCode）</a></p>
<h2 id="子列和-x2F-字串问题："><a href="#子列和-x2F-字串问题：" class="headerlink" title="子列和/字串问题："></a>子列和/字串问题：</h2><ol>
<li><p>求任意子列的乘积最大 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-strength-of-a-group/">6393. 一个小组的最大实力值 - 力扣（Leetcode）</a></p>
</li>
<li><p>一个字符串匹配另一个字典求最大匹配长度问题：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/extra-characters-in-a-string/">6394. 字符串中的额外字符 - 力扣（Leetcode）</a></p>
</li>
<li><p>反转01得到相等字符串问题：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-cost-to-make-all-characters-equal/">6455. 使所有字符相等的最小成本 - 力扣（Leetcode）</a></p>
</li>
</ol>
<h1 id="暴力枚举法"><a href="#暴力枚举法" class="headerlink" title="暴力枚举法"></a>暴力枚举法</h1><p>使用于组合的数量少，但是需要找到最合适的组合的题目<br>例题<br><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-moves-to-spread-stones-over-grid/submissions/">3*3</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">QingQiu</p>
  <div class="site-description" itemprop="description">个人网站，学习记录，面试记录和经验总结、互联网中一块属于自己的小窝</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">43</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">QingQiu</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">NaNm</span>
</div>
  <div class="powered-by">由 <span class="exturl theme-link" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & <span class="exturl theme-link" data-url="aHR0cHM6Ly90aGVtZS1uZXh0Lm9yZw==">NexT.Gemini</span> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/pangu@4/dist/browser/pangu.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  
  <script>
    (function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();
  </script>




  
<script src="/js/local-search.js"></script>













  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  
  <script src="//cdn.jsdelivr.net/npm/quicklink@1/dist/quicklink.umd.js"></script>
  <script>
      window.addEventListener('load', () => {
      quicklink({
        timeout : 3000,
        priority: true,
        ignores : [uri => uri.includes('#'),uri => uri === 'https://zuofw.github.io/page/3/',]
      });
      });
  </script>

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"react":{"opacity":0.7}});</script></body>
</html>
