<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"zuofw.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="个人网站，学习记录，面试记录和经验总结、互联网中一块属于自己的小窝">
<meta property="og:type" content="website">
<meta property="og:title" content="QingQiu&#39;Blog">
<meta property="og:url" content="https://zuofw.github.io/page/3/index.html">
<meta property="og:site_name" content="QingQiu&#39;Blog">
<meta property="og:description" content="个人网站，学习记录，面试记录和经验总结、互联网中一块属于自己的小窝">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="QingQiu">
<meta property="article:tag" content="博客，学习，成长">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://zuofw.github.io/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>QingQiu'Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>


<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">QingQiu'Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">清秋的博客</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-fa fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-fa fa-archive"></i>归档</a>

  </li>
        <li class="menu-item menu-item-github">

    <a href="https://github.com/Zuofw" rel="noopener" target="_blank"><i class="fa fa-fw fa-fab fa-github"></i>Github</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zuofw.github.io/2024/05/23/22/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="QingQiu">
      <meta itemprop="description" content="个人网站，学习记录，面试记录和经验总结、互联网中一块属于自己的小窝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="QingQiu'Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/23/22/" class="post-title-link" itemprop="url">运维</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-05-23 08:52:22" itemprop="dateCreated datePublished" datetime="2024-05-23T08:52:22+08:00">2024-05-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-05-24 13:29:55" itemprop="dateModified" datetime="2024-05-24T13:29:55+08:00">2024-05-24</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.1k</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Docker-Compose"><a href="#Docker-Compose" class="headerlink" title="Docker Compose"></a>Docker Compose</h2><p>编写docker-compose.yml脚本，配合dockerfile和sh脚本进行搭建</p>
<ul>
<li>示例一：搭建一主二从三哨兵的redis集群 ^220b94<pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token property">version</span><span class="token punctuation">:</span> <span class="token string">'3'</span> #dockercompose版本
<span class="token property">services</span><span class="token punctuation">:</span> #定义应用的的服务，每个服务运行一个镜像
  <span class="token property">redis-master</span><span class="token punctuation">:</span> #服务名称
    <span class="token property">image</span><span class="token punctuation">:</span> <span class="token property">redis</span><span class="token punctuation">:</span>latest #镜像
    <span class="token property">command</span><span class="token punctuation">:</span> redis-server --appendonly yes --requirepass bronya #启动容器时要执行命令
    <span class="token property">volumes</span><span class="token punctuation">:</span> #挂载数据卷，不存在的目录会自动创建
      - ./data/<span class="token property">master</span><span class="token punctuation">:</span>/data
    <span class="token property">ports</span><span class="token punctuation">:</span> #定义端口映射
      - <span class="token string">"6379:6379"</span>

  <span class="token property">redis-slave1</span><span class="token punctuation">:</span>
    <span class="token property">image</span><span class="token punctuation">:</span> <span class="token property">redis</span><span class="token punctuation">:</span>latest
    <span class="token property">command</span><span class="token punctuation">:</span> redis-server --slaveof redis-master 6379 --appendonly yes
    <span class="token property">depends_on</span><span class="token punctuation">:</span>
      - redis-master
    <span class="token property">volumes</span><span class="token punctuation">:</span>
      - ./data/<span class="token property">slave1</span><span class="token punctuation">:</span>/data

  <span class="token property">redis-slave2</span><span class="token punctuation">:</span>
    <span class="token property">image</span><span class="token punctuation">:</span> <span class="token property">redis</span><span class="token punctuation">:</span>latest
    <span class="token property">command</span><span class="token punctuation">:</span> redis-server --slaveof redis-master 6379 --appendonly yes
    <span class="token property">depends_on</span><span class="token punctuation">:</span>
      - redis-master
    <span class="token property">volumes</span><span class="token punctuation">:</span>
      - ./data/<span class="token property">slave2</span><span class="token punctuation">:</span>/data

  <span class="token property">redis-sentinel1</span><span class="token punctuation">:</span>
    <span class="token property">image</span><span class="token punctuation">:</span> <span class="token property">redis</span><span class="token punctuation">:</span>latest
    <span class="token property">command</span><span class="token punctuation">:</span> redis-sentinel /etc/redis/sentinel.conf
    <span class="token property">depends_on</span><span class="token punctuation">:</span>
      - redis-master
    <span class="token property">volumes</span><span class="token punctuation">:</span>
      - ./sentinel1.<span class="token property">conf</span><span class="token punctuation">:</span>/etc/redis/sentinel.conf

  <span class="token property">redis-sentinel2</span><span class="token punctuation">:</span>
    <span class="token property">image</span><span class="token punctuation">:</span> <span class="token property">redis</span><span class="token punctuation">:</span>latest
    <span class="token property">command</span><span class="token punctuation">:</span> redis-sentinel /etc/redis/sentinel.conf
    <span class="token property">depends_on</span><span class="token punctuation">:</span>
      - redis-master
    <span class="token property">volumes</span><span class="token punctuation">:</span>
      - ./sentinel2.<span class="token property">conf</span><span class="token punctuation">:</span>/etc/redis/sentinel.conf

  <span class="token property">redis-sentinel3</span><span class="token punctuation">:</span>
    <span class="token property">image</span><span class="token punctuation">:</span> <span class="token property">redis</span><span class="token punctuation">:</span>latest
    <span class="token property">command</span><span class="token punctuation">:</span> redis-sentinel /etc/redis/sentinel.conf
    <span class="token property">depends_on</span><span class="token punctuation">:</span>
      - redis-master
    <span class="token property">volumes</span><span class="token punctuation">:</span>
      - ./sentinel3.<span class="token property">conf</span><span class="token punctuation">:</span>/etc/redis/sentinel.conf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span>
<span class="token function">docker-compose</span> up <span class="token parameter variable">--build</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li>
<li>示例二：基于dockerfile<pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token property">version</span><span class="token punctuation">:</span> <span class="token string">'3'</span>
<span class="token property">services</span><span class="token punctuation">:</span>
  <span class="token property">app</span><span class="token punctuation">:</span>
    <span class="token property">build</span><span class="token punctuation">:</span> 
      <span class="token property">context</span><span class="token punctuation">:</span> .
      <span class="token property">dockerfile</span><span class="token punctuation">:</span> Dockerfile
    <span class="token property">ports</span><span class="token punctuation">:</span>
      - <span class="token string">"8080:8080"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
Dockerfile文件<pre class="line-numbers language-css" data-language="css"><code class="language-css"># 使用官方的java镜像作为基础镜像
FROM <span class="token property">openjdk</span><span class="token punctuation">:</span>8-jdk-alpine

# 设置工作目录
WORKDIR /app

# 将本地的jar包复制到Docker镜像中
COPY ./your-app.jar /app

# 设置启动命令
ENTRYPOINT [<span class="token string">"java"</span><span class="token punctuation">,</span> <span class="token string">"-jar"</span><span class="token punctuation">,</span> <span class="token string">"/app/your-app.jar"</span>]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
<h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><h3 id="常见命令"><a href="#常见命令" class="headerlink" title="常见命令"></a>常见命令</h3><ul>
<li>之间的关系：<br><img src="/2024/05/23/22/docker%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4%E7%9A%84%E5%85%B3%E7%B3%BB.png" alt="常见命令与他们之间的关系"></li>
<li>使用format对ps的结果进行格式化，更容易观察<pre class="line-numbers language-css" data-language="css"><code class="language-css">docker ps -a --format <span class="token selector">"table</span> <span class="token punctuation">{</span><span class="token punctuation">{</span>.ID<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token selector">\t</span><span class="token punctuation">{</span><span class="token punctuation">{</span>.Image<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token selector">\t</span><span class="token punctuation">{</span><span class="token punctuation">{</span>.Ports<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token selector">\t</span><span class="token punctuation">{</span><span class="token punctuation">{</span>.Status<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token selector">\t</span><span class="token punctuation">{</span><span class="token punctuation">{</span>.Names<span class="token punctuation">}</span><span class="token punctuation">}</span>"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
<li>可以通过编辑/root/.bashrc文件去给常用的命令起别名<pre class="line-numbers language-css" data-language="css"><code class="language-css"># 修改/root/.bashrc文件
vi /root/.bashrc
内容如下：
# .bashrc

# User specific aliases and functions

alias rm=<span class="token string">'rm -i'</span>
alias cp=<span class="token string">'cp -i'</span>
alias mv=<span class="token string">'mv -i'</span>
alias dps=<span class="token string">'docker ps --format "table {{.ID}}\t{{.Image}}\t{{.Ports}}\t{{.Status}}\t{{.Names}}"'</span>
alias dis=<span class="token string">'docker images'</span>

# Source global definitions
if [ -f /etc/bashrc ]<span class="token punctuation">;</span> then
        . /etc/bashrc
fi<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><h2 id="网络问题：-容器的ip是一个虚拟ip，其值并不与容器绑定-可以使用docker的网络功能实现容器的互联"><a href="#网络问题：-容器的ip是一个虚拟ip，其值并不与容器绑定-可以使用docker的网络功能实现容器的互联" class="headerlink" title="网络问题：  - 容器的ip是一个虚拟ip，其值并不与容器绑定  - 可以使用docker的网络功能实现容器的互联"></a>网络问题：<br>  - 容器的ip是一个虚拟ip，其值并不与容器绑定<br>  - 可以使用docker的网络功能实现容器的互联</h2></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zuofw.github.io/2024/05/16/42/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="QingQiu">
      <meta itemprop="description" content="个人网站，学习记录，面试记录和经验总结、互联网中一块属于自己的小窝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="QingQiu'Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/16/42/" class="post-title-link" itemprop="url">Java新特性</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-05-16 10:11:42 / 修改时间：16:09:30" itemprop="dateCreated datePublished" datetime="2024-05-16T10:11:42+08:00">2024-05-16</time>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.5k</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Java新特性面试"><a href="#Java新特性面试" class="headerlink" title="Java新特性面试"></a>Java新特性面试</h1><h2 id="Java8"><a href="#Java8" class="headerlink" title="Java8"></a>Java8</h2><ul>
<li>接口：interface 中可以有默认方法，无需被子类实现，通过Interface实现调用</li>
<li><strong>“函数式接口”是指仅仅只包含一个抽象方法,但是可以有多个非抽象方法(也就是上面提到的默认方法)的接口。</strong><ol>
<li>default实现,可以被子类继承重写，使用this调用</li>
<li>static实现使用方法和静态方法一样，但是不能被子类继承</li>
<li>interface和abstract class的区别：interface是为了快速扩展功能，而abstract class是为了被继承实现的。<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token keyword">implements</span> <span class="token class-name">InterfaceNew</span><span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">InterfaceNew</span><span class="token punctuation">.</span><span class="token function">sm</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//调用df方法</span>
        <span class="token class-name">Main</span> main <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        main<span class="token punctuation">.</span><span class="token function">df</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">/**
 * InnerMain
 */</span>
<span class="token keyword">interface</span> <span class="token class-name">InterfaceNew</span> <span class="token punctuation">{</span>
    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sm</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"interface中的sm实现"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
    <span class="token keyword">default</span> <span class="token keyword">void</span>  <span class="token function">df</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"interface提供的df实现"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ol>
</li>
<li>Lambda</li>
<li>Stream：不存储数据，只是对数据进行一系列的处理<ul>
<li>串行流：<ul>
<li>.stream() 为集合创建串行流</li>
</ul>
</li>
<li>并行流：可以多线程执行<ul>
<li>parallelStream()获得并行流</li>
</ul>
</li>
<li>API：<ul>
<li>forEach() 迭代每个数据</li>
<li>map()传入函数作为变量，对每个数据进行映射(处理)</li>
<li>limit() 获取指定数量的流</li>
<li>sorted() 对流进行排序</li>
<li>Collectors 提供很多归约操作，可以讲将流转化为集合或者聚合元素，要配合collect()来实现</li>
<li>count()返回流的的数据</li>
<li>distinct() 返回一个去除重复元素的流</li>
<li>anyMathch() 检查是否有满足条件的元素，返回值为boolean</li>
<li>allMatch() 检查是否所有元素都满足匹配的条件</li>
<li>noneMathc()都不符合匹配条件</li>
<li>findFirst() 返回流中的第一个元素</li>
<li>findAny()返回流中的任意元素，这个任意元素只有在多线程中可以看出不同，他会任何线程中选择一个元素返回</li>
<li>reduce() 将流中元素合并成一个元素 <code>numbers.stream().reduce((n1, n2) -&gt; n1 + n2);</code></li>
<li>filter()过滤</li>
</ul>
</li>
</ul>
</li>
<li>Optional：用于避免空指针<ul>
<li>Optional .ofNullable()返回一个包含指定值Optional对象，如果值为null，则返回一个空的Optional对象</li>
<li>isPresent() Optional不为空，返回true</li>
<li>get()返回值</li>
<li>ifPresent() 如果不为空，可以以调用指定的方法</li>
<li>orElse(默认值) 如果为空返回这个默认值 </li>
<li>orElseGet() 如果为空调用指定的函数</li>
<li>filter() 过滤，如果不满足，返回一个空的Optional</li>
<li>map() 如果对象是Optional，那么就执行给定的函数</li>
<li>flatMap()将Optional展开，不再包装成嵌套的Optional</li>
</ul>
</li>
</ul>
<h2 id="Java9"><a href="#Java9" class="headerlink" title="Java9"></a>Java9</h2><ul>
<li>JShell 类似于python实时命令行交互工具</li>
<li>G1成为默认的垃圾回收器</li>
<li>String使用byte[ ]作为底层，节省空间</li>
</ul>
<h2 id="Java10"><a href="#Java10" class="headerlink" title="Java10"></a>Java10</h2><ul>
<li>var关键字局部变量 ，主要作用是，当类型特别长时，可以使用var替代</li>
<li>Optional增加了orElseThrow来在没有值时抛出指定的异常</li>
</ul>
<h2 id="Java17"><a href="#Java17" class="headerlink" title="Java17"></a>Java17</h2><p>- </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zuofw.github.io/2024/05/13/08/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="QingQiu">
      <meta itemprop="description" content="个人网站，学习记录，面试记录和经验总结、互联网中一块属于自己的小窝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="QingQiu'Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/13/08/" class="post-title-link" itemprop="url">多线程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-05-13 18:05:08" itemprop="dateCreated datePublished" datetime="2024-05-13T18:05:08+08:00">2024-05-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-09-29 15:55:52" itemprop="dateModified" datetime="2024-09-29T15:55:52+08:00">2024-09-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B9%B6%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">并发</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>8.6k</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><p>#todo </p>
<ul>
<li><input disabled="" type="checkbox"> <a target="_blank" rel="noopener" href="https://www.yuque.com/tulingzhouyu/db22bv/gd98aqe6nn6e73qq">金三银四精选面试题系列-徐庶 (yuque.com)</a>专门写一个线程池相关的文章</li>
<li><input disabled="" type="checkbox"> 泛型相关的<a target="_blank" rel="noopener" href="https://www.yuque.com/tulingzhouyu/db22bv/avpxs3qirk1w4qod">👍 2024金三银四100道面试题笔记资料 (yuque.com)</a></li>
</ul>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ol>
<li>CAS (Compare-And-Swap，比较并交换)，是一种用于实现多线程同步的原子操作。主要原理：1.比较内存中的某个位置的当前值和预期值 2.交换如果当前值与预期值相等，则将该位置的值更新为新值，否则不进行任何操作。<ul>
<li>因为是原子操作所以在多线程中很高效。可以实现无锁编程，避免了上下文切换的开销。</li>
<li>缺点是如果CAS操作失败后，通常会进行自旋，消耗CPU资源。</li>
</ul>
</li>
<li>自旋：当一个线程尝试获取锁但是所以经被其他线程获取时，该线程不会进入睡眠模式，而是会在一个循环中不断的检查锁的状态，直到锁被释放，这种方式叫做自旋。<ul>
<li>优点是：低开销，可以避免线程上下文切换的开销，因为线程不会进入睡眠状态。适用于短时间的锁定，因为时间段，自旋等待的开销可能比线程切换开销更低。</li>
<li>缺点是：CPU消耗搞，自旋不断等待占用CPU，也不适合长时间锁定，因为线程会长时间占用CPU资源进行无效的检查。</li>
</ul>
</li>
<li>并发：一段时间内进行  并行：同一时刻同时进行</li>
</ol>
<h2 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h2><p><img src="/2024/05/13/08/CPU%E6%A6%82%E5%BF%B5.png"></p>
<h3 id="处理器如何实现原子操作的"><a href="#处理器如何实现原子操作的" class="headerlink" title="处理器如何实现原子操作的"></a>处理器如何实现原子操作的</h3><ol>
<li>使用总线锁来保证原子性：如果多个处理器同时对共享变量进行读改写操作(例如i++)，共享会被多个处理器同时进行操作，导致共享变量的值与期望不同。<img src="/2024/05/13/08/i++.png">因为他们会从自己的缓存中读取变量i，然后分别进行+1，之后分别写入系统内存中<ul>
<li>处理器总线锁：使用了处理器提供的LOCK#信号，当一个处理器在总线上发出这个信号，其他处理器的请求将被阻塞住。从而实现独占共享内存。</li>
</ul>
</li>
<li>使用缓存锁：总线锁会导致其他处理器不能处理其他内存地址的数据，我们只需要保证对某个内存地址的操作是原子的就行。<ul>
<li>频繁使用的内存会缓存在处理器的L1、L2、L3高速缓存中。</li>
<li>缓存锁定：缓存锁定是某个CPU对缓存数据进行更改时，会通知缓存了该数据的该数据的CPU抛弃缓存的数据或者从内存重新读取。</li>
</ul>
</li>
</ol>
<h2 id="多线程就一定快吗？"><a href="#多线程就一定快吗？" class="headerlink" title="多线程就一定快吗？"></a>多线程就一定快吗？</h2><p>不一定，因为线程切换涉及到上下文切换和线程创建的开销</p>
<h2 id="如何减少上下文的切换次数"><a href="#如何减少上下文的切换次数" class="headerlink" title="如何减少上下文的切换次数"></a>如何减少上下文的切换次数</h2><ol>
<li>无锁并发编程：避免使用锁，利用将数据的ID按照Hash算法取模运算，不同线程处理不同段的数据</li>
<li>CAS算法：不需要加锁</li>
<li>使用最少线程：避免创建不需要的线程</li>
<li>协程：单线程中实现多任务的调度，并且再单线程中维持多个任务间的切</li>
</ol>
<h2 id="资源限制"><a href="#资源限制" class="headerlink" title="资源限制"></a>资源限制</h2><p>并发编程中，如果多线程占用的资源超过系统资源的限制，实际上仍然是串行执行的，而且因为有上下文切换的影响，反而会更慢</p>
<h2 id="如何避免死锁"><a href="#如何避免死锁" class="headerlink" title="如何避免死锁"></a>如何避免死锁</h2><ol>
<li>避免一个线程同时获得多个锁</li>
<li>避免一个线程在锁内同事占用多个资源，尽量保证每个锁只占用一个资源</li>
<li>尝试使用定时锁 <code>lock.tryLock(timeout)</code>来替代内部锁机制</li>
<li>对于数据库锁，枷锁和解锁必须在一个数据库连接里，否则会出现解锁失败的情况</li>
</ol>
<h2 id="常用的线程分析工具"><a href="#常用的线程分析工具" class="headerlink" title="常用的线程分析工具"></a>常用的线程分析工具</h2><h3 id="vmstat"><a href="#vmstat" class="headerlink" title="vmstat"></a>vmstat</h3><p>常用指令，具体的参数自己去搜，这里主要看的是cs指标，代表每秒上下文切换次数</p>
<pre class="line-numbers language-css" data-language="css"><code class="language-css">vmstat [delay] [count] 后面参数可选
每隔delay秒输出一次统计信息，总共输出count次
vmstat -s 显示系统的累计统计信息
	   -d 显示统计信息
	   -p +指定分区 显示指定分区的统计信息
	   -a 显示活动内存和非活动内存的信息
	   -m 显示slabinfo信息<span class="token punctuation">(</span>`slabinfo` 是 Linux 内核中用于显示 slab 分配器（slab allocator）信息的工具<span class="token punctuation">)</span>
	   -t 在输出中添加时间戳<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="Java中的多线程"><a href="#Java中的多线程" class="headerlink" title="Java中的多线程"></a>Java中的多线程</h2><p>当在一个JVM进程里面开多个线程时，这些线程被分成两类：守护线程和非守护线程。默认开的都是非守护线程。在Java中有一个规定：当所有的非守护线程退出后，整个JVM进程就会退出。意思就是守护线程“不算作数”，守护线程不影响整个 JVM 进程的退出。例如，垃圾回收线程就是守护线程，它们在后台默默工作，当开发者的所有前台线程（非守护线程）都退出之后，整个JVM进程就退出了。</p>
<h2 id="Wait方法为什么不定义在Thread中？"><a href="#Wait方法为什么不定义在Thread中？" class="headerlink" title="Wait方法为什么不定义在Thread中？"></a>Wait方法为什么不定义在Thread中？</h2><p>Wait释放的锁是写在Java对象头中，所以是写在Object中而非当前线程</p>
<h3 id="锁的分类和对比"><a href="#锁的分类和对比" class="headerlink" title="锁的分类和对比"></a>锁的分类和对比</h3><p>Java中锁存在四种状态</p>
<ol>
<li>无锁状态</li>
<li>偏向锁状态</li>
<li>轻量级锁状态</li>
<li>重量级锁状态<br>锁可以升级但是不能降级，这种设定能够提高获得锁和释放锁的效率<br><img src="/2024/05/13/08/%E9%94%81%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9.png"></li>
</ol>
<h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><p>大多数情况下锁不仅不存在多线程竞争，而且总是由同意线程多次获得。<br>当一个线程访问同步块并且获得锁时，会在对象头和栈帧中的锁记录里面存锁偏向的线程ID，以后该线程进入/推出额同步块块时，不需要进行CAS来进行枷锁和解锁，只需要测试对象头Mark Word里是否存储着这项当前线程的偏向锁。<br>如果测试失败就看偏向锁的标识是否为1，1是偏向锁，如果不是就用CAS竞争锁，否则尝试使用CAS将偏向锁设置为当前线程</p>
<h5 id="偏向锁的撤销"><a href="#偏向锁的撤销" class="headerlink" title="偏向锁的撤销"></a>偏向锁的撤销</h5><ol>
<li>偏向锁只有其他线程尝试竞争偏向锁时持有偏向锁的线程才会释放锁。</li>
<li>偏向锁的撤销，需要在全局安全点(在这个事件电商没有正在执行的字节码)，会先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否或者，如果线程处于不活跃状态，则将对象头设置成无锁状态；如果线程仍然存活，则拥有偏向锁的栈会被执行，便利偏向对象的锁记录，要么重新偏向其他线程，要么恢复到无锁或者标记独享不适合作为偏向锁，最后唤醒暂停的线程。</li>
</ol>
<h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><h5 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h5><blockquote>
<p>线程在执行同步块之前，JVM会在当前线程的栈帧中创建用于存储锁记录的空间，并且将对象头中的Mark Word复制到锁记录中(Displaced Mark Word替)。然后线程尝试使用CAS将对象头中的Mark Word替换为只想所记录的指针。如果成功，当前线程获得锁，如果失败，尝试使用自旋来获得锁。</p>
</blockquote>
<h5 id="解锁"><a href="#解锁" class="headerlink" title="解锁"></a>解锁</h5><blockquote>
<p>会使用原子的CAS操作将Displaced Mark Word替换回对象头。如果成功则说明没有竞争发生，如果失败，标识当前锁存在竞争。锁会升级成重量级锁。</p>
</blockquote>
<h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><p>volatile是轻量级的synchronized，保证了共享变量的可见性，同时不会引起上下文的切换和调度。<br>但是i++不能保证原子性的，因为i++是读写两次操作。<br>JVM中并没有要求64位long/double写入是原子的。所以多线程读取时又可以读到的是”一半”的值。这个时候就需要使用volatile了</p>
<h4 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h4><ol>
<li>保证单词写入/读入原子性</li>
<li>内存可见性</li>
<li>禁止重排序</li>
</ol>
<h4 id="前置概念"><a href="#前置概念" class="headerlink" title="前置概念"></a>前置概念</h4><p><img src="/2024/05/13/08/%E5%89%8D%E7%BD%AE%E6%A6%82%E5%BF%B5.png"></p>
<h4 id="volatile是如何实现的？"><a href="#volatile是如何实现的？" class="headerlink" title="volatile是如何实现的？"></a>volatile是如何实现的？</h4><ol>
<li>转变成汇编语言之后会多一个Lock前缀，这个前缀会将当前处理器缓存行的数据写回系统内存，同时其他CPU中缓存了该内存地址的数据无效。修改volatile变量会强制将修改之后的值刷新到内存中同时导致其他线程中的该变量值失效。</li>
<li>处理器会根据MESI(修改、独占、共享、无效)控制协议去维护内部缓存。处理器使用嗅探技术保证它的内部缓存、系统内存和其他处理器的缓存的数据在总线上保持一致。</li>
</ol>
<p>可见性：<br>修改volatile变量会强制将修改之后的值刷新到内存中<br>同时导致其他线程中的该变量值失效。<br>有序性：遵循happen-before<br>内存屏障：JVM通过内存屏障来实现的</p>
<h4 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h4><p>CPU防止代码进行重排序而提供的指令。<br>Unsafe提供了以下的内存屏障方法</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//内存屏障，禁止load操作重排序。屏障前的load操作不能被重排序到屏障后，屏障后的load操作不能被重排序到屏障前</span>
<span class="token keyword">public</span> <span class="token keyword">native</span> <span class="token keyword">void</span> <span class="token function">loadFence</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//内存屏障，禁止store操作重排序。屏障前的store操作不能被重排序到屏障后，屏障后的store操作不能被重排序到屏障前</span>
<span class="token keyword">public</span> <span class="token keyword">native</span> <span class="token keyword">void</span> <span class="token function">storeFence</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//内存屏障，禁止load、store操作重排序</span>
<span class="token keyword">public</span> <span class="token keyword">native</span> <span class="token keyword">void</span> <span class="token function">fullFence</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="重排序问题"><a href="#重排序问题" class="headerlink" title="重排序问题"></a>重排序问题</h4><blockquote>
<p>执行程序时，为了提高性能编译器和处理器常常会对执行进行重排序。</p>
<ol>
<li>编译器优化的重排序：不改变单线程语义的情况下，可以重新安排语句的执行顺序</li>
<li>指令级并行的重排序：现代处理器采用了指令级并行技术来讲多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</li>
<li>内存系统的重排序：由于处理器使用缓存和读/写缓冲区，是的加载和存储操作看上去可能时再乱序执行</li>
</ol>
</blockquote>
<p><img src="/2024/05/13/08/%E9%87%8D%E6%8E%92%E5%BA%8F.png"></p>
<h5 id="as-if-serial"><a href="#as-if-serial" class="headerlink" title="as-if-serial"></a>as-if-serial</h5><p>多线程程序中的重排序，编译器和CPU只能保证每个线程的线程内部之间都是“看似完全串行的”，但是多个线程会相互读取和写入共享的变量不会进行考虑。</p>
<h5 id="happen-before"><a href="#happen-before" class="headerlink" title="happen-before"></a>happen-before</h5><p>保证一个线程的执行结果对另一个线程可见。</p>
<h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><h4 id="是可重入的吗"><a href="#是可重入的吗" class="headerlink" title="是可重入的吗"></a>是可重入的吗</h4><blockquote>
<p>可重入（Reentrant）是指在多线程环境中，一个函数可以被多个线程同时调用而不会引起任何问题。</p>
</blockquote>
<p>是可重入的，因为synchronized关键字是基于JVM内部的监视器锁，这种锁是依赖于对象头中的标记字段来管理锁的状态。<br>当线程第一次获得锁时，他的线程ID会被记录在对象头的标记字段中，并且计数器设置为1，如果同一线程需要再次进入由自己持有锁的synchronized块时，计数器就会+1，当synchronized块时，计数器-1。当计数器回到0时，锁才真正被释放，此时其他线程可以尝试获取这个锁。</p>
<h4 id="synchronized可以锁的类型"><a href="#synchronized可以锁的类型" class="headerlink" title="synchronized可以锁的类型"></a>synchronized可以锁的类型</h4><ol>
<li>对于普通同步方法，锁的是实例对象</li>
<li>对于静态同步方法，锁的是当前类的Class对象，包括这个类的所有对象</li>
<li>对于同步方法块，锁的是Synchornized括号里的对象</li>
</ol>
<h4 id="实现和原理"><a href="#实现和原理" class="headerlink" title="实现和原理"></a>实现和原理</h4><ol>
<li>synchronized用的锁是存在Java对象头里的，如果对象是数组类型，则虚拟机用三个字宽存储对象头。<img src="/2024/05/13/08/Java%E5%AF%B9%E8%B1%A1%E5%A4%B4.png"></li>
<li>对象头会随着锁标志位的变化而变化 <img src="/2024/05/13/08/%E5%AF%B9%E8%B1%A1%E5%A4%B4%E4%BC%9A%E9%9A%8F%E7%9D%80%E9%94%81%E6%A0%87%E5%BF%97%E4%BD%8D%E7%9A%84%E5%8F%98%E5%8C%96%E8%80%8C%E5%8F%98%E5%8C%96.png" alt="对象头会随着锁标志位的变化而变化"></li>
</ol>
<h3 id="Java内存模型的基础"><a href="#Java内存模型的基础" class="headerlink" title="Java内存模型的基础"></a>Java内存模型的基础</h3><p>并发编程中常常需要解决线程之间如何进行通信和如何进行同步。<br>在命令式编程中，线程之间的通信机制有两种：共享内存和消息传递。</p>
<blockquote>
<p>共享内存是线程共享程序的公共状态，通过读写内存的公共状态来进行通信。消息传递则是线程之间必须通过发送消息来显示的进行通信。</p>
</blockquote>
<p>Java中使用的是共享内存模型。<img src="/2024/05/13/08/Java%E7%BA%BF%E7%A8%8B%E5%86%85%E5%AD%98%E5%85%B1%E4%BA%AB.png"><br>他们之间的通信需要修改共享变量，然后由另一个去读取共享变量来实现。<br>JDK5 开始，Java使用JSP-133内存模型，使用happens-before：前一个操作的结果对后一个操作可见 </p>
<h3 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h3><h4 id="什么是CountDownLatch？"><a href="#什么是CountDownLatch？" class="headerlink" title="什么是CountDownLatch？"></a>什么是CountDownLatch？</h4><p>CountDownLatch 是通过一个计数器来实现的，计数器的初始值就是线程的数量，每当一个线程执行完毕之后，计数器的值就-1，然后在闭锁上等待的线程就可以恢复工作了。<br>主要使用场景：</p>
<ul>
<li>用于等待多个线程完成一个整体的前提任务<br>实例：在进行业务之前将两个数据库中的数据进行同步(非集群的数据库)<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span></span><span class="token class-name">CountDownLatch</span></span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DatabaseSync</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">syncDatabase1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 这里是同步数据库1的代码</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">syncDatabase2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 这里是同步数据库2的代码</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sync</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>
        <span class="token class-name">CountDownLatch</span> latch <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountDownLatch</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
            <span class="token function">syncDatabase1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            latch<span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
            <span class="token function">syncDatabase2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            latch<span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 等待两个数据库同步操作完成</span>
        latch<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Both databases have been synchronized."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>
        <span class="token keyword">new</span> <span class="token class-name">DatabaseSync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
<h3 id="JUC包"><a href="#JUC包" class="headerlink" title="JUC包"></a>JUC包</h3><h4 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a>CompletableFuture</h4><p>Future的缺点：不支持异步任务的编排，同时get方法是阻塞调用<br>完全可控的Fututure<br>使⽤线程池时，我们应该尽量避免将耗时任务提交到线程池中执⾏。对于⼀些⽐较耗时的操作，如<br>⽹络请求、⽂件读写等，可以采⽤ CompletableFuture 等其他异步操作的⽅式来处理，以避<br>免阻塞线程池中的线程<br>示例代码：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">CompletableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Map</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Map</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> future <span class="token operator">=</span> <span class="token class-name">CompletableFuture</span><span class="token punctuation">.</span><span class="token function">supplyAsync</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> adminClient<span class="token punctuation">.</span><span class="token function">distributedInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h4 id="CompletableFuture源码分析"><a href="#CompletableFuture源码分析" class="headerlink" title="CompletableFuture源码分析"></a>CompletableFuture源码分析</h4><ul>
<li>runAsync不允许返回值，适合需要一步操作但是不关心返回结果 </li>
<li>supplyAsync需要返回值，适合需要返回值的异步操作</li>
<li>thenApply、thenAccept、thenRun、whenComplete 可以对结果进行进一步处理</li>
<li>异常处理使用handle</li>
<li>合并future结果，thenCompose是链接两个CompletabelFuture，并将前一个结果作为下一个任务参数，thenCombine会将两个任务都结束之后，将两个任务的结果合并，并行执行</li>
<li>allOf等待所有的执行完成之后再调用<br>默认使用的是ForkJoinPool.commonPool作为执行器，这个线程池全局共享，可能会被其他任务占用</li>
</ul>
<h4 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h4><p>线程安全的HashMap，多线程情况下HashMap进行put操作会进入死循环。而使用HashTable效率又很低，因为当一个线程访问HashTable的同步方法，其他线程也访问时，会进入阻塞或轮询状态，所有的线程都必须竞争同一把锁。而我们只需要有多把锁，每一把锁都只锁住某一部分数据即可。这就是ConcurrentHashMap使用的锁分段技术。<br>JDK1.7使用的是分段的数据+链表实现的，JDK1.8使用的数据结构跟HashMap一职，数组+链表/红黑树。使用的是Node数组+链表+红黑树，通过synchronized和CAS操作来帮正线程安全</p>
<h4 id="实现原理-具体看源码"><a href="#实现原理-具体看源码" class="headerlink" title="实现原理 具体看源码"></a>实现原理 具体看源码</h4><h5 id="1-7"><a href="#1-7" class="headerlink" title="1.7"></a>1.7</h5><p>Segment数组(不可扩容) 作为分段锁，是可重入锁，对其中的一部分加锁<img src="/2024/05/13/08/JDK1.67%E5%AE%9E%E7%8E%B0.png"></p>
<h4 id="1-8"><a href="#1-8" class="headerlink" title="1.8"></a>1.8</h4><p>使用的是Node数组+链表/红黑树，Node只适用于链表的情况，而红黑树需要TreeNode。使用Node+CAS+synchronized来保证线程安全<img src="/2024/05/13/08/JDK1.8%E5%AE%9E%E7%8E%B0.png"></p>
<h5 id="常用的api"><a href="#常用的api" class="headerlink" title="常用的api"></a>常用的api</h5><h6 id="get"><a href="#get" class="headerlink" title="get"></a>get</h6><p>先进性一次散列，然后使用这个散列值定位到Segment，再进行散列定位到元素。<br>get不需要加锁，因为get方法中使用的共享变量都顶i成volatile类型，额能够在线程之间保持可见性。保证不会读到过期的值，但是只能被单线程写(如果写入的值依赖原值)<br>根据happen before原则，对volatile字段的写是优先于读的。</p>
<h6 id="put"><a href="#put" class="headerlink" title="put"></a>put</h6><p>对共享变量进行写入操作，为了线程安全必须加锁。<br>先定位到Segment，之后再Segment里进行操作，所以只需要锁住一个Segment即可<br>扩容机制：只会对某个segment进行扩容。</p>
<h6 id="count"><a href="#count" class="headerlink" title="count"></a>count</h6><p>先尝试不加锁来统计各个Segment的大小，如果两次中出现了不同的数值，就采用加锁的方式来统计所有Segment大小。<br>原理是格局modCount变量，put、remove、clean方法都会把modCount+1</p>
<h4 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h4><p>线程安全的&nbsp;List，用来替代Vector<br>Vector的核心思想是每次访问都上锁，使用synchronized进行加锁，会导致性能很差<br>而CopyOnWriteArrayList则是使用了跟读写锁相似的思想，读读不互斥。写不会堵塞读取操作，只有写写才会出现互斥，核心思想是写时复制：不会直接修改原数组，而是先创建底层数组的副本，对副本进行修改，修改完之后再将修改后的数据赋值回去。</p>
<h4 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h4><p>线程安全的队列，是非阻塞实现的</p>
<h5 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h5><p>入队<br>使用CAS算法实现的</p>
<ol>
<li>定位尾节点</li>
<li>使用CAS算法来不断尝试将节点加入队列：如果尾节点的next是null表示已经是尾节点了，如果不是说明其他县城更新了尾节点，需要重新或如当前队列的尾节点。<br>出队<br>先获得头节点的元素，判断头节点元素是否为空，如果为空就是已经被别的线程取走，如果不为空就用CAS尝试出队</li>
</ol>
<h4 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h4><p>有多种实现<br>值得注意的时Pirority和Delay<br>阻塞队列，当队列满时，队列会阻塞插入元素的线程，之道队列布满。<br>当队列为空时，获取元素的线程会等待队列变成非空<br>常用于成缠着消费者问题</p>
<h5 id="实现原理-1"><a href="#实现原理-1" class="headerlink" title="实现原理"></a>实现原理</h5><p>通知模式实现</p>
<blockquote>
<p>通知模式是生产者往满的队列中添加队列时会阻塞住生产者。当消费者消费了一个队列中的元素后，会通知生产者当前的队列可用</p>
</blockquote>
<h4 id="CountDownLatch-1"><a href="#CountDownLatch-1" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h4><p>示例代码</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>

    <span class="token keyword">static</span> <span class="token class-name">CountDownLatch</span> countDownLatch <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountDownLatch</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>
        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token punctuation">{</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            countDownLatch<span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            countDownLatch<span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        countDownLatch<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h4><p>同步屏障<br>功能是让一组线程到达一个屏障(同步点)时被阻塞，直到最后一个线程到达屏障时才开门，所有被阻塞的线程才会继续运行。<br>与CountDownLatch的区别：countdownlatch只能使用一次，计数器无法重置。cyclicbarrier可以多次重复使用，当所有的线程到达同步点之后屏障会重置。</p>
<p><strong>CyclicBarrier：用于让一组线程互相等待，直到所有线程都到达某个屏障点，然后所有线程再继续执行。可以重用。<br>CountDownLatch：用于一个或多个线程等待其他线程完成某些操作。不能重用。</strong> </p>
<p>二者使用方法相似<br>如何选择：<br>简单的一次性同步任务可以使用countdownlatch，例如初始化一些配置<br>多阶段反复同步线程或者并发任务需要分阶段执行，每个阶段都需要等待所有的线程完成，选择cyclicbarrier</p>
<h4 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h4><p>信号量，控制同时访问特定资源的线程数量。</p>
<h4 id="Exchanger"><a href="#Exchanger" class="headerlink" title="Exchanger"></a>Exchanger</h4><p>进行线程之间协作的工具类。提供一个同步点，两个线程可以在这个同步点交换彼此的数据。</p>
<h3 id="原子类"><a href="#原子类" class="headerlink" title="原子类"></a>原子类</h3><p>Atomic包</p>
<h3 id="Java中的线程池"><a href="#Java中的线程池" class="headerlink" title="Java中的线程池"></a>Java中的线程池</h3><h4 id="实现原理-2"><a href="#实现原理-2" class="headerlink" title="实现原理"></a>实现原理</h4><ol>
<li>判断核心线程池里的线程是否都在执行任务，如果不是则新建一个工作线程来执行任务；如果都在执行任务，则进入下一个流程</li>
<li>判断工作 队列是否已经满，如果没满，将新提交的任务存储在这个工作队列里，如果满了，进入下一个流程</li>
<li>判断线程池中 当线程是否都在工作中，如果没有就创建一个新的工作线程来执行任务，如果已经满了，则交给饱和策略来处理这个任务<br><img src="/2024/05/13/08/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%89%A7%E8%A1%8C%E7%A4%BA%E6%84%8F%E5%9B%BE.png"><br><img src="/2024/05/13/08/jdk%E7%BA%BF%E7%A8%8B%E6%B1%A0.png"></li>
</ol>
<h4 id="核心参数"><a href="#核心参数" class="headerlink" title="核心参数"></a>核心参数</h4><ol>
<li>核心线程数：任务队列没满时可以同时执行的最大线程数</li>
<li>最大线程数：任务队列满时，可以同时运行的线程数</li>
<li>线程空闲时间：线程数量超过核心线程数时，多余的空闲线程再中止前等待新任务的最长时间</li>
<li>时间单位</li>
<li>任务队列：</li>
<li>线程工厂</li>
<li>拒绝策略：当任务无法提交到线程池时的处理策略。<ul>
<li><code>AbortPolicy</code>：抛出&nbsp;<code>RejectedExecutionException</code>&nbsp;异常（默认策略）。</li>
<li><code>CallerRunsPolicy</code>：由调用线程处理该任务。</li>
<li><code>DiscardPolicy</code>：直接丢弃任务。</li>
<li><code>DiscardOldestPolicy</code>：丢弃队列中最旧的任务，然后重新提交新任务。<br><img src="/2024/05/13/08/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F.png"></li>
</ul>
</li>
</ol>
<h4 id="任务执行顺序"><a href="#任务执行顺序" class="headerlink" title="任务执行顺序"></a>任务执行顺序</h4><ol>
<li>当前运行中的线程数小于核心线程数，就新建一个线程来执行任务，即使线程池中存在空闲线程</li>
<li>如果大于等于核心线程数，但是小于最大线程数，就把任务加入到任务队列中</li>
<li>如果队列已满，但是线程数小于最大线程数，就新建一个线程来执行任务</li>
<li>如果新创建线程会导致当前运行中的线程数大于最大线程数，就会调用拒绝策略</li>
</ol>
<h3 id="生产者-消费者模型："><a href="#生产者-消费者模型：" class="headerlink" title="生产者-消费者模型："></a>生产者-消费者模型：</h3><p>一个内存队列，多个生产线程往内存队列中放数据，多个消费者线程从内存对俄中取数据。</p>
<ol>
<li>内存队列本身需要枷锁，才能实现线程安全</li>
<li>阻塞。当内存队列满了，生产者被阻塞，内存队列为空时消费者被阻塞。</li>
<li>双向通知：消费者被阻塞之后，生产者放入新数据，要通知消费者，反之要通知生产者。</li>
</ol>
<h1 id="Unsafe"><a href="#Unsafe" class="headerlink" title="Unsafe"></a>Unsafe</h1><p>主要功能</p>
<ol>
<li>内存屏障</li>
</ol>
<h1 id="ReenTrantLock"><a href="#ReenTrantLock" class="headerlink" title="ReenTrantLock"></a>ReenTrantLock</h1><h2 id="实现原理-3"><a href="#实现原理-3" class="headerlink" title="实现原理"></a>实现原理</h2><p>实现是一种自旋锁，使用循环调用CAS操作来进行加锁。</p>
<h1 id="线程同步的方法"><a href="#线程同步的方法" class="headerlink" title="线程同步的方法"></a>线程同步的方法</h1><ol>
<li>Synchronized</li>
<li>ReentrantLock</li>
<li>CountDownLatch</li>
<li>CyclicBarrier</li>
<li>Semaphore</li>
<li>Wait和No</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zuofw.github.io/2024/05/13/00/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="QingQiu">
      <meta itemprop="description" content="个人网站，学习记录，面试记录和经验总结、互联网中一块属于自己的小窝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="QingQiu'Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/13/00/" class="post-title-link" itemprop="url">Spring 循环依赖会出现什么情况？ 如何解决?</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-05-13 15:46:00" itemprop="dateCreated datePublished" datetime="2024-05-13T15:46:00+08:00">2024-05-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-06-08 15:00:56" itemprop="dateModified" datetime="2024-06-08T15:00:56+08:00">2024-06-08</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.3k</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="一、什么是循环依赖"><a href="#一、什么是循环依赖" class="headerlink" title="一、什么是循环依赖?"></a>一、什么是循环依赖?</h2><p>在Spring项目中我们经常使用 @Autowired或者@Resource去注入Bean，我们称之为依赖。<br>当多个Bean之间存在互相依赖的关系，并且出现了循环调用时，Spring就会找不到依赖的七点，就会死循环直到抛出异常。<br>例如：A依赖B,B依赖C,C依赖A，三者必须在依赖的类初始化之后才会初始化自己，从而出现死循环。</p>
<h2 id="二、实战场景"><a href="#二、实战场景" class="headerlink" title="二、实战场景"></a>二、实战场景</h2><p>笔者是在使用Spring Security 编写登录和权限验证代码时出现了循环依赖的场景。</p>
<h2 id="三、解决方法"><a href="#三、解决方法" class="headerlink" title="三、解决方法"></a>三、解决方法</h2><p>省流： 笔者使用的方法</p>
<ol>
<li>使用@Lazy延迟创建对象</li>
<li>将@Resource替换为@Autowired</li>
<li>新建一个空Bean，来解决依赖问题： 例如 A依赖B,B依赖A,我们可以新建一个C，然后让A依赖C，B实现C即可将直接依赖转化为间接依赖关系 中介方式打破循环链<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 新的接口</span>
<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">C</span> <span class="token punctuation">{</span>
    <span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// B实现C</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token keyword">implements</span> <span class="token class-name">C</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// ...</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// A依赖C，而不是直接依赖B</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token class-name">C</span> c<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">A</span><span class="token punctuation">(</span><span class="token class-name">C</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>c <span class="token operator">=</span> c<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        c<span class="token punctuation">.</span><span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ol>
<h2 id="四、扩展：-Autowired是如何解决循环依赖的的问题的"><a href="#四、扩展：-Autowired是如何解决循环依赖的的问题的" class="headerlink" title="四、扩展：@Autowired是如何解决循环依赖的的问题的"></a>四、扩展：@Autowired是如何解决循环依赖的的问题的</h2><p>解决的核心是使用了Spring的三级缓存：</p>
<ul>
<li>第一级缓存：singletonObjects，用于存放完全初始化好的bean，避免重复创建，单例池</li>
<li>二级缓存：earlySingletonObjects 存放原始的bean对象，尚未填充属性，同时也没有进行完成依赖注入的类 (<strong>核心</strong>)</li>
<li>三级缓存：singletonFactories 用于存放bean工厂对象中的getObject方法，用于产生原始的bean或者代理对象(如果Bean被AOP切面代理)来放入二级缓存<br>首先我们要知道，实例化 ≠ 完全初始化，当Spring容器创建bean时，会从一级缓存中寻找，如果没找到，会搜索二级缓存，如果存在就会把它注入，如果没有会找三级缓存。当bean初始化时，如果发现依赖的类没有完成完全初始化，就会先使用二级缓存中的bean实例，当所有的bean都初始化之后再从一级缓存中获取完全初始化的bean<br>而我们使用的@Resource并不存在这种机制，会直接抛出BeanCurrentlyInCreationException<br><strong>只用两级缓存可以吗？</strong><br>如果没有AOP的情况下只是用一级和三级缓存就能解决，但是涉及到AOP时，必须使用了<br>如果发生循环依赖的话，就去 <strong>三级缓存 <code>singletonFactories</code></strong> 中拿到三级缓存中存储的 <code>ObjectFactory</code> 并调用它的 <code>getObject()</code> 方法来获取这个循环依赖对象的前期暴露对象（虽然还没初始化完成，但是可以拿到该对象在堆中的存储地址了），并且将这个前期暴露对象放到二级缓存中，这样在循环依赖时，就不会重复初始化了！</li>
</ul>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zuofw.github.io/2024/04/23/25/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="QingQiu">
      <meta itemprop="description" content="个人网站，学习记录，面试记录和经验总结、互联网中一块属于自己的小窝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="QingQiu'Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/23/25/" class="post-title-link" itemprop="url">train</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-04-23 13:39:25" itemprop="dateCreated datePublished" datetime="2024-04-23T13:39:25+08:00">2024-04-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-05-01 20:56:27" itemprop="dateModified" datetime="2024-05-01T20:56:27+08:00">2024-05-01</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.5k</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Tigs:</p>
<ol>
<li>相同的application文件优先使用公共的配置</li>
</ol>
<h2 id="一些没什么用的小概念"><a href="#一些没什么用的小概念" class="headerlink" title="一些没什么用的小概念"></a>一些没什么用的小概念</h2><ul>
<li>并发量：同一时间内，系统中同时处理的用户请求数</li>
<li>响应时间：系统处理一个请求所需的时间</li>
<li>吞吐量：系统在给定时间内处理处理的业务请求数量</li>
<li>QPS(Queries Per Second) 表示系统每秒钟处理的请求数量</li>
<li>TPS(Transactions Per Second ) 表示系统每秒钟完成的事务数量</li>
</ul>
<h2 id="Gateway-网关负责分发前端请求"><a href="#Gateway-网关负责分发前端请求" class="headerlink" title="Gateway 网关负责分发前端请求"></a>Gateway 网关负责分发前端请求</h2><p>使用分布式锁来解决缓存击穿</p>
<ul>
<li><strong>以下是要自己完成的：</strong><ol>
<li>使用Spring Security和GateWay完成路由转发和认证</li>
<li>使用kafka或rocketmq<br>Redis作为缓存</li>
</ol>
</li>
<li>缓存问题：<ol>
<li>每天的用户很多但是用户每天使用的次数很少，同时会员的信息涉及的表很多<ul>
<li>解决：使用本地缓存，因为每个会员使用次数很少，一分钟有效，</li>
<li>问题:fullgc频繁，导致短时间内大量请求失败，因为缓存时间很短，所以大量的新生代出现，引起频繁的gc，然后大量放入老年代引起fullgc ， 解决：不用本地缓存，而是用线程本地变量，放在内存中。</li>
</ul>
</li>
</ol>
</li>
</ul>
<h2 id="Senta"><a href="#Senta" class="headerlink" title="Senta"></a>Senta</h2><ul>
<li>原理：生成反向sql</li>
<li>模式：<ol>
<li>AT模式：默认，添加undo_log,反向生成sql，回滚之后原来没数据的依然没有数据<ul>
<li>使用方法：<ol>
<li>建立undo_log表</li>
</ol>
</li>
</ul>
</li>
<li>TCC模式： try confirm/cancel 三个阶段的代码自己实现，Seata负责调度</li>
<li>SAGA模式：长事务解决方案，需要编写两个阶段的代码，需要一个JSON文件，可以异步执行</li>
<li>XA模式：适用于银行和金融，需要数据库支持XA协议<br>  try 之前的代码出现异常会直接结束，不会走finally</li>
</ol>
</li>
</ul>
<h2 id="如何处理多并发的买票"><a href="#如何处理多并发的买票" class="headerlink" title="如何处理多并发的买票"></a>如何处理多并发的买票</h2><ol>
<li>使用synchronized ，缺点：会导致卡住，只适合单机</li>
<li>使用Redis分布式锁，使用日期+车次来作为锁key，然后放入Redis中，如果拿到锁则继续执行，使用的使setIfAbsent(key,value,timeout),如果这个锁不存在则设置并且返回true，买到票之后删除key 缺点：如果线程执行时间超过了超时时间，也会导致超卖    <strong>对应Redis的命令是setnx</strong></li>
<li>使用Redisson看门狗，使用一个守护线程来关注超时间是，如果事务未完成但是锁即将过期则重置时间，如果事务结束则守护线程结束，lock.isHeldByCurrentThread来判断是否是当前线程的锁，缺点：Redis集群中Redis宕机，会导致获得得不到锁，然后新的线程向新的Redis主节点中获得锁，仍然可以获得锁 ， <strong>最常用</strong> ，Redisson中的锁在释放了之后Redis就查不到了！！！</li>
<li>使用红锁：只有拿到半数以上的同等地位的Redis的锁才算拿到锁，Redisson中也有自带的红锁，不常用， 缺点：性能问题，并且如果都得不到锁就都会等待了，尽量去尝试获得更多的锁来解决单机宕机问题</li>
</ol>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@RestController</span>
<span class="token annotation punctuation">@Slf4j</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RedisController</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Resource</span>
    <span class="token keyword">private</span> <span class="token class-name">RedissonClient</span> redissonClient<span class="token punctuation">;</span>

    <span class="token annotation punctuation">@PostMapping</span><span class="token punctuation">(</span><span class="token string">"/buy"</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">set</span><span class="token punctuation">(</span><span class="token class-name">String</span> ticket<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>
        <span class="token comment">//当前日期</span>
        <span class="token class-name">String</span> key <span class="token operator">=</span> ticket <span class="token punctuation">;</span>
        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"key:{}"</span><span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">RLock</span> lock <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>

            <span class="token comment">//获取锁</span>
            lock <span class="token operator">=</span> redissonClient<span class="token punctuation">.</span><span class="token function">getLock</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">//尝试加锁，最多等待100秒，上锁以后10秒自动解锁</span>
            <span class="token keyword">boolean</span> tryLock <span class="token operator">=</span> lock<span class="token punctuation">.</span><span class="token function">tryLock</span><span class="token punctuation">(</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">SECONDS</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//等待100秒，上锁以后10秒自动解锁</span>
            log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"tryLock:{}"</span><span class="token punctuation">,</span> tryLock<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">//模拟业务处理</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>tryLock<span class="token punctuation">)</span><span class="token punctuation">{</span>
                <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">10000</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//单位是毫秒</span>
                log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"购买成功"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">null</span> <span class="token operator">!=</span> lock <span class="token operator">&amp;&amp;</span> lock<span class="token punctuation">.</span><span class="token function">isHeldByCurrentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                    lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                <span class="token keyword">return</span> <span class="token string">"购买成功"</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"没拿到锁"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">return</span> <span class="token string">"购买失败"</span><span class="token punctuation">;</span>
<span class="token comment">//                throw new RuntimeException("没拿到锁");</span>
            <span class="token punctuation">}</span>


    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="使用Sentinal进行限流和降级"><a href="#使用Sentinal进行限流和降级" class="headerlink" title="使用Sentinal进行限流和降级"></a>使用Sentinal进行限流和降级</h3><ul>
<li>常见的限流算法：<ol>
<li>静态窗口限流：每秒限制多少个请求，例如：第2.5会统计第2秒到现在的流量</li>
<li>动态窗口限流：滑动窗口，往前取1秒,例如：第2.5秒会统计第1.5秒到现在的请求数</li>
<li>漏桶限流：队列，请求全在队列中，出队是匀速的</li>
<li>令牌桶限流：放的是令牌，令牌就是计数，会有一个计数器匀速产生令牌,出队不是匀速的可以适应短时间内大量请求</li>
<li>令牌大闸：当令牌到达一定数量就不再产生新的令牌</li>
</ol>
</li>
</ul>
<h2 id="如何应对刷票"><a href="#如何应对刷票" class="headerlink" title="如何应对刷票"></a>如何应对刷票</h2><p>使用令牌大闸：令牌按照匀速生成，即使有再多的机器人刷票也会被领票的数量限制，判断令牌肯定比更新库存更快</p>
<ol>
<li>使用令牌锁，持有令牌锁的人才能对令牌进行操作</li>
<li>检测令牌数量，如果有就执行，没有就不能执行</li>
<li>不要立刻释放令牌锁，使用固定的时间来释放令牌锁，这样即使有机器人也得等待令牌锁的释放</li>
</ol>
<ul>
<li>同时也可以加入验证码来防止机器人刷票<br>优化：使用缓存加速令牌锁<br>将数据库查出来的令牌存在Redis中，每次对Redis中的令牌数量-1，只有当数量等于我们设定的阈值时再去更改数据库的令牌数量，所以需要在Redis中长期保持这个key</li>
</ul>
<h2 id="使用RocketMQ"><a href="#使用RocketMQ" class="headerlink" title="使用RocketMQ"></a>使用RocketMQ</h2><p>使用RocketMQ来完成<br>购票之后，将请求发送给RocketMQ，然后另一边去消费这个消息，并且进行数据库的增删改查，可以将请求直接转为String 发送，之后另一端pull然后转为需要的类，之后执行具体具体的逻辑</p>
<h2 id="纯手写"><a href="#纯手写" class="headerlink" title="纯手写"></a>纯手写</h2><ol>
<li>登录：<ul>
<li>使用gateway + SpringSecurity + JWT + Redis实现微服务登录</li>
<li>Mybatis+Mybatis-plus</li>
</ul>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zuofw.github.io/2024/04/14/28/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="QingQiu">
      <meta itemprop="description" content="个人网站，学习记录，面试记录和经验总结、互联网中一块属于自己的小窝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="QingQiu'Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/14/28/" class="post-title-link" itemprop="url">es</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-04-14 19:45:28" itemprop="dateCreated datePublished" datetime="2024-04-14T19:45:28+08:00">2024-04-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-07-19 16:43:40" itemprop="dateModified" datetime="2024-07-19T16:43:40+08:00">2024-07-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">分布式</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4k</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Elasticsearch学习笔记"><a href="#Elasticsearch学习笔记" class="headerlink" title="Elasticsearch学习笔记"></a>Elasticsearch学习笔记</h1><ul>
<li>面试问题：<ol>
<li>索引文档的过程：<ol>
<li>协调节点默认使用文档ID参与计算，为路由提供合适的分片，转发请求</li>
<li>分片所在节点接收到请求之后，将请求写入内存缓冲区，定时refresh到文件系统缓存，经过这一步既可以被搜索到了，当Filesystem cache中的数据写入到磁盘中时，才会清除掉translog，这个过程叫做flush；</li>
</ol>
</li>
<li>es的删除：es中的文件并没有删除，每个段都有一个.del文件，删除是在这里进行标志，该文档仍然能够匹配到，但是会在结果中被过滤掉，后续在执行merge(周期性的将较小的段合并为一个较大的段)操作时，会被彻底清除掉</li>
<li>更新：每次更新都是先标记旧的文档为已删除，重新建立一个文档，并通过版本号来区分</li>
<li>搜索过程：<ul>
<li>Query Then Fetch</li>
</ul>
<ol>
<li>查询广播到每一个分片，分片本地执行搜索，建立一个优先队列，搜索只能搜到文件缓存的内容，所以并不是完全实时的</li>
<li>分片返回优先队列中文档的ID和排序值给协调节点，协调节点合并结果并排序</li>
<li>协调节点确定要取回的文档，然后向对应分片发送请求，最后协调节点返回给客户端</li>
</ol>
</li>
<li>写过程：客户端选择一个node(作为协调节点）发请求，协调节点对文档进行路由，将请求转发给有这个文档的主分片的节点，主分片处理请求，并将将数据同步到副本中，之后协调节点根据完成状态，相应给客户端</li>
<li>读过程：协调节点根据doc id来查询，然后对doc id进行hash来确认到了哪个分片上，然后转发请求到对应的节点，使用负载均衡 来选取一个分片来处理，并转发给它，之后由这个节点来读取并返回给协调节点，协调节点返回给客户端</li>
<li>es相对于mongodb，mysql的优势：1.全文检索，相关性排名 2.近实时性3.分布式处理4.数据分析 缺点：不支持事务</li>
</ol>
</li>
<li>DSL查询：由es提供的基于JSON的DSL语句<ul>
<li>叶子查询：在特定字段中查询特定值</li>
<li>符合查询：以逻辑方式组合多个叶子查询或者更改叶子查询的行为方式</li>
<li>指定高亮字段：<pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">GET /</span><span class="token punctuation">{</span>索引库名<span class="token punctuation">}</span><span class="token selector">/_search</span>
<span class="token punctuation">{</span>
  <span class="token string">"query"</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>
    <span class="token string">"match"</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>
      <span class="token string">"搜索字段"</span><span class="token punctuation">:</span> <span class="token string">"搜索关键字"</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token selector">,
  "highlight":</span> <span class="token punctuation">{</span>
    <span class="token string">"fields"</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>
      <span class="token string">"高亮字段名称"</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>
        <span class="token string">"pre_tags"</span><span class="token punctuation">:</span> <span class="token string">"&lt;em&gt;"</span><span class="token punctuation">,</span>
        <span class="token string">"post_tags"</span><span class="token punctuation">:</span> <span class="token string">"&lt;/em&gt;"</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
</li>
<li>索引 :<img src="/2024/04/14/28/%E4%B8%8Emysql%E5%AF%B9%E6%AF%94.png" alt="|725"><ul>
<li>倒排索引和正排索引的区别：<ul>
<li>正排索引是词条分到文档中</li>
<li>倒排索引是给词条统计文档</li>
<li><img src="/2024/04/14/28/%E4%BA%8C%E8%80%85%E5%8C%BA%E5%88%AB.png" alt="|275"></li>
</ul>
</li>
<li>使用索引模板来加快索引的创建与属性设置</li>
<li>索引结构：倒排索引，使用分词，记录每一个分词出现的文档编号和在文档中出现的位置<ul>
<li><img src="/2024/04/14/28/%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95.jpg"></li>
<li>搜索模块，路由值时，</li>
</ul>
</li>
<li>索引搜索：<ul>
<li>当搜索请求不带路由值时，接收到请求的节点成为协调节点，之后会选择使用的分片，之后会转发请求到拥有这些分片的节点上，每个分片产生一部分的局部结果汇总给协调节点，由协调节点汇总并排序之后返回。</li>
<li>使用路由条件进行搜索时，会将请求转发，之后直接由选中的节点进行返回</li>
</ul>
</li>
<li>索引映射：<ul>
<li>相当于指定了索引字段的名字和能够存储的类型</li>
<li>常用的数据类型：long , integer,short,byte,double,date(date可以在后面加一个format字段来执行时间的格式转换),keyword(用于保存原始文本，不会进行分词处理，用于精确匹配)，boolean,geo_poinst经纬度类型，json格式(需要使用properties来指定内部对象的属性，实际存储时会使用 . 来表示层次结构)，lists(数组)</li>
<li>**<em>如何既能快速匹配，又能精确匹配?</em>**，给字段添加一个fields参数，然后在里面放一个keyword字段</li>
<li>在每一个字段的后面使用：”copy_to”:”复制出来的新字段名字” 可以做到复制这些字段的内容</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">PUT mysougoulog/_mapping</span> 
<span class="token punctuation">{</span>
  <span class="token string">"properties"</span><span class="token punctuation">:</span><span class="token punctuation">{</span>
      <span class="token string">"visitTime"</span><span class="token punctuation">:</span><span class="token punctuation">{</span>
        <span class="token string">"type"</span><span class="token punctuation">:</span><span class="token string">"date"</span><span class="token punctuation">,</span>
        <span class="token string">"format"</span><span class="token punctuation">:</span><span class="token string">"yyyy-MM-dd HH:mm:ss || epoch_millis"</span><span class="token punctuation">,</span>
        <span class="token string">"ignore_malformed"</span><span class="token punctuation">:</span>true # 这个字段类型不对时，不写入，但是不影响其他字段的写入
      <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token selector"># 二者兼得
PUT mysougoulog/_mapping</span> 
<span class="token punctuation">{</span>
    <span class="token string">"properties"</span><span class="token punctuation">:</span><span class="token punctuation">{</span>
        <span class="token string">"key"</span><span class="token punctuation">:</span><span class="token punctuation">{</span>
          <span class="token string">"type"</span><span class="token punctuation">:</span><span class="token string">"text"</span><span class="token punctuation">,</span>
          <span class="token string">"fields"</span><span class="token punctuation">:</span><span class="token punctuation">{</span>
            <span class="token string">"keyword"</span><span class="token punctuation">:</span><span class="token punctuation">{</span>
              <span class="token string">"type"</span><span class="token punctuation">:</span><span class="token string">"keyword"</span><span class="token punctuation">,</span>
              <span class="token string">"ignore_above"</span><span class="token punctuation">:</span>256 # 表示256个字符后面的内容被忽略，用来节省字段
            <span class="token punctuation">}</span>
          <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>文档：<ul>
<li>CRUD时如何控制并发：<ul>
<li>修改时，加上?if_seq_no = xx&amp;if_primary_term=xx来使用乐观锁来控制，这两个字段是可以查到的，Elastisearch不支持事务管理</li>
</ul>
</li>
<li>文本分析：<ul>
<li>文本分析需要经过&gt;=0个字符过滤器一个分词器，&gt;=0 个分词过滤器<ul>
<li>字符过滤器：对原始文档本进行转换，如去掉html标签</li>
<li>分词器：按照规则切分为单词，</li>
<li>分词过滤器：过滤掉一些没有用的词比如，的，删除停用词,也可进行分词的处理，如大小写转化，添加同义词</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>分词器：<ul>
<li>创建倒排索引时对文档进行分词，用户搜索时，对输入的内容进行分词</li>
<li>IK分词器：<ul>
<li>ik_smart 智能切分模式，粗粒度</li>
<li>ik_max_word：最细切分，细粒度</li>
</ul>
</li>
</ul>
</li>
<li><h2 id="数据：-搜索数据：-1-精确搜索：搜索内容不经过文本分析直接进行文本匹配，适用于非text类，一般用于keyword字段-2-全文检索：对检索内容和字段都会进行文本分析-3-经纬度搜索，可以指定某个区域，例如⚪-4-复合搜索：-布尔搜索：通过指定布尔逻辑条件来组织多条查询语句，同时满足整个布尔条件的才会被搜索出来-等等-父子关联-因为es会把数据折叠起来，使用点，所以当一个对象有多个相同的key时，不能进行搜索了，例如goods商品，里面存放商品id和生产时间，就会被折叠-警告：-避免使用对象数组-解决方法：使用嵌套对象-使用join字段来明确父子关系-聚集统计：用于分析索引和文档，类似于mysql中的聚集操作"><a href="#数据：-搜索数据：-1-精确搜索：搜索内容不经过文本分析直接进行文本匹配，适用于非text类，一般用于keyword字段-2-全文检索：对检索内容和字段都会进行文本分析-3-经纬度搜索，可以指定某个区域，例如⚪-4-复合搜索：-布尔搜索：通过指定布尔逻辑条件来组织多条查询语句，同时满足整个布尔条件的才会被搜索出来-等等-父子关联-因为es会把数据折叠起来，使用点，所以当一个对象有多个相同的key时，不能进行搜索了，例如goods商品，里面存放商品id和生产时间，就会被折叠-警告：-避免使用对象数组-解决方法：使用嵌套对象-使用join字段来明确父子关系-聚集统计：用于分析索引和文档，类似于mysql中的聚集操作" class="headerlink" title="数据：  - 搜索数据：      1. 精确搜索：搜索内容不经过文本分析直接进行文本匹配，适用于非text类，一般用于keyword字段      2. 全文检索：对检索内容和字段都会进行文本分析      3. 经纬度搜索，可以指定某个区域，例如⚪      4. 复合搜索：          - 布尔搜索：通过指定布尔逻辑条件来组织多条查询语句，同时满足整个布尔条件的才会被搜索出来          - 等等  - 父子关联:      - 因为es会把数据折叠起来，使用点，所以当一个对象有多个相同的key时，不能进行搜索了，例如goods商品，里面存放商品id和生产时间，就会被折叠 警告： 避免使用对象数组      - 解决方法：使用嵌套对象      - 使用join字段来明确父子关系  - 聚集统计：用于分析索引和文档，类似于mysql中的聚集操作"></a>数据：<br>  - 搜索数据：<br>      1. 精确搜索：搜索内容不经过文本分析直接进行文本匹配，适用于非text类，一般用于keyword字段<br>      2. 全文检索：对检索内容和字段都会进行文本分析<br>      3. 经纬度搜索，可以指定某个区域，例如⚪<br>      4. 复合搜索：<br>          - 布尔搜索：通过指定布尔逻辑条件来组织多条查询语句，同时满足整个布尔条件的才会被搜索出来<br>          - 等等<br>  - 父子关联:<br>      - 因为es会把数据折叠起来，使用点，所以当一个对象有多个相同的key时，不能进行搜索了，例如goods商品，里面存放商品id和生产时间，就会被折叠 <strong>警告：</strong> 避免使用对象数组<br>      - 解决方法：使用嵌套对象<br>      - 使用join字段来明确父子关系<br>  - 聚集统计：用于分析索引和文档，类似于mysql中的聚集操作</h2></li>
<li>集群：<ol>
<li>新集群的产生：master节点的职责主要包括集群、节点和索引的管理，不负责文档级别的管理，主节点和数据节点不是一个<ul>
<li>初始化投票配置：将配置文件中的候选节点写入投票配置，所有节点均可参与投票</li>
<li>选举主节点：超过半数就可成为主节点</li>
<li>发现集群中的其他节点，节点尝试连接主节点，连接上之后主节点把最新的状态发布到这些节点中</li>
<li>集群完成，对外启动统一的服务</li>
</ul>
</li>
<li>集群状态的发布过程:  <strong>删除或者新增节点时触发</strong><ul>
<li>主节点把最新的集群状态发送到每个节点上，每个节点将数据保存并向主节点发送确认响应</li>
<li>主节点接收到半数以上的确认消息，开始提交，发送给每个节点通知使用最新的集群状态，子节点接收后发送确认响应，所有的都确认即可完成发布</li>
<li>响应超过时间限制，则删除这个子节点</li>
</ul>
</li>
</ol>
</li>
<li>如何实现master选举？<ul>
<li>对于所有可以成为master的节点，根据nodeId来排序，每个节点把自己直到的节点排一次序，然后选出第一个节点，认为他是master节点，入股某个节点到达可以成为超过master节点的一半，那就成为了master节点</li>
</ul>
</li>
<li>脑裂问题：<ul>
<li>设置最小主节点设置，设置的值应该是集群中节点总数的一半 + 1</li>
</ul>
</li>
<li>读写一致：<ul>
<li>版本控制：每个文档在ES中都有一个版本号，每次被修改后，版本号会增加，获取文档时，会同时或者它的版本号，更新时可以指定这个版本号，如果版本号不匹配，更新操作就会被拒绝</li>
<li>刷新与同步：向ES中写入数据时，数据先被写入内存缓冲区，然后每隔一段时间刷新一次或者缓冲区满时被刷新到磁盘后就可以被搜索到了，但是没有被写入磁盘，之后定期同步到磁盘中，同步后就是持久化存储了</li>
<li>副本和分片:只有主节点可以写入数据，然后被复制到副本分片中，读取数据时可以从任何一个包含该数据的分片中获取</li>
<li>设置写入确认级别</li>
</ul>
</li>
<li>代码中使用:<img src="/2024/04/14/28/%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%811.png" alt="|575"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Test</span>
<span class="token keyword">void</span> <span class="token function">testMatchAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">{</span>
    <span class="token comment">// 1.创建Request</span>
    <span class="token class-name">SearchRequest</span> request <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SearchRequest</span><span class="token punctuation">(</span><span class="token string">"items"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 2.组织请求参数</span>
    request<span class="token punctuation">.</span><span class="token function">source</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">query</span><span class="token punctuation">(</span><span class="token class-name">QueryBuilders</span><span class="token punctuation">.</span><span class="token function">matchAllQuery</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 3.发送请求</span>
    <span class="token class-name">SearchResponse</span> response <span class="token operator">=</span> client<span class="token punctuation">.</span><span class="token function">search</span><span class="token punctuation">(</span>request<span class="token punctuation">,</span> <span class="token class-name">RequestOptions</span><span class="token punctuation">.</span><span class="token constant">DEFAULT</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 4.解析响应</span>
    <span class="token function">handleResponse</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">handleResponse</span><span class="token punctuation">(</span><span class="token class-name">SearchResponse</span> response<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">SearchHits</span> searchHits <span class="token operator">=</span> response<span class="token punctuation">.</span><span class="token function">getHits</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 1.获取总条数</span>
    <span class="token keyword">long</span> total <span class="token operator">=</span> searchHits<span class="token punctuation">.</span><span class="token function">getTotalHits</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>value<span class="token punctuation">;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"共搜索到"</span> <span class="token operator">+</span> total <span class="token operator">+</span> <span class="token string">"条数据"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 2.遍历结果数组</span>
    <span class="token class-name">SearchHit</span><span class="token punctuation">[</span><span class="token punctuation">]</span> hits <span class="token operator">=</span> searchHits<span class="token punctuation">.</span><span class="token function">getHits</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">SearchHit</span> hit <span class="token operator">:</span> hits<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 3.得到_source，也就是原始json文档</span>
        <span class="token class-name">String</span> source <span class="token operator">=</span> hit<span class="token punctuation">.</span><span class="token function">getSourceAsString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 4.反序列化并打印</span>
        <span class="token class-name">ItemDoc</span> item <span class="token operator">=</span> <span class="token class-name">JSONUtil</span><span class="token punctuation">.</span><span class="token function">toBean</span><span class="token punctuation">(</span>source<span class="token punctuation">,</span> <span class="token class-name">ItemDoc</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zuofw.github.io/2024/04/11/19/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="QingQiu">
      <meta itemprop="description" content="个人网站，学习记录，面试记录和经验总结、互联网中一块属于自己的小窝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="QingQiu'Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/11/19/" class="post-title-link" itemprop="url">k8s</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-04-11 10:12:19" itemprop="dateCreated datePublished" datetime="2024-04-11T10:12:19+08:00">2024-04-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-07-19 16:43:54" itemprop="dateModified" datetime="2024-07-19T16:43:54+08:00">2024-07-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%BF%90%E7%BB%B4/" itemprop="url" rel="index"><span itemprop="name">运维</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>13</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>执行kubeadm 时报错，</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zuofw.github.io/2024/04/07/18/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="QingQiu">
      <meta itemprop="description" content="个人网站，学习记录，面试记录和经验总结、互联网中一块属于自己的小窝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="QingQiu'Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/07/18/" class="post-title-link" itemprop="url">MQ</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-04-07 10:07:18" itemprop="dateCreated datePublished" datetime="2024-04-07T10:07:18+08:00">2024-04-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-09-03 14:58:41" itemprop="dateModified" datetime="2024-09-03T14:58:41+08:00">2024-09-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">分布式</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.3k</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="面试常问："><a href="#面试常问：" class="headerlink" title="面试常问："></a>面试常问：</h1><h2 id="生产者出现堆积如何解决"><a href="#生产者出现堆积如何解决" class="headerlink" title="生产者出现堆积如何解决"></a>生产者出现堆积如何解决</h2><ol>
<li>增加消费者</li>
<li>优化消费者的处理速度</li>
<li>使用优先队列，优先处理优先级高的消息</li>
<li>消息压缩：如果网络带宽是瓶颈</li>
<li>升级设备</li>
<li>消息过滤：生产者端发送真正需要处理的消息</li>
<li>调整生产者的速度</li>
</ol>
<h2 id="生产消费过程中如果服务出现异常，如何恢复"><a href="#生产消费过程中如果服务出现异常，如何恢复" class="headerlink" title="生产消费过程中如果服务出现异常，如何恢复"></a>生产消费过程中如果服务出现异常，如何恢复</h2><ol>
<li>重试机制：</li>
<li>死信队列：将无法处理的消息放在一个特殊的队列中，由人工去处理或者特殊处理</li>
<li>备份和恢复：对于重要数据应该定期进行备份，当服务出现异常时，从备份中恢复数据。</li>
<li>服务降级</li>
<li>容错和冗余设计</li>
</ol>
<h2 id="AMQP协议"><a href="#AMQP协议" class="headerlink" title="AMQP协议"></a>AMQP协议</h2><ul>
<li>AMQ Model组件：<ol>
<li>Producer </li>
<li>Exchange 交换器，从Producer中收集消息并根据路由规则发送到对应的消息队列中</li>
<li>Queue 消息队列，存储消息，直到消息被安全的投递到了消费者</li>
<li>Binding 定义了 mq 和 exchange之间的关系，是路由表</li>
<li>Consumer</li>
</ol>
</li>
</ul>
<h2 id="RocketMQ"><a href="#RocketMQ" class="headerlink" title="RocketMQ"></a>RocketMQ</h2><p><a target="_blank" rel="noopener" href="https://javaguide.cn/high-performance/message-queue/rocketmq-questions.html">常见问题</a></p>
<p><img src="/2024/04/07/18/%E8%A7%92%E8%89%B2.png"></p>
<ol>
<li>生产者组-&gt;发送消息的一方<ul>
<li>消息的类型：<ol>
<li>普通消息：并发消息，并发消息没有顺序</li>
<li>分区有序消息:把一个Topic消息分为多个分区，保护和消费，分区内的消息就是队列，FIFO</li>
<li>全局有序：把一个Topic分区数设为1，所有的消息都支持FIFO</li>
<li>延迟消息：消息发送后，消费者不能立刻消费，需要等待</li>
<li>事务消息：涉及分布式事务，保证多个操作同时成功或者失败，消费者才能使用</li>
<li><img src="/2024/04/07/18/%E4%B8%8D%E5%90%8C%E6%B6%88%E6%81%AF%E7%89%B9%E7%82%B9.png"></li>
</ol>
</li>
<li>消息保证机制：<ol>
<li>客户端保证：重试机制和客户端容错(选择延迟较低的Broker来发送消息)</li>
<li>Broker保证</li>
</ol>
</li>
<li>消息发送流程:<ol>
<li>业务层调用Client 发送API业务代码</li>
<li>消息处理层：Client获取消息对象后进行参数检查，准备和封装</li>
<li>通信层：基于Netty封装的RPC通信</li>
</ol>
</li>
</ul>
</li>
<li>Topic：</li>
<li>消费者组： <ul>
<li>订阅关系：一个消费者组订阅一个Topic中的某一个Tag</li>
<li>消费模式：<ul>
<li>集群消费模式：同一个组中的消费者实例负载均衡的消费Topic中的消息，消费进度保存在Broker端，即使应用崩溃，消费进度也不会出错</li>
<li>广播消费：所有消息广播分发，全部的消费者实例可以消费整个Topic中的所有消息，消费进度保存子啊客户端文件中，适用于通知其他服务刷新缓存</li>
</ul>
</li>
<li>可靠消费保证：<ol>
<li>重试-死信机制：正常Topic遭遇消费失败后-&gt;消息被保存在重试Topic中-&gt;多次间隔时间进行重新消费后仍然失败-&gt;进入死信Topic，经由人工处理，不会再被消费者消费</li>
<li>Rebalance机制：重平衡， 用于在发生Broker掉线、Topic扩容和缩容、消费者扩容和缩容等变化时，自动感知并调整自身消费，以尽量减少甚至避免消息没有被消费。</li>
</ol>
</li>
<li>消费方式：<ol>
<li>pull 用户主动pull消息，自主管理位点，由用户代码来进行管理</li>
<li>push 自动pull消息，用户可直接使用，</li>
</ol>
</li>
<li>消费过滤，Broker端可以根据tag进行消费过滤，只返回满足的tag,broker端使用Hash过滤，客户端再进行一次Tag字符串过滤， 因为Hash过来吧可以快速过滤大量数据，但是存在Hash碰撞</li>
</ul>
</li>
</ol>
<ul>
<li>Namesrv集群：一个无状态的元数据管理，Namesrv之于RocketMQ等价于Zookeeper之于Kafka。Topic路由注册和管理、Broker注册和发现的管理者</li>
</ul>
<h1 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h1><p><a target="_blank" rel="noopener" href="https://javaguide.cn/high-performance/message-queue/rabbitmq-questions.html">常见问题</a></p>
<h2 id="RabbitMQ主要架构"><a href="#RabbitMQ主要架构" class="headerlink" title="RabbitMQ主要架构"></a>RabbitMQ主要架构</h2><p><img src="/2024/04/07/18/RabbitMQ%E6%9E%B6%E6%9E%84.png" alt="RabbitMQ架构"></p>
<ul>
<li><p>**<code>publisher</code>**：生产者，也就是发送消息的一方</p>
</li>
<li><p>**<code>consumer</code>**：消费者，也就是消费消息的一方</p>
</li>
<li><p>**<code>queue</code>**：队列，存储消息。生产者投递的消息会暂存在消息队列中，等待消费者处理</p>
</li>
<li><p>**<code>exchange</code>**：交换机，负责消息路由。生产者发送的消息由交换机决定投递到哪个队列。不会持久化数据</p>
</li>
<li><p>**<code>virtual host</code>**：虚拟主机，起到数据隔离的作用。每个虚拟主机相互独立，有各自的exchange、queue，也就是将exchange和queue进行分组</p>
</li>
</ul>
<h2 id="Spring中使用"><a href="#Spring中使用" class="headerlink" title="Spring中使用"></a>Spring中使用</h2><p>使用Spring AMQP来实现</p>
<h3 id="publisher"><a href="#publisher" class="headerlink" title="publisher"></a>publisher</h3><p>使用RabbitTemplate来发送消息</p>
<h3 id="consumer"><a href="#consumer" class="headerlink" title="consumer"></a>consumer</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Component</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SpringRabbitListener</span> <span class="token punctuation">{</span>
        <span class="token comment">// 利用RabbitListener来声明要监听的队列信息</span>
    <span class="token comment">// 将来一旦监听的队列中有了消息，就会推送给当前服务，调用当前方法，处理消息。</span>
    <span class="token comment">// 可以看到方法体中接收的就是消息体的内容</span>
    <span class="token annotation punctuation">@RabbitListener</span><span class="token punctuation">(</span>queues <span class="token operator">=</span> <span class="token string">"simple.queue"</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">listenSimpleQueueMessage</span><span class="token punctuation">(</span><span class="token class-name">String</span> msg<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"spring 消费者接收到消息：【"</span> <span class="token operator">+</span> msg <span class="token operator">+</span> <span class="token string">"】"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="交换机的类型："><a href="#交换机的类型：" class="headerlink" title="交换机的类型："></a>交换机的类型：</h2><h3 id="Fanout"><a href="#Fanout" class="headerlink" title="Fanout"></a><strong>Fanout</strong></h3><p>广播，将消息交给所有绑定到交换机的队列。我们最早在控制台使用的正是Fanout交换机<br>特点：</p>
<ol>
<li>可以有多个队列</li>
<li>每个队列都要绑定到Exchange</li>
<li>生产者发送的消息只能发送到交换机</li>
<li>交换机把消息发送给绑定过的所有队列</li>
<li>订阅队列的消费者都能拿到消息</li>
</ol>
<h3 id="Direct"><a href="#Direct" class="headerlink" title="Direct"></a><strong>Direct</strong></h3><p>订阅，基于RoutingKey（路由key）发送给订阅了消息的队列<br>特点：</p>
<ol>
<li>队列需要与交换机绑定，指定一个RountingKey</li>
<li>消息发送方发送时也需要指定RountingKey</li>
<li>Exchange把消息发送给RountingKey对应的队列</li>
</ol>
<h3 id="Topic"><a href="#Topic" class="headerlink" title="Topic"></a><strong>Topic</strong></h3><p>通配符订阅，与Direct类似，只不过RoutingKey可以使用通配符</p>
<ul>
<li><p><code>#</code>：匹配一个或多个词</p>
</li>
<li><p><code>*</code>：匹配不多不少恰好1个词<br>举例：</p>
</li>
<li><p><code>item.#</code>：能够匹配<code>item.spu.insert</code> 或者 <code>item.spu</code></p>
</li>
<li><p><code>item.*</code>：只能匹配<code>item.spu</code><br>与DIrect类似，但是可以使用通配符来进行队列绑定</p>
</li>
<li><p><strong>Headers</strong>：头匹配，基于MQ的消息头匹配，用的较少。</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zuofw.github.io/2024/03/30/44/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="QingQiu">
      <meta itemprop="description" content="个人网站，学习记录，面试记录和经验总结、互联网中一块属于自己的小窝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="QingQiu'Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/03/30/44/" class="post-title-link" itemprop="url">Netty</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-03-30 19:25:44" itemprop="dateCreated datePublished" datetime="2024-03-30T19:25:44+08:00">2024-03-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-09-29 15:17:45" itemprop="dateModified" datetime="2024-09-29T15:17:45+08:00">2024-09-29</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>6.4k</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>#todo </p>
<ul>
<li><input disabled="" type="checkbox"> 使用Netty替代springboot的tomcat作为服务器</li>
<li><input disabled="" type="checkbox"> 使用Netty替代websocket来通信</li>
<li><input disabled="" type="checkbox"> 更新一下一致性哈希算法，如何更高效，顺便加上解释</li>
</ul>
<h1 id="基本介绍和使用介绍"><a href="#基本介绍和使用介绍" class="headerlink" title="基本介绍和使用介绍"></a>基本介绍和使用介绍</h1><h2 id="I-x2F-O模型："><a href="#I-x2F-O模型：" class="headerlink" title="I/O模型："></a>I/O模型：</h2><ol>
<li>阻塞I/O BIO：程序向内核发起I/O调用，发起调用的线程就一直等待内核返回结果。如果使用BIO实现异步，只能使用多线程模型，会导致增加线程切换的开销。</li>
<li>同步非阻塞IO NIO：应用程序通过轮询的方式获取请求结果。</li>
<li>多路复用I/O：多个进程的I/O可以注册到一个复用器上(Selector)，如果Selector监听的所有的I/O内核缓冲区都没有可读数据，select调用会被阻塞，直到任意I/O在内核缓冲区中有刻度数据时，会立刻返回。并通知其他进程再次发起I/O，也就是使用一个线程监控多个IO操作。 </li>
<li>信号驱动I/O：进程预先告知内核，向内核注册一个信号处理函数，之后进程返回不阻塞，进程通过信号处理函数继续调用I/O读取数据。IO操作就绪后，操作系统会发送信号通知应用程序。 通知何时可以开始一个I/O操作</li>
<li>异步I/O AIO：应用程序发起IO操作之后，立刻返回，操作系统在IO操作执行后，会通知应用程序，应用程序无需轮询IO状态。 通知I/O操作何时结束</li>
</ol>
<ul>
<li>BIO和NIO的区别: <img src="/2024/03/30/44/BIOandNIO.png"></li>
<li>AIO-&gt;异步I/O</li>
</ul>
<h3 id="Reactor-模型"><a href="#Reactor-模型" class="headerlink" title="Reactor 模型"></a>Reactor 模型</h3><blockquote>
<p>是一种处理并发I/O操作的设计模式。核心思想是通过实践多路复用机制来管理多个I/O事件。<br>主要的组件：1. 事件多路分发器(负责监听多个I/O事件，将这些事件分发给相应的事件处理器)<br>2.事件处理器 3.事件分发器：将事件从多路分发器中分发到响应的处理器。</p>
</blockquote>
<h3 id="select、poll、epoll的区别"><a href="#select、poll、epoll的区别" class="headerlink" title="select、poll、epoll的区别"></a>select、poll、epoll的区别</h3><ol>
<li>select：将已连接的Socket都放在一个文件描述符集合中，然后调用select函数将文件描述集合拷贝到内核中，让内核来检查是否有网络事件发生，检查方式就是遍历文件描述符集合。</li>
<li>poll：与select区别是，不再使用BitMap来存储文件描述符，突破了个数上限</li>
<li>epoll：内核使用红黑树来关注待检测的Socket高效，使用事件驱动，内核维护了一个链表来记录就绪事件，只会将事件发生的Socket集合传递给应用程序吗，而不是轮询整个集合</li>
</ol>
<h2 id="如何解决对象创建和销毁问题"><a href="#如何解决对象创建和销毁问题" class="headerlink" title="如何解决对象创建和销毁问题"></a>如何解决对象创建和销毁问题</h2><ol>
<li>对象池服用技术</li>
<li>零拷贝技术：Netty在进行I/O读写时，直接使用DirectBuffer，从而直接避免了数据在堆内存和堆外内存之间的拷贝</li>
</ol>
<h3 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h3><blockquote>
<p>数据从读取到内核缓冲区，然后直接由内核缓冲区发送到网络。而不是拷贝到用户缓冲区域再拷贝到内核缓冲区进行发送。</p>
</blockquote>
<p>Netty零拷贝实现</p>
<ul>
<li>使用堆外内存，避免JVM堆内存到堆外内存的数据拷贝</li>
<li>CompositeByteBuf 类，可以组合多个 Buffer 对象合并成一个逻辑上的对象，避免通过传统内存拷贝的方式将几个 Buffer 合并成一个大的 Buffer。</li>
<li>通过 Unpooled.wrappedBuffer 可以将 byte 数组包装成 ByteBuf 对象，包装过程中不会产生内存拷贝。</li>
<li>ByteBuf.slice ，slice 操作可以将一个 ByteBuf 对象切分成多个 ByteBuf 对象，切分过程中不会产生内存拷贝，底层共享一个 byte 数组的存储空间。</li>
<li>Netty 使用 封装了transferTo() 方法 FileRegion，可以将文件缓冲区的数据直接传输到目标 Channel，避免内核缓冲区和用户态缓冲区之间的数据拷贝</li>
</ul>
<h3 id="Java中的IO模型"><a href="#Java中的IO模型" class="headerlink" title="Java中的IO模型"></a>Java中的IO模型</h3><ol>
<li>BIO java.io是BIO</li>
<li>NIO java.nio包是NIO的实现，实质上仍然是同步的，读写操作时非同步的，但是这些操作是由应用程序主动发起和处理的，所以仍然是同步的。</li>
<li>AIO java.nio.channels是NIO的实现</li>
</ol>
<h2 id="按照定义来说，Netty是一个异步的、事件驱动的、用来做高性能高可靠性的网络应用的框架"><a href="#按照定义来说，Netty是一个异步的、事件驱动的、用来做高性能高可靠性的网络应用的框架" class="headerlink" title="按照定义来说，Netty是一个异步的、事件驱动的、用来做高性能高可靠性的网络应用的框架"></a>按照定义来说，Netty是一个异步的、事件驱动的、用来做高性能高可靠性的网络应用的框架</h2><p>Netty相比于Tomcat，不需要遵循Serlet规范，可以最大化的发挥NIO的特性。<br>如果需要面向TCP的网络应用开发，那么Netty才是最佳选择</p>
<h3 id="三大组件"><a href="#三大组件" class="headerlink" title="三大组件"></a>三大组件</h3><ol>
<li>Channel &amp; Buffer</li>
<li>Selector</li>
<li>Bootstrap</li>
</ol>
<h4 id="逻辑架构"><a href="#逻辑架构" class="headerlink" title="逻辑架构"></a>逻辑架构</h4><p><img src="/2024/03/30/44/Netty%E6%95%B4%E4%BD%93%E9%80%BB%E8%BE%91.png"></p>
<ol>
<li>网络通信层：支持多种网络协议，当网络数据读取到内核缓冲区后，会触发各种网络事件，会分发给事件调度层进行处理。核心是<ul>
<li>BootStrap，负责Netty客户端的启动、初始化、服务器连接等过程</li>
<li>ServerBootStrap：用于服务端绑定本地端端口，会绑定Boss和Worker两个EventLoopGroup</li>
<li>Channle 通道，基于NIO更高层次的抽象吗</li>
</ul>
</li>
<li>事件调度层：通过Reactor线程模型对各种事件进行聚合处理。通过Selector主循环线程继承u洞中时间，实际业务处理逻辑是交由服务编排曾中的Handler解决的。<ul>
<li>EventLoopGroup（核心）：本质是一个<strong>线程池</strong>，主要负责接收I/O请求，并分配线程执行处理请求。通过创建不同的EventLoopGroup参数可以支持Reactor三种线程模型：<ul>
<li>单线程模型：Group中只包含一个EventLoop，Boss和Worker使用同一个Group</li>
<li>多线程：多个EventLoop，B和W使用同一个</li>
<li>主从多线程：多个EventLoop，B和W使用不同的Group</li>
</ul>
</li>
<li>EventLoop负责处理Channel生命周期中所有的I/O事件，一个EventLoopGroup包含一个或者多个EventLoop，一个EventLoop同一时间只会绑定一个Channel，Channel生命周期内可以和多个EventLoop进行多次绑定和解绑<img src="/2024/03/30/44/EventLoop.png"></li>
</ul>
</li>
<li>服务编排层：负责组装各种服务，是核心处理链。<ul>
<li>ChannelPipeline核心编排组件，负责组装各种ChannelHandler，I/O读写触发时，会依次调用Handler进行拦截和处理。</li>
<li>ChannelHandler完成具体的树decode和encode工作和处理公国。</li>
<li>ChannelHandlerContext：用于保存上下文，通过HandlerContext可以知道Pipeline和Handler的关联关系，包含Handler生命周期的所有事件。</li>
</ul>
</li>
</ol>
<h2 id="Bootstrap"><a href="#Bootstrap" class="headerlink" title="Bootstrap"></a>Bootstrap</h2><blockquote>
<p>Netty客户端的启动</p>
</blockquote>
<h2 id="ServerBootStrap"><a href="#ServerBootStrap" class="headerlink" title="ServerBootStrap"></a>ServerBootStrap</h2><blockquote>
<p>服务端启动，会绑定Boss和 Worker两个EventLoopGroup</p>
</blockquote>
<p>Boss线程会不断接受新的连接，然后将连接分给Worker去处理</p>
<h2 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h2><h3 id="常用的Channel实现类"><a href="#常用的Channel实现类" class="headerlink" title="常用的Channel实现类"></a>常用的Channel实现类</h3><ul>
<li>NioServerSocketChannel 异步 TCP 服务端。</li>
<li>NioSocketChannel 异步 TCP 客户端。</li>
<li>OioServerSocketChannel 同步 TCP 服务端。</li>
<li>OioSocketChannel 同步 TCP 客户端。</li>
<li>NioDatagramChannel 异步 UDP 连接。</li>
<li>OioDatagramChannel 同步 UDP 连接。</li>
</ul>
<h3 id="Channel与事件"><a href="#Channel与事件" class="headerlink" title="Channel与事件"></a>Channel与事件</h3><ul>
<li>channelRegistered：Channel创建后被注册后被注册</li>
<li>channelUnregistered：Channel创建后未注册或者从EventLoop取消注册</li>
<li>channelActive：Channel处于就绪状态，可以被读写</li>
<li>channelInactive：处于非就绪状态</li>
<li>channelRead：Channel可以从远端读取数据</li>
<li>channelReadComplete：Channel读取数据完成</li>
</ul>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul>
<li>ChannelFuture<ul>
<li>其 addListener()方法会注册一个ChannelFutureListener来等待通知</li>
</ul>
</li>
<li>ChannelHandler：事件处理的具体逻辑<ol>
<li>生存周期：handlerAddedChannelHandler被添加到ChannelPipeline中时被调用，handlerRemoved被被移除，exceptionCaught处理过程中在ChannelPipeline中有错误产生时。</li>
<li>ChannelInboundHandler-&gt;处理入站数据及状态变化。<ul>
<li>方法：<img src="/2024/03/30/44/ChannelInboundHandler.png"></li>
<li>SimpleChannelInboundHandler会自动释放资源</li>
<li><img src="/2024/03/30/44/ChannelOutboundHandler.png"></li>
</ul>
</li>
</ol>
</li>
<li>ChannelPipeline<ul>
<li>每建立一个新的Channel都会分配一个ChannelPipeline，不可修改</li>
<li>提供了 ChannelHandler 链的容器，channel被创建时会被分配到ChannelPipeline中，ChannelHandler会被安装到其中</li>
<li>流程： ChannelInitializer的实现被注册进ServerBootstrapy中</li>
<li>调用initChannel()方法， ChannelInitializer会在ChannelPipeline中安装一组自定义的ChannelHandler</li>
<li>ChannelInitializer将自己从 ChannelPipeline中移除<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token punctuation">.</span><span class="token function">childHandler</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ChannelInitializer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">SocketChannel</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                       <span class="token comment">//添加一个EchoServerHandle到子Channel的ChannelPipeline</span>
                        <span class="token comment">//ChannelInitializer是一个特殊的处理程序，用于帮助用户配置新的Channel</span>
                        <span class="token annotation punctuation">@Override</span>
                        <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">initChannel</span><span class="token punctuation">(</span><span class="token class-name">SocketChannel</span> socketChannel<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
                            <span class="token comment">//EchoServerHandle被标注为@Shareable，所以我们可以总是使用同样的实例</span>
                            <span class="token comment">//@Shareable表示一个ChannelHandler可以被多个Channel安全地共享</span>
                            <span class="token comment">//在哪标注的呢？在EchoServerHandle类上</span>
                            socketChannel<span class="token punctuation">.</span><span class="token function">pipeline</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span>serverHandle<span class="token punctuation">)</span><span class="token punctuation">;</span>
                        <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
</li>
<li>ChannerlHandlerContext接口<ol>
<li>用于管理关联的ChannelHandler和同一个pipeline中其他的Handler</li>
<li></li>
</ol>
</li>
<li>二者的联系和区别：<img src="/2024/03/30/44/PipeLine%E5%92%8CHandler%E7%9A%84%E5%8C%BA%E5%88%AB.png"><br>  通过使用作为参数传递到每个方法的 ChannelHandlerContext，事件可以被传递给当前ChannelHandler 链中的下一个 ChannelHandler。<ul>
<li>ChannelInboundHandler </li>
<li>SimpleChannelInboundHandler&lt; T &gt; T是要处理消息的Java类型，适用于只需要解码消息并处理逻辑<ul>
<li>channelRead0(ChannelHandlerContext,T)</li>
</ul>
</li>
</ul>
</li>
<li>BootStrap 引导类，用于为应用程序的网络层配置提供了容器<ol>
<li>Bootstrap 用于客户端 ，可以直接.connect来连接服务器，</li>
<li>ServerBootstrap 用于客户端，需要.connect(new  InetSocketAddress) 才能等待客户端的连接</li>
</ol>
</li>
<li>Channel接口：<ul>
<li>方法：</li>
<li><img src="/2024/03/30/44/Channel%E6%96%B9%E6%B3%95.png"></li>
<li>Channel的生命周期：ChannelUnregistered已创建但是没有注册到EventLoop中；已注册ChannelRegistered；ChannelActive处于活跃状态，已经连接到远程节点， ChannelInactive 没有连接到远程给节点。</li>
</ul>
</li>
<li>内置的传输<ol>
<li>NIO 非阻塞-&gt;基于选择器 <img src="/2024/03/30/44/Selector.png"><ul>
<li><img src="/2024/03/30/44/Selector%E6%B5%81%E7%A8%8B.png"></li>
</ul>
</li>
<li>Epoll -&gt; 基于JNI驱动的，速度更快，完全非阻塞的<ul>
<li>使用：EpollEventLoopGroup 和EpollServerSocketChannel.class</li>
</ul>
</li>
<li>OIO -&gt;阻塞流</li>
<li>Local-&gt;在VM内部通过管道进行本地传输</li>
<li>Embedded 测试ChannelHandler使用</li>
</ol>
</li>
<li>ByteBuf<ol>
<li>使用两个索引：readIndex和writerIndex，开始时，两个都位于开头。也就是队列</li>
<li>ByteBufHolder接口用来存储各种属性值。</li>
<li>Netty提供了两种ByteBufAllocator的实现：PooledByteBufAllocator和UnpooledByteBufAllocator。前者池化了ByteBuf的实例以提高性能并最大限度地减少内存碎片。后者不池化。</li>
<li>Unpooled缓冲区：静态工具类来创建未池化的ByteBuf实例<img src="/2024/03/30/44/Unpooled.png"></li>
<li></li>
</ol>
</li>
<li>RPC框架的调用流程<br><img src="/2024/03/30/44/RPC%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B.png"></li>
<li>解码器：ByteToMessageDecoder 编码器：MessageToByteEncoder实际上这两个实现了Handler</li>
<li>协议的支持，自己去看数，Netty实战</li>
</ul>
<h3 id="EventLoopGroup-事件调度层"><a href="#EventLoopGroup-事件调度层" class="headerlink" title="EventLoopGroup 事件调度层"></a>EventLoopGroup 事件调度层</h3><ul>
<li><input disabled="" type="checkbox"> 如何使用自定义线程池，如何确定线程池的参数<br>EventLoopGroup是一个线程池，负责接受I/O请求并分配线程执行处理请求。<br><img src="/2024/03/30/44/EventLoop%E5%92%8CChannel.png"></li>
</ul>
<ol>
<li>EventLoopGroup包含多个EventLoop</li>
<li>EventLoop用于处理Channel生命周期内的所有I/O事件</li>
<li>EventLoop同一时间只会与一个线程绑定，每个EventLoop处理多个Channel</li>
<li>Channel在生命周期内可以对EventLoop进行多次绑定和解绑</li>
</ol>
<h3 id="服务编排层"><a href="#服务编排层" class="headerlink" title="服务编排层"></a>服务编排层</h3><ul>
<li>ChannelPipeline<br>负责组装各种ChannelHandler，内部通过双向链表将不同的ChannelHandler链接起来，依次调用，对Channel中的数据进行拦截和处理。<br>ChannelPipeline是线程安全的，因为一个新的Channel都会绑定一个新的ChannelPipeline，一个ChannelPipeline关联一个EventLoop，然后一个EventLoop绑定一个线程<img src="/2024/03/30/44/%E8%BF%9B%E5%87%BA%E7%AB%99.png"></li>
<li>ChannelHandler &amp; ChannelHandlerContext<br><img src="/2024/03/30/44/ChannelHandler.png"><br>ChannelHandlerContext用于保存ChannelHanler的上下文，可以实现ChannelHandler之间的交互。<br>同时包含了ChannelHandler生命周期的所有事件。<br>使用方式：</li>
</ul>
<p>#todo </p>
<ul>
<li><input disabled="" type="checkbox"> 如何做，搜搜<br>如果ChannelHandler有一些通用的逻辑需要实现，那么就可以放在这里。</li>
</ul>
<h3 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h3><h2 id="Netty实现的一些有特色"><a href="#Netty实现的一些有特色" class="headerlink" title="Netty实现的一些有特色"></a>Netty实现的一些有特色</h2><h3 id="FastThreadLocal"><a href="#FastThreadLocal" class="headerlink" title="FastThreadLocal"></a>FastThreadLocal</h3><p>使用Object数组替代Entry数据，<code>Object[0]</code>存储的是一个<code>Set&lt;FastThreadLocal&lt;?&gt;&gt;</code>集合，1以后都是存value的数据，而不是使用键值对的方式实现。<br>set方法：</p>
<ol>
<li>找到index位置，设置新的value</li>
<li>将<strong>FastThreadLocal对象保存到待清理的Set中</strong><br>优点：</li>
<li>高效查找：可以直接通过数组下标获取，而且扩容不需要进行rehash</li>
<li>安全性更高：ThreadLocal有可能会造成内存泄漏，只能等待线程销毁，但是的线程池下只能主动检测，而FastThreadLocal则封装了FastThreadLocalRunnable，任务执行完成之后一定会执行<code>FastThreadLocal.removeAll()</code>，从而将Set中所有的对象都销毁。</li>
</ol>
<p>#todo </p>
<ul>
<li><input disabled="" type="checkbox"> 以下内容是新开的文章《深入浅出Netty：原理与源码解读》记得新开一篇文章</li>
<li><input disabled="" type="checkbox"> 看看能不能写个爬虫把这个文章爬下来，或者自己复制下来<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/grey-wolf/p/12017818.html">曹工杂谈：Spring boot应用，自己动手用Netty替换底层Tomcat容器 - 三国梦回 - 博客园 (cnblogs.com)</a><br><a target="_blank" rel="noopener" href="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Netty%20%e6%a0%b8%e5%bf%83%e5%8e%9f%e7%90%86%e5%89%96%e6%9e%90%e4%b8%8e%20RPC%20%e5%ae%9e%e8%b7%b5-%e5%ae%8c/00%20%e5%ad%a6%e5%a5%bd%20Netty%ef%bc%8c%e6%98%af%e4%bd%a0%e4%bf%ae%e7%82%bc%20Java%20%e5%86%85%e5%8a%9f%e7%9a%84%e5%bf%85%e7%bb%8f%e4%b9%8b%e8%b7%af.md">00 学好 Netty，是你修炼 Java 内功的必经之路 (lianglianglee.com)</a></li>
</ul>
<h1 id="深入和源码解读"><a href="#深入和源码解读" class="headerlink" title="深入和源码解读"></a>深入和源码解读</h1><h2 id="Netty内部的逻辑流程"><a href="#Netty内部的逻辑流程" class="headerlink" title="Netty内部的逻辑流程"></a>Netty内部的逻辑流程</h2><p><img src="/2024/03/30/44/%E9%80%BB%E8%BE%91%E6%B5%81%E7%A8%8B.png"><br>#todo </p>
<ul>
<li><input disabled="" type="checkbox"> 源码解读<a target="_blank" rel="noopener" href="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Netty%20%e6%a0%b8%e5%bf%83%e5%8e%9f%e7%90%86%e5%89%96%e6%9e%90%e4%b8%8e%20RPC%20%e5%ae%9e%e8%b7%b5-%e5%ae%8c/02%20%20%e7%ba%b5%e8%a7%88%e5%85%a8%e5%b1%80%ef%bc%9a%e6%8a%8a%e6%8f%a1%20Netty%20%e6%95%b4%e4%bd%93%e6%9e%b6%e6%9e%84%e8%84%89%e7%bb%9c.md">02 纵览全局：把握 Netty 整体架构脉络 (lianglianglee.com)</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zuofw.github.io/2024/03/30/46/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="QingQiu">
      <meta itemprop="description" content="个人网站，学习记录，面试记录和经验总结、互联网中一块属于自己的小窝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="QingQiu'Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/03/30/46/" class="post-title-link" itemprop="url">mybatis</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-03-30 14:37:46" itemprop="dateCreated datePublished" datetime="2024-03-30T14:37:46+08:00">2024-03-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-07-27 16:53:11" itemprop="dateModified" datetime="2024-07-27T16:53:11+08:00">2024-07-27</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>5.7k</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="面试常问"><a href="#面试常问" class="headerlink" title="面试常问:"></a>面试常问:</h2><ul>
<li>延迟加载提高加载效率：</li>
</ul>
<h3 id="Mybatis的缓存"><a href="#Mybatis的缓存" class="headerlink" title="Mybatis的缓存"></a>Mybatis的缓存</h3><ul>
<li>一级缓存：也即是本地缓存，是SqlSession级别的,读个sql语句之间不会共享缓存，使用@Transactional来生效，也就是说在一次事务中多次查询会使用到一级缓存<ul>
<li>默认开启，可以在配置中关闭<ol>
<li>当我们执行查询操作时，MyBatis会先去一级缓存中查找是否有之前查询过的数据。如果有，直接返回缓存中的数据；如果没有，去数据库查询数据，并将查询结果放入一级缓存中。  </li>
<li>当我们执行更新操作（包括insert、update、delete）时，MyBatis会清空一级缓存。这是为了保证缓存中的数据和数据库中的数据是一致的。  </li>
<li>当SqlSession结束或关闭时，一级缓存也就清空了。</li>
</ol>
</li>
<li>二级缓存:<ul>
<li>在mapper.xml上方加上<code>&lt;Cache&gt;&lt;/Cache&gt;</code> 即可</li>
<li>根据mapper.xml中命名空间来区分，是mapper级别的，只用当执行同一个mapper中的增改删语句时才会失效，增删改频繁时二级缓存基本失效，并且，微服务中多台服务中只有被调用的那一台的二级缓存才会删除，其余的不删除，造成不一致。</li>
</ul>
</li>
</ul>
</li>
<li>Springboot Cache，会缓存方法的返回值，但是同样也只能在一个节点生效，并且，@Cacheable不会主动刷新缓存，但是@CachePut会强制刷新缓存，并把新的缓存放入</li>
<li>共享的缓存！Redis 可以在配置文件中将springboot的缓存类型设置为Redis</li>
</ul>
<h3 id="和-的区别是什么？"><a href="#和-的区别是什么？" class="headerlink" title="#{} 和 ${} 的区别是什么？"></a>#{} 和 ${} 的区别是什么？</h3><ul>
<li><code>#{}</code> 是Propeties文件中的变量占位符，会被原样替换</li>
<li><code>${}</code>是sql的参数占位符，Mybatis会把他替换成 <code>?</code> 后续通过反射进行替换数据</li>
</ul>
<h3 id="xml-映射文件中，除了常见的-select、insert、update、delete-标签之外，还有哪些标签？"><a href="#xml-映射文件中，除了常见的-select、insert、update、delete-标签之外，还有哪些标签？" class="headerlink" title="xml 映射文件中，除了常见的 select、insert、update、delete 标签之外，还有哪些标签？"></a>xml 映射文件中，除了常见的 select、insert、update、delete 标签之外，还有哪些标签？</h3><h4 id="resultMap-定义查询结果的映射规则"><a href="#resultMap-定义查询结果的映射规则" class="headerlink" title="resultMap 定义查询结果的映射规则"></a>resultMap 定义查询结果的映射规则</h4><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>resultMap</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>userResultMap<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>User<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>user_id<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>username<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>user_name<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>password<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>user_password<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>email<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>user_email<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>bio<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>user_bio<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>resultMap</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="sql：定义可复用的SQL代码段"><a href="#sql：定义可复用的SQL代码段" class="headerlink" title="sql：定义可复用的SQL代码段"></a>sql：定义可复用的SQL代码段</h4><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>sql</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>userColumns<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span> ${alias}.id, ${alias}.username, ${alias}.password, ${alias}.email, ${alias}.bio <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>sql</span><span class="token punctuation">&gt;</span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>selectUsers<span class="token punctuation">"</span></span> <span class="token attr-name">resultMap</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>userResultMap<span class="token punctuation">"</span></span> <span class="token punctuation">&gt;</span></span>
  select
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>include</span> <span class="token attr-name">refid</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>userColumns<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>alias<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>user<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>include</span><span class="token punctuation">&gt;</span></span>
  from some_table user
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="parameterType-定义SQL语句的输入参数类型"><a href="#parameterType-定义SQL语句的输入参数类型" class="headerlink" title="parameterType 定义SQL语句的输入参数类型"></a>parameterType 定义SQL语句的输入参数类型</h4><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>insert</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>insertUser<span class="token punctuation">"</span></span> <span class="token attr-name">parameterType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>User<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
  insert into users (username, password, email, bio)
  values (#{username}, #{password}, #{email}, #{bio})
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>insert</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="resultType：定义-SQL-语句的输出结果类型。"><a href="#resultType：定义-SQL-语句的输出结果类型。" class="headerlink" title="resultType：定义 SQL 语句的输出结果类型。"></a><code>resultType</code>：定义 SQL 语句的输出结果类型。</h4><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>selectUsernames<span class="token punctuation">"</span></span> <span class="token attr-name">resultType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>string<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
  select username from users
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h4 id="association：定义一对一的关联关系。"><a href="#association：定义一对一的关联关系。" class="headerlink" title="association：定义一对一的关联关系。"></a><code>association</code>：定义一对一的关联关系。</h4><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>resultMap</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>userResultMap<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>User<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
  <span class="token comment">&lt;!-- ... --&gt;</span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>association</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>address<span class="token punctuation">"</span></span> <span class="token attr-name">javaType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Address<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>address_id<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>street<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>address_street<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>city<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>address_city<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>state<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>address_state<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>zip<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>address_zip<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>country<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>address_country<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>association</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>resultMap</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="collection：定义一对多的关联关系。"><a href="#collection：定义一对多的关联关系。" class="headerlink" title="collection：定义一对多的关联关系。"></a><code>collection</code>：定义一对多的关联关系。</h4><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>resultMap</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>userResultMap<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>User<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
  <span class="token comment">&lt;!-- ... --&gt;</span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>collection</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>posts<span class="token punctuation">"</span></span> <span class="token attr-name">ofType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Post<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>post_id<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>subject<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>post_subject<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>body<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>post_body<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>collection</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>resultMap</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="dynamic-标签如-if、choose、when、otherwise、trim、where、set：用于构建动态-SQL。"><a href="#dynamic-标签如-if、choose、when、otherwise、trim、where、set：用于构建动态-SQL。" class="headerlink" title="dynamic&nbsp;标签如&nbsp;if、choose、when、otherwise、trim、where、set：用于构建动态 SQL。"></a><code>dynamic</code>&nbsp;标签如&nbsp;<code>if</code>、<code>choose</code>、<code>when</code>、<code>otherwise</code>、<code>trim</code>、<code>where</code>、<code>set</code>：用于构建动态 SQL。</h4><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>findActiveBlogLike<span class="token punctuation">"</span></span> <span class="token attr-name">resultType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Blog<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
  SELECT * FROM BLOG WHERE state = 'ACTIVE' 
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>if</span> <span class="token attr-name">test</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>title != null<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
    AND title like #{title}
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>if</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>执行过程<ul>
<li>java程序加载config文件，创建SqlSessionFactory对象，之后通过SqlSessionFactory创建SqlSession对象，之后通过SqlSession对象执行映射配置文件中定义的SQL语句，最后通过SqlSession对象提交事务，关闭SqlSession对象</li>
<li><img src="/2024/03/30/46/%E5%88%86%E5%B1%82.png"></li>
</ul>
</li>
</ul>
<h3 id="Dao接口-Mapper接口-的原理"><a href="#Dao接口-Mapper接口-的原理" class="headerlink" title="Dao接口(Mapper接口)的原理"></a>Dao接口(Mapper接口)的原理</h3><h4 id="Dao中的方法，参数不同时，可以重载吗"><a href="#Dao中的方法，参数不同时，可以重载吗" class="headerlink" title="Dao中的方法，参数不同时，可以重载吗"></a>Dao中的方法，参数不同时，可以重载吗</h4><p>  Mapper中的方法<strong>可以</strong> 重载，使用的是全限定名 + 方法名 拼接的字符串作为key去匹配。 但是xml文件中的id只能指定一个，也即是重载的所有方法都是用一个sql语句，而这个sql语句我们可以使用动态sql来实现</p>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>getAllStu<span class="token punctuation">"</span></span> <span class="token attr-name">resultType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.pojo.Student<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
  select * from student
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>where</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>if</span> <span class="token attr-name">test</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>id != null<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
      id = #{id}
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>if</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>where</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">&gt;</span></span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>Dao接口的原理：<br>MyBatis运行时会使用JDK动态代理来为Dao生成代理proxy对象，代理对象会拦截接口方法，转而执行MappedStatement中的sql</p>
<h3 id="MyBatis的分页"><a href="#MyBatis的分页" class="headerlink" title="MyBatis的分页"></a>MyBatis的分页</h3><p>nihao</p>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>答：**(1)** MyBatis 使用 RowBounds 对象进行分页，它是针对 ResultSet 结果集执行的内存分页，而非物理分页；**(2)** 可以在 sql 内直接书写带有物理分页的参数来完成物理分页功能，**(3)** 也可以使用分页插件来完成物理分页。</p>
<h4 id="分页插件的原理"><a href="#分页插件的原理" class="headerlink" title="分页插件的原理"></a>分页插件的原理</h4><ol>
<li>插件设置一个ThreadLocal变量来存储分页参数</li>
<li>当执行查询时，MyBatis会调用所有注册的拦截器。</li>
<li>PageHelper 首先会保存原始的查询SQL，然后生成一个新的SQL，这个新的SQL在原始的SQL基础上添加了LIMIT和OFFSET</li>
<li>PageHelper 将新的SQL替换成原始的SQL然后执行</li>
<li>最后PageHelper会清除ThreadLocal中变量，避免内存泄漏</li>
</ol>
<h3 id="MyBatis动态sql是什么的，有哪些，原理"><a href="#MyBatis动态sql是什么的，有哪些，原理" class="headerlink" title="MyBatis动态sql是什么的，有哪些，原理"></a>MyBatis动态sql是什么的，有哪些，原理</h3><h4 id="常用的动态sql标签"><a href="#常用的动态sql标签" class="headerlink" title="常用的动态sql标签"></a>常用的动态sql标签</h4><ul>
<li><code>&lt;if&gt;&lt;/if&gt;</code></li>
<li><code>&lt;where&gt;&lt;/where&gt;(trim,set)</code></li>
<li><code>&lt;choose&gt;&lt;/choose&gt;（when, otherwise）</code></li>
<li><code>&lt;foreach&gt;&lt;/foreach&gt;</code></li>
<li><code>&lt;bind/&gt;</code></li>
</ul>
<h4 id="执行原理"><a href="#执行原理" class="headerlink" title="执行原理"></a>执行原理</h4><p><strong>OGNL</strong> (Object-Graph Navigation Language)表达式，通过他可以在XML配置文件中引用Java对象和方法，在动态SQL中，常常使用其进行判断条件</p>
<ul>
<li>常见的OGNL语法：<pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">person.name #访问对象的属性
person.getName() # 调用对象的方法
persons.</span><span class="token punctuation">{</span>name<span class="token punctuation">}</span> # 获取persons对象的name属性
person.age &gt; 18 ? <span class="token string">'adult'</span> <span class="token punctuation">:</span> <span class="token string">'child'</span> # 条件表达式
person.agge + 1 # 算术表达式
person.age &gt; 18 &amp;&amp; person.gender == <span class="token string">'male'</span> # 逻辑表达式<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
<h4 id="MyBatis如何将sql执行结果封装为目标对象并返回"><a href="#MyBatis如何将sql执行结果封装为目标对象并返回" class="headerlink" title="MyBatis如何将sql执行结果封装为目标对象并返回"></a>MyBatis如何将sql执行结果封装为目标对象并返回</h4><ol>
<li>使用<code>&lt;resultMap&gt;</code> 标签去映射列表名和对象属性名之间的映射关系</li>
<li>使用sql列别名方式，将列名书写为对象属性名，例如：T_NAME AS NAME 对应的属性名是name，会忽略大小写<br>当映射关系建立之后，MyBatis会通过反射创建对象，然后给对象的属性一一赋值</li>
</ol>
<h3 id="MyBatis延迟加载的原理-待写"><a href="#MyBatis延迟加载的原理-待写" class="headerlink" title="MyBatis延迟加载的原理 待写"></a>MyBatis延迟加载的原理 待写</h3><p>MyBatis仅支持association关联对象和collection关联集合对象的延迟加载，association指的是1v1，collection是1v多</p>
<h4 id="Executor执行器"><a href="#Executor执行器" class="headerlink" title="Executor执行器"></a>Executor执行器</h4><ul>
<li>SimpleExecutor 每执行一次 update或select，就开启一个Statement对象，用完立刻关闭Statement对象</li>
<li>ReuseExecutor 执行update/select 以sql为key查找Statement对象，不存在就创建，使用后放在Map中，供下一次使用</li>
<li>BatchExecutor 执行update 时，将所有的sql都添加到批处理中，之后统一执行，缓存多个Statement对象，每个Statement对象都是等待sql添加之后，等待逐一执行</li>
</ul>
<h2 id="深入解读"><a href="#深入解读" class="headerlink" title="深入解读"></a>深入解读</h2><h3 id="基础支持层"><a href="#基础支持层" class="headerlink" title="基础支持层"></a>基础支持层</h3><ul>
<li>解析器模块<ol>
<li>DOM解析将xml的标签组织成一颗DOM树，将整个xml文档加载进内存</li>
<li>SAX基于时间模型的xml解析方式。加载一部分到内存中，并且当程序处理过程中满足条件时，会结束解析，不必解析剩余的xml内容。但是不支持层次关系和父子关系的保存</li>
</ol>
<ul>
<li>XPathParser：MyBatis提供的XPathParser类封装了XPath、Document、EntityResolver</li>
</ul>
</li>
</ul>
<h1 id="MyBatis-Plus"><a href="#MyBatis-Plus" class="headerlink" title="MyBatis Plus"></a><a target="_blank" rel="noopener" href="https://baomidou.com/introduce/">MyBatis Plus</a></h1><h2 id="一些插件"><a href="#一些插件" class="headerlink" title="一些插件"></a>一些插件</h2><h3 id="自定义填充字段"><a href="#自定义填充字段" class="headerlink" title="自定义填充字段"></a>自定义填充字段</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Component</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyBatisPlusDateHandler</span> <span class="token keyword">implements</span> <span class="token class-name">MetaObjectHandler</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">insertFill</span><span class="token punctuation">(</span><span class="token class-name">MetaObject</span> metaObject<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setFieldValByName</span><span class="token punctuation">(</span><span class="token string">"createTime"</span><span class="token punctuation">,</span> <span class="token class-name">LocalDateTime</span><span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> metaObject<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setFieldValByName</span><span class="token punctuation">(</span><span class="token string">"updateTime"</span><span class="token punctuation">,</span> <span class="token class-name">LocalDateTime</span><span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> metaObject<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">updateFill</span><span class="token punctuation">(</span><span class="token class-name">MetaObject</span> metaObject<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setFieldValByName</span><span class="token punctuation">(</span><span class="token string">"updateTime"</span><span class="token punctuation">,</span> <span class="token class-name">LocalDateTime</span><span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> metaObject<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="分页插件"><a href="#分页插件" class="headerlink" title="分页插件"></a>分页插件</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"dataBaseConfigurationByAdmin"</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DataBaseConfiguration</span> <span class="token punctuation">{</span>

    <span class="token comment">/**
     * 分页插件
     */</span>
    <span class="token annotation punctuation">@Bean</span>
    <span class="token annotation punctuation">@ConditionalOnMissingBean</span>
    <span class="token keyword">public</span> <span class="token class-name">MybatisPlusInterceptor</span> <span class="token function">mybatisPlusInterceptorByAdmin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">MybatisPlusInterceptor</span> interceptor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MybatisPlusInterceptor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        interceptor<span class="token punctuation">.</span><span class="token function">addInnerInterceptor</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">PaginationInnerInterceptor</span><span class="token punctuation">(</span><span class="token class-name">DbType</span><span class="token punctuation">.</span><span class="token constant">MYSQL</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> interceptor<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>使用时，只需要在自己定义的方法上加上一个Page类型的变量就可以进行分页查询了</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Page</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">&gt;</span></span> page <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Page</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 第1页，每页10条记录</span>
<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">&gt;</span></span> users <span class="token operator">=</span> userService<span class="token punctuation">.</span><span class="token function">selectUsers</span><span class="token punctuation">(</span>page<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">QingQiu</p>
  <div class="site-description" itemprop="description">个人网站，学习记录，面试记录和经验总结、互联网中一块属于自己的小窝</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">51</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">19</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Zuofw/zuofw-rpc" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Zuofw&#x2F;zuofw-rpc" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2022 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">QingQiu</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="站点总字数">408k</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  















  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
