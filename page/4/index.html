<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"zuofw.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="个人网站，学习记录，面试记录和经验总结、互联网中一块属于自己的小窝">
<meta property="og:type" content="website">
<meta property="og:title" content="QingQiu&#39;Blog">
<meta property="og:url" content="https://zuofw.github.io/page/4/index.html">
<meta property="og:site_name" content="QingQiu&#39;Blog">
<meta property="og:description" content="个人网站，学习记录，面试记录和经验总结、互联网中一块属于自己的小窝">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="QingQiu">
<meta property="article:tag" content="博客，学习，成长">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://zuofw.github.io/page/4/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>QingQiu'Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>


<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">QingQiu'Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">清秋的博客</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-fa fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-fa fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-fa fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-fa fa-archive"></i>归档</a>

  </li>
        <li class="menu-item menu-item-github">

    <a href="https://github.com/Zuofw" rel="noopener" target="_blank"><i class="fa fa-fw fa-fab fa-github"></i>Github</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zuofw.github.io/2024/04/23/25/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="QingQiu">
      <meta itemprop="description" content="个人网站，学习记录，面试记录和经验总结、互联网中一块属于自己的小窝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="QingQiu'Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/23/25/" class="post-title-link" itemprop="url">train</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-04-23 13:39:25" itemprop="dateCreated datePublished" datetime="2024-04-23T13:39:25+08:00">2024-04-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-05-01 20:56:27" itemprop="dateModified" datetime="2024-05-01T20:56:27+08:00">2024-05-01</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.5k</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Tigs:</p>
<ol>
<li>相同的application文件优先使用公共的配置</li>
</ol>
<h2 id="一些没什么用的小概念"><a href="#一些没什么用的小概念" class="headerlink" title="一些没什么用的小概念"></a>一些没什么用的小概念</h2><ul>
<li>并发量：同一时间内，系统中同时处理的用户请求数</li>
<li>响应时间：系统处理一个请求所需的时间</li>
<li>吞吐量：系统在给定时间内处理处理的业务请求数量</li>
<li>QPS(Queries Per Second) 表示系统每秒钟处理的请求数量</li>
<li>TPS(Transactions Per Second ) 表示系统每秒钟完成的事务数量</li>
</ul>
<h2 id="Gateway-网关负责分发前端请求"><a href="#Gateway-网关负责分发前端请求" class="headerlink" title="Gateway 网关负责分发前端请求"></a>Gateway 网关负责分发前端请求</h2><p>使用分布式锁来解决缓存击穿</p>
<ul>
<li><strong>以下是要自己完成的：</strong><ol>
<li>使用Spring Security和GateWay完成路由转发和认证</li>
<li>使用kafka或rocketmq<br>Redis作为缓存</li>
</ol>
</li>
<li>缓存问题：<ol>
<li>每天的用户很多但是用户每天使用的次数很少，同时会员的信息涉及的表很多<ul>
<li>解决：使用本地缓存，因为每个会员使用次数很少，一分钟有效，</li>
<li>问题:fullgc频繁，导致短时间内大量请求失败，因为缓存时间很短，所以大量的新生代出现，引起频繁的gc，然后大量放入老年代引起fullgc ， 解决：不用本地缓存，而是用线程本地变量，放在内存中。</li>
</ul>
</li>
</ol>
</li>
</ul>
<h2 id="Senta"><a href="#Senta" class="headerlink" title="Senta"></a>Senta</h2><ul>
<li>原理：生成反向sql</li>
<li>模式：<ol>
<li>AT模式：默认，添加undo_log,反向生成sql，回滚之后原来没数据的依然没有数据<ul>
<li>使用方法：<ol>
<li>建立undo_log表</li>
</ol>
</li>
</ul>
</li>
<li>TCC模式： try confirm/cancel 三个阶段的代码自己实现，Seata负责调度</li>
<li>SAGA模式：长事务解决方案，需要编写两个阶段的代码，需要一个JSON文件，可以异步执行</li>
<li>XA模式：适用于银行和金融，需要数据库支持XA协议<br>  try 之前的代码出现异常会直接结束，不会走finally</li>
</ol>
</li>
</ul>
<h2 id="如何处理多并发的买票"><a href="#如何处理多并发的买票" class="headerlink" title="如何处理多并发的买票"></a>如何处理多并发的买票</h2><ol>
<li>使用synchronized ，缺点：会导致卡住，只适合单机</li>
<li>使用Redis分布式锁，使用日期+车次来作为锁key，然后放入Redis中，如果拿到锁则继续执行，使用的使setIfAbsent(key,value,timeout),如果这个锁不存在则设置并且返回true，买到票之后删除key 缺点：如果线程执行时间超过了超时时间，也会导致超卖    <strong>对应Redis的命令是setnx</strong></li>
<li>使用Redisson看门狗，使用一个守护线程来关注超时间是，如果事务未完成但是锁即将过期则重置时间，如果事务结束则守护线程结束，lock.isHeldByCurrentThread来判断是否是当前线程的锁，缺点：Redis集群中Redis宕机，会导致获得得不到锁，然后新的线程向新的Redis主节点中获得锁，仍然可以获得锁 ， <strong>最常用</strong> ，Redisson中的锁在释放了之后Redis就查不到了！！！</li>
<li>使用红锁：只有拿到半数以上的同等地位的Redis的锁才算拿到锁，Redisson中也有自带的红锁，不常用， 缺点：性能问题，并且如果都得不到锁就都会等待了，尽量去尝试获得更多的锁来解决单机宕机问题</li>
</ol>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@RestController</span>
<span class="token annotation punctuation">@Slf4j</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RedisController</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Resource</span>
    <span class="token keyword">private</span> <span class="token class-name">RedissonClient</span> redissonClient<span class="token punctuation">;</span>

    <span class="token annotation punctuation">@PostMapping</span><span class="token punctuation">(</span><span class="token string">"/buy"</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">set</span><span class="token punctuation">(</span><span class="token class-name">String</span> ticket<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>
        <span class="token comment">//当前日期</span>
        <span class="token class-name">String</span> key <span class="token operator">=</span> ticket <span class="token punctuation">;</span>
        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"key:{}"</span><span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">RLock</span> lock <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>

            <span class="token comment">//获取锁</span>
            lock <span class="token operator">=</span> redissonClient<span class="token punctuation">.</span><span class="token function">getLock</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">//尝试加锁，最多等待100秒，上锁以后10秒自动解锁</span>
            <span class="token keyword">boolean</span> tryLock <span class="token operator">=</span> lock<span class="token punctuation">.</span><span class="token function">tryLock</span><span class="token punctuation">(</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">SECONDS</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//等待100秒，上锁以后10秒自动解锁</span>
            log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"tryLock:{}"</span><span class="token punctuation">,</span> tryLock<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">//模拟业务处理</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>tryLock<span class="token punctuation">)</span><span class="token punctuation">{</span>
                <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">10000</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//单位是毫秒</span>
                log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"购买成功"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">null</span> <span class="token operator">!=</span> lock <span class="token operator">&amp;&amp;</span> lock<span class="token punctuation">.</span><span class="token function">isHeldByCurrentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                    lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                <span class="token keyword">return</span> <span class="token string">"购买成功"</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"没拿到锁"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">return</span> <span class="token string">"购买失败"</span><span class="token punctuation">;</span>
<span class="token comment">//                throw new RuntimeException("没拿到锁");</span>
            <span class="token punctuation">}</span>


    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="使用Sentinal进行限流和降级"><a href="#使用Sentinal进行限流和降级" class="headerlink" title="使用Sentinal进行限流和降级"></a>使用Sentinal进行限流和降级</h3><ul>
<li>常见的限流算法：<ol>
<li>静态窗口限流：每秒限制多少个请求，例如：第2.5会统计第2秒到现在的流量</li>
<li>动态窗口限流：滑动窗口，往前取1秒,例如：第2.5秒会统计第1.5秒到现在的请求数</li>
<li>漏桶限流：队列，请求全在队列中，出队是匀速的</li>
<li>令牌桶限流：放的是令牌，令牌就是计数，会有一个计数器匀速产生令牌,出队不是匀速的可以适应短时间内大量请求</li>
<li>令牌大闸：当令牌到达一定数量就不再产生新的令牌</li>
</ol>
</li>
</ul>
<h2 id="如何应对刷票"><a href="#如何应对刷票" class="headerlink" title="如何应对刷票"></a>如何应对刷票</h2><p>使用令牌大闸：令牌按照匀速生成，即使有再多的机器人刷票也会被领票的数量限制，判断令牌肯定比更新库存更快</p>
<ol>
<li>使用令牌锁，持有令牌锁的人才能对令牌进行操作</li>
<li>检测令牌数量，如果有就执行，没有就不能执行</li>
<li>不要立刻释放令牌锁，使用固定的时间来释放令牌锁，这样即使有机器人也得等待令牌锁的释放</li>
</ol>
<ul>
<li>同时也可以加入验证码来防止机器人刷票<br>优化：使用缓存加速令牌锁<br>将数据库查出来的令牌存在Redis中，每次对Redis中的令牌数量-1，只有当数量等于我们设定的阈值时再去更改数据库的令牌数量，所以需要在Redis中长期保持这个key</li>
</ul>
<h2 id="使用RocketMQ"><a href="#使用RocketMQ" class="headerlink" title="使用RocketMQ"></a>使用RocketMQ</h2><p>使用RocketMQ来完成<br>购票之后，将请求发送给RocketMQ，然后另一边去消费这个消息，并且进行数据库的增删改查，可以将请求直接转为String 发送，之后另一端pull然后转为需要的类，之后执行具体具体的逻辑</p>
<h2 id="纯手写"><a href="#纯手写" class="headerlink" title="纯手写"></a>纯手写</h2><ol>
<li>登录：<ul>
<li>使用gateway + SpringSecurity + JWT + Redis实现微服务登录</li>
<li>Mybatis+Mybatis-plus</li>
</ul>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zuofw.github.io/2024/04/14/28/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="QingQiu">
      <meta itemprop="description" content="个人网站，学习记录，面试记录和经验总结、互联网中一块属于自己的小窝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="QingQiu'Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/14/28/" class="post-title-link" itemprop="url">es</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-04-14 19:45:28" itemprop="dateCreated datePublished" datetime="2024-04-14T19:45:28+08:00">2024-04-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-10-09 14:14:17" itemprop="dateModified" datetime="2024-10-09T14:14:17+08:00">2024-10-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">分布式</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.3k</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Elasticsearch学习笔记"><a href="#Elasticsearch学习笔记" class="headerlink" title="Elasticsearch学习笔记"></a>Elasticsearch学习笔记</h1><h2 id="Analyzer"><a href="#Analyzer" class="headerlink" title="Analyzer"></a>Analyzer</h2><p>Analyzer是ES中的一个组件，用于将输入的文本转化为索引时锁使用的文本特征向量。将文本分解，然后转化为特定的文本特征。</p>
<h2 id="分片"><a href="#分片" class="headerlink" title="分片"></a>分片</h2><p>分片就是将索引内部的数据分割成多个部分的机制，用于分布、存储和管理索引的数据 。允许索引被拆分为多个物理或逻辑部分从而实现分布式存储和处理数据的能力</p>
<h1 id="面试常问："><a href="#面试常问：" class="headerlink" title="面试常问："></a>面试常问：</h1><ol>
<li>索引文档的过程：<br> 1. 协调节点默认使用文档ID参与计算，为路由提供合适的分片，转发请求<br> 2. 分片所在节点接收到请求之后，将请求写入内存缓冲区，定时refresh到文件系统缓存，经过这一步既可以被搜索到了，当Filesystem cache中的数据写入到磁盘中时，才会清除掉translog，这个过程叫做flush；<ol start="2">
<li>es的删除：es中的文件并没有删除，每个段都有一个.del文件，删除是在这里进行标志，该文档仍然能够匹配到，但是会在结果中被过滤掉，后续在执行merge(周期性的将较小的段合并为一个较大的段)操作时，会被彻底清除掉</li>
<li>更新：每次更新都是先标记旧的文档为已删除，重新建立一个文档，并通过版本号来区分</li>
<li>搜索过程：<ul>
<li>Query Then Fetch</li>
</ul>
<ol>
<li>查询广播到每一个分片，分片本地执行搜索，建立一个优先队列，搜索只能搜到文件缓存的内容，所以并不是完全实时的</li>
<li>分片返回优先队列中文档的ID和排序值给协调节点，协调节点合并结果并排序</li>
<li>协调节点确定要取回的文档，然后向对应分片发送请求，最后协调节点返回给客户端</li>
</ol>
</li>
<li>写过程：客户端选择一个node(作为协调节点）发请求，协调节点对文档进行路由，将请求转发给有这个文档的主分片的节点，主分片处理请求，并将将数据同步到副本中，之后协调节点根据完成状态，相应给客户端</li>
<li>读过程：协调节点根据doc id来查询，然后对doc id进行hash来确认到了哪个分片上，然后转发请求到对应的节点，使用负载均衡 来选取一个分片来处理，并转发给它，之后由这个节点来读取并返回给协调节点，协调节点返回给客户端</li>
<li>es相对于mongodb，mysql的优势：1.全文检索，相关性排名 2.近实时性3.分布式处理4.数据分析 缺点：不支持事务</li>
</ol>
</li>
</ol>
<ul>
<li>DSL查询：由es提供的基于JSON的DSL语句<ul>
<li>叶子查询：在特定字段中查询特定值</li>
<li>符合查询：以逻辑方式组合多个叶子查询或者更改叶子查询的行为方式</li>
<li>指定高亮字段：<pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">GET /</span><span class="token punctuation">{</span>索引库名<span class="token punctuation">}</span><span class="token selector">/_search</span>
<span class="token punctuation">{</span>
  <span class="token string">"query"</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>
    <span class="token string">"match"</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>
      <span class="token string">"搜索字段"</span><span class="token punctuation">:</span> <span class="token string">"搜索关键字"</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token selector">,
  "highlight":</span> <span class="token punctuation">{</span>
    <span class="token string">"fields"</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>
      <span class="token string">"高亮字段名称"</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>
        <span class="token string">"pre_tags"</span><span class="token punctuation">:</span> <span class="token string">"&lt;em&gt;"</span><span class="token punctuation">,</span>
        <span class="token string">"post_tags"</span><span class="token punctuation">:</span> <span class="token string">"&lt;/em&gt;"</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
</li>
<li>索引 :<img src="/2024/04/14/28/%E4%B8%8Emysql%E5%AF%B9%E6%AF%94.png" alt="|725"><ul>
<li>倒排索引和正排索引的区别：<ul>
<li>正排索引是词条分到文档中</li>
<li>倒排索引是给词条统计文档</li>
<li><img src="/2024/04/14/28/%E4%BA%8C%E8%80%85%E5%8C%BA%E5%88%AB.png" alt="|275"></li>
</ul>
</li>
<li>使用索引模板来加快索引的创建与属性设置</li>
<li>索引结构：倒排索引，使用分词，记录每一个分词出现的文档编号和在文档中出现的位置<ul>
<li><img src="/2024/04/14/28/%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95.jpg"></li>
<li>搜索模块，路由值时，</li>
</ul>
</li>
<li>索引搜索：<ul>
<li>当搜索请求不带路由值时，接收到请求的节点成为协调节点，之后会选择使用的分片，之后会转发请求到拥有这些分片的节点上，每个分片产生一部分的局部结果汇总给协调节点，由协调节点汇总并排序之后返回。</li>
<li>使用路由条件进行搜索时，会将请求转发，之后直接由选中的节点进行返回</li>
</ul>
</li>
<li>索引映射：<ul>
<li>相当于指定了索引字段的名字和能够存储的类型</li>
<li>常用的数据类型：long , integer,short,byte,double,date(date可以在后面加一个format字段来执行时间的格式转换),keyword(用于保存原始文本，不会进行分词处理，用于精确匹配)，boolean,geo_poinst经纬度类型，json格式(需要使用properties来指定内部对象的属性，实际存储时会使用 . 来表示层次结构)，lists(数组)</li>
<li>**<em>如何既能快速匹配，又能精确匹配?</em>**，给字段添加一个fields参数，然后在里面放一个keyword字段</li>
<li>在每一个字段的后面使用：”copy_to”:”复制出来的新字段名字” 可以做到复制这些字段的内容</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">PUT mysougoulog/_mapping</span> 
<span class="token punctuation">{</span>
  <span class="token string">"properties"</span><span class="token punctuation">:</span><span class="token punctuation">{</span>
      <span class="token string">"visitTime"</span><span class="token punctuation">:</span><span class="token punctuation">{</span>
        <span class="token string">"type"</span><span class="token punctuation">:</span><span class="token string">"date"</span><span class="token punctuation">,</span>
        <span class="token string">"format"</span><span class="token punctuation">:</span><span class="token string">"yyyy-MM-dd HH:mm:ss || epoch_millis"</span><span class="token punctuation">,</span>
        <span class="token string">"ignore_malformed"</span><span class="token punctuation">:</span>true # 这个字段类型不对时，不写入，但是不影响其他字段的写入
      <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token selector"># 二者兼得
PUT mysougoulog/_mapping</span> 
<span class="token punctuation">{</span>
    <span class="token string">"properties"</span><span class="token punctuation">:</span><span class="token punctuation">{</span>
        <span class="token string">"key"</span><span class="token punctuation">:</span><span class="token punctuation">{</span>
          <span class="token string">"type"</span><span class="token punctuation">:</span><span class="token string">"text"</span><span class="token punctuation">,</span>
          <span class="token string">"fields"</span><span class="token punctuation">:</span><span class="token punctuation">{</span>
            <span class="token string">"keyword"</span><span class="token punctuation">:</span><span class="token punctuation">{</span>
              <span class="token string">"type"</span><span class="token punctuation">:</span><span class="token string">"keyword"</span><span class="token punctuation">,</span>
              <span class="token string">"ignore_above"</span><span class="token punctuation">:</span>256 # 表示256个字符后面的内容被忽略，用来节省字段
            <span class="token punctuation">}</span>
          <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>文档：<ul>
<li>CRUD时如何控制并发：<ul>
<li>修改时，加上?if_seq_no = xx&amp;if_primary_term=xx来使用乐观锁来控制，这两个字段是可以查到的，Elastisearch不支持事务管理</li>
</ul>
</li>
<li>文本分析：<ul>
<li>文本分析需要经过&gt;=0个字符过滤器一个分词器，&gt;=0 个分词过滤器<ul>
<li>字符过滤器：对原始文档本进行转换，如去掉html标签</li>
<li>分词器：按照规则切分为单词，</li>
<li>分词过滤器：过滤掉一些没有用的词比如，的，删除停用词,也可进行分词的处理，如大小写转化，添加同义词</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>分词器：<ul>
<li>创建倒排索引时对文档进行分词，用户搜索时，对输入的内容进行分词</li>
<li>IK分词器：<ul>
<li>ik_smart 智能切分模式，粗粒度</li>
<li>ik_max_word：最细切分，细粒度</li>
</ul>
</li>
</ul>
</li>
<li><h2 id="数据：-搜索数据：-1-精确搜索：搜索内容不经过文本分析直接进行文本匹配，适用于非text类，一般用于keyword字段-2-全文检索：对检索内容和字段都会进行文本分析-3-经纬度搜索，可以指定某个区域，例如⚪-4-复合搜索：-布尔搜索：通过指定布尔逻辑条件来组织多条查询语句，同时满足整个布尔条件的才会被搜索出来-等等-父子关联-因为es会把数据折叠起来，使用点，所以当一个对象有多个相同的key时，不能进行搜索了，例如goods商品，里面存放商品id和生产时间，就会被折叠-警告：-避免使用对象数组-解决方法：使用嵌套对象-使用join字段来明确父子关系-聚集统计：用于分析索引和文档，类似于mysql中的聚集操作"><a href="#数据：-搜索数据：-1-精确搜索：搜索内容不经过文本分析直接进行文本匹配，适用于非text类，一般用于keyword字段-2-全文检索：对检索内容和字段都会进行文本分析-3-经纬度搜索，可以指定某个区域，例如⚪-4-复合搜索：-布尔搜索：通过指定布尔逻辑条件来组织多条查询语句，同时满足整个布尔条件的才会被搜索出来-等等-父子关联-因为es会把数据折叠起来，使用点，所以当一个对象有多个相同的key时，不能进行搜索了，例如goods商品，里面存放商品id和生产时间，就会被折叠-警告：-避免使用对象数组-解决方法：使用嵌套对象-使用join字段来明确父子关系-聚集统计：用于分析索引和文档，类似于mysql中的聚集操作" class="headerlink" title="数据：  - 搜索数据：      1. 精确搜索：搜索内容不经过文本分析直接进行文本匹配，适用于非text类，一般用于keyword字段      2. 全文检索：对检索内容和字段都会进行文本分析      3. 经纬度搜索，可以指定某个区域，例如⚪      4. 复合搜索：          - 布尔搜索：通过指定布尔逻辑条件来组织多条查询语句，同时满足整个布尔条件的才会被搜索出来          - 等等  - 父子关联:      - 因为es会把数据折叠起来，使用点，所以当一个对象有多个相同的key时，不能进行搜索了，例如goods商品，里面存放商品id和生产时间，就会被折叠 警告： 避免使用对象数组      - 解决方法：使用嵌套对象      - 使用join字段来明确父子关系  - 聚集统计：用于分析索引和文档，类似于mysql中的聚集操作"></a>数据：<br>  - 搜索数据：<br>      1. 精确搜索：搜索内容不经过文本分析直接进行文本匹配，适用于非text类，一般用于keyword字段<br>      2. 全文检索：对检索内容和字段都会进行文本分析<br>      3. 经纬度搜索，可以指定某个区域，例如⚪<br>      4. 复合搜索：<br>          - 布尔搜索：通过指定布尔逻辑条件来组织多条查询语句，同时满足整个布尔条件的才会被搜索出来<br>          - 等等<br>  - 父子关联:<br>      - 因为es会把数据折叠起来，使用点，所以当一个对象有多个相同的key时，不能进行搜索了，例如goods商品，里面存放商品id和生产时间，就会被折叠 <strong>警告：</strong> 避免使用对象数组<br>      - 解决方法：使用嵌套对象<br>      - 使用join字段来明确父子关系<br>  - 聚集统计：用于分析索引和文档，类似于mysql中的聚集操作</h2></li>
<li>集群：<ol>
<li>新集群的产生：master节点的职责主要包括集群、节点和索引的管理，不负责文档级别的管理，主节点和数据节点不是一个<ul>
<li>初始化投票配置：将配置文件中的候选节点写入投票配置，所有节点均可参与投票</li>
<li>选举主节点：超过半数就可成为主节点</li>
<li>发现集群中的其他节点，节点尝试连接主节点，连接上之后主节点把最新的状态发布到这些节点中</li>
<li>集群完成，对外启动统一的服务</li>
</ul>
</li>
<li>集群状态的发布过程:  <strong>删除或者新增节点时触发</strong><ul>
<li>主节点把最新的集群状态发送到每个节点上，每个节点将数据保存并向主节点发送确认响应</li>
<li>主节点接收到半数以上的确认消息，开始提交，发送给每个节点通知使用最新的集群状态，子节点接收后发送确认响应，所有的都确认即可完成发布</li>
<li>响应超过时间限制，则删除这个子节点</li>
</ul>
</li>
</ol>
</li>
<li>如何实现master选举？<ul>
<li>对于所有可以成为master的节点，根据nodeId来排序，每个节点把自己直到的节点排一次序，然后选出第一个节点，认为他是master节点，入股某个节点到达可以成为超过master节点的一半，那就成为了master节点</li>
</ul>
</li>
<li>脑裂问题：<ul>
<li>设置最小主节点设置，设置的值应该是集群中节点总数的一半 + 1</li>
</ul>
</li>
<li>读写一致：<ul>
<li>版本控制：每个文档在ES中都有一个版本号，每次被修改后，版本号会增加，获取文档时，会同时或者它的版本号，更新时可以指定这个版本号，如果版本号不匹配，更新操作就会被拒绝</li>
<li>刷新与同步：向ES中写入数据时，数据先被写入内存缓冲区，然后每隔一段时间刷新一次或者缓冲区满时被刷新到磁盘后就可以被搜索到了，但是没有被写入磁盘，之后定期同步到磁盘中，同步后就是持久化存储了</li>
<li>副本和分片:只有主节点可以写入数据，然后被复制到副本分片中，读取数据时可以从任何一个包含该数据的分片中获取</li>
<li>设置写入确认级别</li>
</ul>
</li>
<li>代码中使用:<img src="/2024/04/14/28/%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%811.png" alt="|575"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Test</span>
<span class="token keyword">void</span> <span class="token function">testMatchAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">{</span>
    <span class="token comment">// 1.创建Request</span>
    <span class="token class-name">SearchRequest</span> request <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SearchRequest</span><span class="token punctuation">(</span><span class="token string">"items"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 2.组织请求参数</span>
    request<span class="token punctuation">.</span><span class="token function">source</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">query</span><span class="token punctuation">(</span><span class="token class-name">QueryBuilders</span><span class="token punctuation">.</span><span class="token function">matchAllQuery</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 3.发送请求</span>
    <span class="token class-name">SearchResponse</span> response <span class="token operator">=</span> client<span class="token punctuation">.</span><span class="token function">search</span><span class="token punctuation">(</span>request<span class="token punctuation">,</span> <span class="token class-name">RequestOptions</span><span class="token punctuation">.</span><span class="token constant">DEFAULT</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 4.解析响应</span>
    <span class="token function">handleResponse</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">handleResponse</span><span class="token punctuation">(</span><span class="token class-name">SearchResponse</span> response<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">SearchHits</span> searchHits <span class="token operator">=</span> response<span class="token punctuation">.</span><span class="token function">getHits</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 1.获取总条数</span>
    <span class="token keyword">long</span> total <span class="token operator">=</span> searchHits<span class="token punctuation">.</span><span class="token function">getTotalHits</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>value<span class="token punctuation">;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"共搜索到"</span> <span class="token operator">+</span> total <span class="token operator">+</span> <span class="token string">"条数据"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 2.遍历结果数组</span>
    <span class="token class-name">SearchHit</span><span class="token punctuation">[</span><span class="token punctuation">]</span> hits <span class="token operator">=</span> searchHits<span class="token punctuation">.</span><span class="token function">getHits</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">SearchHit</span> hit <span class="token operator">:</span> hits<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 3.得到_source，也就是原始json文档</span>
        <span class="token class-name">String</span> source <span class="token operator">=</span> hit<span class="token punctuation">.</span><span class="token function">getSourceAsString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 4.反序列化并打印</span>
        <span class="token class-name">ItemDoc</span> item <span class="token operator">=</span> <span class="token class-name">JSONUtil</span><span class="token punctuation">.</span><span class="token function">toBean</span><span class="token punctuation">(</span>source<span class="token punctuation">,</span> <span class="token class-name">ItemDoc</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
<h2 id="MeiliSearch-gt-轻量级的ES"><a href="#MeiliSearch-gt-轻量级的ES" class="headerlink" title="MeiliSearch->轻量级的ES"></a>MeiliSearch-&gt;轻量级的ES</h2><p>ES虽然扩展性和实时性都比较好，但是中小型项目中，ES有些过剩，对设备的要求也比较高，可以使用MeiliSearch来替代。同时MeiliSearch本身就支持中文搜索，而无需配置</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zuofw.github.io/2024/04/11/19/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="QingQiu">
      <meta itemprop="description" content="个人网站，学习记录，面试记录和经验总结、互联网中一块属于自己的小窝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="QingQiu'Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/11/19/" class="post-title-link" itemprop="url">k8s</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-04-11 10:12:19" itemprop="dateCreated datePublished" datetime="2024-04-11T10:12:19+08:00">2024-04-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-07-19 16:43:54" itemprop="dateModified" datetime="2024-07-19T16:43:54+08:00">2024-07-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%BF%90%E7%BB%B4/" itemprop="url" rel="index"><span itemprop="name">运维</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>13</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>执行kubeadm 时报错，</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zuofw.github.io/2024/04/07/18/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="QingQiu">
      <meta itemprop="description" content="个人网站，学习记录，面试记录和经验总结、互联网中一块属于自己的小窝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="QingQiu'Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/07/18/" class="post-title-link" itemprop="url">MQ</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-04-07 10:07:18" itemprop="dateCreated datePublished" datetime="2024-04-07T10:07:18+08:00">2024-04-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-09-03 14:58:41" itemprop="dateModified" datetime="2024-09-03T14:58:41+08:00">2024-09-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">分布式</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.3k</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="面试常问："><a href="#面试常问：" class="headerlink" title="面试常问："></a>面试常问：</h1><h2 id="生产者出现堆积如何解决"><a href="#生产者出现堆积如何解决" class="headerlink" title="生产者出现堆积如何解决"></a>生产者出现堆积如何解决</h2><ol>
<li>增加消费者</li>
<li>优化消费者的处理速度</li>
<li>使用优先队列，优先处理优先级高的消息</li>
<li>消息压缩：如果网络带宽是瓶颈</li>
<li>升级设备</li>
<li>消息过滤：生产者端发送真正需要处理的消息</li>
<li>调整生产者的速度</li>
</ol>
<h2 id="生产消费过程中如果服务出现异常，如何恢复"><a href="#生产消费过程中如果服务出现异常，如何恢复" class="headerlink" title="生产消费过程中如果服务出现异常，如何恢复"></a>生产消费过程中如果服务出现异常，如何恢复</h2><ol>
<li>重试机制：</li>
<li>死信队列：将无法处理的消息放在一个特殊的队列中，由人工去处理或者特殊处理</li>
<li>备份和恢复：对于重要数据应该定期进行备份，当服务出现异常时，从备份中恢复数据。</li>
<li>服务降级</li>
<li>容错和冗余设计</li>
</ol>
<h2 id="AMQP协议"><a href="#AMQP协议" class="headerlink" title="AMQP协议"></a>AMQP协议</h2><ul>
<li>AMQ Model组件：<ol>
<li>Producer </li>
<li>Exchange 交换器，从Producer中收集消息并根据路由规则发送到对应的消息队列中</li>
<li>Queue 消息队列，存储消息，直到消息被安全的投递到了消费者</li>
<li>Binding 定义了 mq 和 exchange之间的关系，是路由表</li>
<li>Consumer</li>
</ol>
</li>
</ul>
<h2 id="RocketMQ"><a href="#RocketMQ" class="headerlink" title="RocketMQ"></a>RocketMQ</h2><p><a target="_blank" rel="noopener" href="https://javaguide.cn/high-performance/message-queue/rocketmq-questions.html">常见问题</a></p>
<p><img src="/2024/04/07/18/%E8%A7%92%E8%89%B2.png"></p>
<ol>
<li>生产者组-&gt;发送消息的一方<ul>
<li>消息的类型：<ol>
<li>普通消息：并发消息，并发消息没有顺序</li>
<li>分区有序消息:把一个Topic消息分为多个分区，保护和消费，分区内的消息就是队列，FIFO</li>
<li>全局有序：把一个Topic分区数设为1，所有的消息都支持FIFO</li>
<li>延迟消息：消息发送后，消费者不能立刻消费，需要等待</li>
<li>事务消息：涉及分布式事务，保证多个操作同时成功或者失败，消费者才能使用</li>
<li><img src="/2024/04/07/18/%E4%B8%8D%E5%90%8C%E6%B6%88%E6%81%AF%E7%89%B9%E7%82%B9.png"></li>
</ol>
</li>
<li>消息保证机制：<ol>
<li>客户端保证：重试机制和客户端容错(选择延迟较低的Broker来发送消息)</li>
<li>Broker保证</li>
</ol>
</li>
<li>消息发送流程:<ol>
<li>业务层调用Client 发送API业务代码</li>
<li>消息处理层：Client获取消息对象后进行参数检查，准备和封装</li>
<li>通信层：基于Netty封装的RPC通信</li>
</ol>
</li>
</ul>
</li>
<li>Topic：</li>
<li>消费者组： <ul>
<li>订阅关系：一个消费者组订阅一个Topic中的某一个Tag</li>
<li>消费模式：<ul>
<li>集群消费模式：同一个组中的消费者实例负载均衡的消费Topic中的消息，消费进度保存在Broker端，即使应用崩溃，消费进度也不会出错</li>
<li>广播消费：所有消息广播分发，全部的消费者实例可以消费整个Topic中的所有消息，消费进度保存子啊客户端文件中，适用于通知其他服务刷新缓存</li>
</ul>
</li>
<li>可靠消费保证：<ol>
<li>重试-死信机制：正常Topic遭遇消费失败后-&gt;消息被保存在重试Topic中-&gt;多次间隔时间进行重新消费后仍然失败-&gt;进入死信Topic，经由人工处理，不会再被消费者消费</li>
<li>Rebalance机制：重平衡， 用于在发生Broker掉线、Topic扩容和缩容、消费者扩容和缩容等变化时，自动感知并调整自身消费，以尽量减少甚至避免消息没有被消费。</li>
</ol>
</li>
<li>消费方式：<ol>
<li>pull 用户主动pull消息，自主管理位点，由用户代码来进行管理</li>
<li>push 自动pull消息，用户可直接使用，</li>
</ol>
</li>
<li>消费过滤，Broker端可以根据tag进行消费过滤，只返回满足的tag,broker端使用Hash过滤，客户端再进行一次Tag字符串过滤， 因为Hash过来吧可以快速过滤大量数据，但是存在Hash碰撞</li>
</ul>
</li>
</ol>
<ul>
<li>Namesrv集群：一个无状态的元数据管理，Namesrv之于RocketMQ等价于Zookeeper之于Kafka。Topic路由注册和管理、Broker注册和发现的管理者</li>
</ul>
<h1 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h1><p><a target="_blank" rel="noopener" href="https://javaguide.cn/high-performance/message-queue/rabbitmq-questions.html">常见问题</a></p>
<h2 id="RabbitMQ主要架构"><a href="#RabbitMQ主要架构" class="headerlink" title="RabbitMQ主要架构"></a>RabbitMQ主要架构</h2><p><img src="/2024/04/07/18/RabbitMQ%E6%9E%B6%E6%9E%84.png" alt="RabbitMQ架构"></p>
<ul>
<li><p>**<code>publisher</code>**：生产者，也就是发送消息的一方</p>
</li>
<li><p>**<code>consumer</code>**：消费者，也就是消费消息的一方</p>
</li>
<li><p>**<code>queue</code>**：队列，存储消息。生产者投递的消息会暂存在消息队列中，等待消费者处理</p>
</li>
<li><p>**<code>exchange</code>**：交换机，负责消息路由。生产者发送的消息由交换机决定投递到哪个队列。不会持久化数据</p>
</li>
<li><p>**<code>virtual host</code>**：虚拟主机，起到数据隔离的作用。每个虚拟主机相互独立，有各自的exchange、queue，也就是将exchange和queue进行分组</p>
</li>
</ul>
<h2 id="Spring中使用"><a href="#Spring中使用" class="headerlink" title="Spring中使用"></a>Spring中使用</h2><p>使用Spring AMQP来实现</p>
<h3 id="publisher"><a href="#publisher" class="headerlink" title="publisher"></a>publisher</h3><p>使用RabbitTemplate来发送消息</p>
<h3 id="consumer"><a href="#consumer" class="headerlink" title="consumer"></a>consumer</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Component</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SpringRabbitListener</span> <span class="token punctuation">{</span>
        <span class="token comment">// 利用RabbitListener来声明要监听的队列信息</span>
    <span class="token comment">// 将来一旦监听的队列中有了消息，就会推送给当前服务，调用当前方法，处理消息。</span>
    <span class="token comment">// 可以看到方法体中接收的就是消息体的内容</span>
    <span class="token annotation punctuation">@RabbitListener</span><span class="token punctuation">(</span>queues <span class="token operator">=</span> <span class="token string">"simple.queue"</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">listenSimpleQueueMessage</span><span class="token punctuation">(</span><span class="token class-name">String</span> msg<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"spring 消费者接收到消息：【"</span> <span class="token operator">+</span> msg <span class="token operator">+</span> <span class="token string">"】"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="交换机的类型："><a href="#交换机的类型：" class="headerlink" title="交换机的类型："></a>交换机的类型：</h2><h3 id="Fanout"><a href="#Fanout" class="headerlink" title="Fanout"></a><strong>Fanout</strong></h3><p>广播，将消息交给所有绑定到交换机的队列。我们最早在控制台使用的正是Fanout交换机<br>特点：</p>
<ol>
<li>可以有多个队列</li>
<li>每个队列都要绑定到Exchange</li>
<li>生产者发送的消息只能发送到交换机</li>
<li>交换机把消息发送给绑定过的所有队列</li>
<li>订阅队列的消费者都能拿到消息</li>
</ol>
<h3 id="Direct"><a href="#Direct" class="headerlink" title="Direct"></a><strong>Direct</strong></h3><p>订阅，基于RoutingKey（路由key）发送给订阅了消息的队列<br>特点：</p>
<ol>
<li>队列需要与交换机绑定，指定一个RountingKey</li>
<li>消息发送方发送时也需要指定RountingKey</li>
<li>Exchange把消息发送给RountingKey对应的队列</li>
</ol>
<h3 id="Topic"><a href="#Topic" class="headerlink" title="Topic"></a><strong>Topic</strong></h3><p>通配符订阅，与Direct类似，只不过RoutingKey可以使用通配符</p>
<ul>
<li><p><code>#</code>：匹配一个或多个词</p>
</li>
<li><p><code>*</code>：匹配不多不少恰好1个词<br>举例：</p>
</li>
<li><p><code>item.#</code>：能够匹配<code>item.spu.insert</code> 或者 <code>item.spu</code></p>
</li>
<li><p><code>item.*</code>：只能匹配<code>item.spu</code><br>与DIrect类似，但是可以使用通配符来进行队列绑定</p>
</li>
<li><p><strong>Headers</strong>：头匹配，基于MQ的消息头匹配，用的较少。</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zuofw.github.io/2024/03/30/44/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="QingQiu">
      <meta itemprop="description" content="个人网站，学习记录，面试记录和经验总结、互联网中一块属于自己的小窝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="QingQiu'Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/03/30/44/" class="post-title-link" itemprop="url">Netty</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-03-30 19:25:44" itemprop="dateCreated datePublished" datetime="2024-03-30T19:25:44+08:00">2024-03-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-10-01 17:26:48" itemprop="dateModified" datetime="2024-10-01T17:26:48+08:00">2024-10-01</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>6.4k</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>#todo </p>
<ul>
<li><input disabled type="checkbox"> 使用Netty替代springboot的tomcat作为服务器</li>
<li><input disabled type="checkbox"> 使用Netty替代websocket来通信</li>
<li><input disabled type="checkbox"> 更新一下一致性哈希算法，如何更高效，顺便加上解释</li>
</ul>
<h1 id="基本介绍和使用介绍"><a href="#基本介绍和使用介绍" class="headerlink" title="基本介绍和使用介绍"></a>基本介绍和使用介绍</h1><h2 id="I-x2F-O模型："><a href="#I-x2F-O模型：" class="headerlink" title="I/O模型："></a>I/O模型：</h2><ol>
<li>阻塞I/O BIO：程序向内核发起I/O调用，发起调用的线程就一直等待内核返回结果。如果使用BIO实现异步，只能使用多线程模型，会导致增加线程切换的开销。</li>
<li>同步非阻塞IO NIO：应用程序通过轮询的方式获取请求结果。</li>
<li>多路复用I/O：多个进程的I/O可以注册到一个复用器上(Selector)，如果Selector监听的所有的I/O内核缓冲区都没有可读数据，select调用会被阻塞，直到任意I/O在内核缓冲区中有刻度数据时，会立刻返回。并通知其他进程再次发起I/O，也就是使用一个线程监控多个IO操作。 </li>
<li>信号驱动I/O：进程预先告知内核，向内核注册一个信号处理函数，之后进程返回不阻塞，进程通过信号处理函数继续调用I/O读取数据。IO操作就绪后，操作系统会发送信号通知应用程序。 通知何时可以开始一个I/O操作</li>
<li>异步I/O AIO：应用程序发起IO操作之后，立刻返回，操作系统在IO操作执行后，会通知应用程序，应用程序无需轮询IO状态。 通知I/O操作何时结束</li>
</ol>
<ul>
<li>BIO和NIO的区别: <img src="/2024/03/30/44/BIOandNIO.png"></li>
<li>AIO-&gt;异步I/O</li>
</ul>
<h3 id="Reactor-模型"><a href="#Reactor-模型" class="headerlink" title="Reactor 模型"></a>Reactor 模型</h3><blockquote>
<p>是一种处理并发I/O操作的设计模式。核心思想是通过实践多路复用机制来管理多个I/O事件。<br>主要的组件：1. 事件多路分发器(负责监听多个I/O事件，将这些事件分发给相应的事件处理器)<br>2.事件处理器 3.事件分发器：将事件从多路分发器中分发到响应的处理器。</p>
</blockquote>
<h3 id="select、poll、epoll的区别"><a href="#select、poll、epoll的区别" class="headerlink" title="select、poll、epoll的区别"></a>select、poll、epoll的区别</h3><ol>
<li>select：将已连接的Socket都放在一个文件描述符集合中，然后调用select函数将文件描述集合拷贝到内核中，让内核来检查是否有网络事件发生，检查方式就是遍历文件描述符集合。</li>
<li>poll：与select区别是，不再使用BitMap来存储文件描述符，突破了个数上限</li>
<li>epoll：内核使用红黑树来关注待检测的Socket高效，使用事件驱动，内核维护了一个链表来记录就绪事件，只会将事件发生的Socket集合传递给应用程序吗，而不是轮询整个集合</li>
</ol>
<h2 id="如何解决对象创建和销毁问题"><a href="#如何解决对象创建和销毁问题" class="headerlink" title="如何解决对象创建和销毁问题"></a>如何解决对象创建和销毁问题</h2><ol>
<li>对象池服用技术</li>
<li>零拷贝技术：Netty在进行I/O读写时，直接使用DirectBuffer，从而直接避免了数据在堆内存和堆外内存之间的拷贝</li>
</ol>
<h3 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h3><blockquote>
<p>数据从读取到内核缓冲区，然后直接由内核缓冲区发送到网络。而不是拷贝到用户缓冲区域再拷贝到内核缓冲区进行发送。</p>
</blockquote>
<p>Netty零拷贝实现</p>
<ul>
<li>使用堆外内存，避免JVM堆内存到堆外内存的数据拷贝</li>
<li>CompositeByteBuf 类，可以组合多个 Buffer 对象合并成一个逻辑上的对象，避免通过传统内存拷贝的方式将几个 Buffer 合并成一个大的 Buffer。</li>
<li>通过 Unpooled.wrappedBuffer 可以将 byte 数组包装成 ByteBuf 对象，包装过程中不会产生内存拷贝。</li>
<li>ByteBuf.slice ，slice 操作可以将一个 ByteBuf 对象切分成多个 ByteBuf 对象，切分过程中不会产生内存拷贝，底层共享一个 byte 数组的存储空间。</li>
<li>Netty 使用 封装了transferTo() 方法 FileRegion，可以将文件缓冲区的数据直接传输到目标 Channel，避免内核缓冲区和用户态缓冲区之间的数据拷贝</li>
</ul>
<h3 id="Java中的IO模型"><a href="#Java中的IO模型" class="headerlink" title="Java中的IO模型"></a>Java中的IO模型</h3><ol>
<li>BIO java.io是BIO</li>
<li>NIO java.nio包是NIO的实现，实质上仍然是同步的，读写操作时非同步的，但是这些操作是由应用程序主动发起和处理的，所以仍然是同步的。</li>
<li>AIO java.nio.channels是NIO的实现</li>
</ol>
<h2 id="按照定义来说，Netty是一个异步的、事件驱动的、用来做高性能高可靠性的网络应用的框架"><a href="#按照定义来说，Netty是一个异步的、事件驱动的、用来做高性能高可靠性的网络应用的框架" class="headerlink" title="按照定义来说，Netty是一个异步的、事件驱动的、用来做高性能高可靠性的网络应用的框架"></a>按照定义来说，Netty是一个异步的、事件驱动的、用来做高性能高可靠性的网络应用的框架</h2><p>Netty相比于Tomcat，不需要遵循Serlet规范，可以最大化的发挥NIO的特性。<br>如果需要面向TCP的网络应用开发，那么Netty才是最佳选择</p>
<h3 id="三大组件"><a href="#三大组件" class="headerlink" title="三大组件"></a>三大组件</h3><ol>
<li>Channel &amp; Buffer</li>
<li>Selector</li>
<li>Bootstrap</li>
</ol>
<h4 id="逻辑架构"><a href="#逻辑架构" class="headerlink" title="逻辑架构"></a>逻辑架构</h4><p><img src="/2024/03/30/44/Netty%E6%95%B4%E4%BD%93%E9%80%BB%E8%BE%91.png"></p>
<ol>
<li>网络通信层：支持多种网络协议，当网络数据读取到内核缓冲区后，会触发各种网络事件，会分发给事件调度层进行处理。核心是<ul>
<li>BootStrap，负责Netty客户端的启动、初始化、服务器连接等过程</li>
<li>ServerBootStrap：用于服务端绑定本地端端口，会绑定Boss和Worker两个EventLoopGroup</li>
<li>Channle 通道，基于NIO更高层次的抽象吗</li>
</ul>
</li>
<li>事件调度层：通过Reactor线程模型对各种事件进行聚合处理。通过Selector主循环线程继承u洞中时间，实际业务处理逻辑是交由服务编排曾中的Handler解决的。<ul>
<li>EventLoopGroup（核心）：本质是一个<strong>线程池</strong>，主要负责接收I/O请求，并分配线程执行处理请求。通过创建不同的EventLoopGroup参数可以支持Reactor三种线程模型：<ul>
<li>单线程模型：Group中只包含一个EventLoop，Boss和Worker使用同一个Group</li>
<li>多线程：多个EventLoop，B和W使用同一个</li>
<li>主从多线程：多个EventLoop，B和W使用不同的Group</li>
</ul>
</li>
<li>EventLoop负责处理Channel生命周期中所有的I/O事件，一个EventLoopGroup包含一个或者多个EventLoop，一个EventLoop同一时间只会绑定一个Channel，Channel生命周期内可以和多个EventLoop进行多次绑定和解绑<img src="/2024/03/30/44/EventLoop.png"></li>
</ul>
</li>
<li>服务编排层：负责组装各种服务，是核心处理链。<ul>
<li>ChannelPipeline核心编排组件，负责组装各种ChannelHandler，I/O读写触发时，会依次调用Handler进行拦截和处理。</li>
<li>ChannelHandler完成具体的树decode和encode工作和处理公国。</li>
<li>ChannelHandlerContext：用于保存上下文，通过HandlerContext可以知道Pipeline和Handler的关联关系，包含Handler生命周期的所有事件。</li>
</ul>
</li>
</ol>
<h2 id="Bootstrap"><a href="#Bootstrap" class="headerlink" title="Bootstrap"></a>Bootstrap</h2><blockquote>
<p>Netty客户端的启动</p>
</blockquote>
<h2 id="ServerBootStrap"><a href="#ServerBootStrap" class="headerlink" title="ServerBootStrap"></a>ServerBootStrap</h2><blockquote>
<p>服务端启动，会绑定Boss和 Worker两个EventLoopGroup</p>
</blockquote>
<p>Boss线程会不断接受新的连接，然后将连接分给Worker去处理</p>
<h2 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h2><h3 id="常用的Channel实现类"><a href="#常用的Channel实现类" class="headerlink" title="常用的Channel实现类"></a>常用的Channel实现类</h3><ul>
<li>NioServerSocketChannel 异步 TCP 服务端。</li>
<li>NioSocketChannel 异步 TCP 客户端。</li>
<li>OioServerSocketChannel 同步 TCP 服务端。</li>
<li>OioSocketChannel 同步 TCP 客户端。</li>
<li>NioDatagramChannel 异步 UDP 连接。</li>
<li>OioDatagramChannel 同步 UDP 连接。</li>
</ul>
<h3 id="Channel与事件"><a href="#Channel与事件" class="headerlink" title="Channel与事件"></a>Channel与事件</h3><ul>
<li>channelRegistered：Channel创建后被注册后被注册</li>
<li>channelUnregistered：Channel创建后未注册或者从EventLoop取消注册</li>
<li>channelActive：Channel处于就绪状态，可以被读写</li>
<li>channelInactive：处于非就绪状态</li>
<li>channelRead：Channel可以从远端读取数据</li>
<li>channelReadComplete：Channel读取数据完成</li>
</ul>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul>
<li>ChannelFuture<ul>
<li>其 addListener()方法会注册一个ChannelFutureListener来等待通知</li>
</ul>
</li>
<li>ChannelHandler：事件处理的具体逻辑<ol>
<li>生存周期：handlerAddedChannelHandler被添加到ChannelPipeline中时被调用，handlerRemoved被被移除，exceptionCaught处理过程中在ChannelPipeline中有错误产生时。</li>
<li>ChannelInboundHandler-&gt;处理入站数据及状态变化。<ul>
<li>方法：<img src="/2024/03/30/44/ChannelInboundHandler.png"></li>
<li>SimpleChannelInboundHandler会自动释放资源</li>
<li><img src="/2024/03/30/44/ChannelOutboundHandler.png"></li>
</ul>
</li>
</ol>
</li>
<li>ChannelPipeline<ul>
<li>每建立一个新的Channel都会分配一个ChannelPipeline，不可修改</li>
<li>提供了 ChannelHandler 链的容器，channel被创建时会被分配到ChannelPipeline中，ChannelHandler会被安装到其中</li>
<li>流程： ChannelInitializer的实现被注册进ServerBootstrapy中</li>
<li>调用initChannel()方法， ChannelInitializer会在ChannelPipeline中安装一组自定义的ChannelHandler</li>
<li>ChannelInitializer将自己从 ChannelPipeline中移除<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token punctuation">.</span><span class="token function">childHandler</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ChannelInitializer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">SocketChannel</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                       <span class="token comment">//添加一个EchoServerHandle到子Channel的ChannelPipeline</span>
                        <span class="token comment">//ChannelInitializer是一个特殊的处理程序，用于帮助用户配置新的Channel</span>
                        <span class="token annotation punctuation">@Override</span>
                        <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">initChannel</span><span class="token punctuation">(</span><span class="token class-name">SocketChannel</span> socketChannel<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
                            <span class="token comment">//EchoServerHandle被标注为@Shareable，所以我们可以总是使用同样的实例</span>
                            <span class="token comment">//@Shareable表示一个ChannelHandler可以被多个Channel安全地共享</span>
                            <span class="token comment">//在哪标注的呢？在EchoServerHandle类上</span>
                            socketChannel<span class="token punctuation">.</span><span class="token function">pipeline</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span>serverHandle<span class="token punctuation">)</span><span class="token punctuation">;</span>
                        <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
</li>
<li>ChannerlHandlerContext接口<ol>
<li>用于管理关联的ChannelHandler和同一个pipeline中其他的Handler</li>
<li></li>
</ol>
</li>
<li>二者的联系和区别：<img src="/2024/03/30/44/PipeLine%E5%92%8CHandler%E7%9A%84%E5%8C%BA%E5%88%AB.png"><br>  通过使用作为参数传递到每个方法的 ChannelHandlerContext，事件可以被传递给当前ChannelHandler 链中的下一个 ChannelHandler。<ul>
<li>ChannelInboundHandler </li>
<li>SimpleChannelInboundHandler&lt; T &gt; T是要处理消息的Java类型，适用于只需要解码消息并处理逻辑<ul>
<li>channelRead0(ChannelHandlerContext,T)</li>
</ul>
</li>
</ul>
</li>
<li>BootStrap 引导类，用于为应用程序的网络层配置提供了容器<ol>
<li>Bootstrap 用于客户端 ，可以直接.connect来连接服务器，</li>
<li>ServerBootstrap 用于客户端，需要.connect(new  InetSocketAddress) 才能等待客户端的连接</li>
</ol>
</li>
<li>Channel接口：<ul>
<li>方法：</li>
<li><img src="/2024/03/30/44/Channel%E6%96%B9%E6%B3%95.png"></li>
<li>Channel的生命周期：ChannelUnregistered已创建但是没有注册到EventLoop中；已注册ChannelRegistered；ChannelActive处于活跃状态，已经连接到远程节点， ChannelInactive 没有连接到远程给节点。</li>
</ul>
</li>
<li>内置的传输<ol>
<li>NIO 非阻塞-&gt;基于选择器 <img src="/2024/03/30/44/Selector.png"><ul>
<li><img src="/2024/03/30/44/Selector%E6%B5%81%E7%A8%8B.png"></li>
</ul>
</li>
<li>Epoll -&gt; 基于JNI驱动的，速度更快，完全非阻塞的<ul>
<li>使用：EpollEventLoopGroup 和EpollServerSocketChannel.class</li>
</ul>
</li>
<li>OIO -&gt;阻塞流</li>
<li>Local-&gt;在VM内部通过管道进行本地传输</li>
<li>Embedded 测试ChannelHandler使用</li>
</ol>
</li>
<li>ByteBuf<ol>
<li>使用两个索引：readIndex和writerIndex，开始时，两个都位于开头。也就是队列</li>
<li>ByteBufHolder接口用来存储各种属性值。</li>
<li>Netty提供了两种ByteBufAllocator的实现：PooledByteBufAllocator和UnpooledByteBufAllocator。前者池化了ByteBuf的实例以提高性能并最大限度地减少内存碎片。后者不池化。</li>
<li>Unpooled缓冲区：静态工具类来创建未池化的ByteBuf实例<img src="/2024/03/30/44/Unpooled.png"></li>
<li></li>
</ol>
</li>
<li>RPC框架的调用流程<br><img src="/2024/03/30/44/RPC%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B.png"></li>
<li>解码器：ByteToMessageDecoder 编码器：MessageToByteEncoder实际上这两个实现了Handler</li>
<li>协议的支持，自己去看数，Netty实战</li>
</ul>
<h3 id="EventLoopGroup-事件调度层"><a href="#EventLoopGroup-事件调度层" class="headerlink" title="EventLoopGroup 事件调度层"></a>EventLoopGroup 事件调度层</h3><ul>
<li><input disabled type="checkbox"> 如何使用自定义线程池，如何确定线程池的参数<br>EventLoopGroup是一个线程池，负责接受I/O请求并分配线程执行处理请求。<br><img src="/2024/03/30/44/EventLoop%E5%92%8CChannel.png"></li>
</ul>
<ol>
<li>EventLoopGroup包含多个EventLoop</li>
<li>EventLoop用于处理Channel生命周期内的所有I/O事件</li>
<li>EventLoop同一时间只会与一个线程绑定，每个EventLoop处理多个Channel</li>
<li>Channel在生命周期内可以对EventLoop进行多次绑定和解绑</li>
</ol>
<h3 id="服务编排层"><a href="#服务编排层" class="headerlink" title="服务编排层"></a>服务编排层</h3><ul>
<li>ChannelPipeline<br>负责组装各种ChannelHandler，内部通过双向链表将不同的ChannelHandler链接起来，依次调用，对Channel中的数据进行拦截和处理。<br>ChannelPipeline是线程安全的，因为一个新的Channel都会绑定一个新的ChannelPipeline，一个ChannelPipeline关联一个EventLoop，然后一个EventLoop绑定一个线程<img src="/2024/03/30/44/%E8%BF%9B%E5%87%BA%E7%AB%99.png"></li>
<li>ChannelHandler &amp; ChannelHandlerContext<br><img src="/2024/03/30/44/ChannelHandler.png"><br>ChannelHandlerContext用于保存ChannelHanler的上下文，可以实现ChannelHandler之间的交互。<br>同时包含了ChannelHandler生命周期的所有事件。<br>使用方式：</li>
</ul>
<p>#todo </p>
<ul>
<li><input disabled type="checkbox"> 如何做，搜搜<br>如果ChannelHandler有一些通用的逻辑需要实现，那么就可以放在这里。</li>
</ul>
<h3 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h3><h2 id="Netty实现的一些有特色"><a href="#Netty实现的一些有特色" class="headerlink" title="Netty实现的一些有特色"></a>Netty实现的一些有特色</h2><h3 id="FastThreadLocal"><a href="#FastThreadLocal" class="headerlink" title="FastThreadLocal"></a>FastThreadLocal</h3><p>使用Object数组替代Entry数据，<code>Object[0]</code>存储的是一个<code>Set&lt;FastThreadLocal&lt;?&gt;&gt;</code>集合，1以后都是存value的数据，而不是使用键值对的方式实现。<br>set方法：</p>
<ol>
<li>找到index位置，设置新的value</li>
<li>将<strong>FastThreadLocal对象保存到待清理的Set中</strong><br>优点：</li>
<li>高效查找：可以直接通过数组下标获取，而且扩容不需要进行rehash</li>
<li>安全性更高：ThreadLocal有可能会造成内存泄漏，只能等待线程销毁，但是的线程池下只能主动检测，而FastThreadLocal则封装了FastThreadLocalRunnable，任务执行完成之后一定会执行<code>FastThreadLocal.removeAll()</code>，从而将Set中所有的对象都销毁。</li>
</ol>
<p>#todo </p>
<ul>
<li><input disabled type="checkbox"> 以下内容是新开的文章《深入浅出Netty：原理与源码解读》记得新开一篇文章</li>
<li><input disabled type="checkbox"> 看看能不能写个爬虫把这个文章爬下来，或者自己复制下来<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/grey-wolf/p/12017818.html">曹工杂谈：Spring boot应用，自己动手用Netty替换底层Tomcat容器 - 三国梦回 - 博客园 (cnblogs.com)</a><br><a target="_blank" rel="noopener" href="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Netty%20%e6%a0%b8%e5%bf%83%e5%8e%9f%e7%90%86%e5%89%96%e6%9e%90%e4%b8%8e%20RPC%20%e5%ae%9e%e8%b7%b5-%e5%ae%8c/00%20%e5%ad%a6%e5%a5%bd%20Netty%ef%bc%8c%e6%98%af%e4%bd%a0%e4%bf%ae%e7%82%bc%20Java%20%e5%86%85%e5%8a%9f%e7%9a%84%e5%bf%85%e7%bb%8f%e4%b9%8b%e8%b7%af.md">00 学好 Netty，是你修炼 Java 内功的必经之路 (lianglianglee.com)</a></li>
</ul>
<h1 id="深入和源码解读"><a href="#深入和源码解读" class="headerlink" title="深入和源码解读"></a>深入和源码解读</h1><h2 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h2><h3 id="单线程模型"><a href="#单线程模型" class="headerlink" title="单线程模型"></a>单线程模型</h3><p>所有的I/O操作都由一个线程完成，会造成积压</p>
<h3 id="多线程模型"><a href="#多线程模型" class="headerlink" title="多线程模型"></a>多线程模型</h3><p>业务逻辑交给多个线程进行处理</p>
<h3 id="主从多线程模型"><a href="#主从多线程模型" class="headerlink" title="主从多线程模型"></a>主从多线程模型</h3><p>MainReactor负责处理客户端的连接，SubReactor分配线程池中的线程处理连接生命周期内的所有的I/O模型</p>
<h2 id="Netty内部的逻辑流程"><a href="#Netty内部的逻辑流程" class="headerlink" title="Netty内部的逻辑流程"></a>Netty内部的逻辑流程</h2><p><img src="/2024/03/30/44/%E9%80%BB%E8%BE%91%E6%B5%81%E7%A8%8B.png"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zuofw.github.io/2024/03/30/46/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="QingQiu">
      <meta itemprop="description" content="个人网站，学习记录，面试记录和经验总结、互联网中一块属于自己的小窝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="QingQiu'Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/03/30/46/" class="post-title-link" itemprop="url">mybatis</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-03-30 14:37:46" itemprop="dateCreated datePublished" datetime="2024-03-30T14:37:46+08:00">2024-03-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-07-27 16:53:11" itemprop="dateModified" datetime="2024-07-27T16:53:11+08:00">2024-07-27</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>5.7k</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="面试常问"><a href="#面试常问" class="headerlink" title="面试常问:"></a>面试常问:</h2><ul>
<li>延迟加载提高加载效率：</li>
</ul>
<h3 id="Mybatis的缓存"><a href="#Mybatis的缓存" class="headerlink" title="Mybatis的缓存"></a>Mybatis的缓存</h3><ul>
<li>一级缓存：也即是本地缓存，是SqlSession级别的,读个sql语句之间不会共享缓存，使用@Transactional来生效，也就是说在一次事务中多次查询会使用到一级缓存<ul>
<li>默认开启，可以在配置中关闭<ol>
<li>当我们执行查询操作时，MyBatis会先去一级缓存中查找是否有之前查询过的数据。如果有，直接返回缓存中的数据；如果没有，去数据库查询数据，并将查询结果放入一级缓存中。  </li>
<li>当我们执行更新操作（包括insert、update、delete）时，MyBatis会清空一级缓存。这是为了保证缓存中的数据和数据库中的数据是一致的。  </li>
<li>当SqlSession结束或关闭时，一级缓存也就清空了。</li>
</ol>
</li>
<li>二级缓存:<ul>
<li>在mapper.xml上方加上<code>&lt;Cache&gt;&lt;/Cache&gt;</code> 即可</li>
<li>根据mapper.xml中命名空间来区分，是mapper级别的，只用当执行同一个mapper中的增改删语句时才会失效，增删改频繁时二级缓存基本失效，并且，微服务中多台服务中只有被调用的那一台的二级缓存才会删除，其余的不删除，造成不一致。</li>
</ul>
</li>
</ul>
</li>
<li>Springboot Cache，会缓存方法的返回值，但是同样也只能在一个节点生效，并且，@Cacheable不会主动刷新缓存，但是@CachePut会强制刷新缓存，并把新的缓存放入</li>
<li>共享的缓存！Redis 可以在配置文件中将springboot的缓存类型设置为Redis</li>
</ul>
<h3 id="和-的区别是什么？"><a href="#和-的区别是什么？" class="headerlink" title="#{} 和 ${} 的区别是什么？"></a>#{} 和 ${} 的区别是什么？</h3><ul>
<li><code>#{}</code> 是Propeties文件中的变量占位符，会被原样替换</li>
<li><code>${}</code>是sql的参数占位符，Mybatis会把他替换成 <code>?</code> 后续通过反射进行替换数据</li>
</ul>
<h3 id="xml-映射文件中，除了常见的-select、insert、update、delete-标签之外，还有哪些标签？"><a href="#xml-映射文件中，除了常见的-select、insert、update、delete-标签之外，还有哪些标签？" class="headerlink" title="xml 映射文件中，除了常见的 select、insert、update、delete 标签之外，还有哪些标签？"></a>xml 映射文件中，除了常见的 select、insert、update、delete 标签之外，还有哪些标签？</h3><h4 id="resultMap-定义查询结果的映射规则"><a href="#resultMap-定义查询结果的映射规则" class="headerlink" title="resultMap 定义查询结果的映射规则"></a>resultMap 定义查询结果的映射规则</h4><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>resultMap</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>userResultMap<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>User<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>user_id<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>username<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>user_name<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>password<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>user_password<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>email<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>user_email<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>bio<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>user_bio<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>resultMap</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="sql：定义可复用的SQL代码段"><a href="#sql：定义可复用的SQL代码段" class="headerlink" title="sql：定义可复用的SQL代码段"></a>sql：定义可复用的SQL代码段</h4><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>sql</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>userColumns<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span> ${alias}.id, ${alias}.username, ${alias}.password, ${alias}.email, ${alias}.bio <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>sql</span><span class="token punctuation">&gt;</span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>selectUsers<span class="token punctuation">"</span></span> <span class="token attr-name">resultMap</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>userResultMap<span class="token punctuation">"</span></span> <span class="token punctuation">&gt;</span></span>
  select
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>include</span> <span class="token attr-name">refid</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>userColumns<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>alias<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>user<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>include</span><span class="token punctuation">&gt;</span></span>
  from some_table user
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="parameterType-定义SQL语句的输入参数类型"><a href="#parameterType-定义SQL语句的输入参数类型" class="headerlink" title="parameterType 定义SQL语句的输入参数类型"></a>parameterType 定义SQL语句的输入参数类型</h4><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>insert</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>insertUser<span class="token punctuation">"</span></span> <span class="token attr-name">parameterType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>User<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
  insert into users (username, password, email, bio)
  values (#{username}, #{password}, #{email}, #{bio})
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>insert</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="resultType：定义-SQL-语句的输出结果类型。"><a href="#resultType：定义-SQL-语句的输出结果类型。" class="headerlink" title="resultType：定义 SQL 语句的输出结果类型。"></a><code>resultType</code>：定义 SQL 语句的输出结果类型。</h4><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>selectUsernames<span class="token punctuation">"</span></span> <span class="token attr-name">resultType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>string<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
  select username from users
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h4 id="association：定义一对一的关联关系。"><a href="#association：定义一对一的关联关系。" class="headerlink" title="association：定义一对一的关联关系。"></a><code>association</code>：定义一对一的关联关系。</h4><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>resultMap</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>userResultMap<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>User<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
  <span class="token comment">&lt;!-- ... --&gt;</span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>association</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>address<span class="token punctuation">"</span></span> <span class="token attr-name">javaType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Address<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>address_id<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>street<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>address_street<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>city<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>address_city<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>state<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>address_state<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>zip<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>address_zip<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>country<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>address_country<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>association</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>resultMap</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="collection：定义一对多的关联关系。"><a href="#collection：定义一对多的关联关系。" class="headerlink" title="collection：定义一对多的关联关系。"></a><code>collection</code>：定义一对多的关联关系。</h4><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>resultMap</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>userResultMap<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>User<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
  <span class="token comment">&lt;!-- ... --&gt;</span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>collection</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>posts<span class="token punctuation">"</span></span> <span class="token attr-name">ofType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Post<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>post_id<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>subject<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>post_subject<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>body<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>post_body<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>collection</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>resultMap</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="dynamic-标签如-if、choose、when、otherwise、trim、where、set：用于构建动态-SQL。"><a href="#dynamic-标签如-if、choose、when、otherwise、trim、where、set：用于构建动态-SQL。" class="headerlink" title="dynamic&nbsp;标签如&nbsp;if、choose、when、otherwise、trim、where、set：用于构建动态 SQL。"></a><code>dynamic</code>&nbsp;标签如&nbsp;<code>if</code>、<code>choose</code>、<code>when</code>、<code>otherwise</code>、<code>trim</code>、<code>where</code>、<code>set</code>：用于构建动态 SQL。</h4><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>findActiveBlogLike<span class="token punctuation">"</span></span> <span class="token attr-name">resultType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Blog<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
  SELECT * FROM BLOG WHERE state = 'ACTIVE' 
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>if</span> <span class="token attr-name">test</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>title != null<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
    AND title like #{title}
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>if</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>执行过程<ul>
<li>java程序加载config文件，创建SqlSessionFactory对象，之后通过SqlSessionFactory创建SqlSession对象，之后通过SqlSession对象执行映射配置文件中定义的SQL语句，最后通过SqlSession对象提交事务，关闭SqlSession对象</li>
<li><img src="/2024/03/30/46/%E5%88%86%E5%B1%82.png"></li>
</ul>
</li>
</ul>
<h3 id="Dao接口-Mapper接口-的原理"><a href="#Dao接口-Mapper接口-的原理" class="headerlink" title="Dao接口(Mapper接口)的原理"></a>Dao接口(Mapper接口)的原理</h3><h4 id="Dao中的方法，参数不同时，可以重载吗"><a href="#Dao中的方法，参数不同时，可以重载吗" class="headerlink" title="Dao中的方法，参数不同时，可以重载吗"></a>Dao中的方法，参数不同时，可以重载吗</h4><p>  Mapper中的方法<strong>可以</strong> 重载，使用的是全限定名 + 方法名 拼接的字符串作为key去匹配。 但是xml文件中的id只能指定一个，也即是重载的所有方法都是用一个sql语句，而这个sql语句我们可以使用动态sql来实现</p>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>getAllStu<span class="token punctuation">"</span></span> <span class="token attr-name">resultType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.pojo.Student<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
  select * from student
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>where</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>if</span> <span class="token attr-name">test</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>id != null<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
      id = #{id}
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>if</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>where</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">&gt;</span></span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>Dao接口的原理：<br>MyBatis运行时会使用JDK动态代理来为Dao生成代理proxy对象，代理对象会拦截接口方法，转而执行MappedStatement中的sql</p>
<h3 id="MyBatis的分页"><a href="#MyBatis的分页" class="headerlink" title="MyBatis的分页"></a>MyBatis的分页</h3><p>nihao</p>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>答：**(1)** MyBatis 使用 RowBounds 对象进行分页，它是针对 ResultSet 结果集执行的内存分页，而非物理分页；**(2)** 可以在 sql 内直接书写带有物理分页的参数来完成物理分页功能，**(3)** 也可以使用分页插件来完成物理分页。</p>
<h4 id="分页插件的原理"><a href="#分页插件的原理" class="headerlink" title="分页插件的原理"></a>分页插件的原理</h4><ol>
<li>插件设置一个ThreadLocal变量来存储分页参数</li>
<li>当执行查询时，MyBatis会调用所有注册的拦截器。</li>
<li>PageHelper 首先会保存原始的查询SQL，然后生成一个新的SQL，这个新的SQL在原始的SQL基础上添加了LIMIT和OFFSET</li>
<li>PageHelper 将新的SQL替换成原始的SQL然后执行</li>
<li>最后PageHelper会清除ThreadLocal中变量，避免内存泄漏</li>
</ol>
<h3 id="MyBatis动态sql是什么的，有哪些，原理"><a href="#MyBatis动态sql是什么的，有哪些，原理" class="headerlink" title="MyBatis动态sql是什么的，有哪些，原理"></a>MyBatis动态sql是什么的，有哪些，原理</h3><h4 id="常用的动态sql标签"><a href="#常用的动态sql标签" class="headerlink" title="常用的动态sql标签"></a>常用的动态sql标签</h4><ul>
<li><code>&lt;if&gt;&lt;/if&gt;</code></li>
<li><code>&lt;where&gt;&lt;/where&gt;(trim,set)</code></li>
<li><code>&lt;choose&gt;&lt;/choose&gt;（when, otherwise）</code></li>
<li><code>&lt;foreach&gt;&lt;/foreach&gt;</code></li>
<li><code>&lt;bind/&gt;</code></li>
</ul>
<h4 id="执行原理"><a href="#执行原理" class="headerlink" title="执行原理"></a>执行原理</h4><p><strong>OGNL</strong> (Object-Graph Navigation Language)表达式，通过他可以在XML配置文件中引用Java对象和方法，在动态SQL中，常常使用其进行判断条件</p>
<ul>
<li>常见的OGNL语法：<pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">person.name #访问对象的属性
person.getName() # 调用对象的方法
persons.</span><span class="token punctuation">{</span>name<span class="token punctuation">}</span> # 获取persons对象的name属性
person.age &gt; 18 ? <span class="token string">'adult'</span> <span class="token punctuation">:</span> <span class="token string">'child'</span> # 条件表达式
person.agge + 1 # 算术表达式
person.age &gt; 18 &amp;&amp; person.gender == <span class="token string">'male'</span> # 逻辑表达式<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
<h4 id="MyBatis如何将sql执行结果封装为目标对象并返回"><a href="#MyBatis如何将sql执行结果封装为目标对象并返回" class="headerlink" title="MyBatis如何将sql执行结果封装为目标对象并返回"></a>MyBatis如何将sql执行结果封装为目标对象并返回</h4><ol>
<li>使用<code>&lt;resultMap&gt;</code> 标签去映射列表名和对象属性名之间的映射关系</li>
<li>使用sql列别名方式，将列名书写为对象属性名，例如：T_NAME AS NAME 对应的属性名是name，会忽略大小写<br>当映射关系建立之后，MyBatis会通过反射创建对象，然后给对象的属性一一赋值</li>
</ol>
<h3 id="MyBatis延迟加载的原理-待写"><a href="#MyBatis延迟加载的原理-待写" class="headerlink" title="MyBatis延迟加载的原理 待写"></a>MyBatis延迟加载的原理 待写</h3><p>MyBatis仅支持association关联对象和collection关联集合对象的延迟加载，association指的是1v1，collection是1v多</p>
<h4 id="Executor执行器"><a href="#Executor执行器" class="headerlink" title="Executor执行器"></a>Executor执行器</h4><ul>
<li>SimpleExecutor 每执行一次 update或select，就开启一个Statement对象，用完立刻关闭Statement对象</li>
<li>ReuseExecutor 执行update/select 以sql为key查找Statement对象，不存在就创建，使用后放在Map中，供下一次使用</li>
<li>BatchExecutor 执行update 时，将所有的sql都添加到批处理中，之后统一执行，缓存多个Statement对象，每个Statement对象都是等待sql添加之后，等待逐一执行</li>
</ul>
<h2 id="深入解读"><a href="#深入解读" class="headerlink" title="深入解读"></a>深入解读</h2><h3 id="基础支持层"><a href="#基础支持层" class="headerlink" title="基础支持层"></a>基础支持层</h3><ul>
<li>解析器模块<ol>
<li>DOM解析将xml的标签组织成一颗DOM树，将整个xml文档加载进内存</li>
<li>SAX基于时间模型的xml解析方式。加载一部分到内存中，并且当程序处理过程中满足条件时，会结束解析，不必解析剩余的xml内容。但是不支持层次关系和父子关系的保存</li>
</ol>
<ul>
<li>XPathParser：MyBatis提供的XPathParser类封装了XPath、Document、EntityResolver</li>
</ul>
</li>
</ul>
<h1 id="MyBatis-Plus"><a href="#MyBatis-Plus" class="headerlink" title="MyBatis Plus"></a><a target="_blank" rel="noopener" href="https://baomidou.com/introduce/">MyBatis Plus</a></h1><h2 id="一些插件"><a href="#一些插件" class="headerlink" title="一些插件"></a>一些插件</h2><h3 id="自定义填充字段"><a href="#自定义填充字段" class="headerlink" title="自定义填充字段"></a>自定义填充字段</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Component</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyBatisPlusDateHandler</span> <span class="token keyword">implements</span> <span class="token class-name">MetaObjectHandler</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">insertFill</span><span class="token punctuation">(</span><span class="token class-name">MetaObject</span> metaObject<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setFieldValByName</span><span class="token punctuation">(</span><span class="token string">"createTime"</span><span class="token punctuation">,</span> <span class="token class-name">LocalDateTime</span><span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> metaObject<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setFieldValByName</span><span class="token punctuation">(</span><span class="token string">"updateTime"</span><span class="token punctuation">,</span> <span class="token class-name">LocalDateTime</span><span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> metaObject<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">updateFill</span><span class="token punctuation">(</span><span class="token class-name">MetaObject</span> metaObject<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setFieldValByName</span><span class="token punctuation">(</span><span class="token string">"updateTime"</span><span class="token punctuation">,</span> <span class="token class-name">LocalDateTime</span><span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> metaObject<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="分页插件"><a href="#分页插件" class="headerlink" title="分页插件"></a>分页插件</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"dataBaseConfigurationByAdmin"</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DataBaseConfiguration</span> <span class="token punctuation">{</span>

    <span class="token comment">/**
     * 分页插件
     */</span>
    <span class="token annotation punctuation">@Bean</span>
    <span class="token annotation punctuation">@ConditionalOnMissingBean</span>
    <span class="token keyword">public</span> <span class="token class-name">MybatisPlusInterceptor</span> <span class="token function">mybatisPlusInterceptorByAdmin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">MybatisPlusInterceptor</span> interceptor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MybatisPlusInterceptor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        interceptor<span class="token punctuation">.</span><span class="token function">addInnerInterceptor</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">PaginationInnerInterceptor</span><span class="token punctuation">(</span><span class="token class-name">DbType</span><span class="token punctuation">.</span><span class="token constant">MYSQL</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> interceptor<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>使用时，只需要在自己定义的方法上加上一个Page类型的变量就可以进行分页查询了</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Page</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">&gt;</span></span> page <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Page</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 第1页，每页10条记录</span>
<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">&gt;</span></span> users <span class="token operator">=</span> userService<span class="token punctuation">.</span><span class="token function">selectUsers</span><span class="token punctuation">(</span>page<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zuofw.github.io/2024/03/30/39/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="QingQiu">
      <meta itemprop="description" content="个人网站，学习记录，面试记录和经验总结、互联网中一块属于自己的小窝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="QingQiu'Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/03/30/39/" class="post-title-link" itemprop="url">SpringSecurity和其他的认证相关</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-03-30 10:41:39" itemprop="dateCreated datePublished" datetime="2024-03-30T10:41:39+08:00">2024-03-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-06-16 09:52:18" itemprop="dateModified" datetime="2024-06-16T09:52:18+08:00">2024-06-16</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2k</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Security"><a href="#Security" class="headerlink" title="Security"></a>Security</h1><blockquote>
<p>RBAC模型： Role-Based Access Control 基于角色的权限控制访问控制，角色关联权限，角色又关联用户的授权方式<br>一个用户可以有多个角色，每一个角色又可以分配多个权限</p>
</blockquote>
<p>AuthenticationProvider是AuthenticationManager的一个组成部分，它负责处理特定类型的Authentication对象。AuthenticationManager可能会有多个AuthenticationProvider，每个AuthenticationProvider都会尝试验证传入的Authentication对象。</p>
<h4 id="使用流程："><a href="#使用流程：" class="headerlink" title="使用流程："></a>使用流程：</h4><p><a target="_blank" rel="noopener" href="https://shusheng007.top/2023/02/15/springsecurity/">参考</a></p>
<ol>
<li>controller</li>
<li>配置拦截器/Filter，继承OncePerRequestFilter，验证token</li>
<li>配置security，在这里可以指定自定义的provider<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span>
<span class="token annotation punctuation">@EnableWebSecurity</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">WebSecurityConfig</span> <span class="token punctuation">{</span>

    <span class="token annotation punctuation">@Bean</span>
    <span class="token keyword">public</span> <span class="token class-name">AuthenticationManager</span> <span class="token function">authenticationManager</span><span class="token punctuation">(</span><span class="token class-name">AuthenticationConfiguration</span> authConfig<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> authConfig<span class="token punctuation">.</span><span class="token function">getAuthenticationManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">//我们自定义的拦截器</span>
    <span class="token annotation punctuation">@Bean</span>
    <span class="token keyword">public</span> <span class="token class-name">JwtAuthenticationTokenFilter</span> <span class="token function">jwtAuthenticationTokenFilter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">JwtAuthenticationTokenFilter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Bean</span>
    <span class="token keyword">public</span> <span class="token class-name">SecurityFilterChain</span> <span class="token function">filterChain</span><span class="token punctuation">(</span><span class="token class-name">HttpSecurity</span> httpSecurity<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
        <span class="token comment">//基于token，所以不需要csrf防护</span>
        httpSecurity<span class="token punctuation">.</span><span class="token function">csrf</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">disable</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
                <span class="token comment">//基于token，所以不需要session</span>
                <span class="token punctuation">.</span><span class="token function">sessionManagement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sessionCreationPolicy</span><span class="token punctuation">(</span><span class="token class-name">SessionCreationPolicy</span><span class="token punctuation">.</span><span class="token constant">STATELESS</span><span class="token punctuation">)</span>
                <span class="token punctuation">.</span><span class="token function">and</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
                <span class="token punctuation">.</span><span class="token function">authorizeRequests</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
                <span class="token comment">//登录注册不需要认证</span>
                <span class="token punctuation">.</span><span class="token function">antMatchers</span><span class="token punctuation">(</span><span class="token string">"/user/login"</span><span class="token punctuation">,</span> <span class="token string">"/user/register"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">permitAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
                <span class="token comment">//除上面的所有请求全部需要鉴权认证</span>
                <span class="token punctuation">.</span><span class="token function">anyRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
                <span class="token punctuation">.</span><span class="token function">authenticated</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//禁用缓存</span>
        httpSecurity<span class="token punctuation">.</span><span class="token function">headers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">cacheControl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//将我们的JWT filter添加到UsernamePasswordAuthenticationFilter前面，因为这个Filter是authentication开始的filter，我们要早于它</span>
        httpSecurity<span class="token punctuation">.</span><span class="token function">addFilterBefore</span><span class="token punctuation">(</span><span class="token function">jwtAuthenticationTokenFilter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">UsernamePasswordAuthenticationFilter</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">return</span> httpSecurity<span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ol>
<h1 id="认证相关的概念和原理"><a href="#认证相关的概念和原理" class="headerlink" title="认证相关的概念和原理"></a>认证相关的概念和原理</h1><h3 id="Cookie被禁用了Session还能使用吗"><a href="#Cookie被禁用了Session还能使用吗" class="headerlink" title="Cookie被禁用了Session还能使用吗"></a>Cookie被禁用了Session还能使用吗</h3><p>可以使用，可以把SessionID放在请求路径中，同时可以对SessionID进行加密</p>
<h2 id="为什么Cookie无法防止CSRF攻击，而Token可以"><a href="#为什么Cookie无法防止CSRF攻击，而Token可以" class="headerlink" title="为什么Cookie无法防止CSRF攻击，而Token可以"></a>为什么Cookie无法防止CSRF攻击，而Token可以</h2><p>CSRF(<strong>Cross Site Request Forgery</strong>) 跨站请求伪造，Token存在localStorage浏览器本地缓存，然后每次发送请求携带这个即可。而Cookie是可以被别的获取的<br>XSS 跨站脚本攻击（Cross Site Scripting）</p>
<h2 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h2><h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><p>xxxxx.yyyyy.zzzz</p>
<h4 id="HEADER"><a href="#HEADER" class="headerlink" title="HEADER"></a>HEADER</h4><p>描述JWT的元数据，定义了生成签名的算法以及Token的类型</p>
<ul>
<li>typ(Type) ：令牌类型，也就是JWT</li>
<li>alg(Algorithm) ：签名算法</li>
</ul>
<h4 id="PAYLOAD"><a href="#PAYLOAD" class="headerlink" title="PAYLOAD"></a>PAYLOAD</h4><p>存放实际要传输的数据，包含Claims(声明，包含JWT的相关信息)</p>
<ul>
<li>注册声明：预定义的一些声明</li>
<li>公有声明：JWT签发方可以自定义的声明</li>
<li>私有声明：签发方因为项目中需要而自定义的声明</li>
</ul>
<h4 id="SIGNATURE-签名"><a href="#SIGNATURE-签名" class="headerlink" title="SIGNATURE (签名)"></a>SIGNATURE (签名)</h4><p>通过Payload和Header和Secret是哟个Header中指定的签名算法<br>用于防止JWT被篡改<br>这个签名的生成需要用到：</p>
<ul>
<li>Header + Payload。</li>
<li>存放在服务端的密钥(一定不要泄露出去)。</li>
<li>签名算法。</li>
</ul>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><h2 id="SSO-单点登录"><a href="#SSO-单点登录" class="headerlink" title="SSO 单点登录"></a>SSO 单点登录</h2><h2 id="OAuth-2-0"><a href="#OAuth-2-0" class="headerlink" title="OAuth 2.0"></a>OAuth 2.0</h2><h2 id="权限设计"><a href="#权限设计" class="headerlink" title="权限设计"></a>权限设计</h2><h3 id="RBAC"><a href="#RBAC" class="headerlink" title="RBAC"></a>RBAC</h3><p>基于角色的权限控制</p>
<h3 id="ABAC"><a href="#ABAC" class="headerlink" title="ABAC"></a>ABAC</h3><p>基于属性的控制访问</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zuofw.github.io/2024/03/17/19/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="QingQiu">
      <meta itemprop="description" content="个人网站，学习记录，面试记录和经验总结、互联网中一块属于自己的小窝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="QingQiu'Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/03/17/19/" class="post-title-link" itemprop="url">TVM</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-03-17 18:50:19" itemprop="dateCreated datePublished" datetime="2024-03-17T18:50:19+08:00">2024-03-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-03-18 23:10:01" itemprop="dateModified" datetime="2024-03-18T23:10:01+08:00">2024-03-18</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>158</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h2><p>TVM（Tensor Virtual Machine，张量虚拟机）是一个开源的、端到端的机器学习编译器框架，旨在将机器学习算法自动编译成可供下层硬件执行的机器语言，从而利用多种类型的算力。也就是将深度学习模型进行高效推理、内存管理与线程调度优化后，再通过LLVM部署在CPU、GPU、FPGA、ARM等硬件设备上。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zuofw.github.io/2024/03/06/23/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="QingQiu">
      <meta itemprop="description" content="个人网站，学习记录，面试记录和经验总结、互联网中一块属于自己的小窝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="QingQiu'Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/03/06/23/" class="post-title-link" itemprop="url">6.S081</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-03-06 14:26:23" itemprop="dateCreated datePublished" datetime="2024-03-06T14:26:23+08:00">2024-03-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-03-17 19:08:12" itemprop="dateModified" datetime="2024-03-17T19:08:12+08:00">2024-03-17</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>5.1k</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="OS"><a href="#OS" class="headerlink" title="OS"></a>OS</h1><ol>
<li><p>系统调用跳到内核与标准的函数调用跳到另一个函数相比，区别是什么？</p>
<p> Kernel的代码总是有特殊的权限。当机器启动Kernel时，Kernel会有特殊的权限能直接访问各种各样的硬件，例如磁盘。而普通的用户程序是没有办法直接访问这些硬件的。所以，当你执行一个普通的函数调用时，你所调用的函数并没有对于硬件的特殊权限。然而，如果你触发系统调用到内核中，内核中的具体实现会具有这些特殊的权限，这样就能修改敏感的和被保护的硬件资源，比如访问硬件磁盘。我们之后会介绍更多有关的细节。</p>
</li>
<li><p>Kernel<br> 内核使用CPU提供的硬件保护机制来确保每个在用户空间执行的进程只能访问它自己的内存。内核程序的执行拥有操控硬件的权限，它需要实现这些保护；而用户程序执行时没有这些特权。当用户程序调用系统调用时，硬件会提升权限级别，并开始执行内核中预先安排好的函数。<br> <img src="/2024/03/06/23/Kernel.png" alt="Kernel"></p>
</li>
<li><p>xv6提供的系统调用<br> <a target="_blank" rel="noopener" href="https://xv6.dgs.zone/tranlate_books/book-riscv-rev1/c1/s0.html">看文档</a></p>
</li>
<li><p>Shell 是一个普通的进程，是一个用户程序，用户使用Shell来与系统调用进行交互</p>
</li>
</ol>
<h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><ol>
<li>进程由 用户空间内存(指令、数据和堆栈)和对内核私有的每个进程状态组成</li>
<li>Xv6 采用分时进程，等待执行中的进程集合切换可用的CPU，当进程没有执行时，xv6会保存他的CPU寄存器，并在下一次运行时恢复，使用进程id或PID标示进程、</li>
</ol>
<h3 id="I-x2F-O"><a href="#I-x2F-O" class="headerlink" title="I/O"></a>I/O</h3><ol>
<li>文件描述符是一个小整数(small integer)，表示进程可以读取或写入的由内核管理的对象</li>
<li>进程从文件描述符0读取（标准输入），将输出写入文件描述符1（标准输出），并将错误消息写入文件描述符2（标准错误）。</li>
<li>管道：作为一对文件描述符公开给进程的小型内核缓冲区，一个用于读取，一个用于写入。将数据写入管道的一端使得这些数据可以从管道的另一端读取。管道为进程提供了一种通信方式。</li>
</ol>
<ul>
<li><p>首先，管道会自动清理自己；在文件重定向时，shell使用完<code>/tmp/xyz</code>后必须小心删除</p>
</li>
<li><p>其次，管道可以任意传递长的数据流，而文件重定向需要磁盘上足够的空闲空间来存储所有的数据。</p>
</li>
<li><p>第三，管道允许并行执行管道阶段，而文件方法要求第一个程序在第二个程序启动之前完成。</p>
</li>
<li><p>第四，如果实现进程间通讯，管道的<strong>阻塞</strong>式读写比文件的非阻塞语义更高效。</p>
</li>
</ul>
<h3 id="操作系统架构"><a href="#操作系统架构" class="headerlink" title="操作系统架构"></a>操作系统架构</h3><p>操作系统必须满足三个要求：多路复用、隔离和交互。</p>
<ol>
<li>隔离：禁止应用程序直接访问敏感的硬件资源，将资源抽象成服务。提供系统调用</li>
<li>用户想要执行内核函数必须由用户模式过渡到管理模式</li>
</ol>
<ul>
<li>整个操作系统都驻留在内核中，这样所有系统调用的实现都以管理模式运行。这种组织被称为<strong>宏内核（monolithic kernel）</strong>。<ul>
<li>缺点是操作系统不同部分之间的接口通常很复杂（正如我们将在本文的其余部分中看到的），因此操作系统开发人员很容易犯错误。在宏内核中，一个错误就可能是致命的，因为管理模式中的错误经常会导致内核失败。如果内核失败，计算机停止工作，因此所有应用程序也会失败。计算机必须重启才能再次使用。</li>
</ul>
</li>
<li>微内核<ul>
<li>操作系统设计者可以最大限度地减少在管理模式下运行的操作系统代码量，并在用户模式下执行大部分操作系统。这种内核组织被称为<strong>微内核（microkernel）</strong></li>
<li>文件系统作为用户级进程运行。作为进程运行的操作系统服务被称为服务器。为了允许应用程序与文件服务器交互，内核提供了允许从一个用户态进程向另一个用户态进程发送消息的进程间通信机制。</li>
</ul>
</li>
<li>进程<ul>
<li>进程抽象给程序提供了一种错觉，即它有自己的专用机器。进程为程序提供了一个看起来像是私有内存系统或地址空间的东西，其他进程不能读取或写入。</li>
</ul>
</li>
<li>启动过程： 初始化自己并运行一个存储在只读内存中的引导加载程序。引导加载程序将xv6内核加载到内存中。然后，在机器模式下，中央处理器从<code>_entry</code>&nbsp;(<strong><em>kernel/entry.S</em></strong>:6)开始运行xv6。Xv6启动时页式硬件（paging hardware）处于禁用模式：也就是说虚拟地址将直接映射到物理地址。</li>
</ul>
<h3 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h3><p>页表是操作系统为每个进程提供私有地址空间和内存的机制。页表决定了内存地址的含义，以及物理内存的哪些部分可以访问。</p>
<h2 id="Lab"><a href="#Lab" class="headerlink" title="Lab"></a>Lab</h2><h3 id="lab1"><a href="#lab1" class="headerlink" title="lab1"></a>lab1</h3><p>推荐使用2021版的官方教程，2020的我打开不了<br>不建议在root用户下进行</p>
<h4 id="sleep-easy"><a href="#sleep-easy" class="headerlink" title="sleep (easy)"></a>sleep (easy)</h4><p><strong>实现xv6的UNIX程序</strong><code>sleep</code><strong>：您的</strong><code>sleep</code><strong>应该暂停到用户指定的计时数。一个滴答(tick)是由xv6内核定义的时间概念，即来自定时器芯片的两个中断之间的时间。您的解决方案应该在文件user/sleep.c中</strong></p>
<p>思路：<strong>先查看系统调用的代码</strong></p>
<ol>
<li>引入头文件，即&nbsp;<code>kernel/types.h</code>&nbsp;声明类型的头文件和&nbsp;<code>user/user.h</code>&nbsp;声明系统调用函数和&nbsp;<code>ulib.c</code>&nbsp;中函数的头文件。</li>
<li>编写&nbsp;<code>main(int argc,char* argv[])</code>&nbsp;函数。其中，参数&nbsp;<code>argc</code>&nbsp;是命令行总参数的个数，参数&nbsp;<code>argv[]</code>&nbsp;是&nbsp;<code>argc</code>&nbsp;个参数，其中第 0 个参数是程序的全名，其他的参数是命令行后面跟的用户输入的参数。</li>
<li>在Makefile中加入$U/_sleep<br>参考答案:<pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">//引入type定义和系统调用文件
#include "kernel/types.h"
#include "user/user.h"

//编写main函数
//argc 是shell接受的参数个数，argv指向对应的参数
//argv[0] 始终指向函数的全名
int main(int argc, char **argv)</span> <span class="token punctuation">{</span>
    <span class="token selector">//shell 中应该输入 sleep +参数，所以只接受一个参数, argc 应为 2
    if(argc != 2)</span> <span class="token punctuation">{</span>
        //write（int fd <span class="token punctuation">,</span>char *buf<span class="token punctuation">,</span> int n<span class="token punctuation">)</span>
        // fd是文件描述符 0 是标准输入，1标准输出<span class="token punctuation">,</span>2是标准错误
        //buf 存放要写入写出的字符数组
        // n 是要传输的字节数
        <span class="token function">write</span><span class="token punctuation">(</span>2<span class="token punctuation">,</span><span class="token string">"Usage: sleep time\n"</span><span class="token punctuation">,</span> <span class="token function">strlen</span><span class="token punctuation">(</span><span class="token string">"Usage: sleep time\n"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        //<span class="token function">exit</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span> 0 标示正常退出，非0藐视错误退出
        <span class="token function">exit</span><span class="token punctuation">(</span>1<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    //使用atoi来转为int型
    <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token function">atoi</span><span class="token punctuation">(</span>argv[1]<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">exit</span><span class="token punctuation">(</span>0<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
Makefile:<pre class="line-numbers language-css" data-language="css"><code class="language-css">UPROGS=\
	$U/_cat\
	$U/_echo\
	$U/_forktest\
	$U/_grep\
	$U/_init\
	$U/_kill\
	$U/_ln\
	$U/_ls\
	$U/_mkdir\
	$U/_rm\
	$U/_sh\
	$U/_stressfs\
	$U/_usertests\
	$U/_grind\
	$U/_wc\
	$U/_zombie\
	$U/_sleep\ # 这是我们要写的<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
单元测试:</li>
<li>make qemu 之后在shell中 sleep 100 看看是否停顿， 如果make qemu 报错，可能是没有 自动编译，建议重新启动</li>
<li>不启动xv6,在xv6-labs-2021 路径下使用： ./grade-lab-util sleep              —-sleep可替换为其他待测的，也可以不加，直接把全部实验代码都进行测，权限不够自己sudo, 报错了可能没安装python3</li>
</ol>
<h4 id="pingpong-Easy"><a href="#pingpong-Easy" class="headerlink" title="pingpong (Easy)"></a>pingpong (Easy)</h4><blockquote>
<p><strong>编写一个使用UNIX系统调用的程序来在两个进程之间“ping-pong”一个字节，请使用两个管道，每个方向一个。父进程应该向子进程发送一个字节;子进程应该打印“<code>&lt;pid&gt;: received ping</code>”，其中<code>&lt;pid&gt;</code>是进程ID，并在管道中写入字节发送给父进程，然后退出;父级应该从读取从子进程而来的字节，打印“<code>&lt;pid&gt;: received pong</code>”，然后退出。您的解决方案应该在文件_user/pingpong.c_中。</strong></p>
</blockquote>
<p>思路：</p>
<ol>
<li>使用pipe来建立管道</li>
<li>fork来建立子进程并用来区分父进程和子进程</li>
<li>getpid来获取进程pid</li>
<li>read 和 write来进行读写</li>
<li>Makefile <pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">// pingpong.c 
#include "kernel/types.h"
#include "user/user.h"
#include "stddef.h"

//
int main(int argc, char **argv)</span> <span class="token punctuation">{</span> // argc是输入的参数个数，argv指向对应的参数
    //定义两个pipe
    int pp2c[2]<span class="token punctuation">,</span>pc2p[2]<span class="token punctuation">;</span> // p parent to child
    //p[0] 是文件描述符0<span class="token punctuation">,</span> 0 是输入端，1是输出端
    <span class="token function">pipe</span><span class="token punctuation">(</span>pp2c<span class="token punctuation">)</span><span class="token punctuation">;</span> //父进程 -&gt; 子进程
    <span class="token function">pipe</span><span class="token punctuation">(</span>pc2p<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token selector">//使用fork来判断子进程和父进程
    if(fork() != 0 )</span> <span class="token punctuation">{</span> //父进程
        //<span class="token function">write</span><span class="token punctuation">(</span>文件描述符<span class="token punctuation">,</span>指针，字节数<span class="token punctuation">)</span>
        <span class="token function">write</span><span class="token punctuation">(</span>pp2c[1]<span class="token punctuation">,</span><span class="token string">"!"</span><span class="token punctuation">,</span>1<span class="token punctuation">)</span><span class="token punctuation">;</span> //父进程向子进程发出一个字节
        char buf <span class="token punctuation">;</span> //待读入缓冲区<span class="token punctuation">,</span>用于存储
        <span class="token function">read</span><span class="token punctuation">(</span>pc2p[0]<span class="token punctuation">,</span>&amp;buf<span class="token punctuation">,</span>1<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d: received pong\n"</span><span class="token punctuation">,</span><span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">wait</span><span class="token punctuation">(</span>0<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token selector">else</span> <span class="token punctuation">{</span>
        char buf<span class="token punctuation">;</span>
        //从父进程读入
        <span class="token function">read</span><span class="token punctuation">(</span>pp2c[0]<span class="token punctuation">,</span>&amp;buf<span class="token punctuation">,</span>1<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d: received ping\n"</span><span class="token punctuation">,</span><span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        //子进程重新发送给父进程
        <span class="token function">write</span><span class="token punctuation">(</span>pc2p[1]<span class="token punctuation">,</span>&amp;buf<span class="token punctuation">,</span>1<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">exit</span><span class="token punctuation">(</span>0<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ol>
<h4 id="prime"><a href="#prime" class="headerlink" title="prime"></a>prime</h4><p>思路：使用筛法，每次输出一个素数之后，把这个素数的倍数删除，之后再重新写入pipe中供下一个子进程使用即可。注意回收文件描述符即可<br>注意: <strong>一定要使用子进程</strong> ，不使用子进程会导致阻塞致死</p>
<pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">#include "kernel/types.h"
#include "user/user.h"
#include "stddef.h" // 为了得到NULL

//将描述符重新定向
void mapping(int n , int pd[])</span> <span class="token punctuation">{</span>
    <span class="token function">close</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
    //dup会返回一个最小的未使用的文件描述符，然后我们close
    //了n，也就是会返回n<span class="token punctuation">,</span>之后会将这个描述符指向pd[n]所指向的文件
    <span class="token function">dup</span><span class="token punctuation">(</span>pd[n]<span class="token punctuation">)</span><span class="token punctuation">;</span>
    //再关闭pd 就实现了将pd[n] 重定向到n的操作
    <span class="token function">close</span><span class="token punctuation">(</span>pd[0]<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">close</span><span class="token punctuation">(</span>pd[1]<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token selector">void primes()</span> <span class="token punctuation">{</span>
    //开始读入数据
    int current<span class="token punctuation">,</span>next<span class="token punctuation">;</span> //current来保存现在的数
    int fd[2]<span class="token punctuation">;</span>
    <span class="token selector">// 从0中读取数据，并写入current,读取字节长度为sizeof(int)
    if(read(0,&amp;current,sizeof(int)))</span> <span class="token punctuation">{</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"prime %d\n"</span><span class="token punctuation">,</span>current<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">pipe</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token selector">//开始筛选，每经历一个子进程就drop一些数据
        if(fork() == 0)</span> <span class="token punctuation">{</span>
            <span class="token function">mapping</span><span class="token punctuation">(</span>1<span class="token punctuation">,</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>//定向到写入端
            <span class="token selector">//重复从1中读入，判断是否是current的倍数
            while(read(0,&amp;next,sizeof(int)))</span> <span class="token punctuation">{</span>
                <span class="token selector">if(next % current != 0)</span> <span class="token punctuation">{</span>
                    <span class="token function">write</span><span class="token punctuation">(</span>1<span class="token punctuation">,</span>&amp;next<span class="token punctuation">,</span><span class="token function">sizeof</span><span class="token punctuation">(</span>int<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span> <span class="token selector">else</span> <span class="token punctuation">{</span>
            <span class="token function">wait</span><span class="token punctuation">(</span>NULL<span class="token punctuation">)</span><span class="token punctuation">;</span> //等待子进程结束
            //反复调用即可
            <span class="token function">mapping</span><span class="token punctuation">(</span>0<span class="token punctuation">,</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">primes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token selector">//0用来读取， 1用来写入
int main(int argc, char **argv)</span> <span class="token punctuation">{</span>
    int fd[2]<span class="token punctuation">;</span> //文件描述符
    //fd是共用的
    <span class="token function">pipe</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token selector">//fd[0]是读入端，也就是从pipe中读取字节，fd[1]是写入端，可以向pipe中写入
    if(fork() == 0)</span> <span class="token punctuation">{</span>
    //子进程写入 2 - 35
        <span class="token function">mapping</span><span class="token punctuation">(</span>1<span class="token punctuation">,</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>//将标准输出指向fd的写入端，也就是将输指向写入端
        <span class="token function">for</span><span class="token punctuation">(</span>int i = 2<span class="token punctuation">;</span> i &lt;= 35<span class="token punctuation">;</span> <span class="token selector">i ++)</span> <span class="token punctuation">{</span>
            //write 是向标准输出写入东西，标准输出已经指向fd[1]了，也就是向fd写入数据
                <span class="token function">write</span><span class="token punctuation">(</span>1<span class="token punctuation">,</span>&amp;i<span class="token punctuation">,</span><span class="token function">sizeof</span><span class="token punctuation">(</span>int<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token selector">else</span> <span class="token punctuation">{</span>
        <span class="token function">wait</span><span class="token punctuation">(</span>NULL<span class="token punctuation">)</span><span class="token punctuation">;</span>//等待子进程写完
        <span class="token comment">/**
         * 当调用 wait(NULL) 时，父进程会被阻塞，直到任意一个子进程终止。一旦子进程终止，wait(NULL) 函数会返回被终止的子进程的进程 ID（PID），并且如果提供了 status 参数，
         * 子进程的退出状态会存储在 status 中。
        */</span>
      <span class="token function">mapping</span><span class="token punctuation">(</span>0<span class="token punctuation">,</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>//将标准输入指向fd来进行读入
      <span class="token function">primes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">exit</span><span class="token punctuation">(</span>0<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zuofw.github.io/2024/03/06/38/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="QingQiu">
      <meta itemprop="description" content="个人网站，学习记录，面试记录和经验总结、互联网中一块属于自己的小窝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="QingQiu'Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/03/06/38/" class="post-title-link" itemprop="url">os</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-03-06 14:14:38" itemprop="dateCreated datePublished" datetime="2024-03-06T14:14:38+08:00">2024-03-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-08-07 16:04:28" itemprop="dateModified" datetime="2024-08-07T16:04:28+08:00">2024-08-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">计算机基础</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>9.6k</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="OS面试常问"><a href="#OS面试常问" class="headerlink" title="OS面试常问"></a>OS面试常问</h2><h3 id="编码问题"><a href="#编码问题" class="headerlink" title="编码问题"></a>编码问题</h3><p>ASCII码规定了128个字符的编码<br>Unicode 是⼀个很⼤的集合，将世界上所有的符号都纳⼊其中，每⼀个符号都给予⼀个独⼀⽆⼆的编<br>码。可以容纳100多万个符号；但是存储⽅式不确定，还可能浪费字节空间</p>
<p>Unicode 是⼀个很⼤的集合，将世界上所有的符号都纳⼊其中，每⼀个符号都给予⼀个独⼀⽆⼆的编</p>
<p>码。可以容纳100多万个符号；但是存储⽅式不确定，还可能浪费字节空间</p>
<h4 id="utf-8中中文占几个字节"><a href="#utf-8中中文占几个字节" class="headerlink" title="utf-8中中文占几个字节"></a>utf-8中中文占几个字节</h4><ol>
<li>对于单字节，字节的第一位设为0，后面7位位Unicode码，英语字母，UTF-8与ASCII是一样的</li>
<li>对于n字节的符号，第一个字节前n位全是1，第n+1位为0，后面字节的前两位为10，剩下的为Unicode码。中文占用三个字节的存储空间。</li>
</ol>
<h3 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h3><p>不同进程的线程间要进行通信需要使用消息通信的方法来实现同步。</p>
<h4 id="线程同步机制"><a href="#线程同步机制" class="headerlink" title="线程同步机制"></a>线程同步机制</h4><ol>
<li>互斥锁Mutex：保证同意时间只能有一个线程可以访问共享资源。</li>
<li>信号量Semaphore：一种计数器，控制同时访问某个共享资源的线程数量。</li>
<li>条件变量Confition Variable：一个线程可以等待某个条件的发生，另一个进程可以在满足条件时，通知等待的线程继续执行。</li>
<li>读写Read-Write Lock：允许多个线程同时读取共享资源，但只允许一个线程写入共享资源。</li>
<li>原子操作：</li>
<li>屏障Barrier：让一组下称在某个点上等待，直到所有进程都到达这个点之后再继续执行。</li>
</ol>
<h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>四个条件：互斥、请求和保持、不剥夺、环路等待<br>死锁预防：破坏任一条件<br>死锁避免：银行家算法、一次封锁法、顺序封锁法</p>
<p>一次封锁法是一种简单的锁定策略，事务在开始时一次性获取所有需要的锁，并在事务结束时一次性释放所有锁。这种方法可以避免死锁，但可能会导致锁的持有时间过长，从而降低系统的并发性能。</p>
<p>顺序封锁法是一种更复杂但更有效的锁定策略，分为两个阶段：扩展阶段和收缩阶段。</p>
<ol>
<li><strong>扩展阶段（Growing Phase）</strong>：事务可以获取锁，但不能释放锁。</li>
<li><strong>收缩阶段（Shrinking Phase）</strong>：事务可以释放锁，但不能获取新的锁。</li>
</ol>
<p>这种方法可以确保事务的可串行化，从而保证数据的一致性。</p>
<h4 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h4><h5 id="如何实现"><a href="#如何实现" class="headerlink" title="如何实现"></a>如何实现</h5><p>基于缓存加锁和总线加锁。<br>总线锁是使用处理器提供的一个lock#信号，当一个处理器在总线上输出这个信号，其他处理器的请求被阻塞。总线吧cpu贺内存之间的通信锁住了，其他处理器不能操作其他内存地址的数据，所以开销很大<br>缓存锁：频繁使用的内存会在L1、L2、L3高速缓存中，所以原子操作只需要对内部缓存中进行，允许使用MESI缓存一致性机制来保证原子性。<br>但是以下情况不能使用缓存锁：</p>
<ol>
<li>操作的数据不能被缓存在处理器内部或者操作的数据跨多个缓存行</li>
<li>有些处理器不支持缓存锁定</li>
</ol>
<h4 id="锁的区别和使用场景"><a href="#锁的区别和使用场景" class="headerlink" title="锁的区别和使用场景"></a>锁的区别和使用场景</h4><h5 id="互斥锁mutex"><a href="#互斥锁mutex" class="headerlink" title="互斥锁mutex"></a>互斥锁mutex</h5><p>特点是任何时刻都只有一个线程可以访问某个资源或者临界区<br>使用场景：共享资源不能被多个线程同时修改，更新全局变量、修改数据库记录</p>
<h5 id="信号量-Semaphore"><a href="#信号量-Semaphore" class="headerlink" title="信号量 Semaphore"></a>信号量 Semaphore</h5><p>控制特定资源的访问线程数<br>场景：限制链接池大小，控制同时访问文件的线程数</p>
<h5 id="临界区-Critical-Section"><a href="#临界区-Critical-Section" class="headerlink" title="临界区 Critical Section"></a>临界区 Critical Section</h5><p>代码中访问共享资源的部分，保证同时只有一个线程可以执行这段代码<br>场景：执行多步骤的事务</p>
<h5 id="循环锁-Spinlock"><a href="#循环锁-Spinlock" class="headerlink" title="循环锁 Spinlock"></a>循环锁 Spinlock</h5><p>一种忙等待锁，反复检查锁的状态，不会让出CPU资源<br>场景：时间很短，持有锁时间很短。</p>
<h5 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h5><ol>
<li>读者优先：读线程可以一直，所有的读线程都释放锁后，写线程才能获得写锁。</li>
<li>写着优先：第一个读线程获得锁之后，当写线程到达会被阻塞，但是阻塞过程中新的读线程要排在写线程之后。</li>
<li>公平策略：使用队列，读写按照先进先出原则加锁。</li>
</ol>
<h4 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h4><ol>
<li>栈：由操作系统自动分配释放，存放函数的参数值，局部变量等 </li>
<li>堆：一般由程序员分配释放，程序员不释放，程序结束时可能由OS回收，分配方式类似链表</li>
</ol>
<h5 id="虚拟内存-Virt"><a href="#虚拟内存-Virt" class="headerlink" title="虚拟内存 Virt"></a>虚拟内存 Virt</h5><p>抽象层，允许操作系统将硬件内存抽象化，使得每个程序都认为自己有一个连续的、私有的内存区域。内存满了也可以通过swap文件或者分页将部分数据暂存到硬盘上，从而使得程序可以运行在超过物理内存大小的内存空间中。大小 = 程序正在使用的物理内存 + 交换空间 + 未使用但已预留的内存。</p>
<h5 id="常驻内存RES"><a href="#常驻内存RES" class="headerlink" title="常驻内存RES"></a>常驻内存RES</h5><p>实际被加载到物理内存中的部分</p>
<h5 id="共享内存-SHR"><a href="#共享内存-SHR" class="headerlink" title="共享内存 SHR"></a>共享内存 SHR</h5><p>多个进程共同使用的内存部分，允许不同进程访问同一块物理地址，从而节省内存小号并提高数据交换效率。共享内存常用于进程间通信IPC</p>
<h6 id="Free-内存"><a href="#Free-内存" class="headerlink" title="Free 内存"></a>Free 内存</h6><p>系统中完全未使用的内存数量，是系统中真正可用的，没有被其他进程使用的内存。</p>
<h6 id="Available内存"><a href="#Available内存" class="headerlink" title="Available内存"></a>Available内存</h6><p>系统中立刻可以分配给进程的内存数量，包括free内存和一部分被缓存的内存。available = free + buff/chche</p>
<h5 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h5><p>缓冲区适用于存储文件系统元数据的内存。读取/写入文件时，数据首先暂存在Buffers中，来提高读取和写入的效率。</p>
<h5 id="Cached"><a href="#Cached" class="headerlink" title="Cached"></a>Cached</h5><p>缓存：用于存储已经从磁盘读取的文件的副本，这些文件可能是系统频繁使用的文件。由Linux内核自动管理，用于提高系统性能。系统有足够的空闲内存时，会将一些文件的副本保留在Cached中。</p>
<h5 id="内存回收"><a href="#内存回收" class="headerlink" title="内存回收"></a>内存回收</h5><p><img src="/2024/03/06/38/%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6.png"><br>当内存大于pages_high是，系统内存充足不会进行内存回收<br>当内存小于pages_low时，标识内存存在压力，会触发kswapd0，进行后台内存回收。直到pages_high位置<br>当内存⼩于 pages_min 时，表⽰此时⽤⼾内存耗尽，会触发直接内存回收，进程被阻塞</p>
<p>OOM⸺Out of Memory 如果直接内存回收之后，系统的剩余空闲内存还不⾜以进⾏内存分配，则会<br>进⼀步触发OOM机制。 OOM Killer 机制会根据算法选择并kill掉⼀个占⽤物理内存较⾼的进程，以便<br>释放内存资源，如果物理内存依然不⾜，OOM Killer 会继续杀死占⽤物理内存较⾼的进程，直到释放<br>⾜够的内存位置。</p>
<h5 id="MMU和TLB"><a href="#MMU和TLB" class="headerlink" title="MMU和TLB"></a>MMU和TLB</h5><p>MMU （Memory Management Unit，内存管理单元）<br>用于在CPU和内存之间实现虚拟内存管理。将虚拟地址转换为物理地址，同时提供访问权限的控制和缓存管理等功能。<br>TLB 是高所缓存，哟关于缓存页表转换的结果。存在TLB时，虚拟地址到物理地址的转换过程发生了变化，虚拟地址首先发往TLB确认是否命中Cache</p>
<h5 id="Drop-Cache"><a href="#Drop-Cache" class="headerlink" title="Drop Cache"></a>Drop Cache</h5><p>“Drop Cache” 是一种清理系统缓存的方法。系统缓存包括页面缓存、目录项缓存（dentry cache）和inode缓存。<br>• dirty pages不能回收；</p>
<p>• 共享内存和tmpfs（临时⽂件系统，指位于内存和/或交换分区中的⽂件系统）不能回收(注意观察<br>free命令显⽰的shared值)；</p>
<h5 id="Buddy分配器-amp-Slab分配器"><a href="#Buddy分配器-amp-Slab分配器" class="headerlink" title="Buddy分配器 &amp; Slab分配器"></a>Buddy分配器 &amp; Slab分配器</h5><p>Buddy系统是⼀种⾼效的内存分配技术，因为它避免了内存空间的碎⽚。伙伴系统确保所有分配的块</p>
<p>具有相同的⼤⼩，以便它们可以轻松地与其伙伴块合并在⼀起。伙伴系统的另⼀个主要优点是它允许</p>
<p>快速分配和释放内存块，这是实时系统中提供增强性能的重要要求。Linux内核中使⽤伙伴系统</p>
<p>（buddy system）算法以⻚为单位管理内存，进⾏内存分配。旨在减少外部碎⽚</p>
<p>Slab 系统 是另⼀种⽤于分配内核内存的技术。 slab内存分配系统的主要优点是它消除了由于内存分配</p>
<p>和释放⽽产⽣的碎⽚。换句话说，slab分配系统是操作系统中⽤来管理内核内存的⼀种内存分配策</p>
<p>略。基本原理是从伙伴系统中申请⼀整⻚内存，然后划分成多个⼤⼩相等的⼩块内存被 slab 所管理。</p>
<p>旨在减少内部碎⽚</p>
<h5 id="内存碎⽚-amp-内存整理"><a href="#内存碎⽚-amp-内存整理" class="headerlink" title="内存碎⽚ &amp; 内存整理"></a>内存碎⽚ &amp; 内存整理</h5><p>内存碎⽚（Memory Fragmentation）是指内存的使⽤效率降低的现象，它分为两种形式：内部碎⽚</p>
<p>（Internal Fragmentation）和外部碎⽚（External Fragmentation）。内部碎⽚发⽣在内存块被分配</p>
<p>出去后，剩余的未使⽤空间⽆法被其他请求利⽤。外部碎⽚则是指多次内存分配和释放后，内存中留</p>
<p>下许多⼩的、不连续的空闲区域，这些区域太⼩，⽆法满⾜新的内存请求，尽管总的空闲内存量可能</p>
<p>⾜够。</p>
<p>Linux内存对碎⽚化的整理算法主要应⽤了内核的⻚⾯迁移机制，是⼀种将可移动⻚⾯进⾏迁移后腾出</p>
<p>连续物理内存的⽅法。在内存碎⽚整理开始前，会在内存区的头和尾各设置⼀个指针，头指针从头向</p>
<p>尾扫描可移动的⻚，⽽尾指针从尾向头扫描空闲的⻚，当他们相遇时终⽌整理。</p>
<h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><blockquote>
<p>&nbsp;<strong>OOM</strong> OOM Killer 机制会根据算法选择一个占用物理内存较高的进程，然后将其杀死，以便释放内存资源，如果物理内存依然不足，OOM Killer 会继续杀死占用物理内存较高的进程，直到释放足够的内存位置。<br>带宽：又叫频宽，是指在固定的的时间可传输的资料数量，亦即在传输管道中可以传递数据的能力。<br>内存管理单元（MMU）<br>位宽 ：位宽就是内存或显存一次能传输的数据量。简单地讲就是一次能传递的数据宽度，就像公路的车道宽度，双向四车道、双向六车道，当然车道越多一次能通过的汽车就越大，所以位宽越大，一次性能舆的数据就越多,对显卡来说对性能的提高很明显。<br>PSW：**<em>包含中断是否开放，处理机执行态等状态的寄存器，叫做处理机状态字 PSW</em>**<br>PCB: 进程控制块<br>TCB: 线程控制模块<br>寄存器分类：CS 代码段寄存器， IP 指令指针寄存器,<br>PC 程序计数器寄存器， PS描述CPU执行状态，主要包含理机当前运行态，处理及优先级，屏蔽外中断等状态<br>shell不是操作系统的一部分，而是终端与操作系统的接口<br>硬件驱动：是一个软件，用于驱动硬件<br>磁道:每个磁头可以读取一段唤醒区域，就是磁道<br>柱面： 所有的磁道合并就是一个柱面<br>上下文切换：由一个程序切换到另一个程序<br>I/O设备：包括设备控制器和设备本身，<br>文件：抽象磁盘空间<br>文件描述符：如果访问文件权限许可，则返回一个小整数，若禁止访问，系统将返回一个错误码<br>管道：一种需文件，可以链接两个进程，进程A要给进程B 发送数据时，要先把它写在管道上，相当于一个输出文件，之后进程B从上面读入并处理<br>PID 进程识别符<br>线程切换要切换栈，否则会弹栈错误<br><strong>切换栈实质就是切换寄存器</strong><br>基本输入输出系统 <strong>BIOS</strong>(Basic Input Output System)</p>
<ol>
<li><p>每台计算机上有一块双亲板，上面有一个叫做 基本输入输出系统 <strong>BIOS</strong>(Basic Input Output System),在BIOS里面有底层I/O软件</p>
</li>
<li><p>设备启动，BIOS启动，检测RAM 的数量和基本硬件的是否已经安装并且响应，</p>
</li>
<li><p>之后通过储存在CMOS存储器中的设备清单决定启动设备</p>
</li>
<li><p>之后操作系统来询问BIOS ，以获得配置信息<br><strong>多路复用：实现时间和空间的复用</strong></p>
</li>
</ol>
</blockquote>
<h1 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h1><h2 id="什么是操作系统"><a href="#什么是操作系统" class="headerlink" title="什么是操作系统"></a>什么是操作系统</h2><ul>
<li><p>操作系统是一种系统软件，是软、硬件资源的控制中心，</p>
</li>
<li><p>操作系统提供一个资源集的抽象，并管理这些硬件资源</p>
</li>
<li><p><strong>主要任务是隐藏硬件，呈现给程序的抽象</strong></p>
</li>
<li><p>记录哪个程序在使用什么资源，对资源请求进行评估代价，并且为不同的程序和用户调解互相冲突的资源冲突</p>
</li>
</ul>
<h4 id="功能-："><a href="#功能-：" class="headerlink" title="功能 ："></a>功能 ：</h4><ol>
<li>进程和线程的创建以及管理:创建，撤销，阻塞，唤醒，通信</li>
<li>存储管理：内存和外存的分配管理</li>
<li>文件管理：读写，创建删除</li>
<li>设备管理：完成设备请求和释放，还有启动</li>
<li>网络管理：</li>
<li>安全管理：用户认证，控制访问，文件加密等</li>
</ol>
<h3 id="。。"><a href="#。。" class="headerlink" title="。。"></a>。。</h3><p>线程：<br>jvm中线程崩溃不会导致进程崩溃，原因是什么<br><em><strong>因为JVM自定义了自己的信号处理函数，拦截了SIGSEGV信号</strong></em></p>
<ul>
<li>用户态和内核态的转换：<ol>
<li>系统调用</li>
<li>中断</li>
<li>异常</li>
</ol>
</li>
<li>死锁的解除：<ol>
<li>立刻结束所有进程</li>
<li>结束涉及死锁的所有进程</li>
<li>逐个撤销涉及死锁的进程</li>
<li>抢占资源</li>
</ol>
</li>
<li>内存管理：<ol>
<li>分配回收</li>
<li>地址转换</li>
<li>扩充</li>
<li>映射</li>
<li>优化</li>
<li>安全</li>
</ol>
</li>
<li>inode：索引节点，用于存储文件的元信息，包括文件被分为几块，权限，所有者等，每个文件拥有唯一的inode。inode的数量是固定的</li>
<li>PCB通过列表的方式组织，相同状态的进程链接在一起</li>
<li>进程和线程的对比：<ol>
<li>进程时资源分配的单位和CPU调度的单位</li>
<li>线程只享有部分资源，如寄存器和栈</li>
<li>线程可以享受进程的公共资源</li>
<li>线程切换开销少：<ul>
<li>线程不涉及资源管理信息</li>
<li>线程释放的资源比进程少</li>
<li>同一个进程中的线程切换比进程快，因为线程共享想用的地址空间，在一个进程中的所以后线程都构想一个页表。切换时不需要切换表。</li>
</ul>
</li>
</ol>
</li>
<li>TCP线程控制块</li>
<li>线程分类： <ol>
<li>用户线程：在用户空间实现的线程,由用户态的线程库来管理</li>
<li>内核线程：在内核中实现的线程，由内核管理</li>
<li>轻量级线程：在内核中来支持用户线程</li>
</ol>
</li>
<li>进程调度：<ul>
<li>调度时机: 就绪态-&gt;运行态，运行态-&gt;阻塞态,运行态-&gt;结束态</li>
<li>调度算法：<ul>
<li>非抢占式调度算法 : 进程阻塞或者结束时才会调用另一个进程</li>
<li>抢占式调度算法：对于一个进程，给予一段时间去运行，时间结束后仍然在运行时，将其挂起，会发生时钟中断</li>
</ul>
<ol>
<li>FCFS 先来先服务</li>
<li>SJF 最短作业优先</li>
<li>高响应比优先调度算法</li>
<li>时间片轮转</li>
</ol>
</li>
</ul>
</li>
<li>进程之间的通信方式：<ol>
<li>pipe    linux中 | 会创建两个子进程共同使用一个pipe</li>
<li>消息队列：进程发送消息后就可以继续做工作，另一个进程读取到消息进行处理，消息队列是保存在内核中的消息链表，缺点是：通信不及时，附件大小有限制</li>
<li>共享内存:拿出一块虚拟地址空间，将其映射到相同的物理内存中，即可做到消除拷贝过程、<ul>
<li>缺点：多个进程共同修改共享地址会出现冲突</li>
<li><img src="/2024/03/06/38/%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98.png"></li>
</ul>
</li>
<li>信号量：P V 操作 初始量为1时，是互斥操作， 为0时是同步操作</li>
<li>信号： 信号 ≠ 信号量，用于处理异常状态下的工作状态</li>
<li>锁：<ul>
<li>忙等待锁(自旋锁)：当获取不到锁时，线程会一直等待，不做别的事情，直至得到锁。</li>
<li>互斥锁：加锁失败后会释放cpud</li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="DMA"><a href="#DMA" class="headerlink" title="DMA"></a>DMA</h3><ul>
<li>用户进程调用 read 方法，向操作系统发出 I/O 请求，请求读取数据到自己的内存缓冲区中，进程进入阻塞状态；</li>
<li>操作系统收到请求后，进一步将 I/O 请求发送 DMA，然后让 CPU 执行其他任务；</li>
<li>DMA 进一步将 I/O 请求发送给磁盘；</li>
<li>磁盘收到 DMA 的 I/O 请求，把数据从磁盘读取到磁盘控制器的缓冲区中，当磁盘控制器的缓冲区被读满后，向 DMA 发起中断信号，告知自己缓冲区已满；</li>
<li><strong>DMA 收到磁盘的信号，将磁盘控制器缓冲区中的数据拷贝到内核缓冲区中，此时不占用 CPU，CPU 可以执行其他任务</strong>；</li>
<li>当 DMA 读取了足够多的数据，就会发送中断信号给 CPU；</li>
<li>CPU 收到 DMA 的信号，知道数据已经准备好，于是将数据从内核拷贝到用户空间，系统调用返回；</li>
<li>一致哈希算法也用了取模运算，但与哈希算法不同的是，哈希算法是对节点的数量进行取模运算，而<strong>一致哈希算法是对 2^32 进行取模运算，是一个固定的值</strong>。</li>
</ul>
<p>我们可以把一致哈希算法是对 2^32 进行取模运算的结果值组织成一个圆环，就像钟表一样，钟表的圆可以理解成由 60 个点组成的圆，而此处我们把这个圆想象成由 2^32 个点组成的圆，这个圆环被称为<strong>哈希环</strong>，如下图：</p>
<p><img src="https://cdn.xiaolincoding.com//mysql/other/0ea3960fef48d4cbaeb4bec4345301e7.png"></p>
<h3 id="内核"><a href="#内核" class="headerlink" title="内核"></a>内核</h3><p>现代操作系统，内核一般会提供 4 个基本能力：</p>
<ul>
<li>管理进程、线程，决定哪个进程、线程使用 CPU，也就是进程调度的能力；</li>
<li>管理内存，决定内存的分配和回收，也就是内存管理的能力；</li>
<li>管理硬件设备，为进程与硬件设备之间提供通信能力，也就是硬件通信能力；</li>
<li>提供系统调用，如果应用程序要运行更高权限运行的服务，那么就需要有系统调用，它是用户程序与操作系统之间的接口。<br><em>宏内核</em> ： 内核的所有模块都在内核态<br>微内核：内核只保留基本能力，进程调度，中断等，剩下的放在用户空间<br>混合内核，是宏内核和微内核的结合体，内核中抽象出了微内核的概念，也就是内核中会有一个小型的内核，其他模块就在这个基础上搭建，整个内核是个完整的程序；</li>
</ul>
<h2 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h2><h3 id="寄存器："><a href="#寄存器：" class="headerlink" title="寄存器："></a>寄存器：</h3><ul>
<li>通用寄存器：存放要运算的数据</li>
<li>程序寄存器： 来存储下一条要执行的指令所在的内存第</li>
<li>指令寄存器：存放指令本身</li>
</ul>
<h3 id="总线："><a href="#总线：" class="headerlink" title="总线："></a>总线：</h3><ul>
<li>地址总线： 指定CPU要操作的内存地址</li>
<li>数据总线：读写内存的数据</li>
<li>控制总线 ： 发送和接受信号，中断，设备复位等，CPU响应也需要控制总线</li>
</ul>
<h3 id="调度"><a href="#调度" class="headerlink" title="调度"></a><a target="_blank" rel="noopener" href="https://xiaolincoding.com/os/1_hardware/how_cpu_deal_task.html#%E5%AE%8C%E5%85%A8%E5%85%AC%E5%B9%B3%E8%B0%83%E5%BA%A6">调度</a></h3><h2 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h2><ul>
<li>寄存器；</li>
<li>CPU Cache：使用SRAM 静态存储器，断电丢失数据</li>
<li><img src="/2024/03/06/38/Cache%E5%88%86%E7%B1%BB.png"><ol>
<li>L1-Cache；&nbsp;L1 高速缓存通常分成<strong>指令缓存</strong>和<strong>数据缓存</strong>。速度几乎和寄存器一样快。每个核心都拥有一个</li>
<li>L2-Cache；比L2离CPU远，大小更大，每一个核心都有</li>
<li>L3-Cahce；多核心公用</li>
<li>写入策略：<ul>
<li>写直达（_Write Through_）</li>
<li>写回（_Write Back_）只有当Cache 中的数据被替换时，写入内存</li>
</ul>
</li>
<li><h2 id="Cache一致性-第一点，某个-CPU-核心里的-Cache-数据更新时，必须要传播到其他核心的-Cache，这个称为写传播（-Write-Propagation-）；使用锁-第二点，某个-CPU-核心里对数据的操作顺序，必须在其他核心看起来顺序是一样的，这个称为事务的串行化（-Transaction-Serialization-）。-使用基于总线嗅探的MESI模型-伪共享：-多个线程同时读写同一个-Cache-Line-的不同变量时，而导致-CPU-Cache-失效的现象称为伪共享（-False-Sharing-）-解决：尽量避免这些数据刚好在同一个Cache-Line-将他们变成对齐的情况。-应用层面解决："><a href="#Cache一致性-第一点，某个-CPU-核心里的-Cache-数据更新时，必须要传播到其他核心的-Cache，这个称为写传播（-Write-Propagation-）；使用锁-第二点，某个-CPU-核心里对数据的操作顺序，必须在其他核心看起来顺序是一样的，这个称为事务的串行化（-Transaction-Serialization-）。-使用基于总线嗅探的MESI模型-伪共享：-多个线程同时读写同一个-Cache-Line-的不同变量时，而导致-CPU-Cache-失效的现象称为伪共享（-False-Sharing-）-解决：尽量避免这些数据刚好在同一个Cache-Line-将他们变成对齐的情况。-应用层面解决：" class="headerlink" title="Cache一致性- - 第一点，某个 CPU 核心里的 Cache 数据更新时，必须要传播到其他核心的 Cache，这个称为写传播（_Write Propagation_）；使用锁 - 第二点，某个 CPU 核心里对数据的操作顺序，必须在其他核心看起来顺序是一样的，这个称为事务的串行化（_Transaction Serialization_）。 - 使用基于总线嗅探的MESI模型 -  -  - 伪共享： 多个线程同时读写同一个 Cache Line 的不同变量时，而导致 CPU Cache 失效的现象称为伪共享（_False Sharing_） - 解决：尽量避免这些数据刚好在同一个Cache Line,将他们变成对齐的情况。 - 应用层面解决："></a>Cache一致性-<br> - 第一点，某个 CPU 核心里的 Cache 数据更新时，必须要传播到其他核心的 Cache，这个称为<strong>写传播（_Write Propagation_）</strong>；使用锁<br> - 第二点，某个 CPU 核心里对数据的操作顺序，必须在其他核心看起来顺序是一样的，这个称为<strong>事务的串行化（_Transaction Serialization_）</strong>。<br> - 使用基于总线嗅探的MESI模型<br> - <img src="/2024/03/06/38/%E7%8A%B6%E6%80%81%E5%9B%BE.png"><br> - <img src="/2024/03/06/38/MESI.png"><br> - 伪共享： 多个线程同时读写同一个 Cache Line 的不同变量时，而导致 CPU Cache 失效的现象称为<strong>伪共享（_False Sharing_）</strong><br> - 解决：尽量避免这些数据刚好在同一个Cache Line,将他们变成对齐的情况。<br> - 应用层面解决：<img src="/2024/03/06/38/%E5%BA%94%E7%94%A8%E5%B1%82%E9%9D%A2%E8%A7%A3%E5%86%B3.png"></h2></li>
</ol>
</li>
<li>内存；DRAM 不断刷新，数据才能被存储起来。</li>
<li>SSD/HDD 硬盘： SSD:固态硬盘，HDD机械硬盘</li>
</ul>
<h3 id="伙伴系统："><a href="#伙伴系统：" class="headerlink" title="伙伴系统："></a>伙伴系统：</h3><p>当可分配内存比所需要内存的二倍还大，那么就将其划分为两个大小为一半一半的空闲分区，重复划分，<strong>直到比二倍小就分配给他</strong></p>
<h3 id="分页，分段"><a href="#分页，分段" class="headerlink" title="分页，分段"></a>分页，分段</h3><ol>
<li><p><strong>分段（Segmentation）</strong>： 不连续，不等长，相当于是一小段逻辑的程序</p>
<ul>
<li>分段将内存划分为若干段（segments），每个段具有不同的大小和含义。</li>
<li>每个段都有自己的基地址和长度。段可以包含代码、数据、堆栈等不同类型的信息。</li>
<li>分段允许程序员以逻辑上独立的方式编写程序，并且使得程序的结构更清晰。</li>
<li>分段的缺点是会导致内存碎片化，难以管理。</li>
</ul>
</li>
<li><p><strong>分页（Paging）</strong>： 连续等长</p>
<ul>
<li>分页将内存划分为固定大小的页面（pages），通常为4KB或者更大。</li>
<li>操作系统将进程的虚拟地址空间划分为与页面大小相同的块，称为虚拟页面（virtual pages）。</li>
<li>虚拟页面和物理页面（physical pages）之间建立映射关系，操作系统负责管理这些映射。</li>
<li>分页的优点是可以更有效地利用内存空间，减少内存碎片化，并且实现了更好的内存保护和共享。</li>
<li>解决了外部碎片，但是仍然存在内部碎片</li>
</ul>
</li>
</ol>
<ul>
<li>页帧：把**物理地址间_**划分为大小相同的基本分配单元</li>
<li>页面：把<strong>逻辑地址空间</strong>也划分为相同大小，基本分配单元</li>
<li>页面置换算法：</li>
<li><strong>最佳页面置换算法（OPT，Optimal）</strong>：优先选择淘汰的页面是以后永不使用的，或者是在最长时间内不再被访问的页面，这样可以保证获得最低的缺页率。但由于人们目前无法预知进程在内存下的若干页面中哪个是未来最长时间内不再被访问的，因而该算法无法实现，只是理论最优的页面置换算法，可以作为衡量其他置换算法优劣的标准。</li>
<li><strong>先进先出页面置换算法（FIFO，First In First Out）</strong> : 最简单的一种页面置换算法，总是淘汰最先进入内存的页面，即选择在内存中驻留时间最久的页面进行淘汰。该算法易于实现和理解，一般只需要通过一个 FIFO 队列即可需求。不过，它的性能并不是很好。</li>
<li><strong>最近最久未使用页面置换算法（LRU ，Least Recently Used）</strong>：LRU 算法赋予每个页面一个访问字段，用来记录一个页面自上次被访问以来所经历的时间 T，当须淘汰一个页面时，选择现有页面中其 T 值最大的，即最近最久未使用的页面予以淘汰。LRU 算法是根据各页之前的访问情况来实现，因此是易于实现的。OPT 算法是根据各页未来的访问情况来实现，因此是不可实现的。</li>
</ul>
<h5 id="LRU算法的弊端："><a href="#LRU算法的弊端：" class="headerlink" title="LRU算法的弊端："></a><em>LRU算法的弊端：</em></h5><p>使用链表：最近使用的数据如果存在，就将其放在头部，如果不存在，就读取数据并放入头部，并删除尾部数据。<br>预读机制：读入数据时，会把相邻的数据一起读入(空间局限性)</p>
<ol>
<li>缓存失效：被预读的数据没有访问，而且把尾部的数据删除，降低了命中率。 解决：实现两个链表，分别存储热数据和冷数据，分别进行LRU算法。预读部分放入冷数据链表，当真正访问时，放入热数据链表</li>
<li>缓存污染：当批量读取数据时，大量数据被放入热数据LRU链表，会导致之前的热点数据失效。解决：提高进入活跃LRU链表的门槛</li>
</ol>
<ul>
<li><p><strong>最少使用页面置换算法（LFU，Least Frequently Used）</strong> : 和 LRU 算法比较像，不过该置换算法选择的是之前一段时间内使用最少的页面作为淘汰页。</p>
</li>
<li><p><strong>时钟页面置换算法（Clock）</strong>：可以认为是一种最近未使用算法，即逐出的页面都是最近没有使用的那个。</p>
<p><strong>局部性原理</strong>是指在程序执行过程中，数据和指令的访问存在一定的空间和时间上的局部性特点。其中，时间局部性是指一个数据项或指令在一段时间内被反复使用的特点，空间局部性是指一个数据项或指令在一段时间内与其相邻的数据项或指令被反复使用的特点。</p>
</li>
</ul>
<h3 id="虚拟内存的作用"><a href="#虚拟内存的作用" class="headerlink" title="虚拟内存的作用"></a>虚拟内存的作用</h3><ol>
<li>使得进程对云翔内存超过物理内存大小，可以把不经常使用的内存换到物理内存之外</li>
<li>每一个进程有自己的页表，所以每个进程的虚拟内存空间时相互独立 的，解决了多进程之间的地址冲突</li>
<li>页表中还存在着一些标记属性的bit，如控制一个页的读写权限，为操作系统提供更好的安全性<br><em>如果没有空闲的物理内存，那么内核就会开始进行<strong>回收内存</strong>的工作，回收的方式主要是两种：直接内存回收和后台内存回收。</em></li>
</ol>
<ul>
<li><strong>后台内存回收</strong>（kswapd）：在物理内存紧张的时候，会唤醒 kswapd 内核线程来回收内存，这个回收内存的过程<strong>异步</strong>的，不会阻塞进程的执行。</li>
<li><strong>直接内存回收</strong>（direct reclaim）：如果后台异步回收跟不上进程内存申请的速度，就会开始直接回收，这个回收内存的过程是<strong>同步</strong>的，会阻塞进程的执行。</li>
<li>OOM 选择一个占用物理内存高的进程，将其杀死，如果不够，重复杀死<ol>
<li>文件页：脏页将其写回磁盘中，再释放， 干净页直接回收内存</li>
<li>匿名页：没有实际载体的文件，将其不常访问写回磁盘</li>
</ol>
</li>
</ul>
<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>进程控制块 PCB Process Control Block</p>
<p>描述了进程的标识，空间运行状态，资源使用等信息</p>
<p>PCB是进程存在的唯一标志</p>
<p>每个进程都在操作系统中有一个对应的PCB</p>
<p>操作系统建立一个表格用于描述该进程的存在和状态，这个表格就叫做进程控制块</p>
<ul>
<li>PCB 使用链表和索引表</li>
<li>同一个状态的进程进入一个链表</li>
<li>索引表指向PCB</li>
</ul>
<h4 id="PCB的使用"><a href="#PCB的使用" class="headerlink" title="PCB的使用"></a>PCB的使用</h4><p>进程创建：生成该进程的PCB<br>进程终止：回收它的PCB</p>
<h3 id="进程的状态："><a href="#进程的状态：" class="headerlink" title="进程的状态："></a>进程的状态：</h3><p>创建状态、运行态、就绪态、阻塞态、结束状态<br><img src="/2024/03/06/38/%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2.png" alt="进程状态转换"><br>需要一个新的状态，来<strong>描述进程没有占用实际的物理内存空间的情况，这个状态就是挂起状态</strong>。</p>
<ul>
<li>阻塞挂起状态：进程在外存（硬盘）并等待某个事件的出现；</li>
<li>就绪挂起状态：进程在外存（硬盘），但只要进入内存，即刻立刻运行；<br><img src="/2024/03/06/38/%E6%8C%82%E8%B5%B7.png"></li>
</ul>
<h4 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a>进程创建</h4><h3 id="主要的事件：系统初始化，正在运行的程序执行了创建进程的系统调用，用户请求创建一个进程，一个批处理作业的初始化"><a href="#主要的事件：系统初始化，正在运行的程序执行了创建进程的系统调用，用户请求创建一个进程，一个批处理作业的初始化" class="headerlink" title="主要的事件：系统初始化，正在运行的程序执行了创建进程的系统调用，用户请求创建一个进程，一个批处理作业的初始化"></a>主要的事件：系统初始化，正在运行的程序执行了创建进程的系统调用，用户请求创建一个进程，一个批处理作业的初始化</h3><p>进程执行</p>
<p>进程等待</p>
<p>进程抢占</p>
<p>进程唤醒</p>
<p>进程结束</p>
<p>核心状态：运行状态，就绪状态，等待状态，创建状态，结束状态<br>进程挂起：</p>
<ol>
<li><p>处于挂起状态的进程映射在磁盘上，目的是减少进程占用内存</p>
</li>
<li><p>等待挂起状态等待挂起状态</p>
</li>
<li><p>就绪挂起状态 进程在外存，但只要进入内存即可运行</p>
</li>
</ol>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>概念：线程是进程的一部分，描述指令流执行状态。是进程中指令执行流的最小单元，是CPU 调度的基本单位<br>线程 = 进程 - 共享资源<br>进程 = 资源+多组线程</p>
<ul>
<li>优点： 1. 一个进程可以有多个线程2.各个线程之间 2.线程之间可以并发。3. 线程之间可以共享地址和文件资源</li>
<li>缺点：一个线程崩溃 会导致所属的进程的所有线程崩溃</li>
</ul>
<h4 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h4><p>为了避免由于中断处理程序执行时间过长，而影响正常进程的调度，Linux 将中断处理程序分为上半部和下半部：</p>
<ul>
<li>上半部，对应硬中断，由硬件触发中断，用来快速处理中断；</li>
<li>下半部，对应软中断，由内核触发中断，用来异步处理上半部未完成的工作；<br>优点：</li>
</ul>
<ol>
<li>提高CPU效率</li>
<li>实时处理</li>
<li>故障处理</li>
<li>实现分时擦欧总<br>中断的来源是外设，异常是应用程序请求的，属于系统调用</li>
</ol>
<h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><p>每一个系统调用都需要切换堆栈，系统调用是操作系统提供给用户态程序的接口，用于调用内核。<br>自陷指令： 能够产生异常的指令</p>
<h4 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行:"></a>并发与并行:</h4><p>并行：两个进程一起进行，单核处理器中不能够并行，多核才可以</p>
<p>并发：单核处理器合理的处理任务的操作，也就是多线程，并不能同时进行多个任务</p>
<p>进程之间的关系：相互独立和相互制约<br>制约： 同步和互斥</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">QingQiu</p>
  <div class="site-description" itemprop="description">个人网站，学习记录，面试记录和经验总结、互联网中一块属于自己的小窝</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">57</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">26</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Zuofw/zuofw-rpc" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Zuofw&#x2F;zuofw-rpc" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2022 – 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">QingQiu</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="站点总字数">466k</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  















  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
