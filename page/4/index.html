<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"zuofw.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="个人网站，学习记录，面试记录和经验总结、互联网中一块属于自己的小窝">
<meta property="og:type" content="website">
<meta property="og:title" content="QingQiu&#39;Blog">
<meta property="og:url" content="https://zuofw.github.io/page/4/index.html">
<meta property="og:site_name" content="QingQiu&#39;Blog">
<meta property="og:description" content="个人网站，学习记录，面试记录和经验总结、互联网中一块属于自己的小窝">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="QingQiu">
<meta property="article:tag" content="博客，学习，成长">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://zuofw.github.io/page/4/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>QingQiu'Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>


<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">QingQiu'Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">清秋的博客</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-fa fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-fa fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-fa fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-fa fa-archive"></i>归档</a>

  </li>
        <li class="menu-item menu-item-github">

    <a href="https://github.com/Zuofw" rel="noopener" target="_blank"><i class="fa fa-fw fa-fab fa-github"></i>Github</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zuofw.github.io/2024/03/30/46/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="QingQiu">
      <meta itemprop="description" content="个人网站，学习记录，面试记录和经验总结、互联网中一块属于自己的小窝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="QingQiu'Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/03/30/46/" class="post-title-link" itemprop="url">mybatis</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-03-30 14:37:46" itemprop="dateCreated datePublished" datetime="2024-03-30T14:37:46+08:00">2024-03-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-07-27 16:53:11" itemprop="dateModified" datetime="2024-07-27T16:53:11+08:00">2024-07-27</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>5.7k</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="面试常问"><a href="#面试常问" class="headerlink" title="面试常问:"></a>面试常问:</h2><ul>
<li>延迟加载提高加载效率：</li>
</ul>
<h3 id="Mybatis的缓存"><a href="#Mybatis的缓存" class="headerlink" title="Mybatis的缓存"></a>Mybatis的缓存</h3><ul>
<li>一级缓存：也即是本地缓存，是SqlSession级别的,读个sql语句之间不会共享缓存，使用@Transactional来生效，也就是说在一次事务中多次查询会使用到一级缓存<ul>
<li>默认开启，可以在配置中关闭<ol>
<li>当我们执行查询操作时，MyBatis会先去一级缓存中查找是否有之前查询过的数据。如果有，直接返回缓存中的数据；如果没有，去数据库查询数据，并将查询结果放入一级缓存中。  </li>
<li>当我们执行更新操作（包括insert、update、delete）时，MyBatis会清空一级缓存。这是为了保证缓存中的数据和数据库中的数据是一致的。  </li>
<li>当SqlSession结束或关闭时，一级缓存也就清空了。</li>
</ol>
</li>
<li>二级缓存:<ul>
<li>在mapper.xml上方加上<code>&lt;Cache&gt;&lt;/Cache&gt;</code> 即可</li>
<li>根据mapper.xml中命名空间来区分，是mapper级别的，只用当执行同一个mapper中的增改删语句时才会失效，增删改频繁时二级缓存基本失效，并且，微服务中多台服务中只有被调用的那一台的二级缓存才会删除，其余的不删除，造成不一致。</li>
</ul>
</li>
</ul>
</li>
<li>Springboot Cache，会缓存方法的返回值，但是同样也只能在一个节点生效，并且，@Cacheable不会主动刷新缓存，但是@CachePut会强制刷新缓存，并把新的缓存放入</li>
<li>共享的缓存！Redis 可以在配置文件中将springboot的缓存类型设置为Redis</li>
</ul>
<h3 id="和-的区别是什么？"><a href="#和-的区别是什么？" class="headerlink" title="#{} 和 ${} 的区别是什么？"></a>#{} 和 ${} 的区别是什么？</h3><ul>
<li><code>#{}</code> 是Propeties文件中的变量占位符，会被原样替换</li>
<li><code>${}</code>是sql的参数占位符，Mybatis会把他替换成 <code>?</code> 后续通过反射进行替换数据</li>
</ul>
<h3 id="xml-映射文件中，除了常见的-select、insert、update、delete-标签之外，还有哪些标签？"><a href="#xml-映射文件中，除了常见的-select、insert、update、delete-标签之外，还有哪些标签？" class="headerlink" title="xml 映射文件中，除了常见的 select、insert、update、delete 标签之外，还有哪些标签？"></a>xml 映射文件中，除了常见的 select、insert、update、delete 标签之外，还有哪些标签？</h3><h4 id="resultMap-定义查询结果的映射规则"><a href="#resultMap-定义查询结果的映射规则" class="headerlink" title="resultMap 定义查询结果的映射规则"></a>resultMap 定义查询结果的映射规则</h4><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>resultMap</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>userResultMap<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>User<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>user_id<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>username<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>user_name<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>password<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>user_password<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>email<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>user_email<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>bio<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>user_bio<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>resultMap</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="sql：定义可复用的SQL代码段"><a href="#sql：定义可复用的SQL代码段" class="headerlink" title="sql：定义可复用的SQL代码段"></a>sql：定义可复用的SQL代码段</h4><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>sql</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>userColumns<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span> ${alias}.id, ${alias}.username, ${alias}.password, ${alias}.email, ${alias}.bio <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>sql</span><span class="token punctuation">&gt;</span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>selectUsers<span class="token punctuation">"</span></span> <span class="token attr-name">resultMap</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>userResultMap<span class="token punctuation">"</span></span> <span class="token punctuation">&gt;</span></span>
  select
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>include</span> <span class="token attr-name">refid</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>userColumns<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>alias<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>user<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>include</span><span class="token punctuation">&gt;</span></span>
  from some_table user
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="parameterType-定义SQL语句的输入参数类型"><a href="#parameterType-定义SQL语句的输入参数类型" class="headerlink" title="parameterType 定义SQL语句的输入参数类型"></a>parameterType 定义SQL语句的输入参数类型</h4><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>insert</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>insertUser<span class="token punctuation">"</span></span> <span class="token attr-name">parameterType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>User<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
  insert into users (username, password, email, bio)
  values (#{username}, #{password}, #{email}, #{bio})
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>insert</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="resultType：定义-SQL-语句的输出结果类型。"><a href="#resultType：定义-SQL-语句的输出结果类型。" class="headerlink" title="resultType：定义 SQL 语句的输出结果类型。"></a><code>resultType</code>：定义 SQL 语句的输出结果类型。</h4><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>selectUsernames<span class="token punctuation">"</span></span> <span class="token attr-name">resultType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>string<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
  select username from users
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h4 id="association：定义一对一的关联关系。"><a href="#association：定义一对一的关联关系。" class="headerlink" title="association：定义一对一的关联关系。"></a><code>association</code>：定义一对一的关联关系。</h4><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>resultMap</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>userResultMap<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>User<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
  <span class="token comment">&lt;!-- ... --&gt;</span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>association</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>address<span class="token punctuation">"</span></span> <span class="token attr-name">javaType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Address<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>address_id<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>street<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>address_street<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>city<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>address_city<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>state<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>address_state<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>zip<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>address_zip<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>country<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>address_country<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>association</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>resultMap</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="collection：定义一对多的关联关系。"><a href="#collection：定义一对多的关联关系。" class="headerlink" title="collection：定义一对多的关联关系。"></a><code>collection</code>：定义一对多的关联关系。</h4><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>resultMap</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>userResultMap<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>User<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
  <span class="token comment">&lt;!-- ... --&gt;</span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>collection</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>posts<span class="token punctuation">"</span></span> <span class="token attr-name">ofType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Post<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>post_id<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>subject<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>post_subject<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>body<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>post_body<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>collection</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>resultMap</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="dynamic-标签如-if、choose、when、otherwise、trim、where、set：用于构建动态-SQL。"><a href="#dynamic-标签如-if、choose、when、otherwise、trim、where、set：用于构建动态-SQL。" class="headerlink" title="dynamic&nbsp;标签如&nbsp;if、choose、when、otherwise、trim、where、set：用于构建动态 SQL。"></a><code>dynamic</code>&nbsp;标签如&nbsp;<code>if</code>、<code>choose</code>、<code>when</code>、<code>otherwise</code>、<code>trim</code>、<code>where</code>、<code>set</code>：用于构建动态 SQL。</h4><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>findActiveBlogLike<span class="token punctuation">"</span></span> <span class="token attr-name">resultType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Blog<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
  SELECT * FROM BLOG WHERE state = 'ACTIVE' 
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>if</span> <span class="token attr-name">test</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>title != null<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
    AND title like #{title}
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>if</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>执行过程<ul>
<li>java程序加载config文件，创建SqlSessionFactory对象，之后通过SqlSessionFactory创建SqlSession对象，之后通过SqlSession对象执行映射配置文件中定义的SQL语句，最后通过SqlSession对象提交事务，关闭SqlSession对象</li>
<li><img src="/2024/03/30/46/%E5%88%86%E5%B1%82.png"></li>
</ul>
</li>
</ul>
<h3 id="Dao接口-Mapper接口-的原理"><a href="#Dao接口-Mapper接口-的原理" class="headerlink" title="Dao接口(Mapper接口)的原理"></a>Dao接口(Mapper接口)的原理</h3><h4 id="Dao中的方法，参数不同时，可以重载吗"><a href="#Dao中的方法，参数不同时，可以重载吗" class="headerlink" title="Dao中的方法，参数不同时，可以重载吗"></a>Dao中的方法，参数不同时，可以重载吗</h4><p>  Mapper中的方法<strong>可以</strong> 重载，使用的是全限定名 + 方法名 拼接的字符串作为key去匹配。 但是xml文件中的id只能指定一个，也即是重载的所有方法都是用一个sql语句，而这个sql语句我们可以使用动态sql来实现</p>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>getAllStu<span class="token punctuation">"</span></span> <span class="token attr-name">resultType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.pojo.Student<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
  select * from student
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>where</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>if</span> <span class="token attr-name">test</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>id != null<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
      id = #{id}
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>if</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>where</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">&gt;</span></span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>Dao接口的原理：<br>MyBatis运行时会使用JDK动态代理来为Dao生成代理proxy对象，代理对象会拦截接口方法，转而执行MappedStatement中的sql</p>
<h3 id="MyBatis的分页"><a href="#MyBatis的分页" class="headerlink" title="MyBatis的分页"></a>MyBatis的分页</h3><p>nihao</p>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>答：**(1)** MyBatis 使用 RowBounds 对象进行分页，它是针对 ResultSet 结果集执行的内存分页，而非物理分页；**(2)** 可以在 sql 内直接书写带有物理分页的参数来完成物理分页功能，**(3)** 也可以使用分页插件来完成物理分页。</p>
<h4 id="分页插件的原理"><a href="#分页插件的原理" class="headerlink" title="分页插件的原理"></a>分页插件的原理</h4><ol>
<li>插件设置一个ThreadLocal变量来存储分页参数</li>
<li>当执行查询时，MyBatis会调用所有注册的拦截器。</li>
<li>PageHelper 首先会保存原始的查询SQL，然后生成一个新的SQL，这个新的SQL在原始的SQL基础上添加了LIMIT和OFFSET</li>
<li>PageHelper 将新的SQL替换成原始的SQL然后执行</li>
<li>最后PageHelper会清除ThreadLocal中变量，避免内存泄漏</li>
</ol>
<h3 id="MyBatis动态sql是什么的，有哪些，原理"><a href="#MyBatis动态sql是什么的，有哪些，原理" class="headerlink" title="MyBatis动态sql是什么的，有哪些，原理"></a>MyBatis动态sql是什么的，有哪些，原理</h3><h4 id="常用的动态sql标签"><a href="#常用的动态sql标签" class="headerlink" title="常用的动态sql标签"></a>常用的动态sql标签</h4><ul>
<li><code>&lt;if&gt;&lt;/if&gt;</code></li>
<li><code>&lt;where&gt;&lt;/where&gt;(trim,set)</code></li>
<li><code>&lt;choose&gt;&lt;/choose&gt;（when, otherwise）</code></li>
<li><code>&lt;foreach&gt;&lt;/foreach&gt;</code></li>
<li><code>&lt;bind/&gt;</code></li>
</ul>
<h4 id="执行原理"><a href="#执行原理" class="headerlink" title="执行原理"></a>执行原理</h4><p><strong>OGNL</strong> (Object-Graph Navigation Language)表达式，通过他可以在XML配置文件中引用Java对象和方法，在动态SQL中，常常使用其进行判断条件</p>
<ul>
<li>常见的OGNL语法：<pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">person.name #访问对象的属性
person.getName() # 调用对象的方法
persons.</span><span class="token punctuation">{</span>name<span class="token punctuation">}</span> # 获取persons对象的name属性
person.age &gt; 18 ? <span class="token string">'adult'</span> <span class="token punctuation">:</span> <span class="token string">'child'</span> # 条件表达式
person.agge + 1 # 算术表达式
person.age &gt; 18 &amp;&amp; person.gender == <span class="token string">'male'</span> # 逻辑表达式<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
<h4 id="MyBatis如何将sql执行结果封装为目标对象并返回"><a href="#MyBatis如何将sql执行结果封装为目标对象并返回" class="headerlink" title="MyBatis如何将sql执行结果封装为目标对象并返回"></a>MyBatis如何将sql执行结果封装为目标对象并返回</h4><ol>
<li>使用<code>&lt;resultMap&gt;</code> 标签去映射列表名和对象属性名之间的映射关系</li>
<li>使用sql列别名方式，将列名书写为对象属性名，例如：T_NAME AS NAME 对应的属性名是name，会忽略大小写<br>当映射关系建立之后，MyBatis会通过反射创建对象，然后给对象的属性一一赋值</li>
</ol>
<h3 id="MyBatis延迟加载的原理-待写"><a href="#MyBatis延迟加载的原理-待写" class="headerlink" title="MyBatis延迟加载的原理 待写"></a>MyBatis延迟加载的原理 待写</h3><p>MyBatis仅支持association关联对象和collection关联集合对象的延迟加载，association指的是1v1，collection是1v多</p>
<h4 id="Executor执行器"><a href="#Executor执行器" class="headerlink" title="Executor执行器"></a>Executor执行器</h4><ul>
<li>SimpleExecutor 每执行一次 update或select，就开启一个Statement对象，用完立刻关闭Statement对象</li>
<li>ReuseExecutor 执行update/select 以sql为key查找Statement对象，不存在就创建，使用后放在Map中，供下一次使用</li>
<li>BatchExecutor 执行update 时，将所有的sql都添加到批处理中，之后统一执行，缓存多个Statement对象，每个Statement对象都是等待sql添加之后，等待逐一执行</li>
</ul>
<h2 id="深入解读"><a href="#深入解读" class="headerlink" title="深入解读"></a>深入解读</h2><h3 id="基础支持层"><a href="#基础支持层" class="headerlink" title="基础支持层"></a>基础支持层</h3><ul>
<li>解析器模块<ol>
<li>DOM解析将xml的标签组织成一颗DOM树，将整个xml文档加载进内存</li>
<li>SAX基于时间模型的xml解析方式。加载一部分到内存中，并且当程序处理过程中满足条件时，会结束解析，不必解析剩余的xml内容。但是不支持层次关系和父子关系的保存</li>
</ol>
<ul>
<li>XPathParser：MyBatis提供的XPathParser类封装了XPath、Document、EntityResolver</li>
</ul>
</li>
</ul>
<h1 id="MyBatis-Plus"><a href="#MyBatis-Plus" class="headerlink" title="MyBatis Plus"></a><a target="_blank" rel="noopener" href="https://baomidou.com/introduce/">MyBatis Plus</a></h1><h2 id="一些插件"><a href="#一些插件" class="headerlink" title="一些插件"></a>一些插件</h2><h3 id="自定义填充字段"><a href="#自定义填充字段" class="headerlink" title="自定义填充字段"></a>自定义填充字段</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Component</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyBatisPlusDateHandler</span> <span class="token keyword">implements</span> <span class="token class-name">MetaObjectHandler</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">insertFill</span><span class="token punctuation">(</span><span class="token class-name">MetaObject</span> metaObject<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setFieldValByName</span><span class="token punctuation">(</span><span class="token string">"createTime"</span><span class="token punctuation">,</span> <span class="token class-name">LocalDateTime</span><span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> metaObject<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setFieldValByName</span><span class="token punctuation">(</span><span class="token string">"updateTime"</span><span class="token punctuation">,</span> <span class="token class-name">LocalDateTime</span><span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> metaObject<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">updateFill</span><span class="token punctuation">(</span><span class="token class-name">MetaObject</span> metaObject<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setFieldValByName</span><span class="token punctuation">(</span><span class="token string">"updateTime"</span><span class="token punctuation">,</span> <span class="token class-name">LocalDateTime</span><span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> metaObject<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="分页插件"><a href="#分页插件" class="headerlink" title="分页插件"></a>分页插件</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"dataBaseConfigurationByAdmin"</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DataBaseConfiguration</span> <span class="token punctuation">{</span>

    <span class="token comment">/**
     * 分页插件
     */</span>
    <span class="token annotation punctuation">@Bean</span>
    <span class="token annotation punctuation">@ConditionalOnMissingBean</span>
    <span class="token keyword">public</span> <span class="token class-name">MybatisPlusInterceptor</span> <span class="token function">mybatisPlusInterceptorByAdmin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">MybatisPlusInterceptor</span> interceptor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MybatisPlusInterceptor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        interceptor<span class="token punctuation">.</span><span class="token function">addInnerInterceptor</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">PaginationInnerInterceptor</span><span class="token punctuation">(</span><span class="token class-name">DbType</span><span class="token punctuation">.</span><span class="token constant">MYSQL</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> interceptor<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>使用时，只需要在自己定义的方法上加上一个Page类型的变量就可以进行分页查询了</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Page</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">&gt;</span></span> page <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Page</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 第1页，每页10条记录</span>
<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">&gt;</span></span> users <span class="token operator">=</span> userService<span class="token punctuation">.</span><span class="token function">selectUsers</span><span class="token punctuation">(</span>page<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zuofw.github.io/2024/03/30/39/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="QingQiu">
      <meta itemprop="description" content="个人网站，学习记录，面试记录和经验总结、互联网中一块属于自己的小窝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="QingQiu'Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/03/30/39/" class="post-title-link" itemprop="url">SpringSecurity和其他的认证相关</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-03-30 10:41:39" itemprop="dateCreated datePublished" datetime="2024-03-30T10:41:39+08:00">2024-03-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-06-16 09:52:18" itemprop="dateModified" datetime="2024-06-16T09:52:18+08:00">2024-06-16</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2k</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Security"><a href="#Security" class="headerlink" title="Security"></a>Security</h1><blockquote>
<p>RBAC模型： Role-Based Access Control 基于角色的权限控制访问控制，角色关联权限，角色又关联用户的授权方式<br>一个用户可以有多个角色，每一个角色又可以分配多个权限</p>
</blockquote>
<p>AuthenticationProvider是AuthenticationManager的一个组成部分，它负责处理特定类型的Authentication对象。AuthenticationManager可能会有多个AuthenticationProvider，每个AuthenticationProvider都会尝试验证传入的Authentication对象。</p>
<h4 id="使用流程："><a href="#使用流程：" class="headerlink" title="使用流程："></a>使用流程：</h4><p><a target="_blank" rel="noopener" href="https://shusheng007.top/2023/02/15/springsecurity/">参考</a></p>
<ol>
<li>controller</li>
<li>配置拦截器/Filter，继承OncePerRequestFilter，验证token</li>
<li>配置security，在这里可以指定自定义的provider<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span>
<span class="token annotation punctuation">@EnableWebSecurity</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">WebSecurityConfig</span> <span class="token punctuation">{</span>

    <span class="token annotation punctuation">@Bean</span>
    <span class="token keyword">public</span> <span class="token class-name">AuthenticationManager</span> <span class="token function">authenticationManager</span><span class="token punctuation">(</span><span class="token class-name">AuthenticationConfiguration</span> authConfig<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> authConfig<span class="token punctuation">.</span><span class="token function">getAuthenticationManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">//我们自定义的拦截器</span>
    <span class="token annotation punctuation">@Bean</span>
    <span class="token keyword">public</span> <span class="token class-name">JwtAuthenticationTokenFilter</span> <span class="token function">jwtAuthenticationTokenFilter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">JwtAuthenticationTokenFilter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Bean</span>
    <span class="token keyword">public</span> <span class="token class-name">SecurityFilterChain</span> <span class="token function">filterChain</span><span class="token punctuation">(</span><span class="token class-name">HttpSecurity</span> httpSecurity<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
        <span class="token comment">//基于token，所以不需要csrf防护</span>
        httpSecurity<span class="token punctuation">.</span><span class="token function">csrf</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">disable</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
                <span class="token comment">//基于token，所以不需要session</span>
                <span class="token punctuation">.</span><span class="token function">sessionManagement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sessionCreationPolicy</span><span class="token punctuation">(</span><span class="token class-name">SessionCreationPolicy</span><span class="token punctuation">.</span><span class="token constant">STATELESS</span><span class="token punctuation">)</span>
                <span class="token punctuation">.</span><span class="token function">and</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
                <span class="token punctuation">.</span><span class="token function">authorizeRequests</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
                <span class="token comment">//登录注册不需要认证</span>
                <span class="token punctuation">.</span><span class="token function">antMatchers</span><span class="token punctuation">(</span><span class="token string">"/user/login"</span><span class="token punctuation">,</span> <span class="token string">"/user/register"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">permitAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
                <span class="token comment">//除上面的所有请求全部需要鉴权认证</span>
                <span class="token punctuation">.</span><span class="token function">anyRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
                <span class="token punctuation">.</span><span class="token function">authenticated</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//禁用缓存</span>
        httpSecurity<span class="token punctuation">.</span><span class="token function">headers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">cacheControl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//将我们的JWT filter添加到UsernamePasswordAuthenticationFilter前面，因为这个Filter是authentication开始的filter，我们要早于它</span>
        httpSecurity<span class="token punctuation">.</span><span class="token function">addFilterBefore</span><span class="token punctuation">(</span><span class="token function">jwtAuthenticationTokenFilter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">UsernamePasswordAuthenticationFilter</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">return</span> httpSecurity<span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ol>
<h1 id="认证相关的概念和原理"><a href="#认证相关的概念和原理" class="headerlink" title="认证相关的概念和原理"></a>认证相关的概念和原理</h1><h3 id="Cookie被禁用了Session还能使用吗"><a href="#Cookie被禁用了Session还能使用吗" class="headerlink" title="Cookie被禁用了Session还能使用吗"></a>Cookie被禁用了Session还能使用吗</h3><p>可以使用，可以把SessionID放在请求路径中，同时可以对SessionID进行加密</p>
<h2 id="为什么Cookie无法防止CSRF攻击，而Token可以"><a href="#为什么Cookie无法防止CSRF攻击，而Token可以" class="headerlink" title="为什么Cookie无法防止CSRF攻击，而Token可以"></a>为什么Cookie无法防止CSRF攻击，而Token可以</h2><p>CSRF(<strong>Cross Site Request Forgery</strong>) 跨站请求伪造，Token存在localStorage浏览器本地缓存，然后每次发送请求携带这个即可。而Cookie是可以被别的获取的<br>XSS 跨站脚本攻击（Cross Site Scripting）</p>
<h2 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h2><h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><p>xxxxx.yyyyy.zzzz</p>
<h4 id="HEADER"><a href="#HEADER" class="headerlink" title="HEADER"></a>HEADER</h4><p>描述JWT的元数据，定义了生成签名的算法以及Token的类型</p>
<ul>
<li>typ(Type) ：令牌类型，也就是JWT</li>
<li>alg(Algorithm) ：签名算法</li>
</ul>
<h4 id="PAYLOAD"><a href="#PAYLOAD" class="headerlink" title="PAYLOAD"></a>PAYLOAD</h4><p>存放实际要传输的数据，包含Claims(声明，包含JWT的相关信息)</p>
<ul>
<li>注册声明：预定义的一些声明</li>
<li>公有声明：JWT签发方可以自定义的声明</li>
<li>私有声明：签发方因为项目中需要而自定义的声明</li>
</ul>
<h4 id="SIGNATURE-签名"><a href="#SIGNATURE-签名" class="headerlink" title="SIGNATURE (签名)"></a>SIGNATURE (签名)</h4><p>通过Payload和Header和Secret是哟个Header中指定的签名算法<br>用于防止JWT被篡改<br>这个签名的生成需要用到：</p>
<ul>
<li>Header + Payload。</li>
<li>存放在服务端的密钥(一定不要泄露出去)。</li>
<li>签名算法。</li>
</ul>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><h2 id="SSO-单点登录"><a href="#SSO-单点登录" class="headerlink" title="SSO 单点登录"></a>SSO 单点登录</h2><h2 id="OAuth-2-0"><a href="#OAuth-2-0" class="headerlink" title="OAuth 2.0"></a>OAuth 2.0</h2><h2 id="权限设计"><a href="#权限设计" class="headerlink" title="权限设计"></a>权限设计</h2><h3 id="RBAC"><a href="#RBAC" class="headerlink" title="RBAC"></a>RBAC</h3><p>基于角色的权限控制</p>
<h3 id="ABAC"><a href="#ABAC" class="headerlink" title="ABAC"></a>ABAC</h3><p>基于属性的控制访问</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zuofw.github.io/2024/03/17/19/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="QingQiu">
      <meta itemprop="description" content="个人网站，学习记录，面试记录和经验总结、互联网中一块属于自己的小窝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="QingQiu'Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/03/17/19/" class="post-title-link" itemprop="url">TVM</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-03-17 18:50:19" itemprop="dateCreated datePublished" datetime="2024-03-17T18:50:19+08:00">2024-03-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-03-18 23:10:01" itemprop="dateModified" datetime="2024-03-18T23:10:01+08:00">2024-03-18</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>158</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h2><p>TVM（Tensor Virtual Machine，张量虚拟机）是一个开源的、端到端的机器学习编译器框架，旨在将机器学习算法自动编译成可供下层硬件执行的机器语言，从而利用多种类型的算力。也就是将深度学习模型进行高效推理、内存管理与线程调度优化后，再通过LLVM部署在CPU、GPU、FPGA、ARM等硬件设备上。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zuofw.github.io/2024/03/06/23/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="QingQiu">
      <meta itemprop="description" content="个人网站，学习记录，面试记录和经验总结、互联网中一块属于自己的小窝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="QingQiu'Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/03/06/23/" class="post-title-link" itemprop="url">6.S081</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-03-06 14:26:23" itemprop="dateCreated datePublished" datetime="2024-03-06T14:26:23+08:00">2024-03-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-03-17 19:08:12" itemprop="dateModified" datetime="2024-03-17T19:08:12+08:00">2024-03-17</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>5.1k</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="OS"><a href="#OS" class="headerlink" title="OS"></a>OS</h1><ol>
<li><p>系统调用跳到内核与标准的函数调用跳到另一个函数相比，区别是什么？</p>
<p> Kernel的代码总是有特殊的权限。当机器启动Kernel时，Kernel会有特殊的权限能直接访问各种各样的硬件，例如磁盘。而普通的用户程序是没有办法直接访问这些硬件的。所以，当你执行一个普通的函数调用时，你所调用的函数并没有对于硬件的特殊权限。然而，如果你触发系统调用到内核中，内核中的具体实现会具有这些特殊的权限，这样就能修改敏感的和被保护的硬件资源，比如访问硬件磁盘。我们之后会介绍更多有关的细节。</p>
</li>
<li><p>Kernel<br> 内核使用CPU提供的硬件保护机制来确保每个在用户空间执行的进程只能访问它自己的内存。内核程序的执行拥有操控硬件的权限，它需要实现这些保护；而用户程序执行时没有这些特权。当用户程序调用系统调用时，硬件会提升权限级别，并开始执行内核中预先安排好的函数。<br> <img src="/2024/03/06/23/Kernel.png" alt="Kernel"></p>
</li>
<li><p>xv6提供的系统调用<br> <a target="_blank" rel="noopener" href="https://xv6.dgs.zone/tranlate_books/book-riscv-rev1/c1/s0.html">看文档</a></p>
</li>
<li><p>Shell 是一个普通的进程，是一个用户程序，用户使用Shell来与系统调用进行交互</p>
</li>
</ol>
<h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><ol>
<li>进程由 用户空间内存(指令、数据和堆栈)和对内核私有的每个进程状态组成</li>
<li>Xv6 采用分时进程，等待执行中的进程集合切换可用的CPU，当进程没有执行时，xv6会保存他的CPU寄存器，并在下一次运行时恢复，使用进程id或PID标示进程、</li>
</ol>
<h3 id="I-x2F-O"><a href="#I-x2F-O" class="headerlink" title="I/O"></a>I/O</h3><ol>
<li>文件描述符是一个小整数(small integer)，表示进程可以读取或写入的由内核管理的对象</li>
<li>进程从文件描述符0读取（标准输入），将输出写入文件描述符1（标准输出），并将错误消息写入文件描述符2（标准错误）。</li>
<li>管道：作为一对文件描述符公开给进程的小型内核缓冲区，一个用于读取，一个用于写入。将数据写入管道的一端使得这些数据可以从管道的另一端读取。管道为进程提供了一种通信方式。</li>
</ol>
<ul>
<li><p>首先，管道会自动清理自己；在文件重定向时，shell使用完<code>/tmp/xyz</code>后必须小心删除</p>
</li>
<li><p>其次，管道可以任意传递长的数据流，而文件重定向需要磁盘上足够的空闲空间来存储所有的数据。</p>
</li>
<li><p>第三，管道允许并行执行管道阶段，而文件方法要求第一个程序在第二个程序启动之前完成。</p>
</li>
<li><p>第四，如果实现进程间通讯，管道的<strong>阻塞</strong>式读写比文件的非阻塞语义更高效。</p>
</li>
</ul>
<h3 id="操作系统架构"><a href="#操作系统架构" class="headerlink" title="操作系统架构"></a>操作系统架构</h3><p>操作系统必须满足三个要求：多路复用、隔离和交互。</p>
<ol>
<li>隔离：禁止应用程序直接访问敏感的硬件资源，将资源抽象成服务。提供系统调用</li>
<li>用户想要执行内核函数必须由用户模式过渡到管理模式</li>
</ol>
<ul>
<li>整个操作系统都驻留在内核中，这样所有系统调用的实现都以管理模式运行。这种组织被称为<strong>宏内核（monolithic kernel）</strong>。<ul>
<li>缺点是操作系统不同部分之间的接口通常很复杂（正如我们将在本文的其余部分中看到的），因此操作系统开发人员很容易犯错误。在宏内核中，一个错误就可能是致命的，因为管理模式中的错误经常会导致内核失败。如果内核失败，计算机停止工作，因此所有应用程序也会失败。计算机必须重启才能再次使用。</li>
</ul>
</li>
<li>微内核<ul>
<li>操作系统设计者可以最大限度地减少在管理模式下运行的操作系统代码量，并在用户模式下执行大部分操作系统。这种内核组织被称为<strong>微内核（microkernel）</strong></li>
<li>文件系统作为用户级进程运行。作为进程运行的操作系统服务被称为服务器。为了允许应用程序与文件服务器交互，内核提供了允许从一个用户态进程向另一个用户态进程发送消息的进程间通信机制。</li>
</ul>
</li>
<li>进程<ul>
<li>进程抽象给程序提供了一种错觉，即它有自己的专用机器。进程为程序提供了一个看起来像是私有内存系统或地址空间的东西，其他进程不能读取或写入。</li>
</ul>
</li>
<li>启动过程： 初始化自己并运行一个存储在只读内存中的引导加载程序。引导加载程序将xv6内核加载到内存中。然后，在机器模式下，中央处理器从<code>_entry</code>&nbsp;(<strong><em>kernel/entry.S</em></strong>:6)开始运行xv6。Xv6启动时页式硬件（paging hardware）处于禁用模式：也就是说虚拟地址将直接映射到物理地址。</li>
</ul>
<h3 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h3><p>页表是操作系统为每个进程提供私有地址空间和内存的机制。页表决定了内存地址的含义，以及物理内存的哪些部分可以访问。</p>
<h2 id="Lab"><a href="#Lab" class="headerlink" title="Lab"></a>Lab</h2><h3 id="lab1"><a href="#lab1" class="headerlink" title="lab1"></a>lab1</h3><p>推荐使用2021版的官方教程，2020的我打开不了<br>不建议在root用户下进行</p>
<h4 id="sleep-easy"><a href="#sleep-easy" class="headerlink" title="sleep (easy)"></a>sleep (easy)</h4><p><strong>实现xv6的UNIX程序</strong><code>sleep</code><strong>：您的</strong><code>sleep</code><strong>应该暂停到用户指定的计时数。一个滴答(tick)是由xv6内核定义的时间概念，即来自定时器芯片的两个中断之间的时间。您的解决方案应该在文件user/sleep.c中</strong></p>
<p>思路：<strong>先查看系统调用的代码</strong></p>
<ol>
<li>引入头文件，即&nbsp;<code>kernel/types.h</code>&nbsp;声明类型的头文件和&nbsp;<code>user/user.h</code>&nbsp;声明系统调用函数和&nbsp;<code>ulib.c</code>&nbsp;中函数的头文件。</li>
<li>编写&nbsp;<code>main(int argc,char* argv[])</code>&nbsp;函数。其中，参数&nbsp;<code>argc</code>&nbsp;是命令行总参数的个数，参数&nbsp;<code>argv[]</code>&nbsp;是&nbsp;<code>argc</code>&nbsp;个参数，其中第 0 个参数是程序的全名，其他的参数是命令行后面跟的用户输入的参数。</li>
<li>在Makefile中加入$U/_sleep<br>参考答案:<pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">//引入type定义和系统调用文件
#include "kernel/types.h"
#include "user/user.h"

//编写main函数
//argc 是shell接受的参数个数，argv指向对应的参数
//argv[0] 始终指向函数的全名
int main(int argc, char **argv)</span> <span class="token punctuation">{</span>
    <span class="token selector">//shell 中应该输入 sleep +参数，所以只接受一个参数, argc 应为 2
    if(argc != 2)</span> <span class="token punctuation">{</span>
        //write（int fd <span class="token punctuation">,</span>char *buf<span class="token punctuation">,</span> int n<span class="token punctuation">)</span>
        // fd是文件描述符 0 是标准输入，1标准输出<span class="token punctuation">,</span>2是标准错误
        //buf 存放要写入写出的字符数组
        // n 是要传输的字节数
        <span class="token function">write</span><span class="token punctuation">(</span>2<span class="token punctuation">,</span><span class="token string">"Usage: sleep time\n"</span><span class="token punctuation">,</span> <span class="token function">strlen</span><span class="token punctuation">(</span><span class="token string">"Usage: sleep time\n"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        //<span class="token function">exit</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span> 0 标示正常退出，非0藐视错误退出
        <span class="token function">exit</span><span class="token punctuation">(</span>1<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    //使用atoi来转为int型
    <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token function">atoi</span><span class="token punctuation">(</span>argv[1]<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">exit</span><span class="token punctuation">(</span>0<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
Makefile:<pre class="line-numbers language-css" data-language="css"><code class="language-css">UPROGS=\
	$U/_cat\
	$U/_echo\
	$U/_forktest\
	$U/_grep\
	$U/_init\
	$U/_kill\
	$U/_ln\
	$U/_ls\
	$U/_mkdir\
	$U/_rm\
	$U/_sh\
	$U/_stressfs\
	$U/_usertests\
	$U/_grind\
	$U/_wc\
	$U/_zombie\
	$U/_sleep\ # 这是我们要写的<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
单元测试:</li>
<li>make qemu 之后在shell中 sleep 100 看看是否停顿， 如果make qemu 报错，可能是没有 自动编译，建议重新启动</li>
<li>不启动xv6,在xv6-labs-2021 路径下使用： ./grade-lab-util sleep              —-sleep可替换为其他待测的，也可以不加，直接把全部实验代码都进行测，权限不够自己sudo, 报错了可能没安装python3</li>
</ol>
<h4 id="pingpong-Easy"><a href="#pingpong-Easy" class="headerlink" title="pingpong (Easy)"></a>pingpong (Easy)</h4><blockquote>
<p><strong>编写一个使用UNIX系统调用的程序来在两个进程之间“ping-pong”一个字节，请使用两个管道，每个方向一个。父进程应该向子进程发送一个字节;子进程应该打印“<code>&lt;pid&gt;: received ping</code>”，其中<code>&lt;pid&gt;</code>是进程ID，并在管道中写入字节发送给父进程，然后退出;父级应该从读取从子进程而来的字节，打印“<code>&lt;pid&gt;: received pong</code>”，然后退出。您的解决方案应该在文件_user/pingpong.c_中。</strong></p>
</blockquote>
<p>思路：</p>
<ol>
<li>使用pipe来建立管道</li>
<li>fork来建立子进程并用来区分父进程和子进程</li>
<li>getpid来获取进程pid</li>
<li>read 和 write来进行读写</li>
<li>Makefile <pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">// pingpong.c 
#include "kernel/types.h"
#include "user/user.h"
#include "stddef.h"

//
int main(int argc, char **argv)</span> <span class="token punctuation">{</span> // argc是输入的参数个数，argv指向对应的参数
    //定义两个pipe
    int pp2c[2]<span class="token punctuation">,</span>pc2p[2]<span class="token punctuation">;</span> // p parent to child
    //p[0] 是文件描述符0<span class="token punctuation">,</span> 0 是输入端，1是输出端
    <span class="token function">pipe</span><span class="token punctuation">(</span>pp2c<span class="token punctuation">)</span><span class="token punctuation">;</span> //父进程 -&gt; 子进程
    <span class="token function">pipe</span><span class="token punctuation">(</span>pc2p<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token selector">//使用fork来判断子进程和父进程
    if(fork() != 0 )</span> <span class="token punctuation">{</span> //父进程
        //<span class="token function">write</span><span class="token punctuation">(</span>文件描述符<span class="token punctuation">,</span>指针，字节数<span class="token punctuation">)</span>
        <span class="token function">write</span><span class="token punctuation">(</span>pp2c[1]<span class="token punctuation">,</span><span class="token string">"!"</span><span class="token punctuation">,</span>1<span class="token punctuation">)</span><span class="token punctuation">;</span> //父进程向子进程发出一个字节
        char buf <span class="token punctuation">;</span> //待读入缓冲区<span class="token punctuation">,</span>用于存储
        <span class="token function">read</span><span class="token punctuation">(</span>pc2p[0]<span class="token punctuation">,</span>&amp;buf<span class="token punctuation">,</span>1<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d: received pong\n"</span><span class="token punctuation">,</span><span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">wait</span><span class="token punctuation">(</span>0<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token selector">else</span> <span class="token punctuation">{</span>
        char buf<span class="token punctuation">;</span>
        //从父进程读入
        <span class="token function">read</span><span class="token punctuation">(</span>pp2c[0]<span class="token punctuation">,</span>&amp;buf<span class="token punctuation">,</span>1<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d: received ping\n"</span><span class="token punctuation">,</span><span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        //子进程重新发送给父进程
        <span class="token function">write</span><span class="token punctuation">(</span>pc2p[1]<span class="token punctuation">,</span>&amp;buf<span class="token punctuation">,</span>1<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">exit</span><span class="token punctuation">(</span>0<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ol>
<h4 id="prime"><a href="#prime" class="headerlink" title="prime"></a>prime</h4><p>思路：使用筛法，每次输出一个素数之后，把这个素数的倍数删除，之后再重新写入pipe中供下一个子进程使用即可。注意回收文件描述符即可<br>注意: <strong>一定要使用子进程</strong> ，不使用子进程会导致阻塞致死</p>
<pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">#include "kernel/types.h"
#include "user/user.h"
#include "stddef.h" // 为了得到NULL

//将描述符重新定向
void mapping(int n , int pd[])</span> <span class="token punctuation">{</span>
    <span class="token function">close</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
    //dup会返回一个最小的未使用的文件描述符，然后我们close
    //了n，也就是会返回n<span class="token punctuation">,</span>之后会将这个描述符指向pd[n]所指向的文件
    <span class="token function">dup</span><span class="token punctuation">(</span>pd[n]<span class="token punctuation">)</span><span class="token punctuation">;</span>
    //再关闭pd 就实现了将pd[n] 重定向到n的操作
    <span class="token function">close</span><span class="token punctuation">(</span>pd[0]<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">close</span><span class="token punctuation">(</span>pd[1]<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token selector">void primes()</span> <span class="token punctuation">{</span>
    //开始读入数据
    int current<span class="token punctuation">,</span>next<span class="token punctuation">;</span> //current来保存现在的数
    int fd[2]<span class="token punctuation">;</span>
    <span class="token selector">// 从0中读取数据，并写入current,读取字节长度为sizeof(int)
    if(read(0,&amp;current,sizeof(int)))</span> <span class="token punctuation">{</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"prime %d\n"</span><span class="token punctuation">,</span>current<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">pipe</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token selector">//开始筛选，每经历一个子进程就drop一些数据
        if(fork() == 0)</span> <span class="token punctuation">{</span>
            <span class="token function">mapping</span><span class="token punctuation">(</span>1<span class="token punctuation">,</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>//定向到写入端
            <span class="token selector">//重复从1中读入，判断是否是current的倍数
            while(read(0,&amp;next,sizeof(int)))</span> <span class="token punctuation">{</span>
                <span class="token selector">if(next % current != 0)</span> <span class="token punctuation">{</span>
                    <span class="token function">write</span><span class="token punctuation">(</span>1<span class="token punctuation">,</span>&amp;next<span class="token punctuation">,</span><span class="token function">sizeof</span><span class="token punctuation">(</span>int<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span> <span class="token selector">else</span> <span class="token punctuation">{</span>
            <span class="token function">wait</span><span class="token punctuation">(</span>NULL<span class="token punctuation">)</span><span class="token punctuation">;</span> //等待子进程结束
            //反复调用即可
            <span class="token function">mapping</span><span class="token punctuation">(</span>0<span class="token punctuation">,</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">primes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token selector">//0用来读取， 1用来写入
int main(int argc, char **argv)</span> <span class="token punctuation">{</span>
    int fd[2]<span class="token punctuation">;</span> //文件描述符
    //fd是共用的
    <span class="token function">pipe</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token selector">//fd[0]是读入端，也就是从pipe中读取字节，fd[1]是写入端，可以向pipe中写入
    if(fork() == 0)</span> <span class="token punctuation">{</span>
    //子进程写入 2 - 35
        <span class="token function">mapping</span><span class="token punctuation">(</span>1<span class="token punctuation">,</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>//将标准输出指向fd的写入端，也就是将输指向写入端
        <span class="token function">for</span><span class="token punctuation">(</span>int i = 2<span class="token punctuation">;</span> i &lt;= 35<span class="token punctuation">;</span> <span class="token selector">i ++)</span> <span class="token punctuation">{</span>
            //write 是向标准输出写入东西，标准输出已经指向fd[1]了，也就是向fd写入数据
                <span class="token function">write</span><span class="token punctuation">(</span>1<span class="token punctuation">,</span>&amp;i<span class="token punctuation">,</span><span class="token function">sizeof</span><span class="token punctuation">(</span>int<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token selector">else</span> <span class="token punctuation">{</span>
        <span class="token function">wait</span><span class="token punctuation">(</span>NULL<span class="token punctuation">)</span><span class="token punctuation">;</span>//等待子进程写完
        <span class="token comment">/**
         * 当调用 wait(NULL) 时，父进程会被阻塞，直到任意一个子进程终止。一旦子进程终止，wait(NULL) 函数会返回被终止的子进程的进程 ID（PID），并且如果提供了 status 参数，
         * 子进程的退出状态会存储在 status 中。
        */</span>
      <span class="token function">mapping</span><span class="token punctuation">(</span>0<span class="token punctuation">,</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>//将标准输入指向fd来进行读入
      <span class="token function">primes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">exit</span><span class="token punctuation">(</span>0<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zuofw.github.io/2024/03/06/38/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="QingQiu">
      <meta itemprop="description" content="个人网站，学习记录，面试记录和经验总结、互联网中一块属于自己的小窝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="QingQiu'Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/03/06/38/" class="post-title-link" itemprop="url">os</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-03-06 14:14:38" itemprop="dateCreated datePublished" datetime="2024-03-06T14:14:38+08:00">2024-03-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-08-07 16:04:28" itemprop="dateModified" datetime="2024-08-07T16:04:28+08:00">2024-08-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">计算机基础</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>9.6k</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="OS面试常问"><a href="#OS面试常问" class="headerlink" title="OS面试常问"></a>OS面试常问</h2><h3 id="编码问题"><a href="#编码问题" class="headerlink" title="编码问题"></a>编码问题</h3><p>ASCII码规定了128个字符的编码<br>Unicode 是⼀个很⼤的集合，将世界上所有的符号都纳⼊其中，每⼀个符号都给予⼀个独⼀⽆⼆的编<br>码。可以容纳100多万个符号；但是存储⽅式不确定，还可能浪费字节空间</p>
<p>Unicode 是⼀个很⼤的集合，将世界上所有的符号都纳⼊其中，每⼀个符号都给予⼀个独⼀⽆⼆的编</p>
<p>码。可以容纳100多万个符号；但是存储⽅式不确定，还可能浪费字节空间</p>
<h4 id="utf-8中中文占几个字节"><a href="#utf-8中中文占几个字节" class="headerlink" title="utf-8中中文占几个字节"></a>utf-8中中文占几个字节</h4><ol>
<li>对于单字节，字节的第一位设为0，后面7位位Unicode码，英语字母，UTF-8与ASCII是一样的</li>
<li>对于n字节的符号，第一个字节前n位全是1，第n+1位为0，后面字节的前两位为10，剩下的为Unicode码。中文占用三个字节的存储空间。</li>
</ol>
<h3 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h3><p>不同进程的线程间要进行通信需要使用消息通信的方法来实现同步。</p>
<h4 id="线程同步机制"><a href="#线程同步机制" class="headerlink" title="线程同步机制"></a>线程同步机制</h4><ol>
<li>互斥锁Mutex：保证同意时间只能有一个线程可以访问共享资源。</li>
<li>信号量Semaphore：一种计数器，控制同时访问某个共享资源的线程数量。</li>
<li>条件变量Confition Variable：一个线程可以等待某个条件的发生，另一个进程可以在满足条件时，通知等待的线程继续执行。</li>
<li>读写Read-Write Lock：允许多个线程同时读取共享资源，但只允许一个线程写入共享资源。</li>
<li>原子操作：</li>
<li>屏障Barrier：让一组下称在某个点上等待，直到所有进程都到达这个点之后再继续执行。</li>
</ol>
<h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>四个条件：互斥、请求和保持、不剥夺、环路等待<br>死锁预防：破坏任一条件<br>死锁避免：银行家算法、一次封锁法、顺序封锁法</p>
<p>一次封锁法是一种简单的锁定策略，事务在开始时一次性获取所有需要的锁，并在事务结束时一次性释放所有锁。这种方法可以避免死锁，但可能会导致锁的持有时间过长，从而降低系统的并发性能。</p>
<p>顺序封锁法是一种更复杂但更有效的锁定策略，分为两个阶段：扩展阶段和收缩阶段。</p>
<ol>
<li><strong>扩展阶段（Growing Phase）</strong>：事务可以获取锁，但不能释放锁。</li>
<li><strong>收缩阶段（Shrinking Phase）</strong>：事务可以释放锁，但不能获取新的锁。</li>
</ol>
<p>这种方法可以确保事务的可串行化，从而保证数据的一致性。</p>
<h4 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h4><h5 id="如何实现"><a href="#如何实现" class="headerlink" title="如何实现"></a>如何实现</h5><p>基于缓存加锁和总线加锁。<br>总线锁是使用处理器提供的一个lock#信号，当一个处理器在总线上输出这个信号，其他处理器的请求被阻塞。总线吧cpu贺内存之间的通信锁住了，其他处理器不能操作其他内存地址的数据，所以开销很大<br>缓存锁：频繁使用的内存会在L1、L2、L3高速缓存中，所以原子操作只需要对内部缓存中进行，允许使用MESI缓存一致性机制来保证原子性。<br>但是以下情况不能使用缓存锁：</p>
<ol>
<li>操作的数据不能被缓存在处理器内部或者操作的数据跨多个缓存行</li>
<li>有些处理器不支持缓存锁定</li>
</ol>
<h4 id="锁的区别和使用场景"><a href="#锁的区别和使用场景" class="headerlink" title="锁的区别和使用场景"></a>锁的区别和使用场景</h4><h5 id="互斥锁mutex"><a href="#互斥锁mutex" class="headerlink" title="互斥锁mutex"></a>互斥锁mutex</h5><p>特点是任何时刻都只有一个线程可以访问某个资源或者临界区<br>使用场景：共享资源不能被多个线程同时修改，更新全局变量、修改数据库记录</p>
<h5 id="信号量-Semaphore"><a href="#信号量-Semaphore" class="headerlink" title="信号量 Semaphore"></a>信号量 Semaphore</h5><p>控制特定资源的访问线程数<br>场景：限制链接池大小，控制同时访问文件的线程数</p>
<h5 id="临界区-Critical-Section"><a href="#临界区-Critical-Section" class="headerlink" title="临界区 Critical Section"></a>临界区 Critical Section</h5><p>代码中访问共享资源的部分，保证同时只有一个线程可以执行这段代码<br>场景：执行多步骤的事务</p>
<h5 id="循环锁-Spinlock"><a href="#循环锁-Spinlock" class="headerlink" title="循环锁 Spinlock"></a>循环锁 Spinlock</h5><p>一种忙等待锁，反复检查锁的状态，不会让出CPU资源<br>场景：时间很短，持有锁时间很短。</p>
<h5 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h5><ol>
<li>读者优先：读线程可以一直，所有的读线程都释放锁后，写线程才能获得写锁。</li>
<li>写着优先：第一个读线程获得锁之后，当写线程到达会被阻塞，但是阻塞过程中新的读线程要排在写线程之后。</li>
<li>公平策略：使用队列，读写按照先进先出原则加锁。</li>
</ol>
<h4 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h4><ol>
<li>栈：由操作系统自动分配释放，存放函数的参数值，局部变量等 </li>
<li>堆：一般由程序员分配释放，程序员不释放，程序结束时可能由OS回收，分配方式类似链表</li>
</ol>
<h5 id="虚拟内存-Virt"><a href="#虚拟内存-Virt" class="headerlink" title="虚拟内存 Virt"></a>虚拟内存 Virt</h5><p>抽象层，允许操作系统将硬件内存抽象化，使得每个程序都认为自己有一个连续的、私有的内存区域。内存满了也可以通过swap文件或者分页将部分数据暂存到硬盘上，从而使得程序可以运行在超过物理内存大小的内存空间中。大小 = 程序正在使用的物理内存 + 交换空间 + 未使用但已预留的内存。</p>
<h5 id="常驻内存RES"><a href="#常驻内存RES" class="headerlink" title="常驻内存RES"></a>常驻内存RES</h5><p>实际被加载到物理内存中的部分</p>
<h5 id="共享内存-SHR"><a href="#共享内存-SHR" class="headerlink" title="共享内存 SHR"></a>共享内存 SHR</h5><p>多个进程共同使用的内存部分，允许不同进程访问同一块物理地址，从而节省内存小号并提高数据交换效率。共享内存常用于进程间通信IPC</p>
<h6 id="Free-内存"><a href="#Free-内存" class="headerlink" title="Free 内存"></a>Free 内存</h6><p>系统中完全未使用的内存数量，是系统中真正可用的，没有被其他进程使用的内存。</p>
<h6 id="Available内存"><a href="#Available内存" class="headerlink" title="Available内存"></a>Available内存</h6><p>系统中立刻可以分配给进程的内存数量，包括free内存和一部分被缓存的内存。available = free + buff/chche</p>
<h5 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h5><p>缓冲区适用于存储文件系统元数据的内存。读取/写入文件时，数据首先暂存在Buffers中，来提高读取和写入的效率。</p>
<h5 id="Cached"><a href="#Cached" class="headerlink" title="Cached"></a>Cached</h5><p>缓存：用于存储已经从磁盘读取的文件的副本，这些文件可能是系统频繁使用的文件。由Linux内核自动管理，用于提高系统性能。系统有足够的空闲内存时，会将一些文件的副本保留在Cached中。</p>
<h5 id="内存回收"><a href="#内存回收" class="headerlink" title="内存回收"></a>内存回收</h5><p><img src="/2024/03/06/38/%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6.png"><br>当内存大于pages_high是，系统内存充足不会进行内存回收<br>当内存小于pages_low时，标识内存存在压力，会触发kswapd0，进行后台内存回收。直到pages_high位置<br>当内存⼩于 pages_min 时，表⽰此时⽤⼾内存耗尽，会触发直接内存回收，进程被阻塞</p>
<p>OOM⸺Out of Memory 如果直接内存回收之后，系统的剩余空闲内存还不⾜以进⾏内存分配，则会<br>进⼀步触发OOM机制。 OOM Killer 机制会根据算法选择并kill掉⼀个占⽤物理内存较⾼的进程，以便<br>释放内存资源，如果物理内存依然不⾜，OOM Killer 会继续杀死占⽤物理内存较⾼的进程，直到释放<br>⾜够的内存位置。</p>
<h5 id="MMU和TLB"><a href="#MMU和TLB" class="headerlink" title="MMU和TLB"></a>MMU和TLB</h5><p>MMU （Memory Management Unit，内存管理单元）<br>用于在CPU和内存之间实现虚拟内存管理。将虚拟地址转换为物理地址，同时提供访问权限的控制和缓存管理等功能。<br>TLB 是高所缓存，哟关于缓存页表转换的结果。存在TLB时，虚拟地址到物理地址的转换过程发生了变化，虚拟地址首先发往TLB确认是否命中Cache</p>
<h5 id="Drop-Cache"><a href="#Drop-Cache" class="headerlink" title="Drop Cache"></a>Drop Cache</h5><p>“Drop Cache” 是一种清理系统缓存的方法。系统缓存包括页面缓存、目录项缓存（dentry cache）和inode缓存。<br>• dirty pages不能回收；</p>
<p>• 共享内存和tmpfs（临时⽂件系统，指位于内存和/或交换分区中的⽂件系统）不能回收(注意观察<br>free命令显⽰的shared值)；</p>
<h5 id="Buddy分配器-amp-Slab分配器"><a href="#Buddy分配器-amp-Slab分配器" class="headerlink" title="Buddy分配器 &amp; Slab分配器"></a>Buddy分配器 &amp; Slab分配器</h5><p>Buddy系统是⼀种⾼效的内存分配技术，因为它避免了内存空间的碎⽚。伙伴系统确保所有分配的块</p>
<p>具有相同的⼤⼩，以便它们可以轻松地与其伙伴块合并在⼀起。伙伴系统的另⼀个主要优点是它允许</p>
<p>快速分配和释放内存块，这是实时系统中提供增强性能的重要要求。Linux内核中使⽤伙伴系统</p>
<p>（buddy system）算法以⻚为单位管理内存，进⾏内存分配。旨在减少外部碎⽚</p>
<p>Slab 系统 是另⼀种⽤于分配内核内存的技术。 slab内存分配系统的主要优点是它消除了由于内存分配</p>
<p>和释放⽽产⽣的碎⽚。换句话说，slab分配系统是操作系统中⽤来管理内核内存的⼀种内存分配策</p>
<p>略。基本原理是从伙伴系统中申请⼀整⻚内存，然后划分成多个⼤⼩相等的⼩块内存被 slab 所管理。</p>
<p>旨在减少内部碎⽚</p>
<h5 id="内存碎⽚-amp-内存整理"><a href="#内存碎⽚-amp-内存整理" class="headerlink" title="内存碎⽚ &amp; 内存整理"></a>内存碎⽚ &amp; 内存整理</h5><p>内存碎⽚（Memory Fragmentation）是指内存的使⽤效率降低的现象，它分为两种形式：内部碎⽚</p>
<p>（Internal Fragmentation）和外部碎⽚（External Fragmentation）。内部碎⽚发⽣在内存块被分配</p>
<p>出去后，剩余的未使⽤空间⽆法被其他请求利⽤。外部碎⽚则是指多次内存分配和释放后，内存中留</p>
<p>下许多⼩的、不连续的空闲区域，这些区域太⼩，⽆法满⾜新的内存请求，尽管总的空闲内存量可能</p>
<p>⾜够。</p>
<p>Linux内存对碎⽚化的整理算法主要应⽤了内核的⻚⾯迁移机制，是⼀种将可移动⻚⾯进⾏迁移后腾出</p>
<p>连续物理内存的⽅法。在内存碎⽚整理开始前，会在内存区的头和尾各设置⼀个指针，头指针从头向</p>
<p>尾扫描可移动的⻚，⽽尾指针从尾向头扫描空闲的⻚，当他们相遇时终⽌整理。</p>
<h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><blockquote>
<p>&nbsp;<strong>OOM</strong> OOM Killer 机制会根据算法选择一个占用物理内存较高的进程，然后将其杀死，以便释放内存资源，如果物理内存依然不足，OOM Killer 会继续杀死占用物理内存较高的进程，直到释放足够的内存位置。<br>带宽：又叫频宽，是指在固定的的时间可传输的资料数量，亦即在传输管道中可以传递数据的能力。<br>内存管理单元（MMU）<br>位宽 ：位宽就是内存或显存一次能传输的数据量。简单地讲就是一次能传递的数据宽度，就像公路的车道宽度，双向四车道、双向六车道，当然车道越多一次能通过的汽车就越大，所以位宽越大，一次性能舆的数据就越多,对显卡来说对性能的提高很明显。<br>PSW：**<em>包含中断是否开放，处理机执行态等状态的寄存器，叫做处理机状态字 PSW</em>**<br>PCB: 进程控制块<br>TCB: 线程控制模块<br>寄存器分类：CS 代码段寄存器， IP 指令指针寄存器,<br>PC 程序计数器寄存器， PS描述CPU执行状态，主要包含理机当前运行态，处理及优先级，屏蔽外中断等状态<br>shell不是操作系统的一部分，而是终端与操作系统的接口<br>硬件驱动：是一个软件，用于驱动硬件<br>磁道:每个磁头可以读取一段唤醒区域，就是磁道<br>柱面： 所有的磁道合并就是一个柱面<br>上下文切换：由一个程序切换到另一个程序<br>I/O设备：包括设备控制器和设备本身，<br>文件：抽象磁盘空间<br>文件描述符：如果访问文件权限许可，则返回一个小整数，若禁止访问，系统将返回一个错误码<br>管道：一种需文件，可以链接两个进程，进程A要给进程B 发送数据时，要先把它写在管道上，相当于一个输出文件，之后进程B从上面读入并处理<br>PID 进程识别符<br>线程切换要切换栈，否则会弹栈错误<br><strong>切换栈实质就是切换寄存器</strong><br>基本输入输出系统 <strong>BIOS</strong>(Basic Input Output System)</p>
<ol>
<li><p>每台计算机上有一块双亲板，上面有一个叫做 基本输入输出系统 <strong>BIOS</strong>(Basic Input Output System),在BIOS里面有底层I/O软件</p>
</li>
<li><p>设备启动，BIOS启动，检测RAM 的数量和基本硬件的是否已经安装并且响应，</p>
</li>
<li><p>之后通过储存在CMOS存储器中的设备清单决定启动设备</p>
</li>
<li><p>之后操作系统来询问BIOS ，以获得配置信息<br><strong>多路复用：实现时间和空间的复用</strong></p>
</li>
</ol>
</blockquote>
<h1 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h1><h2 id="什么是操作系统"><a href="#什么是操作系统" class="headerlink" title="什么是操作系统"></a>什么是操作系统</h2><ul>
<li><p>操作系统是一种系统软件，是软、硬件资源的控制中心，</p>
</li>
<li><p>操作系统提供一个资源集的抽象，并管理这些硬件资源</p>
</li>
<li><p><strong>主要任务是隐藏硬件，呈现给程序的抽象</strong></p>
</li>
<li><p>记录哪个程序在使用什么资源，对资源请求进行评估代价，并且为不同的程序和用户调解互相冲突的资源冲突</p>
</li>
</ul>
<h4 id="功能-："><a href="#功能-：" class="headerlink" title="功能 ："></a>功能 ：</h4><ol>
<li>进程和线程的创建以及管理:创建，撤销，阻塞，唤醒，通信</li>
<li>存储管理：内存和外存的分配管理</li>
<li>文件管理：读写，创建删除</li>
<li>设备管理：完成设备请求和释放，还有启动</li>
<li>网络管理：</li>
<li>安全管理：用户认证，控制访问，文件加密等</li>
</ol>
<h3 id="。。"><a href="#。。" class="headerlink" title="。。"></a>。。</h3><p>线程：<br>jvm中线程崩溃不会导致进程崩溃，原因是什么<br><em><strong>因为JVM自定义了自己的信号处理函数，拦截了SIGSEGV信号</strong></em></p>
<ul>
<li>用户态和内核态的转换：<ol>
<li>系统调用</li>
<li>中断</li>
<li>异常</li>
</ol>
</li>
<li>死锁的解除：<ol>
<li>立刻结束所有进程</li>
<li>结束涉及死锁的所有进程</li>
<li>逐个撤销涉及死锁的进程</li>
<li>抢占资源</li>
</ol>
</li>
<li>内存管理：<ol>
<li>分配回收</li>
<li>地址转换</li>
<li>扩充</li>
<li>映射</li>
<li>优化</li>
<li>安全</li>
</ol>
</li>
<li>inode：索引节点，用于存储文件的元信息，包括文件被分为几块，权限，所有者等，每个文件拥有唯一的inode。inode的数量是固定的</li>
<li>PCB通过列表的方式组织，相同状态的进程链接在一起</li>
<li>进程和线程的对比：<ol>
<li>进程时资源分配的单位和CPU调度的单位</li>
<li>线程只享有部分资源，如寄存器和栈</li>
<li>线程可以享受进程的公共资源</li>
<li>线程切换开销少：<ul>
<li>线程不涉及资源管理信息</li>
<li>线程释放的资源比进程少</li>
<li>同一个进程中的线程切换比进程快，因为线程共享想用的地址空间，在一个进程中的所以后线程都构想一个页表。切换时不需要切换表。</li>
</ul>
</li>
</ol>
</li>
<li>TCP线程控制块</li>
<li>线程分类： <ol>
<li>用户线程：在用户空间实现的线程,由用户态的线程库来管理</li>
<li>内核线程：在内核中实现的线程，由内核管理</li>
<li>轻量级线程：在内核中来支持用户线程</li>
</ol>
</li>
<li>进程调度：<ul>
<li>调度时机: 就绪态-&gt;运行态，运行态-&gt;阻塞态,运行态-&gt;结束态</li>
<li>调度算法：<ul>
<li>非抢占式调度算法 : 进程阻塞或者结束时才会调用另一个进程</li>
<li>抢占式调度算法：对于一个进程，给予一段时间去运行，时间结束后仍然在运行时，将其挂起，会发生时钟中断</li>
</ul>
<ol>
<li>FCFS 先来先服务</li>
<li>SJF 最短作业优先</li>
<li>高响应比优先调度算法</li>
<li>时间片轮转</li>
</ol>
</li>
</ul>
</li>
<li>进程之间的通信方式：<ol>
<li>pipe    linux中 | 会创建两个子进程共同使用一个pipe</li>
<li>消息队列：进程发送消息后就可以继续做工作，另一个进程读取到消息进行处理，消息队列是保存在内核中的消息链表，缺点是：通信不及时，附件大小有限制</li>
<li>共享内存:拿出一块虚拟地址空间，将其映射到相同的物理内存中，即可做到消除拷贝过程、<ul>
<li>缺点：多个进程共同修改共享地址会出现冲突</li>
<li><img src="/2024/03/06/38/%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98.png"></li>
</ul>
</li>
<li>信号量：P V 操作 初始量为1时，是互斥操作， 为0时是同步操作</li>
<li>信号： 信号 ≠ 信号量，用于处理异常状态下的工作状态</li>
<li>锁：<ul>
<li>忙等待锁(自旋锁)：当获取不到锁时，线程会一直等待，不做别的事情，直至得到锁。</li>
<li>互斥锁：加锁失败后会释放cpud</li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="DMA"><a href="#DMA" class="headerlink" title="DMA"></a>DMA</h3><ul>
<li>用户进程调用 read 方法，向操作系统发出 I/O 请求，请求读取数据到自己的内存缓冲区中，进程进入阻塞状态；</li>
<li>操作系统收到请求后，进一步将 I/O 请求发送 DMA，然后让 CPU 执行其他任务；</li>
<li>DMA 进一步将 I/O 请求发送给磁盘；</li>
<li>磁盘收到 DMA 的 I/O 请求，把数据从磁盘读取到磁盘控制器的缓冲区中，当磁盘控制器的缓冲区被读满后，向 DMA 发起中断信号，告知自己缓冲区已满；</li>
<li><strong>DMA 收到磁盘的信号，将磁盘控制器缓冲区中的数据拷贝到内核缓冲区中，此时不占用 CPU，CPU 可以执行其他任务</strong>；</li>
<li>当 DMA 读取了足够多的数据，就会发送中断信号给 CPU；</li>
<li>CPU 收到 DMA 的信号，知道数据已经准备好，于是将数据从内核拷贝到用户空间，系统调用返回；</li>
<li>一致哈希算法也用了取模运算，但与哈希算法不同的是，哈希算法是对节点的数量进行取模运算，而<strong>一致哈希算法是对 2^32 进行取模运算，是一个固定的值</strong>。</li>
</ul>
<p>我们可以把一致哈希算法是对 2^32 进行取模运算的结果值组织成一个圆环，就像钟表一样，钟表的圆可以理解成由 60 个点组成的圆，而此处我们把这个圆想象成由 2^32 个点组成的圆，这个圆环被称为<strong>哈希环</strong>，如下图：</p>
<p><img src="https://cdn.xiaolincoding.com//mysql/other/0ea3960fef48d4cbaeb4bec4345301e7.png"></p>
<h3 id="内核"><a href="#内核" class="headerlink" title="内核"></a>内核</h3><p>现代操作系统，内核一般会提供 4 个基本能力：</p>
<ul>
<li>管理进程、线程，决定哪个进程、线程使用 CPU，也就是进程调度的能力；</li>
<li>管理内存，决定内存的分配和回收，也就是内存管理的能力；</li>
<li>管理硬件设备，为进程与硬件设备之间提供通信能力，也就是硬件通信能力；</li>
<li>提供系统调用，如果应用程序要运行更高权限运行的服务，那么就需要有系统调用，它是用户程序与操作系统之间的接口。<br><em>宏内核</em> ： 内核的所有模块都在内核态<br>微内核：内核只保留基本能力，进程调度，中断等，剩下的放在用户空间<br>混合内核，是宏内核和微内核的结合体，内核中抽象出了微内核的概念，也就是内核中会有一个小型的内核，其他模块就在这个基础上搭建，整个内核是个完整的程序；</li>
</ul>
<h2 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h2><h3 id="寄存器："><a href="#寄存器：" class="headerlink" title="寄存器："></a>寄存器：</h3><ul>
<li>通用寄存器：存放要运算的数据</li>
<li>程序寄存器： 来存储下一条要执行的指令所在的内存第</li>
<li>指令寄存器：存放指令本身</li>
</ul>
<h3 id="总线："><a href="#总线：" class="headerlink" title="总线："></a>总线：</h3><ul>
<li>地址总线： 指定CPU要操作的内存地址</li>
<li>数据总线：读写内存的数据</li>
<li>控制总线 ： 发送和接受信号，中断，设备复位等，CPU响应也需要控制总线</li>
</ul>
<h3 id="调度"><a href="#调度" class="headerlink" title="调度"></a><a target="_blank" rel="noopener" href="https://xiaolincoding.com/os/1_hardware/how_cpu_deal_task.html#%E5%AE%8C%E5%85%A8%E5%85%AC%E5%B9%B3%E8%B0%83%E5%BA%A6">调度</a></h3><h2 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h2><ul>
<li>寄存器；</li>
<li>CPU Cache：使用SRAM 静态存储器，断电丢失数据</li>
<li><img src="/2024/03/06/38/Cache%E5%88%86%E7%B1%BB.png"><ol>
<li>L1-Cache；&nbsp;L1 高速缓存通常分成<strong>指令缓存</strong>和<strong>数据缓存</strong>。速度几乎和寄存器一样快。每个核心都拥有一个</li>
<li>L2-Cache；比L2离CPU远，大小更大，每一个核心都有</li>
<li>L3-Cahce；多核心公用</li>
<li>写入策略：<ul>
<li>写直达（_Write Through_）</li>
<li>写回（_Write Back_）只有当Cache 中的数据被替换时，写入内存</li>
</ul>
</li>
<li><h2 id="Cache一致性-第一点，某个-CPU-核心里的-Cache-数据更新时，必须要传播到其他核心的-Cache，这个称为写传播（-Write-Propagation-）；使用锁-第二点，某个-CPU-核心里对数据的操作顺序，必须在其他核心看起来顺序是一样的，这个称为事务的串行化（-Transaction-Serialization-）。-使用基于总线嗅探的MESI模型-伪共享：-多个线程同时读写同一个-Cache-Line-的不同变量时，而导致-CPU-Cache-失效的现象称为伪共享（-False-Sharing-）-解决：尽量避免这些数据刚好在同一个Cache-Line-将他们变成对齐的情况。-应用层面解决："><a href="#Cache一致性-第一点，某个-CPU-核心里的-Cache-数据更新时，必须要传播到其他核心的-Cache，这个称为写传播（-Write-Propagation-）；使用锁-第二点，某个-CPU-核心里对数据的操作顺序，必须在其他核心看起来顺序是一样的，这个称为事务的串行化（-Transaction-Serialization-）。-使用基于总线嗅探的MESI模型-伪共享：-多个线程同时读写同一个-Cache-Line-的不同变量时，而导致-CPU-Cache-失效的现象称为伪共享（-False-Sharing-）-解决：尽量避免这些数据刚好在同一个Cache-Line-将他们变成对齐的情况。-应用层面解决：" class="headerlink" title="Cache一致性- - 第一点，某个 CPU 核心里的 Cache 数据更新时，必须要传播到其他核心的 Cache，这个称为写传播（_Write Propagation_）；使用锁 - 第二点，某个 CPU 核心里对数据的操作顺序，必须在其他核心看起来顺序是一样的，这个称为事务的串行化（_Transaction Serialization_）。 - 使用基于总线嗅探的MESI模型 -  -  - 伪共享： 多个线程同时读写同一个 Cache Line 的不同变量时，而导致 CPU Cache 失效的现象称为伪共享（_False Sharing_） - 解决：尽量避免这些数据刚好在同一个Cache Line,将他们变成对齐的情况。 - 应用层面解决："></a>Cache一致性-<br> - 第一点，某个 CPU 核心里的 Cache 数据更新时，必须要传播到其他核心的 Cache，这个称为<strong>写传播（_Write Propagation_）</strong>；使用锁<br> - 第二点，某个 CPU 核心里对数据的操作顺序，必须在其他核心看起来顺序是一样的，这个称为<strong>事务的串行化（_Transaction Serialization_）</strong>。<br> - 使用基于总线嗅探的MESI模型<br> - <img src="/2024/03/06/38/%E7%8A%B6%E6%80%81%E5%9B%BE.png"><br> - <img src="/2024/03/06/38/MESI.png"><br> - 伪共享： 多个线程同时读写同一个 Cache Line 的不同变量时，而导致 CPU Cache 失效的现象称为<strong>伪共享（_False Sharing_）</strong><br> - 解决：尽量避免这些数据刚好在同一个Cache Line,将他们变成对齐的情况。<br> - 应用层面解决：<img src="/2024/03/06/38/%E5%BA%94%E7%94%A8%E5%B1%82%E9%9D%A2%E8%A7%A3%E5%86%B3.png"></h2></li>
</ol>
</li>
<li>内存；DRAM 不断刷新，数据才能被存储起来。</li>
<li>SSD/HDD 硬盘： SSD:固态硬盘，HDD机械硬盘</li>
</ul>
<h3 id="伙伴系统："><a href="#伙伴系统：" class="headerlink" title="伙伴系统："></a>伙伴系统：</h3><p>当可分配内存比所需要内存的二倍还大，那么就将其划分为两个大小为一半一半的空闲分区，重复划分，<strong>直到比二倍小就分配给他</strong></p>
<h3 id="分页，分段"><a href="#分页，分段" class="headerlink" title="分页，分段"></a>分页，分段</h3><ol>
<li><p><strong>分段（Segmentation）</strong>： 不连续，不等长，相当于是一小段逻辑的程序</p>
<ul>
<li>分段将内存划分为若干段（segments），每个段具有不同的大小和含义。</li>
<li>每个段都有自己的基地址和长度。段可以包含代码、数据、堆栈等不同类型的信息。</li>
<li>分段允许程序员以逻辑上独立的方式编写程序，并且使得程序的结构更清晰。</li>
<li>分段的缺点是会导致内存碎片化，难以管理。</li>
</ul>
</li>
<li><p><strong>分页（Paging）</strong>： 连续等长</p>
<ul>
<li>分页将内存划分为固定大小的页面（pages），通常为4KB或者更大。</li>
<li>操作系统将进程的虚拟地址空间划分为与页面大小相同的块，称为虚拟页面（virtual pages）。</li>
<li>虚拟页面和物理页面（physical pages）之间建立映射关系，操作系统负责管理这些映射。</li>
<li>分页的优点是可以更有效地利用内存空间，减少内存碎片化，并且实现了更好的内存保护和共享。</li>
<li>解决了外部碎片，但是仍然存在内部碎片</li>
</ul>
</li>
</ol>
<ul>
<li>页帧：把**物理地址间_**划分为大小相同的基本分配单元</li>
<li>页面：把<strong>逻辑地址空间</strong>也划分为相同大小，基本分配单元</li>
<li>页面置换算法：</li>
<li><strong>最佳页面置换算法（OPT，Optimal）</strong>：优先选择淘汰的页面是以后永不使用的，或者是在最长时间内不再被访问的页面，这样可以保证获得最低的缺页率。但由于人们目前无法预知进程在内存下的若干页面中哪个是未来最长时间内不再被访问的，因而该算法无法实现，只是理论最优的页面置换算法，可以作为衡量其他置换算法优劣的标准。</li>
<li><strong>先进先出页面置换算法（FIFO，First In First Out）</strong> : 最简单的一种页面置换算法，总是淘汰最先进入内存的页面，即选择在内存中驻留时间最久的页面进行淘汰。该算法易于实现和理解，一般只需要通过一个 FIFO 队列即可需求。不过，它的性能并不是很好。</li>
<li><strong>最近最久未使用页面置换算法（LRU ，Least Recently Used）</strong>：LRU 算法赋予每个页面一个访问字段，用来记录一个页面自上次被访问以来所经历的时间 T，当须淘汰一个页面时，选择现有页面中其 T 值最大的，即最近最久未使用的页面予以淘汰。LRU 算法是根据各页之前的访问情况来实现，因此是易于实现的。OPT 算法是根据各页未来的访问情况来实现，因此是不可实现的。</li>
</ul>
<h5 id="LRU算法的弊端："><a href="#LRU算法的弊端：" class="headerlink" title="LRU算法的弊端："></a><em>LRU算法的弊端：</em></h5><p>使用链表：最近使用的数据如果存在，就将其放在头部，如果不存在，就读取数据并放入头部，并删除尾部数据。<br>预读机制：读入数据时，会把相邻的数据一起读入(空间局限性)</p>
<ol>
<li>缓存失效：被预读的数据没有访问，而且把尾部的数据删除，降低了命中率。 解决：实现两个链表，分别存储热数据和冷数据，分别进行LRU算法。预读部分放入冷数据链表，当真正访问时，放入热数据链表</li>
<li>缓存污染：当批量读取数据时，大量数据被放入热数据LRU链表，会导致之前的热点数据失效。解决：提高进入活跃LRU链表的门槛</li>
</ol>
<ul>
<li><p><strong>最少使用页面置换算法（LFU，Least Frequently Used）</strong> : 和 LRU 算法比较像，不过该置换算法选择的是之前一段时间内使用最少的页面作为淘汰页。</p>
</li>
<li><p><strong>时钟页面置换算法（Clock）</strong>：可以认为是一种最近未使用算法，即逐出的页面都是最近没有使用的那个。</p>
<p><strong>局部性原理</strong>是指在程序执行过程中，数据和指令的访问存在一定的空间和时间上的局部性特点。其中，时间局部性是指一个数据项或指令在一段时间内被反复使用的特点，空间局部性是指一个数据项或指令在一段时间内与其相邻的数据项或指令被反复使用的特点。</p>
</li>
</ul>
<h3 id="虚拟内存的作用"><a href="#虚拟内存的作用" class="headerlink" title="虚拟内存的作用"></a>虚拟内存的作用</h3><ol>
<li>使得进程对云翔内存超过物理内存大小，可以把不经常使用的内存换到物理内存之外</li>
<li>每一个进程有自己的页表，所以每个进程的虚拟内存空间时相互独立 的，解决了多进程之间的地址冲突</li>
<li>页表中还存在着一些标记属性的bit，如控制一个页的读写权限，为操作系统提供更好的安全性<br><em>如果没有空闲的物理内存，那么内核就会开始进行<strong>回收内存</strong>的工作，回收的方式主要是两种：直接内存回收和后台内存回收。</em></li>
</ol>
<ul>
<li><strong>后台内存回收</strong>（kswapd）：在物理内存紧张的时候，会唤醒 kswapd 内核线程来回收内存，这个回收内存的过程<strong>异步</strong>的，不会阻塞进程的执行。</li>
<li><strong>直接内存回收</strong>（direct reclaim）：如果后台异步回收跟不上进程内存申请的速度，就会开始直接回收，这个回收内存的过程是<strong>同步</strong>的，会阻塞进程的执行。</li>
<li>OOM 选择一个占用物理内存高的进程，将其杀死，如果不够，重复杀死<ol>
<li>文件页：脏页将其写回磁盘中，再释放， 干净页直接回收内存</li>
<li>匿名页：没有实际载体的文件，将其不常访问写回磁盘</li>
</ol>
</li>
</ul>
<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>进程控制块 PCB Process Control Block</p>
<p>描述了进程的标识，空间运行状态，资源使用等信息</p>
<p>PCB是进程存在的唯一标志</p>
<p>每个进程都在操作系统中有一个对应的PCB</p>
<p>操作系统建立一个表格用于描述该进程的存在和状态，这个表格就叫做进程控制块</p>
<ul>
<li>PCB 使用链表和索引表</li>
<li>同一个状态的进程进入一个链表</li>
<li>索引表指向PCB</li>
</ul>
<h4 id="PCB的使用"><a href="#PCB的使用" class="headerlink" title="PCB的使用"></a>PCB的使用</h4><p>进程创建：生成该进程的PCB<br>进程终止：回收它的PCB</p>
<h3 id="进程的状态："><a href="#进程的状态：" class="headerlink" title="进程的状态："></a>进程的状态：</h3><p>创建状态、运行态、就绪态、阻塞态、结束状态<br><img src="/2024/03/06/38/%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2.png" alt="进程状态转换"><br>需要一个新的状态，来<strong>描述进程没有占用实际的物理内存空间的情况，这个状态就是挂起状态</strong>。</p>
<ul>
<li>阻塞挂起状态：进程在外存（硬盘）并等待某个事件的出现；</li>
<li>就绪挂起状态：进程在外存（硬盘），但只要进入内存，即刻立刻运行；<br><img src="/2024/03/06/38/%E6%8C%82%E8%B5%B7.png"></li>
</ul>
<h4 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a>进程创建</h4><h3 id="主要的事件：系统初始化，正在运行的程序执行了创建进程的系统调用，用户请求创建一个进程，一个批处理作业的初始化"><a href="#主要的事件：系统初始化，正在运行的程序执行了创建进程的系统调用，用户请求创建一个进程，一个批处理作业的初始化" class="headerlink" title="主要的事件：系统初始化，正在运行的程序执行了创建进程的系统调用，用户请求创建一个进程，一个批处理作业的初始化"></a>主要的事件：系统初始化，正在运行的程序执行了创建进程的系统调用，用户请求创建一个进程，一个批处理作业的初始化</h3><p>进程执行</p>
<p>进程等待</p>
<p>进程抢占</p>
<p>进程唤醒</p>
<p>进程结束</p>
<p>核心状态：运行状态，就绪状态，等待状态，创建状态，结束状态<br>进程挂起：</p>
<ol>
<li><p>处于挂起状态的进程映射在磁盘上，目的是减少进程占用内存</p>
</li>
<li><p>等待挂起状态等待挂起状态</p>
</li>
<li><p>就绪挂起状态 进程在外存，但只要进入内存即可运行</p>
</li>
</ol>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>概念：线程是进程的一部分，描述指令流执行状态。是进程中指令执行流的最小单元，是CPU 调度的基本单位<br>线程 = 进程 - 共享资源<br>进程 = 资源+多组线程</p>
<ul>
<li>优点： 1. 一个进程可以有多个线程2.各个线程之间 2.线程之间可以并发。3. 线程之间可以共享地址和文件资源</li>
<li>缺点：一个线程崩溃 会导致所属的进程的所有线程崩溃</li>
</ul>
<h4 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h4><p>为了避免由于中断处理程序执行时间过长，而影响正常进程的调度，Linux 将中断处理程序分为上半部和下半部：</p>
<ul>
<li>上半部，对应硬中断，由硬件触发中断，用来快速处理中断；</li>
<li>下半部，对应软中断，由内核触发中断，用来异步处理上半部未完成的工作；<br>优点：</li>
</ul>
<ol>
<li>提高CPU效率</li>
<li>实时处理</li>
<li>故障处理</li>
<li>实现分时擦欧总<br>中断的来源是外设，异常是应用程序请求的，属于系统调用</li>
</ol>
<h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><p>每一个系统调用都需要切换堆栈，系统调用是操作系统提供给用户态程序的接口，用于调用内核。<br>自陷指令： 能够产生异常的指令</p>
<h4 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行:"></a>并发与并行:</h4><p>并行：两个进程一起进行，单核处理器中不能够并行，多核才可以</p>
<p>并发：单核处理器合理的处理任务的操作，也就是多线程，并不能同时进行多个任务</p>
<p>进程之间的关系：相互独立和相互制约<br>制约： 同步和互斥</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zuofw.github.io/2024/03/05/33/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="QingQiu">
      <meta itemprop="description" content="个人网站，学习记录，面试记录和经验总结、互联网中一块属于自己的小窝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="QingQiu'Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/03/05/33/" class="post-title-link" itemprop="url">微服务</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-03-05 17:45:33" itemprop="dateCreated datePublished" datetime="2024-03-05T17:45:33+08:00">2024-03-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-07-19 16:43:23" itemprop="dateModified" datetime="2024-07-19T16:43:23+08:00">2024-07-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">分布式</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>15k</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Quarkus"><a href="#Quarkus" class="headerlink" title="Quarkus"></a>Quarkus</h2><ul>
<li>GreetingResourceTest是在jvm中测试</li>
</ul>
<h2 id="面试常问"><a href="#面试常问" class="headerlink" title="面试常问"></a>面试常问</h2><p><a target="_blank" rel="noopener" href="https://ticknet-studio.feishu.cn/docx/TNCGdBx2vodggwxqLcCcK3hTnpc">微服务面试</a></p>
<ul>
<li><p>CAP理论：任何一个分布式系统都无法做到一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance）全部满足。</p>
<ul>
<li>C数据一致</li>
<li>A读写操作必须都能成功</li>
<li>P分区容错，当分布式系统节点之间出现网络故障导致节点之间无法通信，导致出现了分区 必须要满足的</li>
</ul>
</li>
<li><p>BASE理论：<img src="/2024/03/05/33/BASE.png"></p>
<ul>
<li>基于BASE理论的柔性事务，不同于ACID的刚性事务，通过一些新的方案，只要保证最终一致性即可</li>
</ul>
</li>
<li><p>AP：无需锁定数据，实现最终一致即可</p>
</li>
<li><p>CP：各个子事务执行后不要提交，锁定资源，不允许其他人访问。</p>
</li>
<li><p>SpringCloud </p>
</li>
<li><p>分布式事务：</p>
<ul>
<li>接口幂等性：接口的幂等性是指一次和多次请求某一个资源应该具有同样的副作用。</li>
<li>XA/两阶段提交：<ul>
<li>第一阶段：存在一个负责协调各个本地资源管理的事务管理器，事务管理器在第一阶段询问各个资源管理器是否就绪，如果收到的没辙资源的回复都是yes，在在第二阶段提交事务时，任意一个回复no就回滚事务</li>
<li>第二阶段：事务管理器根据所有本地资源管理器的返回，通知所有本地资源管理器，步调一致的在所有分支上提交或者回滚事务</li>
<li>缺点：<ul>
<li>同步阻塞：当参与事务者存在占用公共资源的情况，齐总一个占用了资源，其他参与者只能等待资源释放，处于阻塞装填。</li>
<li>单点故障：一旦事务管理器故障，整个系统都不可用了</li>
<li>数据不一致：在阶段二如果事务管理器只发送了部分commit消息，如果出现网络异常，那么只有部分参与者会提交事务</li>
<li>不确定性：当协事务管理器发送 commit 之后，并且此时只有一个参与者收到了 commit，那么当该参与者与事务管理器同时宕机之后，重新选举的事务管理器无法确定该条消息是否提交成功。</li>
</ul>
</li>
</ul>
</li>
<li>TCC Try-Confirm-Cancel <img src="/2024/03/05/33/TCC%E4%BC%98%E7%82%B9.png"><ol>
<li>Try 阶段：尝试执行，完成所有业务检查（一致性）, 预留必须业务资源（准隔离性）  </li>
<li>Confirm 阶段：确认执行真正执行业务，不作任何业务检查，只使用 Try 阶段预留的业务资源，Confirm 操作满足幂等性。要求具备幂等设计，Confirm 失败后需要进行重试。  </li>
<li>Cancel 阶段：取消执行，释放 Try 阶段预留的业务资源 Cancel 操作满足幂等性 Cancel 阶段的异常和 Confirm 阶段异常处理方案基本上一致。</li>
</ol>
</li>
<li>本地消息表：依靠MQ实现<img src="/2024/03/05/33/%E6%9C%AC%E5%9C%B0%E6%B6%88%E6%81%AF%E8%A1%A8.png"> <img src="/2024/03/05/33/%E6%B6%88%E6%81%AF%E7%9A%84%E6%9C%80%E7%BB%88%E4%B8%80%E8%87%B4%E6%80%A7.png" alt="|500"></li>
</ul>
</li>
<li><p>路由：</p>
<ul>
<li>gateway<ul>
<li>配置<ul>
<li><code>id</code>：路由的唯一标示</li>
<li><code>predicates</code>：路由断言，其实就是匹配条件</li>
<li><code>filters</code>：路由过滤条件，后面讲</li>
<li><code>uri</code>：路由目标地址，<code>lb://</code>代表负载均衡，从注册中心获取目标微服务的实例列表，并且负载均衡选择一个访问。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Nacos:</p>
<ul>
<li>namespace：用于环境隔离 <img src="/2024/03/05/33/namespace.png" alt="|500"></li>
<li>分级模型：<img src="/2024/03/05/33/Nacos%E5%88%86%E7%BA%A7%E6%A8%A1%E5%9E%8B.png"><img src="/2024/03/05/33/Nacos%E5%88%86%E7%BA%A7%E6%A8%A1%E5%9E%8B%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86.png"><ul>
<li>namespace 命名空间<ul>
<li>group分组<ul>
<li>服务service<ul>
<li>集群cluster 对应不同的机房/ip<ul>
<li>实例instance：</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Nacos挂了能不能正常访问：答案是能，Nacos会把注册的服务的地址推送给他们，他们各自维护一个列表，所以Nacos挂了也不影响调用</li>
<li>nacos和eureka的区别：<ul>
<li>Nacos支持服务端主动检测提供者状态：临时实例采用心跳模式，非临时实例采用主动检测模式</li>
<li>临时实例心跳不正常会被删除，非临时实例不会呗删除</li>
<li>Nacos支持服务列表变更的消息推送模式，服务列表更新更及时</li>
<li>Nacos默认使用AP方式，</li>
</ul>
</li>
<li>nacos读取配置的流程<img src="/2024/03/05/33/nacos%E8%AF%BB%E5%85%A5%E9%85%8D%E7%BD%AE%E7%9A%84%E6%B5%81%E7%A8%8B.png"></li>
<li>配置热更新：<ul>
<li><h2 id="动态路由：-需要实现Nacos动态监听配置接口-引入配置"><a href="#动态路由：-需要实现Nacos动态监听配置接口-引入配置" class="headerlink" title="动态路由：  - 需要实现Nacos动态监听配置接口  - 引入配置"></a>动态路由：<br>  - 需要实现Nacos动态监听配置接口<br>  - 引入配置</h2></li>
</ul>
</li>
</ul>
</li>
<li><p>OpenFeign：</p>
<ul>
<li>执行过程：<img src="/2024/03/05/33/OpenFeign%E6%89%A7%E8%A1%8C%E9%80%BB%E8%BE%91.png"><ol>
<li>获取请求中的serviceId</li>
<li>根据serviceId负载均衡，找到一个可用的服务实例</li>
<li>利用服务实例ip和port信息重构url</li>
<li>向真正的url发起请求</li>
</ol>
</li>
</ul>
</li>
<li><p>负载均衡：</p>
<ul>
<li>使用LoadBalancer实现负载均衡</li>
<li>使用Ribbon组件实现：发起远程调用时，ribbon先从注册中心拉取服务地址列表，然后按照一定的路由策略选择一个发起远程调用，</li>
<li>Ribbon发负载均衡策略： 已经被集成到Eureka-client和Nacos-Discovery中，后来被废弃，使用LoadBalancer了，OpenFeign也整合了LoadBalancer<ul>
<li>轮询，根据权重选择，随机选择一个可用的，</li>
<li>区域敏感策略，以区域可用的服务器为基础进行服务器的选择。使用Zone对服务器进行分类，这个Zone可以理解为一个机房、一个机架等。而后再对Zone内的多个服务做轮询(默认)</li>
</ul>
</li>
</ul>
</li>
<li><p>服务保护</p>
<ul>
<li>Sentinel：<ul>
<li>线程隔离：<ol>
<li>线程池隔离：给每个服务调用业务分配一个线程池，利用线程池本身进行隔离<ul>
<li>支持主动超时，支持异步调用</li>
<li>缺点是线程的额外开销较大</li>
<li>使用场景低扇出</li>
</ul>
</li>
<li>信号量隔离：不创建线程池而是使用计数器模式，记录业务使用的线程数量，打到信号量上限时，禁止新的请求<ul>
<li>优点：轻量级，无额外开销</li>
<li>缺点：不支持主动超时，不支持异步调用</li>
<li>适合高频调用高扇出(一个服务需要调用其他许多服务，那么我们就可以说这个服务有高扇出)</li>
</ul>
</li>
</ol>
</li>
<li>限流：<ul>
<li>滑动窗口算法：</li>
<li>令牌桶算法：<ul>
<li>固定速率生成令牌，桶满了就舍弃，每个请求必须向桶中获取令牌才能被处理，没有获得令牌的请求等待或者丢弃</li>
<li>一般情况下每秒产生的令牌数量就是QPS上限，但是当前这一秒没有请求进入，下一半秒涌入了超过2N个请求，然后这一秒生成了N个令牌，所以放行了2N个请求，超过了阈值，所以要预留一定的波动空间</li>
</ul>
</li>
<li>漏桶算法：请求放入队列中，以固定的速率去取出并处理请求。</li>
</ul>
</li>
</ul>
</li>
<li>限流：<ul>
<li>使用nginx基于漏桶实现限流</li>
<li>使用gateway 的令牌桶算法，根据ip或者路径进行限流</li>
<li>Feign整合sentinel，在配置文件中开启即可</li>
</ul>
</li>
<li>熔断：对于超过QPS上限的请求或者延迟较高的请求，对其进行熔断，同时设置一个降级处理逻辑。<ul>
<li><img src="/2024/03/05/33/%E6%96%AD%E8%B7%AF%E5%99%A8%E7%8A%B6%E6%80%81%E6%9C%BA.png" alt="断路器的工作状态机|475"><ol>
<li>closed关闭装填，放行所有请求，并开始统计异常比例、满请求比例，超过阈值切换到open</li>
<li>open服务调用被熔断，访问这个被熔断的请求会被拒绝，快速失败，走降级逻辑。持续一段时间之后转到half-open</li>
<li>half-open 半开模式，放行一次请求，根据执行结果来判断接下来的操作<ul>
<li>请求成功：切换到closed状态</li>
<li>请求失败：切换到open状态</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li><p>分布式事务：</p>
<ul>
<li>使用seata解决分布式事务：<ul>
<li>seata有三个重要角色：<img src="/2024/03/05/33/seata%E6%9E%B6%E6%9E%84.png" alt="|500"><ul>
<li>TC 事务协调者：维护全局和分支失物的状态，协调全局事务的</li>
<li>TM 事务管理器：定义全局事务的范围，开始全局事务，提交或回滚全局事务</li>
<li>RM 资源管理器：管理分支事务，与TC交谈以注册分之十五和报告分支事务的状态，并驱动分支事务的提交和回滚</li>
</ul>
</li>
<li>xa模式：<ul>
<li>RM一阶段工作：<ol>
<li>注册分支事务到TC</li>
<li>执行分支事务sql但不提交</li>
<li>报告执行状态到TC</li>
</ol>
</li>
<li>TC二阶段工作：<ul>
<li>TC检测各分支事务执行状态<ul>
<li>如果都成功则通知所有RM提交事务</li>
<li>如果都失败则通知所有RM回滚事务</li>
</ul>
</li>
</ul>
</li>
<li>RM二阶段工作：<ul>
<li>接收TC指令，提交或回滚事务</li>
</ul>
</li>
<li>优点：强一致性，没有代码侵入</li>
<li>缺点：一阶段需要锁定数据库资源，等待二阶段结束才释放，性能差</li>
<li>依赖关系型数据库实现事务</li>
</ul>
</li>
<li>at模式：<ol>
<li>阶段一RM：<img src="/2024/03/05/33/AT%E4%B8%80%E9%98%B6%E6%AE%B5.png" alt="|525"><ul>
<li>注册分支事务，</li>
<li>记录undo-log 快照数据</li>
<li>执行业务sql并提交</li>
<li>报告事务状态</li>
</ul>
</li>
</ol>
<ul>
<li>二阶段<img src="/2024/03/05/33/AT%E4%BA%8C%E9%98%B6%E6%AE%B5.png" alt="|500"><ol>
<li>阶段而提交时RM工作：删除undo-log</li>
<li>回滚时，RM工作：根据undo-log恢复数据到更新前</li>
</ol>
</li>
</ul>
</li>
<li>两者区别：<ul>
<li>XA一阶段不提交事务，锁定资源，AT一阶段提交事务，不锁定资源</li>
<li>XA模式伊利数据库实现回滚，AT模式利用数据快照实现数据回滚</li>
<li>XA模式强一致性，AT模式最终一致</li>
</ul>
</li>
<li>TCC模式：TCC模式与AT模式非常相似，每阶段都是独立事务，不同的是TCC通过人工编码来实现数据恢复。需要实现三个方法：<img src="/2024/03/05/33/TCC%E6%A8%A1%E5%BC%8F.png"><ul>
<li><code>try</code>：资源的检测和预留；</li>
<li><code>confirm</code>：完成资源操作业务；要求 <code>try</code> 成功 <code>confirm</code> 一定要能成功。</li>
<li><code>cancel</code>：预留资源释放，可以理解为try的反向操作。</li>
<li>优点：一阶段完成直接提交事务，释放资源，无需快照，无需依赖数据库事务，可用于关系型数据库</li>
<li>缺点：代码侵入严重，软状态，事务最终一致</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>接口幂等性：</p>
<ul>
<li>使用token+redis实现接口幂等性，第二次请求之后每次请求都会携带之前的token，后台先对redis进行验证，如果存在token则执行业务，同时删除token，如果不存再则直接返回，保证了幂等性，保证了同一个token只处理一次业务</li>
</ul>
</li>
<li><h2 id="MQ：-组成-producer消息的生产者-broker-消息的保存-consumer-消息的消费者-选择："><a href="#MQ：-组成-producer消息的生产者-broker-消息的保存-consumer-消息的消费者-选择：" class="headerlink" title="MQ：  - 组成      - producer消息的生产者      - broker 消息的保存      - consumer 消息的消费者  - 选择："></a>MQ：<br>  - 组成<br>      - producer消息的生产者<br>      - broker 消息的保存<br>      - consumer 消息的消费者<br>  - 选择：<img src="/2024/03/05/33/MQ%E7%9A%84%E9%80%89%E6%8B%A9.png"></h2></li>
</ul>
<h3 id="Kafka面试题"><a href="#Kafka面试题" class="headerlink" title="Kafka面试题"></a>Kafka面试题</h3><ul>
<li>如何保证消息不丢失：<ol>
<li>producer时，可以使用异步回调发送，如果消息发送失败，我们可以通过回调获取失败后的消息信息，可以重试或者记录日志，也可以后续进行不成</li>
<li>broker中消息丢失，通过kafka的复制机制来保证消息不丢失，在生产者发送消息的时候，可以设置一个acks的参数位all，这样就会在broker的leader和foller分区都保存确认，只有所有的副本都确认之后才算是成功过发送了消息</li>
</ol>
</li>
<li>consumer时使用pull，还是push：<ul>
<li>Kafka使用了pull模式，consumer可以自主决定是否批量从broker拉取数据。push为了避免consumer崩溃而采用较低的推送速率，到一次只推送较少的消息造成浪费，pull模式下，consumer可以根据自己的消费能力而去决定如何拉取消息</li>
<li>缺点：如果broker没有提供可消费的消息，将导致consumer不断循环中轮询，直到最新消息到达。</li>
<li>Kafka可以有个参数可以让consumer阻塞知道新消息的到达，或者阻塞直到消息的数量到达某个特定的量就可以批量发送。</li>
</ul>
</li>
<li>Kafka将Topic分成了若干分区，每个分区同一时间只能被有一个consumer消费，意味着每个分区被消费的消息在日志中的位置仅仅是有一个简单的整数：offset ，consumer可以把offset调成一个较老的值，从而重新消费老消息</li>
<li>主从复制：一个topic可以有多个副本<ul>
<li>主节点将消息写入本地日志，从节点从主节点拉取信息，写入本地日志，之后向主节点发送确认消息，如果主节点收到所有从节点的确认消息，该消息就会被认为是已提交的，主节点会更新自己的高水位，消费者只能消费已提交的消息</li>
<li>优点：保证了主节点崩溃消息也不会丢失</li>
</ul>
</li>
<li>脑裂问题：<ul>
<li>只有领导者负责处理生产者和消费者的读写请求，追随者只能从领导者那里复制数据</li>
<li>Kafka的选举是由ZooKeeper协调的，ZooKeeper可以保证在任何时候只有一个领导者被选举出来</li>
<li>Zookeeper是如何做到的？<ul>
<li>当Zookeeper启动或者领导者崩溃时，所有的Zookeeper节点都会进入选举状态</li>
<li>投票阶段：每个节点会将自己作为领导者后端，然后发送投票信息给其他节点，当一个节点收到其他节点的投票信息是，如果ZXID更大，也就是收到的消息更，会更新自己的投票信息，并将新的投票信息发送给其他节点</li>
<li>确定阶段：当一个节点收到超过半数节点的相同投票信息中，他就认为选举结束，选举出的领导者就是投票信息中的候选节点，然后将结果发送给其他节点。</li>
</ul>
</li>
</ul>
</li>
<li>消息重复消费如何解决<ul>
<li>kafka都是按照offset进行标记消费的，消费者默认是自动按期提交已经消费的偏移量，如果出现重复消费的问题，我们需要禁用自动提交offset，改为手动提交，消费成功后报告给broker，为了维护消息的幂等性，我们可以设置唯一主键进行区分，或者是枷锁，数据库的锁或者是Redis的分布式锁都能解决幂等问题。</li>
</ul>
</li>
<li>如何保证消息的顺序性：<ol>
<li>将消息都存储在同一个分区下</li>
<li>发送消息时按照相同的业务设置相同的key，默认的分区是通过key的hashcode值来选择分区的，如果hash值一样，分区也是一样的。</li>
</ol>
</li>
<li>高可用：<ul>
<li>集群：多个broker，即使一台宕机，其他可以继续服务<ul>
<li>broker如何实现消息同步？<ul>
<li>主从同步，Leader Broker接受消息后，将消息写入本地日志，Follower拉取消息，写入本地日志，当所欲的ISR(同步复制保存的follower)都完成，Leader就会向生产者发送确认消息。</li>
</ul>
</li>
<li>通过过程中Leader宕机了，该怎么办？<ul>
<li>Kafka回从ISR列表中选择一个新的Leader，ISR列表中的都是已经同步最新数据的副本，当Follower同步完成后，会重新加入到ISR列表中。</li>
</ul>
</li>
</ul>
</li>
<li>数据清洗：<ul>
<li>日志清洗：<ul>
<li>根据消息保留时间，超过指定时间触发清洗，默认是168小时</li>
<li>根据topic存储的数据大小，大于一定法制，开始删除最久的消息，默认关闭。</li>
</ul>
</li>
</ul>
</li>
<li>高性能设计：<ul>
<li>消息分区：不受单台服务器限制，处理更多数据</li>
<li>顺序读写：顺序读写，提高读写效率</li>
<li>页缓存：磁盘中的数据缓存到内存，把磁盘的访问变为对内存的访问</li>
<li>零拷贝：减少上下文切换及数据拷贝</li>
<li>消息压缩：减少磁盘IO和网络IO</li>
<li>分批发送：分批发送，将消息打包批量发送，减少网络开销</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="SpringCloud"><a href="#SpringCloud" class="headerlink" title="SpringCloud"></a>SpringCloud</h2><h3 id="注册中心"><a href="#注册中心" class="headerlink" title="注册中心"></a>注册中心</h3><ol>
<li>方便更改微服务的ip和 端口号</li>
<li>如果存在多个服务，可以配置负载均衡</li>
<li>方便维护<br>服务注册中心：实现微服务之间的动态注册与发现<br><img src="/2024/03/05/33/%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E7%9A%84%E4%BD%9C%E7%94%A8.png"></li>
</ol>
<h3 id="consul"><a href="#consul" class="headerlink" title="consul"></a>consul</h3><p>功能：</p>
<ol>
<li>服务发现 支持 http和dns</li>
<li>健康监测</li>
<li>KV存储 配置</li>
<li>多数据中心</li>
<li>可视化Web界面<br>在main方法上使用 @EnableDiscoveryClient<br>controller 层上<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> <span class="token class-name">PaymentSrv_URL</span> <span class="token operator">=</span> <span class="token string">"http://cloud-payment-service"</span><span class="token punctuation">;</span><span class="token comment">//服务注册中心上的微服务名称</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<pre class="line-numbers language-cssx" data-language="cssx"><code class="language-cssx">consul agent -dev 进入开发者模式 localhost:8500<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!--SpringCloud consul discovery --&gt;</span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-cloud-starter-consul-discovery<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-css" data-language="css"><code class="language-css">  <span class="token selector">####Spring Cloud Consul for Service Discovery
spring:
    cloud: # 服务注册
      consul: # consul注册中心
        host: localhost # consul地址
        port: 8500 # consul端口
        discovery: # 服务发现
          service-name: $</span><span class="token punctuation">{</span>spring.application.name<span class="token punctuation">}</span> # 服务名称<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
RestTemplate提供了多种便捷访问远程Http服务的方法，</li>
</ol>
<p>&nbsp;</p>
<p>是一种简单便捷的访问restful服务模板类，是Spring提供的用于访问Rest服务的客户端模板工具集</p>
<blockquote>
<p>applicaiton.yml是用户级的资源配置项</p>
</blockquote>
<p>bootstrap.yml是系统级的，优先级更加高</p>
<p>Spring Cloud会创建一个“Bootstrap Context”，作为Spring应用的<code>Application Context</code>的父上下文。初始化的时候，<code>Bootstrap Context</code>负责从外部源加载配置属性并解析配置。这两个上下文共享一个从外部获取的<code>Environment</code>。</p>
<p><code>Bootstrap</code>属性有高优先级，默认情况下，它们不会被本地配置覆盖。 <code>Bootstrap context</code>和<code>Application Context</code>有着不同的约定，所以新增了一个<code>bootstrap.yml</code>文件，保证<code>Bootstrap Context</code>和<code>Application Context</code>配置的分离。</p>
<pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">spring:
  application:
    name: cloud-payment-service
    ####Spring Cloud Consul for Service Discovery
  cloud:
    consul:
      host: localhost
      port: 8500
      discovery:
        service-name: $</span><span class="token punctuation">{</span>spring.application.name<span class="token punctuation">}</span>
      <span class="token property">config</span><span class="token punctuation">:</span>
        <span class="token property">profile-separator</span><span class="token punctuation">:</span> <span class="token string">'-'</span> # default value is <span class="token string">","</span>，we update <span class="token string">'-'</span>
        <span class="token property">format</span><span class="token punctuation">:</span> YAML

# config/cloud-payment-service/data
#       /cloud-payment-service-dev/data
#       /cloud-payment-service-prod/data<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>&nbsp;application.yml文件改为bootstrap.yml,这是很关键的或者两者共存<br>因为bootstrap.yml是比application.yml先加载的。bootstrap.yml优先级高于application.yml </p>
<ul>
<li>consul kv写法</li>
<li>config/配置文件/data  里面写配置</li>
<li>动态刷新：在main上写 : @RefreshScope<br>问题: 重启consul之后，配置丢失，如何持久化配置？</li>
</ul>
<h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><ul>
<li>客户端负载和服务器负载<br>loadbalancer本地负载均衡客户端 VS Nginx服务端负载均衡区别</li>
</ul>
<p>Nginx是服务器负载均衡，客户端所有请求都会交给nginx，然后由nginx实现转发请求，即负载均衡是由服务端实现的。</p>
<p>loadbalancer本地负载均衡，在调用微服务接口时候，会在注册中心上获取注册信息服务列表之后缓存到JVM本地，从而在本地实现RPC远程服务调用技术。</p>
<ul>
<li>LoadBalancer 在工作时分成两步：</li>
</ul>
<p><strong>第一步</strong>，先选择ConsulServer从服务端查询并拉取服务列表，知道了它有多个服务(上图3个服务)，这3个实现是完全一样的，</p>
<p>默认轮询调用谁都可以正常执行。类似生活中求医挂号，某个科室今日出诊的全部医生，客户端你自己选一个。</p>
<p><strong>第二步</strong>，按照指定的负载均衡策略从server取到的服务注册列表中由客户端自己选择一个地址，所以LoadBalancer是一个<strong>客户端的</strong>负载均衡器。</p>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!--loadbalancer--&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-cloud-starter-loadbalancer<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>访问时即可在多个服务器中切换<br>均衡算法默认为轮询：<br>可以切换为随机算法：<br>修改RestTemplateConfig:</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span>
<span class="token annotation punctuation">@LoadBalancerClient</span><span class="token punctuation">(</span>
        <span class="token comment">//下面的value值大小写一定要和consul里面的名字一样，必须一样</span>
        value <span class="token operator">=</span> <span class="token string">"cloud-payment-service"</span><span class="token punctuation">,</span>configuration <span class="token operator">=</span> <span class="token class-name">RestTemplateConfig</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RestTemplateConfig</span>
<span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Bean</span>
    <span class="token annotation punctuation">@LoadBalanced</span> <span class="token comment">//使用@LoadBalanced注解赋予RestTemplate负载均衡的能力</span>
    <span class="token keyword">public</span> <span class="token class-name">RestTemplate</span> <span class="token function">restTemplate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">RestTemplate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Bean</span>
    <span class="token class-name">ReactorLoadBalancer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ServiceInstance</span><span class="token punctuation">&gt;</span></span> <span class="token function">randomLoadBalancer</span><span class="token punctuation">(</span><span class="token class-name">Environment</span> environment<span class="token punctuation">,</span>
                                                            <span class="token class-name">LoadBalancerClientFactory</span> loadBalancerClientFactory<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">String</span> name <span class="token operator">=</span> environment<span class="token punctuation">.</span><span class="token function">getProperty</span><span class="token punctuation">(</span><span class="token class-name">LoadBalancerClientFactory</span><span class="token punctuation">.</span><span class="token constant">PROPERTY_NAME</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">RandomLoadBalancer</span><span class="token punctuation">(</span>loadBalancerClientFactory<span class="token punctuation">.</span><span class="token function">getLazyProvider</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token class-name">ServiceInstanceListSupplier</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="OpenFeign"><a href="#OpenFeign" class="headerlink" title="OpenFeign"></a>OpenFeign</h2><p>Feign是一个<strong>声明性web服务客户端</strong>。它使编写web服务客户端变得更容易。使用Feign创建一个接口并对其进行注释。它具有可插入的注释支持，包括Feign注释和JAX-RS注释。Feign还支持可插拔编码器和解码器。Spring Cloud添加了对Spring MVC注释的支持，以及对使用Spring Web中默认使用的HttpMessageConverter的支持。Spring Cloud集成了Eureka、Spring Cloud CircuitBreaker以及Spring Cloud LoadBalancer，以便在使用Feign时提供负载平衡的http客户端。</p>
<p>OpenFeign能干什么</p>
<p>前面在使用<strong>SpringCloud LoadBalancer</strong>+RestTemplate时，利用RestTemplate对http请求的封装处理形成了一套模版化的调用方法。**<em>但是在实际开发中，</em>**</p>
<p>由于对服务依赖的调用可能不止一处，往往一个接口会被多处调用，所以通常都会针对每个微服务自行封装一些客户端类来包装这些依赖服务的调用。所以，OpenFeign在此基础上做了进一步封装，由他来帮助我们定义和实现依赖服务接口的定义。在OpenFeign的实现下，我们只需创建一个接口并使用注解的方式来配置它(在一个微服务接口上面标注一个**_@FeignClient_**注解即可)，即可完成对服务提供方的接口绑定，统一对外暴露可以被调用的接口方法，大大简化和降低了调用客户端的开发量，也即由服务提供者给出调用接口清单，消费者直接通过OpenFeign调用即可，O(∩_∩)O。</p>
<p>OpenFeign同时还集成SpringCloud LoadBalancer</p>
<p>可以在使用OpenFeign时提供Http客户端的负载均衡，也可以集成阿里巴巴Sentinel来提供熔断、降级等功能。而与SpringCloud LoadBalancer不同的是，通过OpenFeign只需要定义服务绑定接口且以声明式的方法，优雅而简单的实现了服务调用。</p>
<ul>
<li>引入依赖:<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!--openfeign--&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-cloud-starter-openfeign<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li>配置文件<pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">server:
  port: 80

spring:
  application:
    name: cloud-consumer-openfeign-order
  ####Spring Cloud Consul for Service Discovery
  cloud:
    consul:
      host: localhost
      port: 8500
      discovery:
        prefer-ip-address: true #优先使用服务ip进行注册
        service-name: $</span><span class="token punctuation">{</span>spring.application.name<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
main函数上使用<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@EnableDiscoveryClient</span> <span class="token comment">//该注解用于向使用consul为注册中心时注册服务</span>
<span class="token annotation punctuation">@EnableFeignClients</span><span class="token comment">//启用feign客户端,定义服务+绑定接口，以声明式的方法优雅而简单的实现服务调用</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
api接口上使用:<br>@FeignClient(value = “xxx”)</li>
<li>超时控制<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">sspring</span><span class="token punctuation">:</span>
  <span class="token key atrule">cloud</span><span class="token punctuation">:</span>
    <span class="token key atrule">openfeign</span><span class="token punctuation">:</span>
      <span class="token key atrule">client</span><span class="token punctuation">:</span>
        <span class="token key atrule">config</span><span class="token punctuation">:</span>

          <span class="token comment"># default 设置的全局超时时间，指定服务名称可以设置单个服务的超时时间</span>
          <span class="token key atrule">default</span><span class="token punctuation">:</span>
             <span class="token comment">#连接超时时间</span>
             <span class="token key atrule">connectTimeout</span><span class="token punctuation">:</span> <span class="token number">4000</span>
             <span class="token comment">#读取超时时间</span>
             <span class="token key atrule">readTimeout</span><span class="token punctuation">:</span> <span class="token number">4000</span>

          <span class="token comment"># 为serviceC这个服务单独配置超时时间，单个配置的超时时间将会覆盖全局配置</span>

          <span class="token key atrule">serviceC</span><span class="token punctuation">:</span>
             <span class="token comment">#连接超时时间</span>
             <span class="token key atrule">connectTimeout</span><span class="token punctuation">:</span> <span class="token number">2000</span>
             <span class="token comment">#读取超时时间</span>
             <span class="token key atrule">readTimeout</span><span class="token punctuation">:</span> <span class="token number">2000</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
<p><strong>服务雪崩</strong></p>
<p>多个微服务之间调用的时候，假设微服务A调用微服务B和微服务C，微服务B和微服务C又调用其它的微服务，这就是所谓的“扇出”。如果扇出的链路上某个微服务的调用响应时间过长或者不可用，对微服务A的调用就会占用越来越多的系统资源，进而引起系统崩溃，所谓的“雪崩效应”.</p>
<p>对于高流量的应用来说，单一的后端依赖可能会导致所有服务器上的所有资源都在几秒钟内饱和。比失败更糟糕的是，这些应用程序还可能导致服务之间的延迟增加，备份队列，线程和其他系统资源紧张，导致整个系统发生更多的级联故障。这些都表示需要对故障和延迟进行隔离和管理，以便单个依赖关系的失败，不能取消整个应用程序或系统。</p>
<p>所以，</p>
<p>通常当你发现一个模块下的某个实例失败后，这时候这个模块依然还会接收流量，然后这个有问题的模块还调用了其他的模块，这样就会发生级联故障，或者叫雪崩。</p>
<h2 id="CircuitBreaker-断路器"><a href="#CircuitBreaker-断路器" class="headerlink" title="CircuitBreaker  断路器"></a>CircuitBreaker  断路器</h2><p>配置参考<br><img src="/2024/03/05/33/%E6%96%AD%E8%B7%AF%E5%99%A8%E9%85%8D%E7%BD%AE.png" alt="断路器配置"></p>
<p>断路器的状态：</p>
<ol>
<li>CLOSED</li>
<li>OPEN</li>
<li>HALF_OPEN 半开<br><img src="/2024/03/05/33/%E7%8A%B6%E6%80%81.png"><br>pox<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!--resilience4j-circuitbreaker--&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-cloud-starter-circuitbreaker-resilience4j<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>
<span class="token comment">&lt;!-- 由于断路保护等需要AOP实现，所以必须导入AOP包 --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-boot-starter-aop<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<img src="/2024/03/05/33/%E5%8E%9F%E7%90%86.png"></li>
</ol>
<h2 id="分布式链路追踪"><a href="#分布式链路追踪" class="headerlink" title="分布式链路追踪"></a>分布式链路追踪</h2><p>原因:<br><img src="/2024/03/05/33/%E5%8E%9F%E5%9B%A0.png" alt="原因"><br><strong>ZipKin概述</strong></p>
<p>Zipkin是一种分布式链路跟踪系统图形化的工具，Zipkin 是 Twitter 开源的分布式跟踪系统，能够收集微服务运行过程中的实时调用链路信息，并能够将这些调用链路信息展示到Web图形化界面上供开发人员分析，开发人员能够从ZipKin中分析出调用链路中的性能瓶颈，识别出存在问题的应用程序，进而定位问题和解决问题<br>运行: java -jar zipkin-server-3.0.0-rc0-exec.jar</p>
<h2 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h2><p><img src="/2024/03/05/33/%E7%BD%91%E5%85%B3.png" alt="网关"></p>
<h3 id="执行流程："><a href="#执行流程：" class="headerlink" title="执行流程："></a>执行流程：</h3><ol>
<li>路由判断：用户端的请求到达网关之后，根据Gateway Handler Mapping 处理，会进行断言判断</li>
<li>路由过滤：很多Handler 组成的Fileter Chain</li>
<li>服务处理：后端服务会对请求进行处理</li>
<li>响应过滤：返回给-Gateway的过滤器会再次进行处理，逻辑上可以乘坐Post-Filters</li>
<li>响应返回：响应经过过处理之后，返回给客户端</li>
</ol>
<ul>
<li>作用<ol>
<li>反向代理</li>
<li>鉴权</li>
<li>流量控制</li>
<li>熔断</li>
<li>日志监控</li>
</ol>
</li>
</ul>
<h3 id="Spring-Cloud-Gateway如何实现动态路由"><a href="#Spring-Cloud-Gateway如何实现动态路由" class="headerlink" title="Spring Cloud Gateway如何实现动态路由"></a>Spring Cloud Gateway如何实现动态路由</h3><p>可以使用Nacos作为注册中心去动态更改<br>配置的路由断言类型</p>
<h3 id="Gateway过滤器的类型"><a href="#Gateway过滤器的类型" class="headerlink" title="Gateway过滤器的类型"></a>Gateway过滤器的类型</h3><ul>
<li>Pre类型：在请求被转发到微服务之前及逆行拦截和修改</li>
<li>Post ： 微服务处理请求之后，返回响应给网关，网关可以再次进行处理，例如修改相应内容或者响应头，日志输出，流量监控<br>或者</li>
<li>GatewayFilter：局部过滤器，应用在单个路由或者一组路由上的过滤器</li>
<li>GlobalFilter：全局过滤器<br>pom<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!--gateway--&gt;</span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>
          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>
          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-cloud-starter-gateway<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
yml<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">server</span><span class="token punctuation">:</span>
  <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">9527</span>

<span class="token key atrule">spring</span><span class="token punctuation">:</span>
  <span class="token key atrule">application</span><span class="token punctuation">:</span>
    <span class="token key atrule">name</span><span class="token punctuation">:</span> cloud<span class="token punctuation">-</span>gateway <span class="token comment">#以微服务注册进consul或nacos服务列表内</span>
  <span class="token key atrule">cloud</span><span class="token punctuation">:</span>
    <span class="token key atrule">consul</span><span class="token punctuation">:</span> <span class="token comment">#配置consul地址</span>
      <span class="token key atrule">host</span><span class="token punctuation">:</span> localhost
      <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">8500</span>
      <span class="token key atrule">discovery</span><span class="token punctuation">:</span>
        <span class="token key atrule">prefer-ip-address</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>
        <span class="token key atrule">service-name</span><span class="token punctuation">:</span> $<span class="token punctuation">{</span>spring.application.name<span class="token punctuation">}</span>
	<span class="token key atrule">gateway</span><span class="token punctuation">:</span>
      <span class="token key atrule">routes</span><span class="token punctuation">:</span>
        <span class="token punctuation">-</span> <span class="token key atrule">id</span><span class="token punctuation">:</span> pay_routh1 <span class="token comment">#pay_routh1                #路由的ID(类似mysql主键ID)，没有固定规则但要求唯一，建议配合服务名</span>
          <span class="token key atrule">uri</span><span class="token punctuation">:</span> http<span class="token punctuation">:</span>//localhost<span class="token punctuation">:</span><span class="token number">8001</span>                <span class="token comment">#匹配后提供服务的路由地址</span>
          <span class="token key atrule">predicates</span><span class="token punctuation">:</span>
            <span class="token punctuation">-</span> Path=/pay/gateway/get/<span class="token important">**</span>              <span class="token comment"># 断言，路径相匹配的进行路由id: pay_routh2 #pay_routh2                #路由的ID(类似mysql主键ID)，没有固定规则但要求唯一，建议配合服务名</span>
          <span class="token key atrule">uri</span><span class="token punctuation">:</span> http<span class="token punctuation">:</span>//localhost<span class="token punctuation">:</span><span class="token number">8001</span>                <span class="token comment">#匹配后提供服务的路由地址</span>
          <span class="token key atrule">predicates</span><span class="token punctuation">:</span>
            <span class="token punctuation">-</span> Path=/pay/gateway/info/<span class="token important">**</span>              <span class="token comment"># 断言，路径相匹配的进行路由      </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
<h2 id="SpringCloud-1"><a href="#SpringCloud-1" class="headerlink" title="SpringCloud"></a>SpringCloud</h2><p><img src="/2024/03/05/33/alibaba.png" alt="阿里巴巴"></p>
<ul>
<li>功能<br><img src="/2024/03/05/33/%E5%8A%9F%E8%83%BD.png" alt="功能"></li>
<li>组件<br><img src="/2024/03/05/33/%E7%BB%84%E4%BB%B6.png" alt="组件"></li>
</ul>
<h3 id="服务注册-Nacos-x3D-x3D-consul"><a href="#服务注册-Nacos-x3D-x3D-consul" class="headerlink" title="服务注册 Nacos == consul"></a>服务注册 Nacos == consul</h3><p><strong>注意是根据ID来区分的不是根据名字来区分命名空间的，所以ID要填自己想填的</strong></p>
<p><img src="/2024/03/05/33/%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E5%AF%B9%E6%AF%94.png" alt="对比"></p>
<ul>
<li><p>命令行</p>
<pre class="line-numbers language-css" data-language="css"><code class="language-css">startup.cmd -m standalone<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
<li><p>服务提供者<br>pom:</p>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>  
	<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>com.alibaba.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>  
	<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-cloud-starter-alibaba-nacos-discovery<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>  
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>yml</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">server</span><span class="token punctuation">:</span>
  <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">9001</span>

<span class="token key atrule">spring</span><span class="token punctuation">:</span>
  <span class="token key atrule">application</span><span class="token punctuation">:</span>
    <span class="token key atrule">name</span><span class="token punctuation">:</span> nacos<span class="token punctuation">-</span>payment<span class="token punctuation">-</span>provider
  <span class="token key atrule">cloud</span><span class="token punctuation">:</span>
    <span class="token key atrule">nacos</span><span class="token punctuation">:</span>
      <span class="token key atrule">discovery</span><span class="token punctuation">:</span>
        <span class="token key atrule">server-addr</span><span class="token punctuation">:</span> localhost<span class="token punctuation">:</span><span class="token number">8848</span> <span class="token comment">#配置Nacos地址</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>main函数上使用@EnableDiscoveryClient<br>业务类示范<br><img src="/2024/03/05/33/controller%E7%A4%BA%E8%8C%83.png" alt="示范"></p>
</li>
<li><p>消费者<br>pom</p>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!--nacos-discovery--&gt;</span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>
           <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>com.alibaba.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>
           <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-cloud-starter-alibaba-nacos-discovery<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>
       <span class="token comment">&lt;!--loadbalancer--&gt;</span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>
           <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>
           <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-cloud-starter-loadbalancer<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>xml</p>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">
server:
  port: 83

spring:
  application:
    name: nacos-order-consumer
  cloud:
    nacos:
      discovery:
        server-addr: localhost:8848
#消费者将要去访问的微服务名称(nacos微服务提供者叫什么你写什么)
service-url:
  nacos-user-service: http://nacos-payment-provider<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>main上也使用@EnableDiscoveryClient</p>
</li>
</ul>
<p>restTemplate配置</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">ackage com<span class="token punctuation">.</span>atguigu<span class="token punctuation">.</span>cloud<span class="token punctuation">.</span>config<span class="token punctuation">;</span>

<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>cloud<span class="token punctuation">.</span>client<span class="token punctuation">.</span>loadbalancer<span class="token punctuation">.</span></span><span class="token class-name">LoadBalanced</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>context<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">Bean</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>context<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">Configuration</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>client<span class="token punctuation">.</span></span><span class="token class-name">RestTemplate</span></span><span class="token punctuation">;</span>

<span class="token comment">/**
 * @auther zzyy
 * @create 2023-11-23 17:20
 */</span>
<span class="token annotation punctuation">@Configuration</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RestTemplateConfig</span>
<span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Bean</span>
    <span class="token annotation punctuation">@LoadBalanced</span> <span class="token comment">//赋予RestTemplate负载均衡的能力</span>
    <span class="token keyword">public</span> <span class="token class-name">RestTemplate</span> <span class="token function">restTemplate</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">RestTemplate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>Nacos作为配置中心，进行动态配置<br>导入pom<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!--bootstrap--&gt;</span>
     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>
         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>
         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-cloud-starter-bootstrap<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>
     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>
     <span class="token comment">&lt;!--nacos-config--&gt;</span>
     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>
         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>com.alibaba.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>
         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-cloud-starter-alibaba-nacos-config<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>
     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
为什么进行两个配置？ bootstrap和application?<br>Nacos同Consul一样，在项目初始化时，要保证先从配置中心进行配置拉取，<br>拉取配置之后，才能保证项目的正常启动，为了满足动态刷新和全局广播通知<br>springboot中配置文件的加载是存在优先级顺序的，bootstrap优先级高于application<br>bootstrap<pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector"># nacos配置
spring:
  application:
    name: nacos-config-client
  cloud:
    nacos:
      discovery:
        server-addr: localhost:8848 #Nacos服务注册中心地址
      config:
        server-addr: localhost:8848 #Nacos作为配置中心地址
        file-extension: yaml #指定yaml格式的配置

# nacos端配置文件DataId的命名规则是：
# $</span><span class="token punctuation">{</span>spring.application.name<span class="token punctuation">}</span><span class="token selector">-$</span><span class="token punctuation">{</span>spring.profile.active<span class="token punctuation">}</span><span class="token selector">.$</span><span class="token punctuation">{</span>spring.cloud.nacos.config.file-extension<span class="token punctuation">}</span>
# <span class="token property">本案例的DataID是</span><span class="token punctuation">:</span>nacos-config-client-dev.yaml<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
application<pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token property">server</span><span class="token punctuation">:</span>
  <span class="token property">port</span><span class="token punctuation">:</span> 3377

<span class="token property">spring</span><span class="token punctuation">:</span>
  <span class="token property">profiles</span><span class="token punctuation">:</span>
    <span class="token property">active</span><span class="token punctuation">:</span> dev # 表示开发环境
      #<span class="token property">active</span><span class="token punctuation">:</span> prod # 表示生产环境
    #<span class="token property">active</span><span class="token punctuation">:</span> test # 表示测试环境<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
controller层上使用@RefreshScope //在控制器类加入@RefreshScope注解使当前类下的配置支持Nacos的动态刷新功能。</li>
</ul>
<p><em><strong>问题1：</strong></em></p>
<p>实际开发中，通常一个系统会准备</p>
<p>dev开发环境</p>
<p>test测试环境</p>
<p>prod生产环境。</p>
<p>如何保证指定环境启动时服务能正确读取到Nacos上相应环境的配置文件呢？</p>
<p><em><strong>问题2:</strong></em></p>
<p>一个大型分布式微服务系统会有很多微服务子项目，</p>
<p>每个微服务项目又都会有相应的开发环境、测试环境、预发环境、正式环境……</p>
<p>那怎么对这些微服务配置进行分组和命名空间管理呢？</p>
<p><img src="/2024/03/05/33/model.png" alt="model"></p>
<h2 id="Sentinel-等价于-Circuit-Breaker-自己去官网看"><a href="#Sentinel-等价于-Circuit-Breaker-自己去官网看" class="headerlink" title="Sentinel 等价于 Circuit Breaker 自己去官网看"></a>Sentinel 等价于 Circuit Breaker 自己去官网看</h2><p><img src="/2024/03/05/33/%E9%9B%AA%E5%B4%A9.png"><br><img src="/2024/03/05/33/%E9%99%8D%E7%BA%A7.png"><br><img src="/2024/03/05/33/%E7%86%94%E6%96%AD.png"><br><img src="/2024/03/05/33/%E9%99%90%E6%B5%81.png"><br><img src="/2024/03/05/33/%E9%9A%94%E7%A6%BB.png"><br><img src="/2024/03/05/33/%E9%9A%94%E7%A6%BB.png"><br><img src="/2024/03/05/33/%E8%B6%85%E6%97%B6.png"></p>
<p>pom</p>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!--SpringCloud alibaba sentinel --&gt;</span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>
           <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>com.alibaba.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>
           <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-cloud-starter-alibaba-sentinel<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>yml</p>
<pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token property">server</span><span class="token punctuation">:</span>
  <span class="token property">port</span><span class="token punctuation">:</span> 8401

<span class="token property">spring</span><span class="token punctuation">:</span>
  <span class="token property">application</span><span class="token punctuation">:</span>
    <span class="token property">name</span><span class="token punctuation">:</span> cloudalibaba-sentinel-service
  <span class="token property">cloud</span><span class="token punctuation">:</span>
    <span class="token property">nacos</span><span class="token punctuation">:</span>
      <span class="token property">discovery</span><span class="token punctuation">:</span>
        <span class="token property">server-addr</span><span class="token punctuation">:</span> <span class="token property">localhost</span><span class="token punctuation">:</span>8848         #Nacos服务注册中心地址
    <span class="token property">sentinel</span><span class="token punctuation">:</span>
      <span class="token property">transport</span><span class="token punctuation">:</span>
        <span class="token property">dashboard</span><span class="token punctuation">:</span> <span class="token property">localhost</span><span class="token punctuation">:</span>8080 #配置Sentinel dashboard控制台服务地址
        <span class="token property">port</span><span class="token punctuation">:</span> 8719 #默认8719端口，假如被占用会自动从8719开始依次+1扫描<span class="token punctuation">,</span>直至找到未被占用的端口<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="/2024/03/05/33/%E6%87%92%E5%8A%A0%E8%BD%BD.png" alt="懒加载"></p>
<ul>
<li>流控规则<br><img src="/2024/03/05/33/%E6%B5%81%E6%8E%A7%E8%A7%84%E5%88%99.png"></li>
<li>熔断降级<br>Sentinel 熔断降级会在调用链路中某个资源出现不稳定状态时（例如调用超时或异常比例升高），对这个资源的调用进行限制，</li>
</ul>
<p>让请求快速失败，避免影响到其它的资源而导致级联错误。当资源被降级后，在接下来的降级时间窗口之内，对该资源的调用都自动熔断（默认行为是抛出 DegradeException）。、</p>
<h3 id="如何处理分布式-事务"><a href="#如何处理分布式-事务" class="headerlink" title="如何处理分布式 事务"></a>如何处理分布式 事务</h3><h2 id="Seata"><a href="#Seata" class="headerlink" title="Seata"></a>Seata</h2><p><img src="/2024/03/05/33/senta.png" alt="senta"></p>
<p>去官网看</p>
<p>面试题：<br><img src="/2024/03/05/33/AT%E9%9D%A2%E8%AF%95%E9%A2%98.png"><br><img src="/2024/03/05/33/AT%E9%9D%A2%E8%AF%95%E9%A2%981.png"></p>
<p><img src="/2024/03/05/33/%E6%8F%90%E4%BA%A4.png"><br><img src="/2024/03/05/33/%E5%9B%9E%E6%BB%9A.png"></p>
<h2 id="分布式详细"><a href="#分布式详细" class="headerlink" title="分布式详细"></a>分布式详细</h2><h3 id="分布式ID-分布式ID-https-javaguide-cn-distributed-system-distributed-id-design-html"><a href="#分布式ID-分布式ID-https-javaguide-cn-distributed-system-distributed-id-design-html" class="headerlink" title="[分布式ID](### 分布式ID https://javaguide.cn/distributed-system/distributed-id-design.html)"></a>[分布式ID](### 分布式ID <a target="_blank" rel="noopener" href="https://javaguide.cn/distributed-system/distributed-id-design.html">https://javaguide.cn/distributed-system/distributed-id-design.html</a>)</h3><h4 id="需求："><a href="#需求：" class="headerlink" title="需求："></a>需求：</h4><ol>
<li>全局唯一</li>
<li>高可用</li>
<li>高性能</li>
<li>安全</li>
<li>方便易用</li>
</ol>
<h4 id="解决方式："><a href="#解决方式：" class="headerlink" title="解决方式："></a>解决方式：</h4><p>推荐使用雪花算法</p>
<h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><h4 id="Redis实现"><a href="#Redis实现" class="headerlink" title="Redis实现"></a>Redis实现</h4><h5 id="setnx"><a href="#setnx" class="headerlink" title="setnx"></a>setnx</h5><h6 id="Redisson"><a href="#Redisson" class="headerlink" title="Redisson"></a>Redisson</h6><h4 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h4><p>一个线程中可以多次获取同一把锁，例如，方法又调用了另一个需要相同锁的方法。<br>可以使用红锁</p>
<h4 id="ZooKeeper"><a href="#ZooKeeper" class="headerlink" title="ZooKeeper"></a><a target="_blank" rel="noopener" href="https://javaguide.cn/distributed-system/distributed-lock-implementations.html#%E5%9F%BA%E4%BA%8E-zookeeper-%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81">ZooKeeper</a></h4><p><a target="_blank" rel="noopener" href="https://javaguide.cn/distributed-system/distributed-process-coordination/zookeeper/zookeeper-intro.html">https://javaguide.cn/distributed-system/distributed-process-coordination/zookeeper/zookeeper-intro.html</a><br>Redis的性能更好，但是Zookeeper的可靠性更高。<br>推荐使用 Curator 来实现 ZooKeeper 分布式锁。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zuofw.github.io/2024/02/27/04/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="QingQiu">
      <meta itemprop="description" content="个人网站，学习记录，面试记录和经验总结、互联网中一块属于自己的小窝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="QingQiu'Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/02/27/04/" class="post-title-link" itemprop="url">python and web or ai</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-02-27 19:23:04" itemprop="dateCreated datePublished" datetime="2024-02-27T19:23:04+08:00">2024-02-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-03-01 20:12:49" itemprop="dateModified" datetime="2024-03-01T20:12:49+08:00">2024-03-01</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>815</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><h2 id="web"><a href="#web" class="headerlink" title="web"></a>web</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python">pip install beautifulsoup4 <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="Scrapy框架"><a href="#Scrapy框架" class="headerlink" title="Scrapy框架"></a>Scrapy框架</h2><p>项目结构:</p>
<pre class="line-numbers language-css" data-language="css"><code class="language-css">scrapy.cfg 配置文件
setting.py 定义爬虫的相关配置信息
items.py 定义待爬页面数据的结构
pipelines.py 定义存储爬到的数据的方式
middlewares.py 定义随机切换ip等逻辑
Spiders 在目录里，存放爬虫代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">scrapy startproject projectName 新建一个项目
1.在items模块中定义待爬取内容的数据结构
2.在spiders文件中
scrapy genspider name xxx.com 新建一个爬虫文件
3.pipelines中定义存储方式
4.settings中加入
ITEM_PIPELINES =</span> <span class="token punctuation">{</span>

    <span class="token string">"cnblogPrj.pipelines.CnblogprjPipeline"</span><span class="token punctuation">:</span> 300<span class="token punctuation">,</span>

<span class="token punctuation">}</span>

# 禁用cookies

COOKIES_ENABLED = False<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-none"><code class="language-none">x = float(input() )

y = float(input())

print("{:.3f} + {:.3f} = {:.3f}".format(x, y, x + y))

print("{:.3f} - {:.3f} = {:.3f}" .format (x, y, x - y))

print("{:.3f} * {:.3f} = {:.3f}" .format (x, y, x * y))

print("{:.3f} / {:.3f} = {:.3f}" .format (x, y, x / &nbsp;y))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zuofw.github.io/2023/10/23/46/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="QingQiu">
      <meta itemprop="description" content="个人网站，学习记录，面试记录和经验总结、互联网中一块属于自己的小窝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="QingQiu'Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/10/23/46/" class="post-title-link" itemprop="url">计网</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-10-23 20:01:46" itemprop="dateCreated datePublished" datetime="2023-10-23T20:01:46+08:00">2023-10-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-10-15 22:28:33" itemprop="dateModified" datetime="2024-10-15T22:28:33+08:00">2024-10-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">计算机基础</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>16k</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="计网"><a href="#计网" class="headerlink" title="计网"></a>计网</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>MTU:网络中一次可以传输的最大数据包的大小<br>MSS:TCP中除去TCP和IP的头部，能够传输的最大的数据量<br>SDU，Service Data Unit，服务数据单元。<br>ISP 是 Internet Service Provider 的缩写，翻译为互联网服务提供商。<br>协议<br>Telnet 客户端登录协议，属于应用层<br>TLD 是 Top-Level Domain 的缩写，翻译为顶级域名<br>GBN (Go-Back-N)  退回<br>SR 选择性重传<br>mask 子网掩码<br>SDN 是指软件定义网络（Software-Defined Networking）<br>OSPF（Open Shortest Path First）是一种开放式的链路状态路由协议，用于计算机网络中的动态路由。<br>Secure sockets layer (SSL)</p>
<p><strong>MSL:报文最大生存时间<br>TTL:经过的路由跳数</strong></p>
<p>序列号：在建立连接时由内核生成的随机数作为其初始值，通过 SYN 报文传给接收端主机，每发送一次数据，就「累加」一次该「数据字节数」的大小。用来解决网络包乱序问题。<br>确认号：指下一次「期望」收到的数据的序列号，发送端收到接收方发来的 ACK 确认报文以后，就可以认为在这个序号以前的数据都已经被正常接收。用来解决丢包的问题。<br><strong>控制位：</strong> 用来标识 TCP 报文是什么类型的报文，比如是 SYN 报文、数据报文、ACK 报文，FIN 报文等。</p>
<h1 id="面试常问"><a href="#面试常问" class="headerlink" title="面试常问"></a>面试常问</h1><ul>
<li>UDP是面向报文的：发送方不会对报文进行拆分，所以一个报文就是一个完整的消息，接收方使用队列来区分不同报文</li>
<li>TCP是面向字节流的：粘包问题：TCP报文会拆分成多个，取决于<strong>发送窗口、拥塞窗口以及当前发送缓冲区的大小等条件</strong>，所以不容易知道一个用户消息的边界<ul>
<li><img src="/2023/10/23/46/TcpHeader.png"></li>
<li>控制位是单独的留出来的几个位置</li>
<li>TCP面向字节流的，发送的是一个个连续的字节，而UDP是面向数据报的，一个UDP数据报就是一个完整的消息</li>
<li>重传机制：1.超时重传，重传时间最好略大于包的往返时间，2.快速重传3.SACK重传，选择性确认&nbsp;TCP 头部「选项」字段里加一个&nbsp;<code>SACK</code>&nbsp;的东西，它<strong>可以将已收到的数据的信息发送给「发送方」</strong>，这样发送方就可以知道哪些数据收到了，哪些数据没收到，知道了这些信息，就可以<strong>只重传丢失的数据</strong>。4.   Duplicate SACK,只告诉对方有哪些数据被重复接受了</li>
<li>滑动窗口：<strong>无需等待确认应答，而可以继续发送数据的最大值</strong></li>
<li><strong>拥塞窗口 cwnd</strong>是发送方维护的一个的状态变量，它会根据<strong>网络的拥塞程度动态变化的</strong>。 网络没出现拥塞，cwnd增加，出现拥塞cwnd减少</li>
</ul>
</li>
<li>HTTP：最常使用的是HTTP/1.1 <ul>
<li>优化 HTTP/1.1<ol>
<li>减少请求次数：1.使用客户端缓存，2.减少重定向次数，3.合并请求，4.延迟发送，只发送一部分内容</li>
<li>减少响应数据大小：使用压缩方式</li>
</ol>
</li>
</ul>
<ol>
<li>Keep-Alive：用于保持长连接，keepalive，TCP中的保活机制,HTTP1.1默认是开启的，在请求头中使用<code>Connection: Keep-Alive</code></li>
<li>强制缓存：服务器直接要求使用浏览器缓存的数据， 协商缓存：服务器会对比缓存过期时间，决定是否过期，返回给浏览器决定是否使用浏览器的缓存</li>
<li>队头阻塞：服务端在处理请求时耗时较长导致后面的请求无法即使发送，解决方式 ：使用管道：客户端可以直接发送多个请求，服务端根据发送顺序来解决，但是管道技术基本 <strong>没人使用</strong></li>
</ol>
<ul>
<li>演进过程：<ol>
<li>1.1 使用长连接改善短链接的性能开销，使用管道进传输，改善了队头阻塞。缺点是：header未压缩，只能压缩body,只能从客户端开始发送请求，没有请求优先级</li>
<li>2 头部压缩，当同时发送多个请求，如果请求头是一样或者相似的就把重复发部分消除，基于HTTPS的，头部全部使用二进制格式取代原来的纯文本，使用Stream,一个Stream可以包含多个Message,Message中可以包含多个Frame,Frame中包含Headers和Body,Stream都跑在同一个TCP上，客户端收到后会根据相同的Stream ID 有序组装成HTTP消息，Stream流用于多路复用TCP<ul>
<li>缺点是：由于TCP的是基于字节流的，必须保证收到的字节数据是完整且恋雪的才能将数据返回给应用层</li>
</ul>
</li>
<li>HTTP/3 使用UDP协议来解决响应的队头阻塞。<ol>
<li>使用基于UDP的QUIC协议，保证类似的可靠传输</li>
<li>QUIC 有自己的一套机制可以保证传输的可靠性的。当某个流发生丢包时，只会阻塞这个流，其他流不会受到影响，因此不存在队头阻塞问题。这与 HTTP/2 不同，HTTP/2 只要某个流中的数据包丢失了，其他流也会因此受影响。</li>
<li>当某个流丢包时，只会阻塞这个流，其他流不会阻塞，不存在队头阻塞问题</li>
<li><a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/2_http/https_rsa.html#tls-%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B">RSA算法</a>不支持前向加密，只要获取浏览器的私钥，即可破解</li>
<li></li>
</ol>
</li>
</ol>
</li>
</ul>
</li>
<li>HTTPS: <ol>
<li>使用混合加密：通信建立前使用非对称加密来交换会话密钥， 通信过程中使用对称加密的会话密钥来进行通信</li>
<li>公钥运算出的结果，只有使用私钥来进行逆运算得到结果。 发送时，发送者使用接收者的公钥，公钥是可知的，解决了密钥交换的问题，接收者使用自己的私钥进行解密。</li>
<li>公钥加密，私钥解密：保证传输过程中内容的加密</li>
<li>私钥加密，公钥解密：保证消息不会被篡改。—&gt;数字签名算法</li>
<li>使用权威机构CA(数字证书认证机构)来保存数字证书：个人信息+公钥+数字签名</li>
</ol>
</li>
<li>TCP<ul>
<li>三次握手的过程<ol>
<li>客户端发送带有SYN(同步序列)SEQ(序列号) = x  标志的数据包，客户端进入SYN_SEND状态</li>
<li>服务端发送带有SYN(SEQ = y) + ACK (ACK = x + 1) 标志的数据包，进入SYN_RECV状态</li>
<li>客户端发送 带有ACK(ACK = y + 1) 标志的数据包，二者进入ESTABLISHED状态</li>
</ol>
<ul>
<li>为什么要第二次传回SYN 用于表明所收到的是对应的客户端发送的信号</li>
</ul>
</li>
<li>四次挥手:<ol>
<li>客户端发送FIN(SEQ = x) ，进入FIN-WAIT-1状态</li>
<li>服务端发送ACK(ACK=x+1) 进入CLOSE-WAIT状态，客户端进入FIN-WAIT-2</li>
<li>服务端发送FIN(SEQ=y) 请求关闭,进入LAST-ACK</li>
<li>客户端发送，ACK(ACK=y+1) ，客户端进入TIME-WAIT，服务端接收后进入CLOSE，客户端等待一段时间之后如果没有收到回复，就关闭客户端。</li>
</ol>
</li>
<li>可不可以把ACK和FIN合并起来变成三次挥手： 不行，因为服务器收到断开请求时，可能还有一些数据没有传输完成，所以先发送ACK表明收到请求，等待所有数据发送完成之后发送FIN断开连接</li>
</ul>
</li>
<li>IP<ul>
<li>DNS:域名解析：</li>
<li>DHCP（动态主机配置协议）是一个网络协议，用于自动分配 IP 地址和其他相关配置信息给网络中的设备。这使得设备可以在加入网络时自动获取网络配置，无需手动设置。</li>
<li>ARP工作原理：广播问询，单播响应<ul>
<li>一个局域网中<ol>
<li>维护一个ARP表 &lt;IP,MAC,TTL&gt;</li>
<li>查询ARP表，如果不存在，则构造一个ARP查询分组，将其广播到局域网中，MAC地址为广播地址，然后希望收到的是IP地址</li>
<li>设备接收后查询是否为自己的IP，如果不是则丢弃，如果是，则构造ARP响应分组，发送给查询主机，并在自己的表中构造一条查询主机的IP-MAC映射表，使用的是单播，不再广播</li>
<li>查询的主机接受后，将其加入ARP表中</li>
</ol>
</li>
<li>不在一个局域网中：通过路由器转发查询</li>
</ul>
</li>
<li>NAT:同一个场景下将私有IP转化为共有IP地址</li>
<li>ICMP：互联网控制报文协议，确认Ip包是否<ul>
<li>ping：基于ICMP协议工作的，使用的ICMP类型中0和8，也就是回送应答和会送请求，根据这个来判断是否到达IP地址，如果路由器中间没有找到对应的接收端IP就会往发送端IP发送ICMP报文，8是源主机向目标主机的发送的请求，0是目标主机的回应</li>
<li>各种本地IP代指的区别：<ol>
<li>localhost 默认就是同于127.0.0.1，但是可以修改，是属于域名</li>
<li>0.0.0.0 IPv4中是无效地址，代指的是广播，监听本地的0.0.0.0时，代表的监听本机上所有的IPv4地址</li>
<li>127.0.0.1是回环地址</li>
</ol>
</li>
</ul>
</li>
<li>IGMP：Internet组管理协议，工作哎主机和最后一跳的路由之间。</li>
<li>为何断网了也能ping通127.0.0.1? 因为会把消息交给本地网卡，本地网卡直接把消息发送到本机接受到的消息链表中并触发软中断，由内核线程来传递给上层应用程序</li>
</ul>
</li>
</ul>
<h2 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h2><p>分类</p>
<h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><h2 id="如何解决粘包问题"><a href="#如何解决粘包问题" class="headerlink" title="如何解决粘包问题"></a>如何解决粘包问题</h2><p>找到消息的边界就能解决这个问题</p>
<ol>
<li>固定长度</li>
<li>特殊字符作为边界</li>
<li>自定义消息结构</li>
</ol>
<h3 id="重传机制"><a href="#重传机制" class="headerlink" title="重传机制"></a>重传机制</h3><p>重传是由序列号和确认应答来控制的</p>
<ol>
<li>超时重传，TCP的超时重传策略是间隔时间每次都设置为先前值的两倍，如果出现两次超时，说明网络环境差，不会重传了</li>
<li>快速重传：当收到三个相同ACK报文时，说明出现了丢包，会重传丢失的报文。</li>
</ol>
<h3 id="滑动窗口-4-2-TCP-重传、滑动窗口、流量控制、拥塞控制-小林coding-xiaolincoding-com"><a href="#滑动窗口-4-2-TCP-重传、滑动窗口、流量控制、拥塞控制-小林coding-xiaolincoding-com" class="headerlink" title="[滑动窗口](4.2 TCP 重传、滑动窗口、流量控制、拥塞控制 | 小林coding (xiaolincoding.com))"></a>[滑动窗口](<a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/3_tcp/tcp_feature.html#%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6">4.2 TCP 重传、滑动窗口、流量控制、拥塞控制 | 小林coding (xiaolincoding.com)</a>)</h3><p>TCP头中有一个Window字段，代表滑动窗口大小。表示接受方告诉对方自己还有多少缓冲区可以接受数据。</p>
<h4 id="发送方窗口"><a href="#发送方窗口" class="headerlink" title="发送方窗口"></a>发送方窗口</h4><p><img src="/2023/10/23/46/%E5%8F%91%E9%80%81%E6%96%B9%E7%AA%97%E5%8F%A3.png"></p>
<h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>HTTP是一个在计算机世界中专门在亮点之间传输文字、图片等超文本的约定与规范</p>
<h3 id="常见的状态码"><a href="#常见的状态码" class="headerlink" title="常见的状态码"></a>常见的状态码</h3><ol>
<li>1xx 是一种中间状态，实际使用较少</li>
<li>2xx 表示服务器成功处理了请求<ul>
<li>200 OK</li>
<li>204 No Content 与200基本相同，但是响应头没有body数据</li>
<li>206 Partial Content表示响应返回的body数据并不是资源的全部。</li>
</ul>
</li>
<li>3xx 重定向<ul>
<li>301 永久重定向</li>
<li>302 Found 临时重定向，注意301和302都会在响应头中使用Location字段知名后续需要跳转的URL，浏览器会自动重定向到新的URL</li>
<li>304  资源未修改，可以使用缓存资源</li>
</ul>
</li>
<li>4xx 客户端发送的报文有误<ul>
<li>400 请求有误，笼统的错误</li>
<li>403 服务器禁止访问资源</li>
<li>404 服务器不存在或未找到</li>
</ul>
</li>
<li>5xx 客户端请求报文正确，但是服务器处理时，内部出现了错误，属于服务端错误码<ul>
<li>500 笼统错误</li>
<li>501 客户端请求功能不支持，敬请期待</li>
<li>502 网关错误</li>
<li>503 服务器繁忙，无法咱是无法响应客户端。</li>
</ul>
</li>
</ol>
<h3 id="HTTP缓存"><a href="#HTTP缓存" class="headerlink" title="HTTP缓存"></a>HTTP缓存</h3><ol>
<li>强制缓存：浏览器判断缓存没过期就强制使用本地缓存。使用的是Cache-Control和Expires，第一个是相对时间，第二个是绝对时间。第一个优先级更高。<ul>
<li>浏览器第一次请求时，会加上这个过期时间</li>
<li>再次请求时，根据请求时间和这个过期时间进行比较，来判断是否过期，并且更新这个时间</li>
</ul>
</li>
<li>协商缓存： 与服务器协商之后，通过协商结果来判断是否使用本地缓存。<img src="/2023/10/23/46/%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98.png"></li>
</ol>
<h2 id="不同版本的HTTP特点"><a href="#不同版本的HTTP特点" class="headerlink" title="不同版本的HTTP特点"></a>不同版本的HTTP特点</h2><p>HTTP: 80<br>HTTPS: 443</p>
<h3 id="HTTP缓存-1"><a href="#HTTP缓存-1" class="headerlink" title="HTTP缓存"></a>HTTP缓存</h3><p>Cache-Control(相对时间)优先级高于Expires(绝对时间)<br>强制缓存是浏览器中的缓存没过期就强制使用缓存，协商缓存是每次与服务器协商是否过期。</p>
<h3 id="HTTP的迭代和对比"><a href="#HTTP的迭代和对比" class="headerlink" title="HTTP的迭代和对比"></a>HTTP的迭代和对比</h3><h4 id="HTTP1-1"><a href="#HTTP1-1" class="headerlink" title="HTTP1.1"></a>HTTP1.1</h4><p><strong>已经实现了长连接和管道网络传输(不需要一问一答，可以连续发送请求)</strong><br>解决了 <strong>请求的队头阻塞</strong>，但是没解决响应的队头阻塞。<br>头部冗长，未压缩，请求只能由客户端开始</p>
<h4 id="优点和缺点"><a href="#优点和缺点" class="headerlink" title="优点和缺点"></a>优点和缺点</h4><p>双刃剑：无状态、明文传输<br>缺点：不安全</p>
<ul>
<li>无状态可以使得浏览器不需要额外记忆HTTP的状态，缺点是处理有关联性的操作时会很麻烦<ul>
<li>解决方式就是使用Cookie</li>
</ul>
</li>
<li>明文传输：方便调试的同时不安全</li>
<li>不安全：1. 明文传输2.不验证通信双方的身份3.不能证明报文的完整性 <ul>
<li>解决方式使用HTTPS</li>
</ul>
</li>
</ul>
<h4 id="性能-长连接"><a href="#性能-长连接" class="headerlink" title="性能(长连接)"></a>性能(长连接)</h4><ol>
<li>相比较于1.0，1.1使用了长连接，一次TCP连接发起多次请求</li>
<li>可以使用管道通信，只要请求发送出去后，不需要等待响应结果即可发送下一个请求<br>解决了请求的队头阻塞，但是没有解决响应的队头阻塞，同时不是默认使用的<blockquote>
<p>队头阻塞是指当一个请求因为某种原因被阻塞，会导致后面排队的所有请求都一同被阻塞<br>进步：</p>
</blockquote>
</li>
<li>长连接</li>
<li>支持管道网络传输<br>缺点：</li>
<li>Header部分未经压缩就发送，延迟大，只能压缩Body部分</li>
<li>会出现队头阻塞：服务端响应慢，导致后续的请求不能及时发送</li>
<li>请求只能从客户端开始</li>
</ol>
<h4 id="HTTP-x2F-2"><a href="#HTTP-x2F-2" class="headerlink" title="HTTP/2"></a>HTTP/2</h4><p>进步：</p>
<ol>
<li>HTTP/2是基于HTTPS，安全有保证</li>
<li>队头压缩：如果同时发出多个请求，他们的请求头是一样的或者是相似的，就会消除重复的部分，原理是客户端和服务端同时维护一张头信息表，所有字段都会存在里面来进行索引</li>
<li>二进制格式：报文使用二进制格式，而不是使用纯文本的格式</li>
<li>并发传输，多路复用，一条TCP连接包含多个Stream，StreamID来区分，不同Stream的帧是可以乱序发送的</li>
<li>服务器可以主动推送资源<br>虽然在HTTP层解决了队头阻塞，但是TCP是字节流协议，导致必须满足一个一个字节才能够读取数据，从而降低效率，一旦丢包，必须进行TCP的重传，就会导致效率降低。</li>
</ol>
<h4 id="HTTP-x2F-3"><a href="#HTTP-x2F-3" class="headerlink" title="HTTP/3"></a>HTTP/3</h4><p>使用UDP来进行传输</p>
<h5 id="QUIC协议"><a href="#QUIC协议" class="headerlink" title="QUIC协议"></a>QUIC协议</h5><p>QUIC协议也实现了Stream的概念，从而某个流发生丢包时，只会则色这个流，而不会阻塞其他流，从而不会存在队头阻塞。<br>QUIC是google设计的一个基于UDP的网络传输协议，旨在替代TCP协议以提供更快的连接建立和数据传输速度。</p>
<ol>
<li>快速建立连接：使用基于TLS的安全连接，同时将连接的建立与TLS握手合并，从而减少了连接所需要的往返时间。</li>
<li>多路复用：允许在单个连接上同时进行多个独立的数据流，从避免了TCP连接中的队头阻塞</li>
<li>零RTT握手：QUIC支持零往返时间握手，允许客户端在第一次连接时发送数据，无需等待握手完成，进一步减少了连接建立时间。</li>
<li>动态调整拥塞控制：使用更先进的拥塞控制算法，能够动态的根据网络条件调增数据传输速率。</li>
<li>错误恢复：QUIC内置了一些错误恢复机制，包括快速重传和前向错误纠正，能够在发生丢包或网络拥塞时更快的恢复数据传输。</li>
</ol>
<p>HTTP/2 是⼀个应⽤层协议，是 HTTP/1.1 的后继版本，旨在提⾼ Web ⻚⾯加载速度和性能。 HTTP/2<br>在传输层使⽤了⼆进制分帧，头部压缩，多路复⽤等技术，以减少延迟和提⾼效率。 HTTP/2 不是⼀个<br>替代传输层协议，⽽是在传输层上实现的 HTTP 协议的增强版本。</p>
<h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><blockquote>
<p>HTTPS是在TCP和HTTP之间加入了SSL/TLS安全协议</p>
</blockquote>
<h4 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h4><ol>
<li>混合加密：对称加密和非对称加密的混合加密方式，通信建立之前使用的是非对称加密，建立之后通信使用的对称加密，对称加密只需要使用一个密钥，所以更加高效。</li>
<li>摘要算法 + 数字签名：通过摘要算法获得哈希值，来判断报文是否被修改。而数字签名则能保证通信双方的身份</li>
<li>数字证书：可信的第三方来保证双方身份，主要是CA通过私钥加密双方的公钥数字签名，然后CA的公钥是公开的，之后另一方通过CA的公钥解密获得对方的公钥，之后对方使用私钥加密，就可以使用公钥进行解密了或者是加密通信。<img src="/2023/10/23/46/CA%E7%AE%97%E6%B3%95.png"></li>
</ol>
<h4 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h4><ol>
<li>公钥加密，私钥解密：保证内容的安全，只有私钥可以解密内容</li>
<li>私钥加密，公钥解密：保证消息不可冒充，因为私钥是不可以泄漏的，验证双方身份，也就是数字签名算法<img src="/2023/10/23/46/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D%E7%AE%97%E6%B3%95.png" alt="|525"></li>
</ol>
<h4 id="流程-RSA算法为例"><a href="#流程-RSA算法为例" class="headerlink" title="流程(RSA算法为例)"></a>流程(RSA算法为例)</h4><ol>
<li>三次握手建立TCP连接</li>
<li>客户端发送ClientHello请求，携带客户端支持的TLS版本信息和客户端随机数Client Random，支持的密码套件列表(比如RSA算法)</li>
<li>ServerHello响应：确定TLS版本，浏览器不支持就断开，服务器随机数Server Random， 使用的加密算法，服务器的数字证书</li>
<li>客户端使用CA的公钥确定证书的真实性，之后取出公钥，加密报文发送：1. 随机数 pre-master key 2.加密通信算法改变通知，表示之后都将使用会话密钥(对称加密)进行通信，客户端握手结束通知，把之前所有的内容进行摘要，给服务器进行校验</li>
<li>双方使用这三个随机数和加密算法生成会话密钥</li>
<li>服务器最后1.加密算法改变 2.握手结束，生成摘要供客户端校验</li>
</ol>
<h4 id="HTTPS抓包-x2F-代理人"><a href="#HTTPS抓包-x2F-代理人" class="headerlink" title="HTTPS抓包/代理人"></a>HTTPS抓包/代理人</h4><p><img src="/2023/10/23/46/%E4%BB%A3%E7%90%86%E4%BA%BA.webp"></p>
<p>抓包工具的原理就是往系统受信任的根证书列表导入抓包工具生成的证书，这个证书会被浏览器新人，也就是转包工具给自己建立了一个CA。<br>如何解决中间人攻击：使用HTTPS双向认证，服务器也对客户端的认证信息进行验证。</p>
<h2 id="计网常问"><a href="#计网常问" class="headerlink" title="计网常问"></a>计网常问</h2><h3 id="一个请求整个网络的处理"><a href="#一个请求整个网络的处理" class="headerlink" title="一个请求整个网络的处理"></a>一个请求整个网络的处理</h3><ol>
<li>浏览器解析URL生成HTTP消息</li>
<li>通过DNS解析获得IP地址</li>
<li>之后将HTTP的传输工作通过调用Socket库交给操作系统的协议栈</li>
<li>TCP简历链接需要三次握手，保证双方都有发送和接收的能力</li>
<li>建立连接之后，TCP报文中的数据部分就是存放HTTP头部+数据，组装好TCP报文之后，交给下面的网络层处理</li>
<li>IP协议里需要源地址和目的地址IP，存在多个网卡时，需要根据路由表规则。</li>
<li>生成IP头部之后，需要在前面加上MAC头部，接收方的MAC地址通过ARP协议获得，并且放入ARP缓存</li>
<li>网卡驱动获得网络包，将其复制到网卡内的缓存区中，从开头加上包头和起始帧分节符，末尾加上用于校验错误的帧校验序列。之后网卡将包转为电信号，通过网线发送</li>
<li>电信号到达网线接口，交换机里的模块进行接收。之后将电信号转化为数字信号。FCS校验没问题后放入缓冲区，之后查询MAC地址，如果找不到，就发除了源端口的所有端口。</li>
<li>电信号到达⽹线接⼝部分，路由器中的模块会将电信号转成数字信号， FCS 进⾏错误校验没问题后确认接收⽅MAC地址，然后去掉MAC头部，查询路由表判断转发⽬标，如果⽹关为空则 IP 头部中的接收⽅ IP 地址就是要转发到的⽬标地址</li>
<li>知道对⽅的 IP 地址之后，接下来需要通过 ARP 协议根据 IP 地址查询 MAC 地址，加上MAC头部，发送⽹络包，通过交换机到达下⼀个路由器</li>
<li>最后数据包抵达了服务器</li>
</ol>
<h3 id="IPv6优点"><a href="#IPv6优点" class="headerlink" title="IPv6优点"></a>IPv6优点</h3><ol>
<li>更⼤的地址空间：IPv6将地址⻓度从IPv4的32位扩展到了128位，理论上可以分配⼤约3.4x10^38个唯⼀的IP地址。</li>
<li>简化的报⽂格式：IPv6头部格式更为简洁，减少了处理的复杂性，提⾼了路由效率。</li>
<li>改进的服务质量（QoS）：IPv6⽀持更好的流量分类和优先级处理，有助于提供更加可靠的服务质量。</li>
<li>内建的安全机制：IPv6原⽣⽀持IPsec（⽹络安全协议），为数据传输提供了端到端的加密和认证。</li>
<li>⾃动配置能⼒：IPv6⽀持有状态和⽆状态的地址⾃动配置（SLAAC），简化了⽹络设备的配置和管理</li>
</ol>
<h3 id="BGP、OSPF协议原理"><a href="#BGP、OSPF协议原理" class="headerlink" title="BGP、OSPF协议原理"></a>BGP、OSPF协议原理</h3><blockquote>
<p>边界⽹关协议(Border Gateway Protocol，简称BGP)和开放最短路径优先协议(Open Shortest Path<br>First，简称OSPF)是世界上最流⾏的两种基于标准的动态路由协议。</p>
</blockquote>
<h3 id="三握四挥"><a href="#三握四挥" class="headerlink" title="三握四挥"></a>三握四挥</h3><p><img src="/2023/10/23/46/%E4%B8%89%E6%8F%A1%E5%9B%9B%E6%8C%A5.png"></p>
<h3 id="TCP和UDP"><a href="#TCP和UDP" class="headerlink" title="TCP和UDP"></a>TCP和UDP</h3><p><img src="/2023/10/23/46/%E5%A4%B4%E9%83%A8.png" alt="|525"></p>
<ol>
<li>序列号：建立连接时，由计算机生成的随机数作为初始值，通过SYN包传给接收端主机，每发送一次，就累加一次该数据字节数的大小，解决网络包乱序问题。</li>
<li>确认应答号：下一次期望收到数据的序列号。发送端收到这个之后可以认为在这之前的数据都被正常接收，用于解决丢包问题。</li>
<li>控制位为1时：<ul>
<li>ACK：确认应答变为有效，TCP规定除了最初建立连接时的SYN包之外必须设为1</li>
<li>RST：标识连接异常必须强制断开连接</li>
<li>SYN：表示希望建立连接</li>
<li>FIN：今后不会再有数据发送，希望断开连接时，表示今后不再有数据发送，希望断开连接。当通信结束希望断开连接时，通信双方可以交换FIN位为1的TCP段。</li>
</ul>
</li>
</ol>
<h4 id="SYN攻击"><a href="#SYN攻击" class="headerlink" title="SYN攻击"></a>SYN攻击</h4><blockquote>
<p>攻击者短时间伪造不同的IP地址的SYN报文，沾满服务端的办理按揭队列，导致客户端无法和服务端建立连接。</p>
</blockquote>
<p>解决方案：</p>
<ol>
<li>增大netdev_max_backlog：网卡接收数据包的数据大于内核处理速度时保存数据包的队列长度</li>
<li>增大TCP半连接队列：<ul>
<li>增大net.ipv4.tcp_max_syn_backlog</li>
<li>增大listen()函数中的backlog</li>
<li>增大net.core.somaxconn</li>
</ul>
</li>
<li>开启net.ipv4.tcp_syncookies，就可以在使用SYN半连接的情况下成功建立连接。<img src="/2023/10/23/46/%E4%BD%BF%E7%94%A8cookie%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5.png" alt="|550"></li>
</ol>
<ul>
<li>减少SYN+ACK重传次数，tcp_synack_retries内核参数</li>
<li>Anti-DDoS系统拦截客⼾端发送的SYN报⽂，代替服务器向客⼾端发送SYN-ACK报⽂，如果客⼾端不应答，则认为该客⼾端为虚假源；如果客⼾端应答，则Anti-DDoS系统认为该客⼾端为真实源，并将其IP地址加⼊⽩名单，在⼀段时间允许该源发送的所有SYN报⽂通过，也不做代答。</li>
</ul>
<h4 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h4><p>滑动窗口机制允许发送方在等待接收方确认之前发送多个数据包，从而提高数据传输效率。<br>为了解决一发一答的效率问题。窗口的实现实际上是操作系统开辟一个缓存空间，发送方主机在等到确认应答返回之前，必须在缓冲区中保留已发送的数据，如果按期收到确认应答，这个数据就可以从缓冲区删除。<img src="/2023/10/23/46/TCP%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3.png"></p>
<h4 id="慢启动"><a href="#慢启动" class="headerlink" title="慢启动"></a>慢启动</h4><p>当连接开始时，以指数速率增加发送速率，直到第一次报文丢失事件发生为止。<br>初始：拥塞窗口值cwnd = 1 MSS<br>每RTT倍增cwnd<br>每收到一个ACK，增加cwnd<br>初始速率很低，但是以指数增加</p>
<h4 id="阻塞控制"><a href="#阻塞控制" class="headerlink" title="阻塞控制"></a>阻塞控制</h4><ol>
<li>慢启动：发送方每收到一个ACK，拥塞窗口cwnd大小指数增加</li>
<li>拥塞避免算法：当cwnd超过慢启动门限ssthresh就会进入拥塞避免算法：每个 RTT（往返时间）增加 1 个 MSS，而不是每个 ACK 增加 1 个 MSS。</li>
<li>拥塞发生：发生了 超时重传时，sshtresh设置为cwnd/2，cwnd恢复为初始化值，发生快速重传是，cwnd =cwnd/2，ssthresh=cwnd并进入快速恢复算法。</li>
<li>快速恢复<img src="/2023/10/23/46/%E5%BF%AB%E9%80%9F%E6%81%A2%E5%A4%8D.png"></li>
</ol>
<h4 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h4><p>主机名到IP地址的转换<br>主机别名：一个主机可以有一个规范主机名和多个主机别名。<br>邮件服务器别名：负载分配：DNS实现冗余服务器，一个IP地址集合可以对应同一个规范主机名。</p>
<p>DNS客⼾端设置使⽤的DNS服务器⼀般都是递归服务器，它负责全权处理客⼾端的DNS查询请求，直<br>到返回最终结果。⽽DNS服务器之间⼀般采⽤迭代查询⽅式。<br><img src="/2023/10/23/46/DNS%E8%AE%B0%E5%BD%95%E6%A0%BC%E5%BC%8F.png"></p>
<h4 id="DNS劫持"><a href="#DNS劫持" class="headerlink" title="DNS劫持"></a>DNS劫持</h4><blockquote>
<p>通过某些手段获得对某域名的解析控制权，修改此域名的解析结果，导致对该域名的访问由原IP转为修改后的指定IP，记过就是对特定网站不能访问/访问的是假网站</p>
</blockquote>
<p>防止：限制对DNS的访问、设置较小的TTL值，定期修改域名管理系统的账号，使用支持DNSSEC的注册商，使用可靠的DNS服务商。</p>
<blockquote>
<p>DNSSEC（Domain Name System Security Extensions，域名系统安全扩展）是一组用于保护 DNS（域名系统）信息安全的协议和技术。它通过数字签名验证 DNS 数据的真实性和完整性，防止 DNS 缓存投毒和其他类型的攻击。</p>
</blockquote>
<h2 id="网络核心"><a href="#网络核心" class="headerlink" title="网络核心"></a>网络核心</h2><p>概念：路由器的网状网络<br>提问： 数据怎么通过网络进行传输？</p>
<ul>
<li>电路电路交换：  不可共享资源，会造成资源浪费，不适合计算机之间的通讯，计算机通信的特点： 突发性，耗时短</li>
<li>分组交换： 存储 – 转发  ， 数据转发过程中使用所有的资源，而不是使用一部分pieces，会将所有的的分组都存储之后再进行转发，方便共享的实现</li>
</ul>
<h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><ol>
<li>应用架构<ul>
<li>CS体系 客户-服务器:<ul>
<li>服务器： 一直运行，固定ip和周知的端口号，扩展性差</li>
<li>客户端： 主动与服务器通信，可能是动态ip，不直接与其他客户端通信</li>
</ul>
</li>
<li>P2P 每个端都可以作为服务器，点对点</li>
<li>混合体 c/s + P2P</li>
</ul>
</li>
<li>TCP socket ：对于面向连接服务（TCP) 的应用而言，socket是四元组的一个具有本地意义的标示,相当于一个记录特定会话的指针，只需要用socket就可以指定这个应用<ul>
<li>socket 其实是应用层和传输层之间的，使得允许应用能发起通信，与其他主机上的应用进程进行通信</li>
<li>4元组  源IP 源port 目标IP 目标port</li>
<li>唯一指定了一个会话</li>
<li>应用使用这个标示，与远程的应用进程进行通讯</li>
<li>不必在每一个报文中都指定这四元组</li>
<li>udp 只提供源主机的ip 和 port</li>
</ul>
</li>
<li>WebSocket 工作过程：<ol>
<li>客户端发送一个HTTP请求，包含升级字段</li>
<li>服务器接收之后,进行协议升级，如果支持，会返回一个101状态码，包含一些对应响应头</li>
<li>进行双向通信，数据以帧的方式传送。</li>
<li>其中一方发送一个关闭帧，二者关闭TCP连接</li>
<li>通过心跳机制保证WebSocket的稳定性和活跃性</li>
</ol>
</li>
<li>UDP socket<br> UDP 两个进程之间的通信之前不需要建立连接，每个报文独立传输，前后报文可能给不同的分布式进程<br> udp socket 记录本IP 本port 但是传输报文时，需要提供对方ip， port ,接收报文时传输层需要上传对方IP port<br> 二元组： 源IP  源port</li>
</ol>
<p>TCP 服务：</p>
<ul>
<li><p>可靠的传输服务</p>
</li>
<li><p>流量控制：发送方不会淹</p>
</li>
</ul>
<p>没接受方</p>
<ul>
<li>拥塞控制：当网络出现拥</li>
</ul>
<p>塞时，能抑制发送方</p>
<ul>
<li><p>不能提供的服务：时间保证、最小吞吐保证和安全</p>
</li>
<li><p>面向连接：要求在客户端进程和服务器进程之间建立连接</p>
</li>
</ul>
<p>UDP 服务：</p>
<ul>
<li><p>不可靠数据传输</p>
</li>
<li><p>不提供的服务：可靠，流量控制、拥塞控制、时间、带宽保证、建立连接<br>UDP存在的必要性</p>
</li>
<li><p>能够区分不同的进程，而IP服务不能</p>
</li>
<li><p>在IP提供的主机到主机端到端功能的基础上，区分了主机的</p>
</li>
</ul>
<p>应用进程</p>
<ul>
<li>无需建立连接，省去了建立连接时间，适合事务性的</li>
</ul>
<p>应用</p>
<ul>
<li>不做可靠性的工作，例如检错重发，适合那些对实时</li>
</ul>
<p>性要求比较高而对正确性要求不高的应用</p>
<ul>
<li>因为为了实现可靠性（准确性、保序等），必须付出时间代</li>
</ul>
<p>价（检错重发）</p>
<ul>
<li>没有拥塞控制和流量控制，应用能够按照设定的速度</li>
</ul>
<p>发送数据</p>
<ul>
<li>而在TCP上面的应用，应用发送数据的速度和主机向网络发送</li>
</ul>
<p>的实际速度是不一致的，因为有流量控制和拥塞控制</p>
<ul>
<li>安全TCP<br>  TCP和UDP都没有加密，明文传输<br>  使用SSL协议来实现加密，在TCP的基础上实现，提供加密的TCP，私密性，数据完整性，段堆到端的鉴别<br>  SSL socket API 应用通过API将铭文交给socket，SSL将其加密<br>URL : 访问协议 + 用户名 + 口令字 + 端口等</li>
</ul>
<h3 id="常见的应用层协议"><a href="#常见的应用层协议" class="headerlink" title="常见的应用层协议"></a>常见的应用层协议</h3><h4 id="HTTP面试题"><a href="#HTTP面试题" class="headerlink" title="HTTP面试题"></a>HTTP面试题</h4><ul>
<li><p>状态码：</p>
<ol>
<li>200 </li>
<li>204 No Content 响应头没有body数据</li>
<li>206 &nbsp;<strong>Partial Content</strong> 表示返回的body数据不是资源的全部，只是一部分</li>
<li>301 <strong>Moved Permanently</strong> 永久重定向，请求的资源已经不存在的</li>
<li>302: Found: 表示临时重定向，301，302都会在响应头中使用字段Location指明后续要跳转URL,浏览器会自动重定向到新的URL</li>
<li>304：<strong>Not Modified</strong> 告诉客户端可以接着使用缓存资源</li>
<li>400<strong>Bad Request</strong> 报文有错</li>
<li>403 <strong>Forbidden</strong> 禁止访问</li>
<li>404 <strong>Not Found</strong> 资源不存在或者没找到</li>
<li>500 <strong>Internal Server Error</strong> 服务器内部错误</li>
<li><strong>501 Not Implemented</strong> 客户端请求还不支持</li>
<li><strong>502 Bad Gateway</strong> 通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。</li>
<li><strong>03 Service Unavailable</strong> 服务器忙，暂时无法响应</li>
</ol>
</li>
<li><p>缓存技术：把请求-响应的数据存到本地，下一次直接都本地数据，不需要等待服务器的想用了</p>
<ol>
<li>强制缓存<ul>
<li><code>Cache-Control</code>， 是一个相对时间；</li>
<li><code>Expires</code>，是一个绝对时间；</li>
</ul>
</li>
<li>协商缓存<ul>
<li>在强制缓存未命中时，服务器第一次请求资源时，会在Response头部加上ETag唯一表示</li>
<li>当浏览器再次请求访问服务器中的资源时，先检查缓存是否过期，如果没有过期直接使用本地缓存，如果过期了会在Request头部上加上If-None-Match紫萼段</li>
<li>服务器再次收到请求之后，会根据请求中的If-None-Match值是否与当前请求的资源生成的唯一标识比较<ul>
<li>如果值相等，返回304 Not Modified 不会返回资源</li>
<li>如果不相等，则返回 200 状态码和返回资源，并在 Response 头部加上新的 ETag 唯一标识；</li>
</ul>
</li>
<li>浏览器收到304响应码，会从本地加载资源否则更新资源。</li>
</ul>
</li>
</ol>
</li>
<li><p>HTTP/1.1 的优点：简单灵活、应用广泛</p>
<ul>
<li>缺点是：无状态一方面可以不需要服务器使用额外的资源来记录状态信息</li>
<li>坏处是：进行关联性操作时，需要每次都验证一次身份</li>
<li>解决方法：使用Cookie</li>
</ul>
</li>
<li></li>
<li><p>HTTP：超文本传输协议 HTTP默认80 HTTPS默认 443</p>
<ul>
<li>流程： 1. 客户发起一个与服务器的TCP连接，(建立socket) 2. 服务器接受TCP 连接 3. 浏览器和web服务器之间交换HTTP报文 4. TCP连接关闭 </li>
<li>HTTP 是无状态的连接，不会维护任何和客户有关的信息，这时候就需要websocket了</li>
<li>HTTP/1.1 之后默认使用持久连接，保证了多个u第项可以在一个TCP连接上传输 ，非持久连接下载多个文件需要及案例多个TCP连接<br> 响应时间<br> 往返时间 RTT round - trip - time： 一个小的分组从客户端到服务器，再回到客户端的时间，传输时间忽略不计<br> 响应时间为： 2RTT + 传输时间<br> 1. 一个RTT 用来发起TCP请求<br> 2. 一个用来HTTP请求和等待响应<br> 3. 文件传输时间<br> <strong>持久HTTP</strong> ： 一个TCP连接建立之后，不会断开然后进行多个HTTP请求<br> 服务器在发送响应之后仍然保持TCP连接<br> 在相同客户端和服务器之间的后续请求和响应报文通过相同的连接进行传送<br> 客户端，在遇到一个引用对象的时候就可以尽快的发送该对象的请求，<br> 1. 每个对象要两个RTT<br> 2. 操作系统必须为每一个TCP连接分配资源，但是浏览器通常并行打开TPC连接，以获得引用对象<br> 两种方式：<br>     1. 非流线方式的持久HTTP，客户端只能在前一个HTTP请求响应之后才能发送新的请求，每个引用对象花费一个RTT<br>     2. 流水线方式：客户端遇到一个引用对象（一个小的ui所指的资源）之后就立即产生一个请<br>     3. 所有(小)的引用对象只花费一个RTT是有可能的<br> HTTP 报文格式 ： 请求行 + 请求头 + (request body)<br> tips : PUT 请求是将实体对象中文件载到URL指定的路径(一般是更新资源)<br> POST 不需要在URL 中指定资源位置，一般用于创建资源<ul>
<li>缓存：命中率(h)： 百分之多少的请求可以在缓存中满足</li>
<li>接入链路的利用率:  (1-h) *  请求速率 / 带宽</li>
</ul>
</li>
</ul>
</li>
<li><p>FTP 文件传输协议(基于TCP)<br> ftp服务器端口号默认为 21，需要建立两个TCP连接，一个用于控制，一个用于传输</p>
</li>
<li><p>SMIT 电子邮件的邮件传输协议 (默认端口25)<br>  用于上传邮件，和HTTP的区别，HTTP的每个对象封装在各自的响应报文中，SMIT可以将多个 引用对象封装在一个报文中<br>  报文格式：<br>  HEAD<br>  To :<br>  From :<br>  Subject:<br>  BODY:<br>  报文</p>
<ul>
<li>MIME 多媒体邮件扩展</li>
<li>POP 邮局访问协议 用户确认身份(代理 &lt;–&gt;服务器)并下载<ul>
<li>POP3 不保留会话状态 本地管理文件夹</li>
</ul>
</li>
<li>IMAP Internet 邮件访问协议，保留用户状态 远程管理文件夹</li>
</ul>
</li>
<li><p><em>DNS</em> Domain Name System 建立IP 地址和 对应域名之间的映射<br>  <strong><em>DNS默认默认端口是53</em></strong><br>  主要思路：分层，基于域的命名机制，在若干分布式的数据库上完成转换<br>  也可以做到负载均衡<br>  域名结构：使用层次树状结构来进行命名<br>  域名结构：从本域开始往上直至树根，域严格遵循组织界限，而不是物理网络<br>  DNS 记录格式<br>  RP格式: (name,value,type , ttl)<br>  type=A  时， name 为主机 value 为IP<br>  =CNAME  Name 为规范名字的别名<br>  =NS           Name 为域名 (foo.com) value 为该域名的权威服务器的域名<br>  =MX          Value 为name对应邮件服务器名字</p>
<ul>
<li>应用调用 解析器(resolver)</li>
<li>解析器作为客户 向Name Server发出查询报文（封装在UDP段中）</li>
<li>Name Server返回响应报文(name/ip)</li>
<li>本地名字服务器 Local Name Server 起到代理的作用，将查询转发到DNS服务器<ul>
<li>不严格属于层次结构，每个ISP 都有一个本地DNS，优先去本地DNS服务器中查询</li>
<li>递归查询：本地LNS 无，<strong>直接</strong> 去找权威服务器，然后从权威服务器往下开始查询，只需要向一个服务器去请求，然后由这个服务器去查询或者去向其他服务器来进行查找，最终由这个服务器来返回结果</li>
<li>迭代查询：转发到服务器，如果这个服务器没有就告诉发起请求的服务器要去查询下个一个服务器，由请求服务器去接着请求其他服务器，最终由能查询到的服务器来返回结果，就可以降低根服务器的负荷了</li>
</ul>
</li>
<li>缓存，一旦名字服务器得到了一个映射，就将该映射缓存起来，根服务器一般在本地服务器中缓存着，使用TTL (Time to Live)</li>
<li>攻击DNS的方法： <ul>
<li>DDoS攻击：对根服务器进行流量轰炸，发送大量的ping</li>
<li>向TLD(权威，顶级域名)攻击</li>
<li>重定向攻击：</li>
</ul>
</li>
</ul>
</li>
<li><p>CDN 内容分发网络：在CDN节点中存储内容的多个拷贝，用户请求重定向到最近的一个CDN节点</p>
</li>
</ul>
<h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><p>提供服务：为运行在不同主机上应用程序提供逻辑通信<br>数据元为报文段<br>与网络层的区别：网络层提供不同主机之间的逻辑通信，传输层提供的应用程序之间的通讯<br>tips：TCP和UDP都不提供延时保证和带宽保证，都支持多路复用和解复用，TCP额外提供拥塞控制和流量控制，以及建立连接</p>
<ul>
<li>多路复用/解复用：多路复用指的是许多个信号或数据流共享同一物理通信通道，解复用指的是根据报文段的头背部信息中的IP地址和端口号将接受的报文段发给正确的socket</li>
<li>为何要有UDP ： <ol>
<li>不建立连接(会增加延时)</li>
<li>简单：在发送端和接收端没有连接状态</li>
<li>报文段的头部很小(开销小)</li>
<li>无阻塞控制和流量控制可以保证UDP尽快的发送报文段，应用-&gt; 传输速率 = 主机 -&gt; 网络的速率</li>
<li><u>UDP也会进行校验，但是只是通过校验和的方式来检测是否遭到篡改</u></li>
</ol>
</li>
<li>RDT 是一种模型: RDT（Reliable Data Transfer）是一种可靠的数据传输协议，用于在不可靠的通信信道上实现可靠的数据传输。<ol>
<li>RDT 1.0（停等协议）：相信信道可靠<ul>
<li>发送方只发送一次数据，不进行重传。</li>
<li>接收方只接受一次数据，不进行重传请求。</li>
<li>适用于理想化的通信信道，不考虑错误和丢失。</li>
</ul>
</li>
<li>RDT 2.0（回退N协议）： 相信会出现bits errors<ul>
<li>使用checksum 来进行错误检验</li>
<li>引入了有限状态自动机，来切换来指定发送者和接收者</li>
<li>发送方发送数据帧，并等待接收方的确认帧。</li>
<li>接收方接收数据帧，发送确认帧。</li>
<li>如果发送方未收到确认帧，它将重传数据帧。</li>
<li>接收方可能收到重复的数据帧，但通过带有序号的数据帧来排除重复。</li>
<li>问题：如果ACK或者NCK传错了，就会重复</li>
</ul>
</li>
<li>RDT 3.0 <ul>
<li>机制：在超过合理时间之后进行重传</li>
<li><ul>
<li>如果package（或ACK）只是被延迟了：</li>
<li>重传将会导致数据重复，但利用序列号已经可以处理这个问题</li>
<li>接收方必须指明被正确接收的序列号</li>
</ul>
</li>
</ul>
</li>
</ol>
<ul>
<li>需要一个倒计数定时器<ol>
<li>停等协议：发送方发送一个分组，然后等待接收方的应答</li>
<li>ACK NAK   NAK 是negative ACK</li>
</ol>
</li>
</ul>
</li>
<li>TCP:<ul>
<li>点对点：一个发送方，一个接收方 </li>
<li>可靠的、按顺序的字节流：没有报文边界 </li>
<li>管道化：TCP拥塞控制和流量控制设置窗口的大小</li>
<li>面向连接：交换数据之前，通过握手来初始化双方的状态变量</li>
<li>流量控制：发送方不会淹没接收方</li>
<li><img src="/2023/10/23/46/tcp%E6%8A%A5%E6%96%87.png" alt="tcp报文"></li>
<li>序号：报文段首字节在字节流的编号</li>
<li>确认号：期望从另一方收到的下一个字节的序号</li>
<li>TCP超时时间= EstimatedRTT + 安全边界时间</li>
<li>。。。。待续</li>
</ul>
</li>
</ul>
<h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><p>DU 为 数据包</p>
<ul>
<li>服务：在发送和接收主机之间传送段</li>
<li>功能：<ul>
<li>转发：将分组从路由器的输入接口转发到合适的输出接口上</li>
<li>路由：使用路由算法来决定分组从发送主机到目标接收主机的路径</li>
</ul>
</li>
<li>数据平面：转发</li>
<li>控制平面：路径</li>
<li>路由器的结构：<ul>
<li>路由：运行路由选择算法生成路由表</li>
<li>转发：从输入到输出链路交换数据报，根据路由表进行分组的转发</li>
</ul>
</li>
<li>查表方式： <ul>
<li>最长前缀匹配</li>
</ul>
</li>
<li>交换结构：<ul>
<li>通过内存交换，在cpu的直接控制下进行交换</li>
<li>使用总线进行交换： 数据报通过共享总线进行转发，交换速度受限于总线带宽</li>
<li>使用互联网络进行交换</li>
</ul>
</li>
<li>调度机制： 调度指的是选择下一个要通过链路交换的分组<ul>
<li>FIFO</li>
<li>优先权调度</li>
<li>轮询</li>
</ul>
</li>
<li>IP<ul>
<li>IP地址是对主机或者路由器的接口进行编址</li>
<li>接口指的是 主机/路由器 和 物理链路的连接处</li>
<li>关系是1 : 1</li>
<li><strong>子网</strong>：<ol>
<li>一个子网内的节点，他们IP地址的高位部分都相同，这些节点叫做子网</li>
<li>无需路由器介入，子网内的个主机在物理上是可以直接打到</li>
<li>将子网掩码转为二进制，则为1的部分代表着IP地址中的这一部分是网络中的地址，为0的部分是标识子网中的主机</li>
</ol>
</li>
<li>分类：根据第一个8位bit来进行分类<ul>
<li>A 类 最高位固定为0：也就是 1 - 126  7 位网络  24 位主机</li>
<li>B : 10  128 - 191 14位 网络 16主机</li>
<li>C : 110 192 - 223  21位 网络  8位主机</li>
<li>D : 224 - 239 用于多播</li>
<li>E : 240 - 255 保留用于实验和研究目的</li>
</ul>
</li>
<li>CIDR Classless InterDomain Routing 无类域间路由<ul>
<li>也就是 a.b.c.d/x x是子网掩码(mask)</li>
</ul>
</li>
<li>NAT 网络地址转换 <ul>
<li>将私有网络中的内部IP映射到公共网络中的单个IP地址</li>
</ul>
<ol>
<li><p>节省IP地址：NAT允许多个内部设备共享一个公共IP地址，因此可以延长IPv4地址池的使用寿命。</p>
</li>
<li><p>增强网络安全性：因为内部设备的私有IP地址不直接暴露在互联网上，NAT提供了一层基本的安全性，可以隐藏内部网络结构。</p>
</li>
<li><p>简化网络管理：NAT可以使网络管理员更轻松地管理多台设备，而无需为每个设备分配唯一的公共IP地址。</p>
</li>
</ol>
</li>
</ul>
</li>
<li>IPv6 <ul>
<li>IPv4和IPv6通信方式：隧道 Tunneling， 在IPv4路由器之间传输的IPv4报文中携带PIv6的报文</li>
</ul>
</li>
<li>SDN</li>
<li>OpenFlow</li>
<li>route 路由，按照某种指标找到一条从源节点到目标节点的较好路径<ul>
<li>路由算法分为 全局和 分布式</li>
<li>全局：<ul>
<li>所有边都拥有完整(所有的拓扑)的拓扑和边的代价的信息</li>
<li>link state  LS  链路状态路由选择算法</li>
</ul>
</li>
<li>分布式: <ul>
<li>路由器只知道与它物理连接关系的邻居路由器和到响应邻居路由器的代价</li>
<li>迭代的与邻居路由器交换路由信息，计算路由信息</li>
<li>distance vector DV算法  距离矢量路由选择算法</li>
</ul>
</li>
</ul>
</li>
<li>RIP（Routing Information Protocol）是一种用于计算机网络中的距离矢量路由协议</li>
<li>OSP</li>
<li>DNS 主机向要访问-&gt;向DNS查询IP地址-&gt;所查询的DNS服务器未知要查询的IP地址-&gt;向根域名服务器查询-&gt;根域名服务器收录了这个地址 -&gt;返回地址给客户端-&gt;客户端建立通信<br>网络层解决一个两个网络之间的问题，链路层要解决点对点传输的问题</li>
<li><strong>ARP</strong>:以目标IP地址为线索，来定位下一个应该接受数据分包的网络设备的MAC地址，沟通IP和MAC地址 **IP-&gt;MAC **数据元为 frame 帧，帧的头部时使用MAC地址来标示源和目的地<ul>
<li>ARP记录一个&lt;IP,MAC,TTL&gt; 的表，TTL是生存周期</li>
</ul>
</li>
<li><strong>RARP</strong> MAC-&gt;IP<br>实现是在适配器上实现的，例如以太网卡</li>
<li>WAN 广域网 网络形式采用点到点链路</li>
<li>LAN 局域网 一般采用多点连接的方式</li>
<li>奇偶校验<ul>
<li>单bit奇偶校验只能检测单个bit级别的错误，不能纠错</li>
<li>二维奇偶校验可以检测和纠正单个bit错误</li>
<li>checksum </li>
<li>CRC 循环冗余校验</li>
</ul>
</li>
</ul>
<h3 id="网络接口层：等价数据链路层，使用mac地址"><a href="#网络接口层：等价数据链路层，使用mac地址" class="headerlink" title="网络接口层：等价数据链路层，使用mac地址"></a>网络接口层：等价数据链路层，使用mac地址</h3><ul>
<li><p>NIC的驱动程序</p>
</li>
<li><p>NIC 是网络适配器，也就是网卡</p>
</li>
<li><p>PPP也属于数据链路层</p>
</li>
</ul>
<h2 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h2><h4 id="OSI参考模型-有七个分层"><a href="#OSI参考模型-有七个分层" class="headerlink" title="OSI参考模型 有七个分层"></a>OSI参考模型 有七个分层</h4><p>自上而下 每一层的功能和作用由协议规定，协议的内容是规范</p>
<ol>
<li><p><strong>应用层</strong></p>
<ul>
<li>针对特定应用的协议</li>
</ul>
</li>
<li><p><strong>表示层</strong></p>
<ul>
<li>设备固有数据格式和网络标准数据格式 比如：接受不同表现形式的信息</li>
</ul>
</li>
<li><p><em>会话层</em></p>
<ul>
<li>负责通信管理，负责建立连接和断开，管理传输层以下的分层</li>
</ul>
</li>
<li><p><strong>传输层</strong></p>
<ul>
<li>管理两个节点之间的数据传输，负责可靠传输</li>
</ul>
</li>
<li><p><strong>网络层</strong></p>
<ul>
<li>路由选择与地址管理</li>
</ul>
</li>
<li><p><strong>数据链路层</strong></p>
<ul>
<li>互连设备之间传送，和 识别数据帧</li>
</ul>
</li>
<li><p><strong>物理层</strong></p>
<ul>
<li>界定连接器和网线的规格，比特流和电子信号转换</li>
</ul>
</li>
</ol>
<h2 id="网络安全"><a href="#网络安全" class="headerlink" title="网络安全"></a>网络安全</h2><ul>
<li>对称加密：发送方和接收方的密钥相同</li>
<li>公开密钥加密：发送方使用接收方的公钥进行加密，接收方使用自己的私钥进行解密</li>
<li>数字签名：</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zuofw.github.io/2023/10/21/39/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="QingQiu">
      <meta itemprop="description" content="个人网站，学习记录，面试记录和经验总结、互联网中一块属于自己的小窝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="QingQiu'Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/10/21/39/" class="post-title-link" itemprop="url">简历</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-10-21 10:10:39" itemprop="dateCreated datePublished" datetime="2023-10-21T10:10:39+08:00">2023-10-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-11-03 17:38:35" itemprop="dateModified" datetime="2023-11-03T17:38:35+08:00">2023-11-03</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>37</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>国外的那些课的实验是可以写在简历上的比如 15445<br>苍穹外卖项目 + 服务器部署</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zuofw.github.io/2023/10/16/48/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="QingQiu">
      <meta itemprop="description" content="个人网站，学习记录，面试记录和经验总结、互联网中一块属于自己的小窝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="QingQiu'Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/10/16/48/" class="post-title-link" itemprop="url">计组</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-10-16 19:11:48" itemprop="dateCreated datePublished" datetime="2023-10-16T19:11:48+08:00">2023-10-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-07-19 16:42:27" itemprop="dateModified" datetime="2024-07-19T16:42:27+08:00">2024-07-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">计算机基础</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.5k</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>海明码:<a target="_blank" rel="noopener" href="https://www.cnblogs.com/godoforange/p/12003676.html">https://www.cnblogs.com/godoforange/p/12003676.html</a><br><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1t4411e7LH?p=38&amp;spm_id_from=pageDriver&amp;vd_source=603b67fa519e58ee792d9e969a3ad8a1">https://www.bilibili.com/video/BV1t4411e7LH?p=38&amp;spm_id_from=pageDriver&amp;vd_source=603b67fa519e58ee792d9e969a3ad8a1</a></p>
<h2 id="基本名词解释"><a href="#基本名词解释" class="headerlink" title="基本名词解释"></a>基本名词解释</h2><p>PC 程序计数器<br>IR 指令寄存器，存放当前正在执行的指令，<br>MAR<br>CU 控制单元，为控制器的核心部件，其功能是产生微操作命令序列。<br>ALU：Arithmetic Logic Unit，算术逻辑运算单元，为运算器的核心部件，其功能是进行算术、逻辑运算。<br>ACC：Accumulator，累加器，是运算器中既能存放运算前的操作数，又能存放运算结果的寄存器。<br>MQ：Multiplier-Quotient Register，乘商寄存器，乘法运算时存放乘数、除法时存放商的寄存器。<br>MAR：Memory Address Register，存储器地址寄存器，在主存中用来存放欲访问的存储单元的地址。<br>MDR：Memory Data Register，存储器数据缓冲寄存器，在主存中用来存放从某单元读出、或要写入某存储单元的数据。<br>I/O：Input/Output equipment，输入/输出设备，为输入设备和输出设备的总称，用于计算机内部和外界信息的转换与传送。</p>
<p>MIPS：Million Instruction Per Second，每秒执行百万条指令数，为计算机运算速度指标的一种计量单位。</p>
<p>CPI：执行一条指令所需的时钟周期（机器主频的倒数)。</p>
<p>FLOPS：浮点运算次数每秒。</p>
<h2 id="主存储器"><a href="#主存储器" class="headerlink" title="主存储器"></a>主存储器</h2><ul>
<li>汉明码</li>
</ul>
<ol>
<li>汉明码要添加 检测位要满足 2 ^k &gt;= n + k +1 k位检测位 ， n为总位数</li>
<li>检测位放在 2 ^i  次方处 i = 0 , 1 , ……</li>
</ol>
<h2 id="进制字母表示"><a href="#进制字母表示" class="headerlink" title="进制字母表示"></a>进制字母表示</h2><p>十进制数用D表示，二进制用B表示，十六进制数用H表示，八进制用O表示。</p>
<h2 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h2><p>命中率： 访问成功次数 / 总访问次数<br>命中率与Cache 的容量和块长有关<br>访问效率 = 访问Cache 的时间 / 平均访问时间   * 100 %<br>e 访问效率 ， h 命中率， 访问Cache 时间为tc 访问主存时间为tm<br>则 e = tc / h * tc   + ( 1 - h) * t    * 100%<br>访问时间 / 命中的时间 + 未命中的时间</p>
<ul>
<li>读写操作 <ul>
<li>写 ： 1. 写直达法 ： 写时同时写入Cache和主存</li>
<li><ol start="2">
<li>写回法： 只写入Cache 不写入内存，当Cache数据被替换出去的时候才写会主存，会导致Cache和主存的不一致</li>
</ol>
</li>
</ul>
</li>
<li>地址映射<ol>
<li>直接映射 Cache任意一块可以放在</li>
<li>全相联映射  主存任何一块可以放在Cache任意一块中</li>
<li></li>
</ol>
</li>
</ul>
<h2 id="DMA"><a href="#DMA" class="headerlink" title="DMA"></a>DMA</h2><ol start="3">
<li>DMA和 CPU交替访问<br> CPU工作周期  C1 专供DMA访存，C2专攻CPU访存</li>
</ol>
<ul>
<li>功能：<ol>
<li>向CPU申请DMA传送</li>
<li>处理总线控制权的转交</li>
<li>管理系统总线，控制数据传输</li>
<li>确定数据传送的首地址和长度，修正传送过程中的数据和长度</li>
<li>DMA传送结束时，给出操作完成的信号</li>
</ol>
</li>
</ul>
<h2 id="数"><a href="#数" class="headerlink" title="数"></a>数</h2><p>浮点数： 阶码组成为 阶符 + 数值部分   尾数由数符和数值组成<br>阶码是用二进制来表示的比如<br>2 ^15<br>就是 2 ^1111<br>即可，所以要用四位二进制来表示</p>
<ul>
<li>规格化<br>基数为<br>2  要求尾数最高位为 1  2 ^1<br>4                 最高2位为1  2 ^2</li>
</ul>
<p>8                 最高3位为 1  2 ^3</p>
<p>左规，数据左移，尾数变大<br>小数转二进制，直接把分子写成二进制，然后根据分母是2的多少次方，移动小数点就行了</p>
<ul>
<li><p>IEEE 754标准<br>数符 + 阶码(含阶符) 尾数<br>尾数使用规格化表示，非 0 的有效位最高位为1</p>
</li>
<li><p>运算<br>补码 左移时，后面加0 ， 右移时前面加 1<br>定点数运算：</p>
</li>
</ul>
<ol>
<li>补码加减运算，直接 A + B  mod 2 ^n+1</li>
<li>小数 就mod 2</li>
</ol>
<h2 id="指令系统"><a href="#指令系统" class="headerlink" title="指令系统"></a>指令系统</h2><ul>
<li>指令格式 ： 操作码 + 地址码+寻址方式<br>指令字长分为可变和固定字长<br>RISC 精简指令系统<br>长度可变的指令：操作码分散在指令字的不同字段中</li>
<li>地址码</li>
</ul>
<ol>
<li>四地址    op + A1 + A2 + A3 + A4  分别是第一操作数地址，第二操作数地址，结果地址，下一条指令地址  (A1) OP(A2) –&gt; A3</li>
<li>三地址  OP A1 A2 A3   </li>
<li>二地址   OP A1 A2    (A1) OP (A2) –&gt; A1 或者 (A1) OP(A2) -&gt; A2</li>
<li>一地址 OP A1     (ACC) OP (A1) -&gt; A1  ACC暂存</li>
<li>零地址，对ACC中的数据进行操作<br>可以使用寄存器地址来替代指令地址字段，因为寄存器很少，占用的位数少</li>
</ol>
<ul>
<li>指令寻址<br>顺序 PC + 1 -&gt; PC<br>跳跃 由转移指令给出<br>数据寻址： 操作码 + 寻址特征+ 形式地址A<br>形式地址 是指令字中的地址，有效地址是操作数的真实地址</li>
</ul>
<ol>
<li>立即寻址： 形式地址A就是操作数，OP # A   # 为立寻址标志 A 使用补码</li>
<li>直接寻址，EA = A 有效地址由形式地址给出，无偏移量</li>
<li>隐含寻址 间接寻址 有效地址由形式地址简介提供，A提供的是EA 的地址，需要去寻址，EA 的地址才是指向真实的数据</li>
<li>寄存器寻址，EA = Ri 有效地址为寄存器的编号</li>
<li>寄存器间接寻址： EA = (Ri) 有效地址在寄存器中</li>
</ol>
<ul>
<li>基址寻址<ol>
<li>使用专用寄存器作为基址寄存器<br> EA = (BR) + A BR 为基址寄存器，也就是 物理地址 = 逻辑地址 + 基址地址</li>
</ol>
</li>
</ul>
<h2 id="CPU-组成"><a href="#CPU-组成" class="headerlink" title="CPU 组成"></a>CPU 组成</h2><ul>
<li>寄存器<ol>
<li>通用寄存器 ： 存放操作数，可作为某中寻址方式的专用寄存器</li>
<li>数据寄存器：存放操作数，两个寄存器拼接放双倍字长的数据</li>
<li>地址寄存器： 存放地址</li>
<li>条件码寄存器： 存放条件码，可作为程序分支的依据，正负,0，溢出等</li>
<li>控制和状态寄存器： <ul>
<li>控制寄存器 PC -&gt; MAR -&gt; M -&gt; MDR -&gt; IR</li>
<li>PC用户可见</li>
<li>状态寄存器 存放条件码</li>
<li>PSW 存放程序状态字</li>
</ul>
</li>
</ol>
</li>
<li>指令周期 ： 取出并执行一条指令所需的全部时间</li>
<li>包括 取指，分析 =&gt; 取指周期  执行=&gt;执行周期</li>
</ul>
<p>流水线</p>
<ul>
<li>吞吐率： 单位时间内流水线所完成执行或输出结果的数量</li>
<li>最大吞吐率: Tpmax = 1 / Δt Δt为m段流水线各段时间</li>
<li>加速比 ： <ul>
<li>使用流水线的方式完成n条指令在m段流水线上共需 T = m * t + (n-1) * t   </li>
<li>使用等效的非流水线共需： T =  nmt</li>
<li>加速比等于  不使用 / 使用</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">QingQiu</p>
  <div class="site-description" itemprop="description">个人网站，学习记录，面试记录和经验总结、互联网中一块属于自己的小窝</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">52</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">26</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Zuofw/zuofw-rpc" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Zuofw&#x2F;zuofw-rpc" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2022 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">QingQiu</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="站点总字数">438k</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  















  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
