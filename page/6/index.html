<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"zuofw.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="个人网站，学习记录，面试记录和经验总结、互联网中一块属于自己的小窝">
<meta property="og:type" content="website">
<meta property="og:title" content="QingQiu&#39;Blog">
<meta property="og:url" content="https://zuofw.github.io/page/6/index.html">
<meta property="og:site_name" content="QingQiu&#39;Blog">
<meta property="og:description" content="个人网站，学习记录，面试记录和经验总结、互联网中一块属于自己的小窝">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="QingQiu">
<meta property="article:tag" content="博客，学习，成长">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://zuofw.github.io/page/6/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>QingQiu'Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>


<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">QingQiu'Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">清秋的博客</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-fa fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-fa fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-fa fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-fa fa-archive"></i>归档</a>

  </li>
        <li class="menu-item menu-item-github">

    <a href="https://github.com/Zuofw" rel="noopener" target="_blank"><i class="fa fa-fw fa-fab fa-github"></i>Github</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zuofw.github.io/2023/09/09/34/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="QingQiu">
      <meta itemprop="description" content="个人网站，学习记录，面试记录和经验总结、互联网中一块属于自己的小窝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="QingQiu'Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/09/09/34/" class="post-title-link" itemprop="url">学算法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-09-09 20:35:34" itemprop="dateCreated datePublished" datetime="2023-09-09T20:35:34+08:00">2023-09-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-10-11 16:20:12" itemprop="dateModified" datetime="2024-10-11T16:20:12+08:00">2024-10-11</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>54k</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="JAVA-快写"><a href="#JAVA-快写" class="headerlink" title="JAVA 快写"></a>JAVA 快写</h2><h2 id="最短路与具体的路径记录问题"><a href="#最短路与具体的路径记录问题" class="headerlink" title="最短路与具体的路径记录问题"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-edges-in-shortest-paths/description/">最短路与具体的路径记录问题</a></h2><h2 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">TreeMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
map<span class="token punctuation">.</span><span class="token function">getOrDefault</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span> 获得这个数，如果为空<span class="token punctuation">,</span>返回默认值，可以自己设定
k <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">higherKey</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span> 获得下一个顺序的键<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h2 id="把toCharArray向右移动一位"><a href="#把toCharArray向右移动一位" class="headerlink" title="把toCharArray向右移动一位"></a>把toCharArray向右移动一位</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"> a <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token char">' '</span><span class="token operator">+</span> re<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="a-z-之间偏移量确认"><a href="#a-z-之间偏移量确认" class="headerlink" title="a ~ z 之间偏移量确认"></a>a ~ z 之间偏移量确认</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token char">'a'</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> offset <span class="token operator">-</span> <span class="token char">'a'</span><span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">26</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="看到唯一解，且是难以做的图形题，可以考虑转化为方程"><a href="#看到唯一解，且是难以做的图形题，可以考虑转化为方程" class="headerlink" title="看到唯一解，且是难以做的图形题，可以考虑转化为方程"></a>看到唯一解，且是难以做的图形题，可以考虑转化为方程</h2><p><a target="_blank" rel="noopener" href="https://www.lanqiao.cn/problems/17160/learning/?contest_id=179">https://www.lanqiao.cn/problems/17160/learning/?contest_id=179</a></p>
<h3 id="卡特兰数问题-：h-n-x3D-C-2n-n-−C-2n-n−1-n-x3D-0-1-2-…-组合数C不解释了；-C是组合数"><a href="#卡特兰数问题-：h-n-x3D-C-2n-n-−C-2n-n−1-n-x3D-0-1-2-…-组合数C不解释了；-C是组合数" class="headerlink" title="卡特兰数问题 ：h[n]=C[2n,n]−C [2n,n−1] (n=0,1,2,…)&nbsp;组合数C不解释了； C是组合数"></a>卡特兰数问题 ：h[n]=C[2n,n]−C [2n,n−1] (n=0,1,2,…)&nbsp;组合数C不解释了； C是组合数</h3><ol>
<li>出栈顺序问题 假设有N个数字依次入栈：1,2,3,…,n，试问有多少种出栈顺序？这里为表述简便，下文用+1表示一个元素入栈，用-1表示一个元素出栈</li>
<li>问题描述：有n对()括号，试问可以组成多少种合法正确的括号序列？</li>
</ol>
<h2 id="树是无向边"><a href="#树是无向边" class="headerlink" title="树是无向边"></a>树是无向边</h2><h2 id="Java日期"><a href="#Java日期" class="headerlink" title="Java日期"></a>Java日期</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">LocalDate</span> d1 <span class="token operator">=</span> <span class="token class-name">LocalDate</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span><span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>time<span class="token punctuation">.</span>format<span class="token punctuation">.</span></span>DateTimeFormatter</span><span class="token punctuation">.</span><span class="token constant">BASIC_ISO_DATE</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		s <span class="token operator">=</span> reader<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token class-name">LocalDate</span> d2 <span class="token operator">=</span> <span class="token class-name">LocalDate</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span><span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>time<span class="token punctuation">.</span>format<span class="token punctuation">.</span></span>DateTimeFormatter</span><span class="token punctuation">.</span><span class="token constant">BASIC_ISO_DATE</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">long</span> diff <span class="token operator">=</span> <span class="token class-name">ChronoUnit</span><span class="token punctuation">.</span><span class="token constant">DAYS</span><span class="token punctuation">.</span><span class="token function">between</span><span class="token punctuation">(</span>d1<span class="token punctuation">,</span> d2<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">abs</span><span class="token punctuation">(</span>diff<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">BufferedWriter</span> writer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedWriter</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">OutputStreamWriter</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
writer<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 才会写<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h2 id="JAVA更快更强的读入和写-https-www-luogu-com-cn-problem-P2367"><a href="#JAVA更快更强的读入和写-https-www-luogu-com-cn-problem-P2367" class="headerlink" title="JAVA更快更强的读入和写 https://www.luogu.com.cn/problem/P2367"></a>JAVA更快更强的读入和写 <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P2367">https://www.luogu.com.cn/problem/P2367</a></h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"> <span class="token class-name">StreamTokenizer</span> reader <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StreamTokenizer</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

reader<span class="token punctuation">.</span><span class="token function">nextToken</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
n <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> reader<span class="token punctuation">.</span>nval<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="取余数的小技巧"><a href="#取余数的小技巧" class="headerlink" title="取余数的小技巧"></a>取余数的小技巧</h2><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token punctuation">(</span>x + n<span class="token punctuation">)</span> % n 可以保证不会出现负数<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>先思考再做题，前几个题大概率时模拟题，所以别急着用算法</p>
<h2 id="常用算法"><a href="#常用算法" class="headerlink" title="常用算法"></a>常用算法</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">next_permutation</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>a<span class="token operator">+</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span> 对数组的前n个数进行全排列，并存储在这个数组中
<span class="token keyword">char</span> a<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span>
<span class="token function">puts</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> 可以直接输出一行，如果不是最后一行还会输出换行符
求 q<span class="token operator">^</span><span class="token number">0</span> <span class="token operator">+</span> q<span class="token operator">^</span><span class="token number">1</span> <span class="token operator">+</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token operator">+</span> q<span class="token operator">^</span>n
<span class="token keyword">long</span> <span class="token keyword">long</span> t <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token keyword">while</span><span class="token punctuation">(</span>n<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">//秦九zhao算法</span>
    t <span class="token operator">=</span> <span class="token punctuation">(</span>t <span class="token operator">*</span>q <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span>mod<span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>整数划分</strong><a target="_blank" rel="noopener" href="https://ac.nowcoder.com/acm/problem/252724">https://ac.nowcoder.com/acm/problem/252724</a></p>
<p>accumulate 求和</p>
<p>快乐的模板：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits/stdc++.h&gt;  
#define ll long long   
#define pii pair&lt;int,int&gt;  
using namespace std;  
void solve(){  
 &nbsp; &nbsp;return ;  
}  
int main(){  
 &nbsp; &nbsp;ios::sync_with_stdio(false);  
 &nbsp; &nbsp;cin.tie(nullptr);  
 &nbsp; &nbsp;int T;  
 &nbsp; &nbsp;cin &gt;&gt; T;  
 &nbsp; &nbsp;while (T--) solve();  
 &nbsp; &nbsp;return 0;  
}  
​```


## 小TIPS：

做题思路：

1. 从小数据，小范围推大范围
    
2. 划分，以及反证，如果要求全部满足一个性质，那么只要有部分不满足我们已经推出来的条件即可不满足所有性质
    

&gt; 1. 数组和字符串比较字典序是可以直接用大于号小于号比较的
&gt;     
&gt; 2. 字典序是指在ASCII码中出现的顺序所以 也就是 a b c 0 1 2 3 ABC 等z
&gt;     
&gt; 3. vector &lt;&gt; 可以直接赋值
&gt;     

## 牛顿迭代法：

求平方根

例子： f(x)=m,可转化为 g(x)=f(x)-m=0;

迭代公式：_x_n+1 = _x_n − _g_ (_x_n)/ _g_ ′ (_x_n)

例题：[力扣（LeetCode）官网 - 全球极客挚爱的技术成长平台](https://leetcode.cn/problems/sqrtx/submissions/431189596/)
```c++
//f (x) = x2 − a = 0  
int mySqrt(int a) {  
long x = a;  
while (x * x &gt; a) {  
x = (x + a / x) / 2;  
}  
return x;  
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="stl和一些内置函数"><a href="#stl和一些内置函数" class="headerlink" title="stl和一些内置函数"></a>stl和一些内置函数</h3><p>accumulate(num.begin(),num.end(),0); //第三个参数是初始化要返回的东西 </p>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="快速排序模板-根据数来分治"><a href="#快速排序模板-根据数来分治" class="headerlink" title="快速排序模板 根据数来分治"></a>快速排序模板 根据数来分治</h3><p>先找数字中的中位数，然后递归<br><strong>注意：</strong> while中先递归的左边，那么最后递归的时候就要以j来为界限，递归的顺序无所谓</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void quick_sort(int q[], int l, int r)
{
    if (l &gt;= r) return;
    int x = q[rand()% (r-l+1)+l]; // 随机取
    int i = l - 1, j = r + 1; 
    while (i &lt; j) {
        do i++; while (
        q[i] &lt; x);
        do j--; while (q[j] &gt; x);
        if (i &lt; j) swap(q[i], q[j]);    //如果i与j没有相遇，就交换一下
    }

    quick_sort(q, l, j);    //递归处理左右两边
    quick_sort(q, j + 1, r);
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="归并排序模板-分治-根据中间两个数为分界线"><a href="#归并排序模板-分治-根据中间两个数为分界线" class="headerlink" title="归并排序模板 分治 根据中间两个数为分界线"></a>归并排序模板 分治 根据中间两个数为分界线</h3><ol>
<li><p>确定分界点， mid=(l+r)/2</p>
</li>
<li><p>递归排序 left，right</p>
</li>
<li><p>归并 合二为一</p>
</li>
</ol>
<p>模板</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">
void msort(int a[], int l, int r) {  
    if (l &gt;= r) return;  
    //确定分界  
    int mid = l + r &gt;&gt; 1;  
    //递归  
    msort(a, l, mid); msort(a, mid + 1, r);  
    //归并  
    int k = 0, i = l, j = mid + 1;  
      
    while (i &lt;=mid &amp;&amp; j &lt;= r) {//左右比较，小的放在辅助数组里，直到有一个指针到达边界  
        if (a[i] &lt;= a[j]) tmp[k++] = a[i++];  
        else tmp[k++] = a[j++];  
    }  
    //这里继续把另一个没到边界的指针赋值给辅助数组  
    while (i &lt;= mid) tmp[k++] = a[i++];  
    while (j &lt;= r)tmp[k++] = a[j++];  
    //最后把辅助数组的元素还回去  
    for (int i = l, j = 0; i &lt;= r; i++, j++) a[i] = tmp[j];  
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="二分法-二分要保证有解"><a href="#二分法-二分要保证有解" class="headerlink" title="二分法 二分要保证有解"></a>二分法 二分要保证有解</h2><h3 id="整数二分"><a href="#整数二分" class="headerlink" title="整数二分"></a>整数二分</h3><p>一分为二，一边满足性质，一半不满足，可以来用来寻找性质的边界</p>
<p>两种模板：一种去检查满足的一半，另一种去检查不满足性质的的一半</p>
<p>考虑边界是否会包括进去</p>
<ol>
<li><p>先写出 mid=r+l&gt;&gt;1</p>
</li>
<li><p>二分要检查的性质</p>
</li>
<li><p>画图考虑，直线图</p>
</li>
<li><p>思考mid是否会包含</p>
</li>
<li><p>考虑不存在条件时</p>
</li>
</ol>
<h2 id="l-x3D-mid-1-时-输出的是-L-r-x3D-mid-1-时-输出的是r"><a href="#l-x3D-mid-1-时-输出的是-L-r-x3D-mid-1-时-输出的是r" class="headerlink" title="l = mid + 1 时,输出的是 L , r = mid -1 时 输出的是r"></a>l = mid + 1 时,输出的是 L , r = mid -1 时 输出的是r</h2><p>注意死循环，男左女右，查找从右侧往左的时候mid 要 + 1，否则不+1</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">l + (r - l + 1 &gt;&gt; 1); 
​<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">更好的二分模板
<span class="token keyword">while</span><span class="token punctuation">(</span>l<span class="token operator">&lt;=</span>r<span class="token punctuation">)</span><span class="token punctuation">{</span>
	mid <span class="token operator">=</span> <span class="token punctuation">(</span>l <span class="token operator">+</span> r<span class="token punctuation">)</span> <span class="token operator">&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>mid <span class="token operator">&lt;</span> r<span class="token punctuation">)</span> r <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token keyword">else</span>  mid <span class="token operator">=</span> l <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="浮点数二分-不要处理边界"><a href="#浮点数二分-不要处理边界" class="headerlink" title="浮点数二分 不要处理边界"></a>浮点数二分 不要处理边界</h3><p>思路：通过mid来判断，答案落在缩小的区间内，只要近似值</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">bool check(double x) {/* ... */} // 检查x是否满足某种性质  
  
double bsearch_3(double l, double r)  
{  
    const double eps = 1e-6;   // eps 表示精度，取决于题目对精度的要求  
    while (r - l &gt; eps)  
    {  
        double mid = (l + r) / 2;  
        if (check(mid)) r = mid;  
        else l = mid;  
    }  
    //或者直接不管精度，直接循环几百次  
    return l;  
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="高精度"><a href="#高精度" class="headerlink" title="高精度"></a>高精度</h2><h3 id="加法：-注意要把A设为位数更大的那一个，因为最后的位数取决于位数大的那一个，使用vector容器可以更方便的进行计算和进位和确定位数"><a href="#加法：-注意要把A设为位数更大的那一个，因为最后的位数取决于位数大的那一个，使用vector容器可以更方便的进行计算和进位和确定位数" class="headerlink" title="加法： 注意要把A设为位数更大的那一个，因为最后的位数取决于位数大的那一个，使用vector容器可以更方便的进行计算和进位和确定位数"></a>加法： 注意要把A设为位数更大的那一个，因为最后的位数取决于位数大的那一个，使用vector容器可以更方便的进行计算和进位和确定位数</h3><ol>
<li><p>逆序存数的每一位</p>
</li>
<li><p>从低位开始计算，之后计算进位</p>
</li>
<li><p>加完之后检查最后一位是否还有进位</p>
</li>
<li><p>返回数字</p>
</li>
</ol>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">vector&lt;int&gt; add(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B)  
{  
    if (A.size() &lt; B.size()) return add(B, A);  
  
    vector&lt;int&gt; C;  
    int t = 0;  
    for (int i = 0; i &lt; A.size(); i ++ )  
    {  
        t += A[i];  
        if (i &lt; B.size()) t += B[i];  
        C.push_back(t % 10);  
        t /= 10;  
    }  
  
    if (t) C.push_back(1);  
    return C;  
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="减法"><a href="#减法" class="headerlink" title="减法"></a>减法</h3><p>和加法基本一致，只要变进位为借位即可</p>
<p>// C = A - B, 满足A &gt;= B, A &gt;= 0, B &gt;= 0  </p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">vector&lt;int&gt; sub(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B)  
{  
    vector&lt;int&gt; C;  
    for (int i = 0, t = 0; i &lt; A.size(); i ++ )  
    {  
        t = A[i] - t;  
        if (i &lt; B.size()) t -= B[i];  
        C.push_back((t + 10) % 10);  
        if (t &lt; 0) t = 1;  
        else t = 0;  
    }  
  
    while (C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back();  
    return C;  
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="乘法"><a href="#乘法" class="headerlink" title="乘法"></a>乘法</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">vector&lt;int&gt; mul(vector&lt;int&gt;&amp;A,int b){  
 &nbsp; vector&lt;int&gt;C;  
 &nbsp; int t=0;  
 &nbsp; for(int i=0;i&lt;A.size()||t;i++){//出现进位  
 &nbsp; &nbsp; &nbsp;if(i&lt;A.size()) t+=A[i]*b;  
 &nbsp; &nbsp; &nbsp;C.push_back(t%10);  
 &nbsp; &nbsp; &nbsp;t/=10;  
 &nbsp; }  
 &nbsp; while(C.size()&gt;1&amp;&amp;C.back()==0) C.pop_back();  
 &nbsp; //去除前导零  
 &nbsp; return C;  
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">### 除法

vector&lt;int&gt; div(vector&lt;int&gt;&amp;A,int b){  
 &nbsp; vector&lt;int&gt;C;  
 &nbsp; int t=0;  
 &nbsp; for(int i=0;i&lt;A.size();i++){  
 &nbsp; &nbsp; &nbsp;t=t*10+A[i];  
 &nbsp; &nbsp; &nbsp;C.push_back(t/b);  
 &nbsp; &nbsp; &nbsp;t %= b;  
 &nbsp; }  
 &nbsp; //这里是清除前置零，不是后置零
 &nbsp; reverse(C.begin(),C.end());  
 &nbsp; while(C.size()&gt;1&amp;&amp;C.back()==0) C.pop_back();  
 &nbsp; return C;  
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="前缀和和差分"><a href="#前缀和和差分" class="headerlink" title="前缀和和差分"></a>前缀和和差分</h2><p><strong>构造差分可以用一个空数组，一直执行插入操作即可</strong></p>
<p>前缀和一般初始化为0到n但是只用1到n</p>
<p>二维</p>
<p>S[i, j] = 第i行j列格子左上部分所有元素的和<br>以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：<br>S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]</p>
<p>二维差分： 差分的前缀和就是原数组</p>
<p>给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：<br>S[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c//注意是x2+1,y2+1不是x2,y2</p>
<h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int x;  
int * p1 = &amp;x; // 指针可以被修改，值也可以被修改  
const int * p2 = &amp;x; // 指针可以被修改，值不可以被修改（const int）  
int * const p3 = &amp;x; // 指针不可以被修改（* const），值可以被修改  
const int * const p4 = &amp;x; // 指针不可以被修改，值也不可以被修改

for (int i = 0, j = 0; i &lt; n; i ++ )  
{  
    while (j &lt; i &amp;&amp; check(i, j)) j ++ ;  
  
    // 具体问题的逻辑  
}  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>常见问题分类：<br>    (1) 对于一个序列，用两个指针维护一段区间<br>    (2) 对于两个序列，维护某种次序，比如归并排序中合并两个有序序列的操作</p>
<h3 id="Floyd判圈法-龟兔赛跑法-用于判断链表有无环和求出环的长度"><a href="#Floyd判圈法-龟兔赛跑法-用于判断链表有无环和求出环的长度" class="headerlink" title="Floyd判圈法 龟兔赛跑法 用于判断链表有无环和求出环的长度"></a>Floyd判圈法 龟兔赛跑法 用于判断链表有无环和求出环的长度</h3><p>两个指针fast slow 都从起始位置出发，fast 一次走2步，slow一次走1步，如果能相遇，则存在环</p>
<p>计算环的长度</p>
<p>让其中一个指针停在环的起点不动，另一个一步一步向前走并记录步数，再次相遇时步数即为环的长度。</p>
<p>寻找环的起点</p>
<p>其中一个指针在环的起点不动，另一个放到起点，两个指针同时一步一步移动，则两指针将会在循环节的起点相遇。</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/linked-list-cycle-ii/description/">142. 环形链表 II - 力扣（Leetcode）</a></p>
<p>/**  </p>
<ul>
<li>Definition for singly-linked list.  </li>
<li>struct ListNode {  </li>
<li><pre><code>int val;  
</code></pre>
</li>
<li><pre><code>ListNode *next;  
</code></pre>
</li>
<li><pre><code>ListNode(int x) : val(x), next(NULL) {}  
</code></pre>
</li>
<li>};<br> */<br>class Solution {<br>public:<br> ListNode *detectCycle(ListNode *head) {<br>ListNode *fast=head,*slow=head;<br>   do{<br>   if(!fast||!fast-&gt;next) return NULL;//如果能到达末尾，则不存在环<br>   fast=fast-&gt;next-&gt;next;<br>   slow=slow-&gt;next;<br>   }while(fast!=slow);<br>   fast=head;<br>   while(fast!=slow){<br>   fast=fast-&gt;next;<br>   slow=slow-&gt;next;<br>   }<br>   return slow;<br> }<br>};</li>
</ul>
<h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><p>思路：</p>
<p>n的第k位是什么？ n&gt;&gt;k&amp;1 右移k位与1与得到是0就是0，反之就是1</p>
<ol>
<li><p>先把要判断的位置移到最左边</p>
</li>
<li><p>判断</p>
</li>
</ol>
<h3 id="lowbit"><a href="#lowbit" class="headerlink" title="lowbit"></a>lowbit</h3><p>解释：cpp的负数使用的补码表示的所以，-x就等于 ~x+1 反码+1</p>
<p>用法：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/93795692">树状数组</a>和求1的个数</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">

<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Scanner</span></span><span class="token punctuation">;</span>
<span class="token comment">// 1:无需package</span>
<span class="token comment">// 2: 类名必须Main, 不可修改</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>
    <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token class-name">N</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token number">1e5</span> <span class="token operator">+</span> <span class="token number">10</span><span class="token punctuation">;</span>
    <span class="token keyword">static</span> <span class="token keyword">long</span><span class="token punctuation">[</span><span class="token punctuation">]</span> tree <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">long</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">static</span> <span class="token keyword">int</span> n <span class="token punctuation">;</span>
    <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">lowbit</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    	<span class="token keyword">return</span> x <span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token operator">-</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">update</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token punctuation">,</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> pos <span class="token operator">=</span> i <span class="token punctuation">;</span> pos <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> pos <span class="token operator">+=</span> <span class="token function">lowbit</span><span class="token punctuation">(</span>pos<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    		tree<span class="token punctuation">[</span>pos<span class="token punctuation">]</span> <span class="token operator">+=</span> x<span class="token punctuation">;</span>
    	<span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">static</span> <span class="token keyword">long</span> <span class="token function">query</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    	<span class="token keyword">long</span> sum <span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
    	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> pos <span class="token operator">=</span> x<span class="token punctuation">;</span> pos <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">;</span> pos<span class="token operator">-=</span><span class="token function">lowbit</span><span class="token punctuation">(</span>pos<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    		sum <span class="token operator">+=</span>tree<span class="token punctuation">[</span>pos<span class="token punctuation">]</span><span class="token punctuation">;</span>
    	<span class="token punctuation">}</span>
    	<span class="token keyword">return</span> sum<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">static</span> <span class="token keyword">long</span> <span class="token function">ask</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span><span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    	<span class="token keyword">return</span> <span class="token function">query</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token function">query</span><span class="token punctuation">(</span>a<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Scanner</span> scan <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Scanner</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span>
        n <span class="token operator">=</span> scan<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> m <span class="token operator">=</span>scan<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        	<span class="token keyword">int</span> x <span class="token operator">=</span> scan<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        	<span class="token function">update</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>m<span class="token operator">--</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        	<span class="token keyword">int</span> k <span class="token operator">=</span> scan<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        	<span class="token keyword">int</span> a <span class="token operator">=</span> scan<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        	<span class="token keyword">int</span> b <span class="token operator">=</span> scan<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        	<span class="token keyword">if</span><span class="token punctuation">(</span>k <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        		<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token function">ask</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        	<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        		<span class="token function">update</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
        	<span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        scan<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="树状数组：对差分和前缀和的利用："><a href="#树状数组：对差分和前缀和的利用：" class="headerlink" title="树状数组：对差分和前缀和的利用："></a>树状数组：对差分和前缀和的利用：</h1><h3 id="使用情况："><a href="#使用情况：" class="headerlink" title="使用情况："></a>使用情况：</h3><ol>
<li><p>数组不变求区间和</p>
</li>
<li><p>多次修改某个区间，求区间和</p>
</li>
<li><p>将某个区间变为同一个数求区间和</p>
</li>
<li><p>多次修改区间，寻找定点值</p>
</li>
</ol>
<h2 id="模板："><a href="#模板：" class="headerlink" title="模板："></a>模板：</h2><p>说明：lowbit()奇妙用法…..</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define low
```bit(x) (-x)&amp;x  
///或者 int lowbit(int x) {return -x&amp;x;}  
int tree[length];//树状数组，长度和原数组相等  
//区间修改  
void update(int x,int val)  
{  
    while(x){  
        tree[x]+=val;  
        x+=lowbit(x);  
    }  
}  
//区间求和  
int sum(int l,int r){  
    int ans=0;  
    while(r){  
        ans+=tree[r];  
        r-=lowbit(r);  
    }  
    l--;//  
    while(l){  
        ans-=tree[l];  
        l-=lowbit(l);  
    }  
    return ans;  
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="使用方式："><a href="#使用方式：" class="headerlink" title="使用方式："></a>使用方式：</h2><ol>
<li><p>正常的顶点修改，区间求和直接用</p>
</li>
<li><p><strong>区间修改，求单独一个数</strong> <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3368">P3368 【模板】树状数组 2 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>
<ul>
<li><p>树状数组是保存的每一个下标为位置的前缀和</p>
</li>
<li><p>想要求指定位置的数值需要用到差分,差分的前缀和就是每一个位置的数据大小</p>
</li>
<li><p>修改时只需要修改 update(l,val),update(r+1,-val)</p>
</li>
<li><p>初始化时，要插入的是差分</p>
  <pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;  
#include &lt;algorithm&gt;  
#define ll long long  
#define lowbit(x) (x&amp;(-x))  
using namespace std;  
const int mx = 10e5 + 5;  
int t[mx], m, n;  
int add(int x, int k) {  
	while (x &lt;= n) {  
		t[x] += k;  
		x += lowbit(x);  
	}  
}  
int query(int x){  
	ll ans=0;  
	while(x){  
		ans+=t[x];  
		x-=lowbit(x);  
	}  
	return ans;  
}  
//用差分来的前缀和来表示每一位置上的数字，  
//第一个数字之后，每次把差分加入，再求前缀和就能得到每一个位置上的数字是多少了  
//修改时只需要修改x和y+1两个位置的差分，但是我们用的tree是前缀和，所以依然要用把和lowbit有关的都修改 了   
int main() {  
	cin &gt;&gt; n &gt;&gt; m;  
	int cf=0;   
	for (int i = 1; i &lt;= n; i++) {  
		int num;  
		scanf("%d", &amp;num);  
		add(i,num-cf);  
		cf=num;  
	}  
	  
	for (int i = 1; i &lt;= m; i++) {  
		int ch, x, y,k;  
		scanf("%d", &amp;ch);  
		if (ch == 1){  
			scanf("%d %d %d", &amp;x, &amp;y, &amp;k);  
			add(x,k);  
			add(y+1,-k);  
		}  
		else {  
			int s;  
			scanf("%d", &amp;s);  
			printf("%d\n", query(s));  
		}  
	}  
	return 0;  
}  
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
</li>
<li><p>用指定数据替换某个数据，然后求和 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/range-sum-query-mutable/submissions/429237767/">307. 区域和检索 - 数组可修改 - 力扣（Leetcode）</a></p>
<ul>
<li><p>更换数据也是用到了差分，新的数据-原数据==要更新的val</p>
</li>
<li><p>然后更新之后，原数组指定位置也要更新，方便下次修改同一位置</p>
</li>
<li><p>其他正常食用即可</p>
  <pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class NumArray {  
    int []t;  
    int n;  
    int []nums;  
    int lowbit(int x){return x&amp;(-x);}  
    public NumArray(int[] nums) {  
        this.nums=nums;  
        n=nums.length;  
        t=new int[n+1];  
        int i=1;  
        for (int num:nums  
             ) {  
            add(i++,num);  
        }  
    }  
    void add(int index,int val){  
        while(index&lt;=n){  
            t[index]+=val;  
            index+=lowbit(index);  
        }  
    }  
    public void update(int index, int val) {  
        add(index+1,val-nums[index]);  
        nums[index]=val;  
    }  
      
    public int sumRange(int left, int right) {  
        int ans=0;  
        right++;  
        while(right&gt;0){  
            ans+=t[right];  
            right-=lowbit(right);  
        }  
  
        while(left&gt;0){  
            ans-=t[left];  
            left-=lowbit(left);  
        }  
        return ans;  
    }  
}  
  
/**  
 * Your NumArray object will be instantiated and called as such:  
 * NumArray obj = new NumArray(nums);  
 * obj.update(index,val);  
 * int param_2 = obj.sumRange(left,right);  
 */<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
</li>
</ol>
<p>求1的个数</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;algorithm&gt;  
#include &lt;vector&gt;  
#include &lt;iostream&gt;  
#define lowbit(x) (-x)&amp;x  
using namespace std;  
int main(){  
 &nbsp; &nbsp;int n,ans=0;  
 &nbsp; &nbsp;cin&gt;&gt;n;  
 &nbsp; &nbsp;while(n){  
 &nbsp; &nbsp; &nbsp; &nbsp;ans++;  
 &nbsp; &nbsp; &nbsp; &nbsp;n-=lowbit(n);  
 &nbsp;  }  
 &nbsp; &nbsp;cout&lt;&lt;ans&lt;&lt;endl;  
 &nbsp; &nbsp;return 0;  
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="离散化"><a href="#离散化" class="headerlink" title="离散化"></a>离散化</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">unique 返回的是下下标
vector&lt;int&gt; alls; // 存储所有待离散化的值  
sort(alls.begin(), alls.end()); // 将所有值排序  
alls.erase(unique(alls.begin(), alls.end()), alls.end()); &nbsp; // 去掉重复元素  
//配合erase 即可把放在后面的重复元素删除  
/*  
该函数的作用是“去除”容器或者数组中相邻元素的重复出现的元素  
(1) 这里的去除并非真正意义的erase，而是将重复的元素放到容器的末尾，返回值是去重之后的尾地址。   
(2) unique针对的是相邻元素，所以对于顺序顺序错乱的数组成员，或者容器成员，需要先进行排序，可以调用std::sort()函数  
// 二分求出x对应的离散化的值*/  
int find(int x) // 找到第一个大于等于x的位置  
{  
 &nbsp; &nbsp;int l = 0, r = alls.size() - 1;  
 &nbsp; &nbsp;while (l &lt; r)  
 &nbsp;  {  
 &nbsp; &nbsp; &nbsp; &nbsp;int mid = l + r &gt;&gt; 1;  
 &nbsp; &nbsp; &nbsp; &nbsp;if (alls[mid] &gt;= x) r = mid;  
 &nbsp; &nbsp; &nbsp; &nbsp;else l = mid + 1;  
 &nbsp;  }  
 &nbsp; &nbsp;return r + 1; // 映射到1, 2, ...n  
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="区间和并"><a href="#区间和并" class="headerlink" title="区间和并"></a>区间和并</h2><p>每次维护一个右端点</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">// 将所有存在交集的区间合并  
void merge(vector&lt;PII&gt; &amp;segs)  
{  
    vector&lt;PII&gt; res;  
  
    sort(segs.begin(), segs.end());//根据first进行排序，默认的就是这样的不需要进行自定义  
  
    int st = -2e9, ed = -2e9;  
    for (auto seg : segs)  
        if (ed &lt; seg.first)  
        {  
            //当起点的值大于右端点的时候，一段区间结束，可以继续下一段区间了  
            if (st != -2e9) res.push_back({st, ed});  
            st = seg.first, ed = seg.second;  
        }  g
        else ed = max(ed, seg.second);//如果左没大于右端点，那么右端点每次更新完为最大值  
  
    if (st != -2e9) res.push_back({st, ed});  
    segs = res;  
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="数组模拟链表"><a href="#数组模拟链表" class="headerlink" title="数组模拟链表"></a>数组模拟链表</h2><h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">
int head,e[N],ne[N],idx;  
void init(){  
    head=-1;  
    idx=0;  
}  
//头插  
//head 也是指针,e[idx] 新节点  
void add_head(int x){  
    e[idx]=x;//插入数据  
    ne[idx]=head;//idx 当前的位置的指针指向head指向的位置 -1  
    head=idx;//head 指针指向idx   
    idx++;  
}  
//插入任意位置  
void insert_linkedlist(int k,int x){  
    e[idx]=x;//建立新节点  
    ne[idx]=ne[k];//新节点指向k的下一个节点  
    ne[k]=ne[idx]; //k指向idx这个结点  
    idx++;  
}  
void delete_linkedlist(int k){  
    ne[k]=ne[ne[k]];  
}  
int main(){  
    int k,x,m;  
    char op;  
    cin&gt;&gt;m;  
    init();  
    while(m--){  
        cin&gt;&gt;op;  
        if(op=='h'){  
            cin&gt;&gt;x;  
            add_head(x);  
        }  
        else if(op=='d'){  
            cin&gt;&gt;k;  
            delete_linkedlist(k-1);  
        }  
        else {  
            cin&gt;&gt;k&gt;&gt;x;  
            insert_linkedlist(k-1,x);  
        }  
    }  
    for(int i=head;i!=-1;i=ne[i]){cout&lt;&lt;e[i]&lt;&lt;' ';}  
    return 0;  
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">// e[]表示节点的值，l[]表示节点的左指针，r[]表示节点的右指针，idx表示当前用到了哪个节点  
int e[N], l[N], r[N], idx;  
  
// 初始化  
void init()  
{  
    //0是左端点，1是右端点  
    r[0] = 1, l[1] = 0;  
    idx = 2;  
}  
  
// 在节点a的右边插入一个数x  
void insert(int a, int x)  
{  
    e[idx] = x;  
    l[idx] = a, r[idx] = r[a];  
    l[r[a]] = idx, r[a] = idx ++ ;  
}  
  
// 删除节点a  
void remove(int a)  
{  
    l[r[a]] = l[a];  
    r[l[a]] = r[a];  
}  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">// tt表示栈顶  
int stk[N], tt = 0;  
  
// 向栈顶插入一个数  
stk[ ++ tt] = x;  
  
// 从栈顶弹出一个数  
tt -- ;  
  
// 栈顶的值  
stk[tt];  
  
// 判断栈是否为空，如果 tt &gt; 0，则表示不为空  
if (tt &gt; 0)  
{  
  
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h2><p>注意这个题目要的是结果的下标不是具体的数据</p>
<p>用栈暴力模拟一遍，然后再考虑哪些元素没有用处，就可以排除</p>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P5788">P5788 【模板】单调栈 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;  
#include &lt;cstdio&gt;  
#define ll long long   
using namespace std;  
const ll N=3*1000000+1;  
ll stk[N],a[N],ans[N];  
int tt=0;  
int main(){  
    int n;  
    cin&gt;&gt;n;  
    for(int i=1;i&lt;=n;i++){  
        scanf("%lld",&amp;a[i]);  
    }  
    for(int i=n;i&gt;0;i--){  
        while(tt!=0&amp;&amp;a[i]&gt;=a[stk[tt]]) tt--;  
        ans[i]= tt==0?0:stk[tt];  
        stk[++tt]=i;  
    }  
    for(int i=1;i&lt;=n;i++)printf("%lld ",ans[i]);  
    return 0;  
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">// hh 表示队头，tt表示队尾  
int q[N], hh = 0, tt = -1;  
  
// 向队尾插入一个数  
q[ ++ tt] = x;  
  
// 从队头弹出一个数  
hh ++ ;  
  
// 队头的值  
q[hh];  
  
// 判断队列是否为空，如果 hh &lt;= tt，则表示不为空  
if (hh &lt;= tt)  
{  
  
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h1 id="单调队列-（好东西）"><a href="#单调队列-（好东西）" class="headerlink" title="单调队列 （好东西）"></a>单调队列 （好东西）</h1><p><strong>几个点：</strong></p>
<ul>
<li><p>初始化时，hh=0,tt=-1 使得队列为空</p>
</li>
<li><p>比较的是队尾元素与当前元素</p>
</li>
<li><p>注意队列长度为0时不要输出</p>
</li>
</ul>
<p>常见模型：找出滑动窗口中的最大值/最小值  </p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int hh = 0, tt = -1;  
for (int i = 0; i &lt; n; i ++ )  
{  
    while (hh &lt;= tt &amp;&amp; check_out(q[hh])) hh ++ ;  // 判断队头是否滑出窗口  
    while (hh &lt;= tt &amp;&amp; check(q[tt], i)) tt -- ;  
    q[ ++ tt] = i;  
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>例题</p>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1886">P1886 滑动窗口 /【模板】单调队列 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;  
#include &lt;cstdio&gt;  
#define ll long long   
using namespace std;  
const int N=1000000+2;  
int n,k,a[N],q[N],ans,hh,tt;  
  
int main(){  
    cin&gt;&gt;n&gt;&gt;k;  
    for(int i=0;i&lt;n;i++){  
        scanf("%d",&amp;a[i]);  
    }  
    //队列存的是下标  
    //最小值  
    hh=0;tt=-1;//目的是让队列初始化为空  
    for(int i=0;i&lt;n;i++){  
        //判断队列是否为空  
        if(hh&lt;=tt&amp;&amp;i-k+1&gt;q[hh]) hh++;  
        //目的是把最小的元素放在队头  
        while(hh&lt;=tt&amp;&amp;a[q[tt]]&gt;=a[i]) tt--;//从队尾删除，因为经过我们的处理，已经是严格单调递增的了，所以如果第一个都大于这个元素的话，那么后面几个都大于，所以要删除  
        q[++tt]=i;  
        if(i&gt;=k-1)  
        printf("%d ",a[q[hh]]);  
    }  
    cout&lt;&lt;endl;  
    //最大值  
      hh=0;tt=-1;  
    for(int i=0;i&lt;n;i++){  
        //判断队列是否为空  
        if(hh&lt;=tt&amp;&amp;i-k+1&gt;q[hh]) hh++;  
        //目的是把最大的元素放在队头  
        while(hh&lt;=tt&amp;&amp;a[q[tt]]&lt;=a[i]) tt--;  
        q[++tt]=i;  
        if(i&gt;=k-1)  
        printf("%d ",a[q[hh]]);  
    }  
      
    return 0;  
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h2><p>对称的 ,以j这个点为中点的前后缀是相同的，所以可以直接变成next[ j ]<br><img src="file://D:/typora%E7%94%A8%E5%9B%BE/Screenshots/image-20230511171657614.png?lastModify=1694256669" alt="image-20230511171657614"></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">s从1开始，p从0开始

// s[]是长文本，p[]是模式串，n是s的长度，m是p的长度  
求模式串的Next数组：ne[1]=0  ,一开始就错了肯定从零开始
for (int i = 2, j = 0; i &lt;= m; i ++ )  
{  
    while (j &amp;&amp; p[i] != p[j + 1]) j = ne[j];  
    if (p[i] == p[j + 1]) j ++ ;  
    ne[i] = j;  
}  
  
// 匹配  
for (int i = 1, j = 0; i &lt;= n; i ++ )  
{  
    while (j &amp;&amp; s[i] != p[j + 1]) j = ne[j];  
    if (s[i] == p[j + 1]) j ++ ;  
    if (j == m)  
    {  
        j = ne[j];  
        // 匹配成功后的逻辑  
    }  
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>例题</strong></p>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3375">P3375 【模板】KMP字符串匹配 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">
#include &lt;iostream&gt;  
#include &lt;cstring&gt;  
#define N 1000010  
using namespace std;  
char s[N],p[N];  
int ls,lp,ne[N];  
int main(){  
    cin&gt;&gt;s+1&gt;&gt;p+1;  
    ls=strlen(s+1);  
    lp=strlen(p+1);  
    for(int i=2,j=0;i&lt;=lp;i++){  
        while(j&amp;&amp;p[i]!=p[j+1]) j=ne[j];  
        if(p[j+1]==p[i]) j++;  
        ne[i]=j;  
    }  
     for(int i=1,j=0;i&lt;=ls;i++){  
        while(j&amp;&amp;s[i]!=p[j+1]) j=ne[j];  
        if(s[i]==p[j+1]) j++;  
        if(j==lp){  
            cout&lt;&lt;i-lp+1&lt;&lt;endl;  
            j=ne[j];  
        }  
    }  
    for(int i=1;i&lt;=lp;i++){  
        cout&lt;&lt;ne[i]&lt;&lt;" ";  
    }  
    return 0;  
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="Trie树-高效存储和查找字符串"><a href="#Trie树-高效存储和查找字符串" class="headerlink" title="Trie树 高效存储和查找字符串"></a>Trie树 高效存储和查找字符串</h2><p>集合的数据结构</p>
<p>将字符串分解为一个一个单独的字符然后存储，然后查询这个字符串是否出现过，</p>
<p>出现过几次</p>
<h4 id="更全面-的映射"><a href="#更全面-的映射" class="headerlink" title="更全面 的映射"></a>更全面 的映射</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int getnum(char x){  
    if(x&gt;='A'&amp;&amp;x&lt;='Z')  
        return x-'A';  
    else if(x&gt;='a'&amp;&amp;x&lt;='z')  
        return x -'a'+26;  
    else  
        return x-'0'+52;  
} 

#include&lt;iostream&gt;  
#include &lt;algorithm&gt;  
#include &lt;cstdio&gt;  
using namespace std;  
const int N=100010;  
int son[N][26],cnt[N],idx;//子子节点的个数，只包含26个 小写字母 cnt是以这个字母为结尾的单词出现了福哦少个  
//idx 当前用到哪了  
//插入操作  
char str[N];  
void insert(char str[]){  
 &nbsp; &nbsp;int p=0;//当前的结点  
 &nbsp; &nbsp;for(int i=0;str[i];i++){  
 &nbsp; &nbsp; &nbsp; &nbsp;int u=str[i]-'a';//将26个小写字母映射为数字  
 &nbsp; &nbsp; &nbsp; &nbsp;if(!son[p][u]) son[p][u]=++idx;  
 &nbsp; &nbsp; &nbsp; &nbsp;p=son[p][u];  
 &nbsp;  }  
 &nbsp; &nbsp;cnt[p]++;  
}  
int query(char str[]){  
 &nbsp; &nbsp;int p=0;  
 &nbsp; &nbsp;for(int i=0;str[i];i++){  
 &nbsp; &nbsp; &nbsp; &nbsp;int u=str[i]-'a';  
 &nbsp; &nbsp; &nbsp; &nbsp;if(!son[p][u]) return 0;  
 &nbsp; &nbsp; &nbsp; &nbsp;p=son[p][u];  
 &nbsp;  }  
 &nbsp; &nbsp;return cnt[p];  
}  
int main(){  
 &nbsp; &nbsp;int n;  
 &nbsp; &nbsp;cin&gt;&gt;n;  
 &nbsp; &nbsp;while(n--){  
 &nbsp; &nbsp; &nbsp; char op[2];  
 &nbsp; &nbsp; &nbsp; cin&gt;&gt;op&gt;&gt;str;  
 &nbsp; &nbsp; &nbsp; if(op[0]=='i') insert(str);  
 &nbsp; &nbsp; &nbsp; else cout&lt;&lt;query(str)&lt;&lt;endl;  
 &nbsp;  }  
 &nbsp; &nbsp;return 0;  
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P8306">P8306 【模板】字典树 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;  
#include &lt;algorithm&gt;  
#include &lt;cstdio&gt;  
#include &lt;cstring&gt;  
using namespace std;  
const int N=3000005;  
int son[N][65],cnt[N],idx;//子子节点的个数，只包含26个 小写字母 cnt是以这个字母位借位的单词出现了福哦少个  
//idx 当前用到哪了  
//插入操作  
 int n,m,t;  
char str[N];  
int hashs(char x){  
    if(x&gt;='A'&amp;&amp;x&lt;='Z')  
        return x-'A';  
    else if(x&gt;='a'&amp;&amp;x&lt;='z')  
        return x-'a'+26;  
    else  
        return x-'0'+52;  
}  
void insert(char str[]){  
    int p=0;//当前的结点  
    int l=strlen(str);  
    for(int i=0;i&lt;l;i++){  
        int u=hashs(str[i]);//将26个小写字母映射为数字  
        if(!son[p][u]) son[p][u]=++idx;  
        p=son[p][u];  
        cnt[p]++;  
    }  
      
}  
int query(char str[]){  
    int p=0;//当前的结点  
    int l=strlen(str);  
    for(int i=0;i&lt;l;i++){  
        int u =hashs(str[i]);  
        if(!son[p][u]) return 0;  
        p=son[p][u];  
    }  
    return cnt[p];  
}  
int main(){  
     
    cin&gt;&gt;t;  
    while(t--){  
          for(int i=0;i&lt;=idx;i++){  
            for(int j=0;j&lt;=122;j++){  
                son[i][j]=0;  
            }  
          }  
          for(int i=0;i&lt;=idx;i++)  
            cnt[i]=0;  
        idx=0;  
       scanf("%d%d",&amp;n,&amp;m);  
        while(n--){  
            scanf("%s",str);  
            insert(str);  
        }  
        while(m--){  
             scanf("%s",str);  
            printf("%d\n",query(str));  
        }  
    }  
    return 0;  
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><p>用法：</p>
<h3 id="某些点或者数据是否处于一个连通块中"><a href="#某些点或者数据是否处于一个连通块中" class="headerlink" title="某些点或者数据是否处于一个连通块中"></a>某些点或者数据是否处于一个连通块中</h3><ol>
<li><p>将两个集合合并</p>
</li>
<li><p>询问两个元素是否在一个集合中</p>
</li>
</ol>
<p>基本原理：每个集合用一个树来表示，树根的编号就是整个集合的编号，</p>
<p>每一个结点表示他的父节点p[x] 表示x的父节点</p>
<ul>
<li><p>判断树根: if（p[x]==x）</p>
</li>
<li><p>如何集合的编号： while(p[x]!=x) x=p[x];</p>
</li>
<li><p>如何合并两个集合直接让其中一个的根节点的父节点为另一个集合的根节点就行</p>
</li>
<li><p>如何优化，查询一次后，将将所经过的路径的父节点全都修改为根节点</p>
</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;  
#include &lt;algorithm&gt;  
#include &lt;cstdio&gt;  
#include &lt;cstring&gt;  
using namespace std;  
const int N=10010;  
int p[N];  
//初始每个点都是一个单独的集合  
void init(int n){  
    for(int i=1;i&lt;=n;i++){  
        p[i]=i;  
    }  
}  
int find(int x){  
    if(p[x]!=x) p[x]=find(p[x]);  
    return p[x];  
}  
  
int main(){  
    int n,m;  
    cin&gt;&gt;n&gt;&gt;m;  
    init(n);  
    char op[2];  
    while(m--){  
        int a,b;  
        cin&gt;&gt;op&gt;&gt;a&gt;&gt;b;  
        //合并两个集合,路径压缩  
        if(op[0]=='i') p[find(a)]=find(b);//让a的父节点等于b的父节点，即可合并  
        else {  
            //查询  
            if(find(a)==find(b)) cout&lt;&lt;"yes"&lt;&lt;endl;  
            else cout&lt;&lt;"no"&lt;&lt;endl;  
        }  
    }  
    return 0;  
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3367">P3367 【模板】并查集 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>
<p>维护点的数量：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;  
#include &lt;algorithm&gt;  
#include &lt;cstdio&gt;  
#include &lt;cstring&gt;  
using namespace std;  
const int N=10010;  
int p[N],sizes[N];//每个集合中点的数量  
//初始每个点都是一个单独的集合  
void init(int n){  
    for(int i=1;i&lt;=n;i++){  
        p[i]=i;  
        sizes[i]=1;  
    }  
}  
int find(int x){  
    if(p[x]!=x) p[x]=find(p[x]);  
    return p[x];  
}  
  
int main(){  
    int n,m;  
    cin&gt;&gt;n&gt;&gt;m;  
    init(n);  
    int op;  
    while(m--){  
        int a,b;  
        cin&gt;&gt;op;  
        //合并两个集合,路径压缩  
        if(op==1){  
            cin&gt;&gt;a&gt;&gt;b;  
            if(find(a)==find(b)) continue;  
            sizes[find(b)]+=sizes[find(a)];  
            p[find(a)]=find(b);//让a的父节点等于b的父节点，即可合并  
      
        }  
        else if(op==2){  
            //查询  
            cin&gt;&gt;a&gt;&gt;b;  
            if(find(a)==find(b)) cout&lt;&lt;"Y"&lt;&lt;endl;  
            else cout&lt;&lt;"N"&lt;&lt;endl;  
        }  
        else {  
            //询问某个集合中点的数量  
            cin&gt;&gt;n;  
            cout&lt;&lt;sizes[find(a)]&lt;&lt;endl;  
        }  
    }  
    return 0;  
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="堆-只能保证堆顶是最值，保证不了左右两边的大小关系"><a href="#堆-只能保证堆顶是最值，保证不了左右两边的大小关系" class="headerlink" title="堆 只能保证堆顶是最值，保证不了左右两边的大小关系"></a>堆 只能保证堆顶是最值，保证不了左右两边的大小关系</h2><p>操作：down 和up 把元素向下或向上走，使用的是一维数组，x的左儿子2x,右儿子2x+1</p>
<p>size 表示数组的最后一个位置</p>
<ol>
<li><p>插入一个元素： heap[++size]=x up(size)</p>
</li>
<li><p>求最小值 heap[1]</p>
</li>
<li><p>删除最小值 数组尾部好删除，所以用最后一个元素覆盖数组的头，然后执行down，</p>
<p> 再删除尾部，head[k]=heap[size];size–; down(k)||up(k)</p>
</li>
<li><p>修改 heap[k]=k; down(k)||up(k);</p>
</li>
</ol>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">// h[N]存储堆中的值, h[1]是堆顶，x的左儿子是2x, 右儿子是2x + 1  
// ph[k]存储第k个插入的点在堆中的位置  
// hp[k]存储堆中下标是k的点是第几个插入的  
int h[N], ph[N], hp[N], size;  
  
// 交换两个点，及其映射关系  
void heap_swap(int a, int b)  
{  
    swap(ph[hp[a]],ph[hp[b]]);  
    swap(hp[a], hp[b]);  
    swap(h[a], h[b]);  
}  
  
void down(int u)  
{  
    int t = u;  
    //查找到三个结点中的最小值  
    if (u * 2 &lt;= size &amp;&amp; h[u * 2] &lt; h[t]) t = u * 2;  
    if (u * 2 + 1 &lt;= size &amp;&amp; h[u * 2 + 1] &lt; h[t]) t = u * 2 + 1;  
    if (u != t)  
    {  
        heap_swap(u, t);  
        down(t);  
    }  
}  
  
void up(int u)  
{  
    while (u / 2 &amp;&amp; h[u] &lt; h[u / 2])//父节点存在且当前结点小于父节点   
    {  
        heap_swap(u, u / 2);  
        u &gt;&gt;= 1;//下一个父节点  
    }  
}  
  
// O(n)建堆  
for (int i = n / 2; i; i -- ) down(i);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3378">P3378 【模板】堆 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits/stdc++.h&gt;  
using namespace std;  
const int N=1000001;  
int h[N],s;  
void down(int u){  
    int t=u;  
    if(u*2&lt;=s&amp;&amp;h[u*2]&lt;h[t]) t=u*2;  
    if(u*2+1&lt;=s&amp;&amp;h[u*2+1]&lt;h[t]) t=u*2+1;  
    if(u!=t){  
        swap(h[u],h[t]);  
        down(t);  
    }  
}  
void up(int u){  
    while(u/2&amp;&amp;h[u]&lt;h[u/2]){  
        swap(h[u],h[u/2]);  
        u&gt;&gt;=1;  
    }  
}  
int main(){  
    int n,op;  
    cin&gt;&gt;n;  
    for(int i=n/2;i;i--){  
        down(i);  
    }  
    while(n--){  
        scanf("%d",&amp;op);  
        if(op==1) {  
            int x;  
            scanf("%d",&amp;x);  
            h[++s]=x;  
            up(s);  
        }  
        else if(op==2){  
            printf("%d\n",h[1]);  
        }  
        else {  
            //最后一个换到第一个  
            swap(h[1],h[s]);  
            s--;//删除最后一个  
            down(1);  
        }  
    }  
  
}
			<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h2><p>删除的话打个标记<br>(1) 拉链法 </p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int h[N], e[N], ne[N], idx;  
  
// 向哈希表中插入一个数  
void insert(int x)  
{  
    int k = (x % N + N) % N;  
    e[idx] = x;  
    ne[idx] = h[k];  
    h[k] = idx ++ ;  
}  
  
// 在哈希表中查询某个数是否存在  
bool find(int x)  
{  
    int k = (x % N + N) % N;  
    for (int i = h[k]; i != -1; i = ne[i])  
        if (e[i] == x)  
            return true;  
  
    return false;  
}  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>开放寻址法，遇到冲突的话直接往后找没用的节点</p>
<p>数组要开比原来数据范围大2~3倍</p>
<p>//只要开一个h数组就可以了，不需要e和ne了，找一个不在数据范围内的数据来表示当前位置为空<br>(2) 开放寻址法  </p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">   int h[N];  
const int null =xxx;  
   // 如果x在哈希表中，返回x的下标；如果x不在哈希表中，返回x应该插入的位置  
   int find(int x)  
   {  
       int t = (x % N + N) % N;  
       while (h[t] != null &amp;&amp; h[t] != x)  
       {  
           t ++ ;  
           if (t == N) t = 0;  
       }  
       return t;  
   }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="字符串哈希"><a href="#字符串哈希" class="headerlink" title="字符串哈希"></a>字符串哈希</h3><p>快速判断两个字符串是否相等</p>
<p>核心思想：将字符串看成P进制数，P的经验值是131或13331，取这两个值的冲突概率低<br>小技巧：取模的数用2^64，这样直接用unsigned long long存储，溢出的结果就是取模的结果  </p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">typedef unsigned long long ULL;  
ULL h[N], p[N]; // h[k]存储字符串前k个字母的哈希值, p[k]存储 P^k mod 2^64  
  
// 初始化  
p[0] = 1;  
for (int i = 1; i &lt;= n; i ++ )  
{  
    h[i] = h[i - 1] * P + str[i];  
    p[i] = p[i - 1] * P;//P存储的是每一位的基数值  
}  
  
// 计算子串 str[l ~ r] 的哈希值  
ULL get(int l, int r)  
{  
    return h[r] - h[l - 1] * p[r - l + 1];  
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="STL常用"><a href="#STL常用" class="headerlink" title="STL常用"></a>STL常用</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">vector, 变长数组，倍增的思想 &nbsp;优化思路：减少申请空间的次数  
 &nbsp; &nbsp;size() &nbsp;返回元素个数  
 &nbsp; &nbsp;empty() &nbsp;返回是否为空  
 &nbsp; &nbsp;clear() &nbsp;清空  
 &nbsp; &nbsp;front()/back()  
 &nbsp; &nbsp;push_back()/pop_back()  
 &nbsp; &nbsp;begin()/end()  
 &nbsp;  []  
 &nbsp; &nbsp;支持比较运算，按字典序  
 &nbsp; &nbsp;vector&lt;int&gt; a(1,2),b(3,4);  
printf(a&lt;b) == 0  
​  
pair&lt;int, int&gt;  
 &nbsp; &nbsp;first, 第一个元素  
 &nbsp; &nbsp;second, 第二个元素  
 &nbsp; &nbsp;支持比较运算，以first为第一关键字，以second为第二关键字（字典序）  
​  
string，字符串  
 &nbsp; &nbsp;size()/length() &nbsp;返回字符串长度  
 &nbsp; &nbsp;empty()  
 &nbsp; &nbsp;clear()  
 &nbsp; &nbsp;substr(起始下标，(子串长度)) &nbsp;返回子串  
 &nbsp; &nbsp;c_str() &nbsp;返回字符串所在字符数组的起始地址  
​  
queue, 队列  
 &nbsp; &nbsp;size()  
 &nbsp; &nbsp;empty()  
 &nbsp; &nbsp;push() &nbsp;向队尾插入一个元素  
 &nbsp; &nbsp;front() &nbsp;返回队头元素  
 &nbsp; &nbsp;back() &nbsp;返回队尾元素  
 &nbsp; &nbsp;pop() &nbsp;弹出队头元素  
​  
priority_queue, 优先队列，默认是大根堆  
 &nbsp; &nbsp;size()  
 &nbsp; &nbsp;empty()  
 &nbsp; &nbsp;push() &nbsp;插入一个元素  
 &nbsp; &nbsp;top() &nbsp;返回堆顶元素  
 &nbsp; &nbsp;pop() &nbsp;弹出堆顶元素  
 &nbsp; &nbsp;定义成小根堆的方式：priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; q;  
​  
stack, 栈  
 &nbsp; &nbsp;size()  
 &nbsp; &nbsp;empty()  
 &nbsp; &nbsp;push() &nbsp;向栈顶插入一个元素  
 &nbsp; &nbsp;top() &nbsp;返回栈顶元素  
 &nbsp; &nbsp;pop() &nbsp;弹出栈顶元素  
​  
deque, 双端队列  
 &nbsp; &nbsp;size()  
 &nbsp; &nbsp;empty()  
 &nbsp; &nbsp;clear()  
 &nbsp; &nbsp;front()/back()  
 &nbsp; &nbsp;push_back()/pop_back()  
 &nbsp; &nbsp;push_front()/pop_front()  
 &nbsp; &nbsp;begin()/end()  
 &nbsp;  []  
​  
set, map, multiset, multimap, 基于平衡二叉树（红黑树），动态维护有序序列  
 &nbsp; &nbsp;size()  
 &nbsp; &nbsp;empty()  
 &nbsp; &nbsp;clear()  
 &nbsp; &nbsp;begin()/end()  
 &nbsp; &nbsp;++, -- 返回前驱和后继，时间复杂度 O(logn)  
​  
 &nbsp; &nbsp;set/multiset  
 &nbsp; &nbsp; &nbsp; &nbsp;insert() &nbsp;插入一个数  
 &nbsp; &nbsp; &nbsp; &nbsp;find() &nbsp;查找一个数  
 &nbsp; &nbsp; &nbsp; &nbsp;count() &nbsp;返回某一个数的个数  
 &nbsp; &nbsp; &nbsp; &nbsp;erase()  
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  (1) 输入是一个数x，删除所有x &nbsp; O(k + logn)  
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  (2) 输入一个迭代器，删除这个迭代器  
 &nbsp; &nbsp; &nbsp; &nbsp;lower_bound()/upper_bound()  
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;lower_bound(x) &nbsp;返回大于等于x的最小的数的迭代器  
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;upper_bound(x) &nbsp;返回大于x的最小的数的迭代器  
 &nbsp; &nbsp;map/multimap  
 &nbsp; &nbsp; &nbsp; &nbsp;insert() &nbsp;插入的数是一个pair  
 &nbsp; &nbsp; &nbsp; &nbsp;erase() &nbsp;输入的参数是pair或者迭代器  
 &nbsp; &nbsp; &nbsp; &nbsp;find()  
 &nbsp; &nbsp; &nbsp;  [] &nbsp;注意multimap不支持此操作。 时间复杂度是 O(logn)  
 &nbsp; &nbsp; &nbsp; &nbsp;lower_bound()/upper_bound()  
​  
unordered_set, unordered_map, unordered_multiset, unordered_multimap, 哈希表  
 &nbsp; &nbsp;和上面类似，增删改查的时间复杂度是 O(1)  
 &nbsp; &nbsp;不支持 lower_bound()/upper_bound()， 迭代器的++，--  
​  
bitset, 圧位 省空间 &nbsp; &nbsp;  
 &nbsp; &nbsp;bitset&lt;10000&gt; s; &nbsp;//&lt; &gt;里面是个数, 可以用来替代bool 数组  
    //以下操作都支持  
    ~, &amp;, |, ^  
 &nbsp; &nbsp;&gt;&gt;, &lt;&lt;  
 &nbsp; &nbsp;==, !=  
 &nbsp;  []  
​  
 &nbsp; &nbsp;count() &nbsp;返回有多少个1  
​  
 &nbsp; &nbsp;any() &nbsp;判断是否至少有一个1  
 &nbsp; &nbsp;none() &nbsp;判断是否全为0  
​  
 &nbsp; &nbsp;set() &nbsp;把所有位置成1  
 &nbsp; &nbsp;set(k, v) &nbsp;将第k位变成v  
 &nbsp; &nbsp;reset() &nbsp;把所有位变成0  
 &nbsp; &nbsp;flip() &nbsp;等价于~  
 &nbsp; &nbsp;flip(k) 把第k位取反  
​<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="图论背思路"><a href="#图论背思路" class="headerlink" title="图论背思路"></a>图论背思路</h2><h2 id="BFS和DFS"><a href="#BFS和DFS" class="headerlink" title="BFS和DFS"></a>BFS和DFS</h2><h3 id="非常完美的一道dfs-并查集-https-www-luogu-com-cn-problem-P1127"><a href="#非常完美的一道dfs-并查集-https-www-luogu-com-cn-problem-P1127" class="headerlink" title="非常完美的一道dfs + 并查集 https://www.luogu.com.cn/problem/P1127"></a>非常完美的一道dfs + 并查集 <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1127">https://www.luogu.com.cn/problem/P1127</a></h3><p><u>还原现场很重要</u> </p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span> start<span class="token punctuation">,</span><span class="token keyword">int</span> num<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>num <span class="token operator">==</span> n<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
		<span class="token comment">//开始搜索</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			<span class="token comment">//找start这个开头的string</span>
			<span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token char">'a'</span> <span class="token operator">==</span> start <span class="token operator">&amp;&amp;</span> st<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
				<span class="token comment">//标记</span>
				st<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
				ans<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">dfs</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token char">'a'</span><span class="token punctuation">,</span>num<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
				<span class="token comment">//还原现场</span>
				st<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
				ans<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>ans<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			
		<span class="token punctuation">}</span>
		<span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="DFS-回溯的时候记得回复现场"><a href="#DFS-回溯的时候记得回复现场" class="headerlink" title="DFS 回溯的时候记得回复现场"></a>DFS 回溯的时候记得回复现场</h3><h3 id="邻接矩阵：-p-a-b-a-gt-b-适合稠密图"><a href="#邻接矩阵：-p-a-b-a-gt-b-适合稠密图" class="headerlink" title="邻接矩阵： p[ a] [ b ] a -> b 适合稠密图"></a>邻接矩阵： p[ a] [ b ] a -&gt; b 适合稠密图</h3><h3 id="邻接表：-稀疏图"><a href="#邻接表：-稀疏图" class="headerlink" title="邻接表： 稀疏图"></a>邻接表： 稀疏图</h3><p>和哈希表思路一样</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">// 对于每个点k，开一个单链表，存储k所有可以走到的点。h[k]存储这个单链表的头结点  
int h[N], e[N], ne[N], idx; //e是终点end  
  
// 添加一条边a-&gt;b  
void add(int a, int b)  
{  
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;  
}   
// 初始化  
idx = 0;  
memset(h, -1, sizeof h);  
//遍历图  
for(int i = h[t] ; i != -1 ; i = ne[i] )

## 另一种使用结构体的邻接表存法

int idx=0,n;  
int h[N] , dis[N] , vis[N];  
struct Edge{  
    int ne,to,dis;  
}ed[N];  
//添加， 从 1 开始  
void add(int a,int b ,int c){  
    ed[++idx].ne = h[a];  
    ed[idx].to = b;  
    ed[idx].dis = c;  
    h[a] = idx;  
}
//遍历图  
for(int i = h[t] ; i ; i = ed[i].ne)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="BFS-可用于解决权值相等的最短路径问题"><a href="#BFS-可用于解决权值相等的最短路径问题" class="headerlink" title="BFS 可用于解决权值相等的最短路径问题"></a>BFS 可用于解决权值相等的最短路径问题</h3><h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><p>必须是又向无环</p>
<p>排完后，所有的起点都在终点之前</p>
<ol>
<li><p>统计每一个节点的入度和出度</p>
</li>
<li><p>每一次将入读相同的点放入queue</p>
</li>
<li><p>枚举队头的出边，删掉 出边,这条边的终点的入度-1</p>
</li>
<li><p>如果某个点的入度为0 放入队列</p>
</li>
</ol>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">bool topsort()  
{  
    int hh = 0, tt = -1;  
  
    // d[i] 存储点i的入度  
    for (int i = 1; i &lt;= n; i ++ )  
        if (!d[i])  
            q[ ++ tt] = i;//把每个入度为0的点加入队列  
  
    while (hh &lt;= tt)  
    {  
        int t = q[hh ++ ];//取出队头  
		//从队头开始找路径  
        for (int i = h[t]; i != -1; i = ne[i])  
        {  
            int j = e[i];  
            if (-- d[j] == 0)  
                q[ ++ tt] = j;  
        }  
    }  
  
    // 如果所有点都入队了，说明存在拓扑序列；否则不存在拓扑序列。  
    return tt == n - 1;  
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="最短路问题："><a href="#最短路问题：" class="headerlink" title="最短路问题："></a>最短路问题：</h2><h2 id="分层最短路-，适用于乘车路线和免费次数。"><a href="#分层最短路-，适用于乘车路线和免费次数。" class="headerlink" title="_分层最短路_，适用于乘车路线和免费次数。"></a>_分层最短路_，适用于乘车路线和免费次数。</h2><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P4568#submit">飞机路线</a></p>
<h3 id="单源最短路-一个点-x2F-到其他所有点的最短路"><a href="#单源最短路-一个点-x2F-到其他所有点的最短路" class="headerlink" title="单源最短路 一个点./.到其他所有点的最短路"></a>单源最短路 一个点./.到其他所有点的最短路</h3><ul>
<li><p>所有边的权都是正数</p>
<ol>
<li>朴素Dijkstra O(n^2) n为点的数量 稠密图 边很多 外部迭代n-1 次 <pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int g[N][N];  // 存储每条边  权值  
int dist[N];  // 存储1号点到每个点的最短距离  
bool st[N];   // 存储每个点的最短路是否已经确定  
  
// 求1号点到n号点的最短路，如果不存在则返回-1  
int dijkstra()  
{  
    memset(dist, 0x3f, sizeof dist);  
    dist[1] = 0;  
  
    for (int i = 0; i &lt; n - 1; i ++ )//迭代n-1 次，因为上来选中了一个点  
    {  
        int t = -1;     // 在还未确定最短路的点中，寻找距离最小的点  
        for (int j = 1; j &lt;= n; j ++ )  
            if (!st[j] &amp;&amp; (t == -1 || dist[t] &gt; dist[j]))  
                t = j;  
  
        // 用t更新其他点的距离  
        for (int j = 1; j &lt;= n; j ++ )  
            dist[j] = min(dist[j], dist[t] + g[t][j]);  
  
        st[t] = true;  
    }  
  
    if (dist[n] == 0x3f3f3f3f) return -1;  
    return dist[n];  
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li>堆优化版的 O(mlogn) 稀疏图  <pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">typedef pair&lt;int, int&gt; PII;  
  
int n;      // 点的数量  
int h[N], w[N], e[N], ne[N], idx;       // 邻接表存储所有边  
int dist[N];        // 存储所有点到1号点的距离  
bool st[N];     // 存储每个点的最短距离是否已确定  
  
// 求1号点到n号点的最短距离，如果不存在，则返回-1  
int dijkstra()  
{  
    memset(dist, 0x3f, sizeof dist);  
    dist[1] = 0;  
    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;  
    heap.push({0, 1});      // first存储距离，second存储节点编号  
  
    while (heap.size())  
    {  
        auto t = heap.top();  
        heap.pop();  
  
        int ver = t.second, distance = t.first;  
  
        if (st[ver]) continue;  
        st[ver] = true;  
  
        for (int i = h[ver]; i != -1; i = ne[i])  
        {  
            int j = e[i];  
            if (dist[j] &gt; distance + w[i])  
            {  
                dist[j] = distance + w[i];  
                heap.push({dist[j], j});  
            }  
        }  
    }  
  
    if (dist[n] == 0x3f3f3f3f) return -1;  
    return dist[n];  
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ol>
</li>
<li><p>存在负权边</p>
<ol>
<li><p>Bellman -Ford O(nm) <strong>奇妙的存图方式</strong> 无负权回路 经过路径有次数限制的话只能用这个了，外面限制的是经过i的点的个数，然后每次遍历边即可。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int n, m;       // n表示点数，m表示边数  
int dist[N];        // dist[x]存储1到x的最短路距离  
  
struct Edge     // 边，a表示出点，b表示入点，w表示边的权重  
{  
    int a, b, w;  
}edges[M];  
  
// 求1到n的最短路距离，如果无法从1走到n，则返回-1。  
int bellman_ford()  
{  
    memset(dist, 0x3f, sizeof dist);  
    dist[1] = 0;  
	//不需要进行收录顶点  
    // 如果第n次迭代仍然会松弛三角不等式，就说明存在一条长度是n+1的最短路径，由抽屉原理，路径中至少存在两个相同的点，说明图中存在负权回路。  
    for (int i = 0; i &lt; n; i ++ )//这个n是指的是最多不经过 多少次经过同一条边  
    {  
        for (int j = 0; j &lt; m; j ++ )  
        {  
            int a = edges[j].a, b = edges[j].b, w = edges[j].w;  
            if (dist[b] &gt; dist[a] + w)  
                dist[b] = dist[a] + w;  
        }  
    }  
  
    if (dist[n] &gt; 0x3f3f3f3f / 2) return -1;  
    return dist[n];  
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><p>SPFA 一般： O（m) 最坏O（nm） 不存在负权环才能使用 99%都没有负环比较好用</p>
<p> 优化思路：只有更新过点才对后面的点更新有影响</p>
<p> 要从 1 开始存比较好 ，e 是end 也就是一条边的终点</p>
 <pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int n;      // 总点数  
int h[N], w[N], e[N], ne[N], idx;       // 邻接表存储所有边  
int dist[N];        // 存储每个点到1号点的最短距离  
bool st[N];     // 存储每个点是否在队列中  
  
  
// 求x号点到n号点的最短路距离，如果从1号点无法走到n号点则返回-1  
int spfa(int x)  
{  
    memset(dist, 0x3f, sizeof dist);//初始化要根据题目来  
      
    dist[x] = 0;  
/*或者  
for(int i = 1 ; i &lt;= n ; i ++){  
        dis[i] = INT_MAX;  
    }*/	  
    queue&lt;int&gt; q;  
    q.push(x);  
  
    while (q.size())//不为空，即为还有更新的点  
    {  
        auto t = q.front();  
        q.pop();  
  
        st[t] = false;//这里不要忘记  
       //遍历所以能到达的顶点，进行更新  
        for (int i = h[t]; i != -1; i = ne[i])  
        {  
            int j = e[i];  
            if (dist[j] &gt; dist[t] + w[i])  
            {  
                dist[j] = dist[t] + w[i];  
                if (!st[j])     // 如果队列中已存在j，则不需要将j重复插入  
                {  
                    q.push(j);//这里是j  
                    st[j] = true;//这里是j  
                }  
            }  
        }  
    }  
  
    if (dist[n] == 0x3f3f3f3f) return -1;  
    return dist[n];  
}  
//初始化和存图  
void add(int a, int b , int c){  
    w[idx] = c;  
    ne[idx] = h[a];   
    en[idx] =  b;    
    h[a] = idx++;  
}  
void init(){  
    idx = 1;  
    memset(h , -1 ,sizeof h);  
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="模板题："><a href="#模板题：" class="headerlink" title="模板题："></a>模板题：</h4><p> <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3371">P3371 【模板】单源最短路径（弱化版） - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>
</li>
</ol>
</li>
</ul>
<h2 id="x3D-x3D-判断有无负环-用cnt-来记录当前最短路的边数"><a href="#x3D-x3D-判断有无负环-用cnt-来记录当前最短路的边数" class="headerlink" title="==判断有无负环 用cnt 来记录当前最短路的边数"></a>==<strong>判断有无负环 用cnt 来记录当前最短路的边数</strong></h2><p>例题： <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3385">负环路</a></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int n;      // 总点数  
int h[N], w[N], e[N], ne[N], idx;       // 邻接表存储所有边  
int dist[N], cnt[N];        // dist[x]存储1号点到x的最短距离，cnt[x]存储1到x的最短路中经过的点数  
bool st[N];     // 存储每个点是否在队列中  
  
// 如果存在负环，则返回true，否则返回false。  
bool spfa()  
{  
    // 不需要初始化dist数组  
    // 原理：如果某条最短路径上有n个点（除了自己），那么加上自己之后一共有n+1个点，由抽屉原理一定有两个点相同，所以存在环。  
  
    queue&lt;int&gt; q;  
    for (int i = 1; i &lt;= n; i ++ )  
    {  
        q.push(i);  
        st[i] = true;  
    }  
  
    while (q.size())  
    {  
        auto t = q.front();  
        q.pop();  
  
        st[t] = false;  
  
        for (int i = h[t]; i != -1; i = ne[i])  
        {  
            int j = e[i];  
            if (dist[j] &gt; dist[t] + w[i])  
            {  
                dist[j] = dist[t] + w[i];  
                cnt[j] = cnt[t] + 1;  
                if (cnt[j] &gt;= n) return true;       // 如果从1号点到x的最短路中包含至少n个点（不包括自己），则说明存在环  
                if (!st[j])  
                {  
                    q.push(j);  
                    st[j] = true;  
                }  
            }  
        }  
    }  
  
    return false;  
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="多源汇最短路-起点终点都不确定"><a href="#多源汇最短路-起点终点都不确定" class="headerlink" title="多源汇最短路 起点终点都不确定"></a>多源汇最短路 起点终点都不确定</h3><p>Floyd O(n^3)</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">初始化：  
 &nbsp; &nbsp;for (int i = 1; i &lt;= n; i ++ )  
 &nbsp; &nbsp; &nbsp; &nbsp;for (int j = 1; j &lt;= n; j ++ )  
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if (i == j) d[i][j] = 0;  
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;else d[i][j] = INF;  
​  
// 算法结束后，d[a][b]表示a到b的最短距离  
void floyd()  
{  
 &nbsp; &nbsp;for (int k = 1; k &lt;= n; k ++ )  
 &nbsp; &nbsp; &nbsp; &nbsp;for (int i = 1; i &lt;= n; i ++ )  
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;for (int j = 1; j &lt;= n; j ++ )  
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;d[i][j] = min(d[i][j], d[i][k] + d[k][j]);// i经过k 点到达j   
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><h3 id="普利姆算法-Prim-思路和Dijsktra算法相似-外部迭代-n-次，因为没有提前选中一个点"><a href="#普利姆算法-Prim-思路和Dijsktra算法相似-外部迭代-n-次，因为没有提前选中一个点" class="headerlink" title="普利姆算法 Prim 思路和Dijsktra算法相似 外部迭代 n 次，因为没有提前选中一个点"></a>普利姆算法 Prim 思路和Dijsktra算法相似 外部迭代 n 次，因为没有提前选中一个点</h3><h3 id="迭代n次因为没有提前选中一个点-枚举所有点"><a href="#迭代n次因为没有提前选中一个点-枚举所有点" class="headerlink" title="迭代n次因为没有提前选中一个点 枚举所有点"></a>迭代n次因为没有提前选中一个点 枚举所有点</h3><ol>
<li><p>朴素Prim算法 稠密图 每次找到未收录的距离最近的点，收录并进行更新其他点到<strong>集合</strong>的距离</p>
</li>
<li><p>找这个点是否与集合内部相连</p>
</li>
<li><p>某个点到这个集合的距离为某个点到这个集合当中的点的距离最短的边</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int n; &nbsp; &nbsp; &nbsp;// n表示点数  
int g[N][N]; &nbsp; &nbsp; &nbsp; &nbsp;// 邻接矩阵，存储所有边  
int dist[N]; &nbsp; &nbsp; &nbsp; &nbsp;// 存储其他点到当前最小生成树的距离  
bool st[N]; &nbsp; &nbsp; // 存储每个点是否已经在生成树中  
​  
​  
// 如果图不连通，则返回INF(值是0x3f3f3f3f), 否则返回最小生成树的树边权重之和  
int prim()  
{  
 &nbsp; &nbsp;memset(dist, 0x3f, sizeof dist);  
​  
 &nbsp; &nbsp;int res = 0;  
 &nbsp; &nbsp;for (int i = 0; i &lt; n; i ++ )  
 &nbsp;  {  
 &nbsp; &nbsp; &nbsp; &nbsp;int t = -1;  
 &nbsp; &nbsp; &nbsp; &nbsp;for (int j = 1; j &lt;= n; j ++ )  
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if (!st[j] &amp;&amp; (t == -1 || dist[t] &gt; dist[j]))  
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;t = j;  
​  
 &nbsp; &nbsp; &nbsp; &nbsp;if (i &amp;&amp; dist[t] == INF) return INF;  
​  
 &nbsp; &nbsp; &nbsp; &nbsp;if (i) res += dist[t];  
 &nbsp; &nbsp; &nbsp; &nbsp;st[t] = true;  
​  
 &nbsp; &nbsp; &nbsp; &nbsp;for (int j = 1; j &lt;= n; j ++ ) dist[j] = min(dist[j], g[t][j]);  
 &nbsp; &nbsp; &nbsp; &nbsp;//不是相加  
 &nbsp;  }  
​  
 &nbsp; &nbsp;return res;  
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>堆优化版的Prim 稀疏图 不常用</p>
</li>
</ol>
<h3 id="克鲁斯卡尔算法-Kruskal-先对边进行排序-稀疏图-可以用并查集-枚举所有边"><a href="#克鲁斯卡尔算法-Kruskal-先对边进行排序-稀疏图-可以用并查集-枚举所有边" class="headerlink" title="克鲁斯卡尔算法 Kruskal 先对边进行排序 稀疏图 可以用并查集 枚举所有边"></a>克鲁斯卡尔算法 Kruskal 先对边进行排序 稀疏图 可以用并查集 枚举所有边</h3><p>java版本:</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">bronya</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token operator">*</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>math<span class="token punctuation">.</span></span><span class="token class-name">BigInteger</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token operator">*</span></span><span class="token punctuation">;</span>


<span class="token keyword">class</span> <span class="token class-name">Edge</span> <span class="token punctuation">{</span>
	<span class="token keyword">int</span> a <span class="token punctuation">,</span> b <span class="token punctuation">,</span> w<span class="token punctuation">;</span>
	<span class="token keyword">public</span> <span class="token class-name">Edge</span><span class="token punctuation">(</span><span class="token keyword">int</span> a <span class="token punctuation">,</span> <span class="token keyword">int</span> b <span class="token punctuation">,</span> <span class="token keyword">int</span> w<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">this</span><span class="token punctuation">.</span>a <span class="token operator">=</span> a<span class="token punctuation">;</span>
		<span class="token keyword">this</span><span class="token punctuation">.</span>b <span class="token operator">=</span> b<span class="token punctuation">;</span>
		<span class="token keyword">this</span><span class="token punctuation">.</span>w <span class="token operator">=</span> w<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span><span class="token punctuation">{</span>

	<span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token class-name">N</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token number">2</span> <span class="token operator">*</span> <span class="token number">1e5</span> <span class="token operator">+</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">static</span> <span class="token keyword">int</span> n <span class="token punctuation">,</span> m <span class="token punctuation">;</span>
	<span class="token keyword">static</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token keyword">static</span> <span class="token class-name">Edge</span><span class="token punctuation">[</span><span class="token punctuation">]</span> ed <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Edge</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token keyword">static</span> <span class="token keyword">long</span> ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>x <span class="token operator">!=</span> p<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">)</span> p<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>p<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span> p<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">check</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n <span class="token punctuation">;</span>  i <span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			p<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>ed<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>m<span class="token punctuation">,</span><span class="token punctuation">(</span>e1<span class="token punctuation">,</span>e2<span class="token punctuation">)</span><span class="token operator">-&gt;</span>e1<span class="token punctuation">.</span>w <span class="token operator">-</span> e2<span class="token punctuation">.</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">int</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
		<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m <span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			<span class="token keyword">int</span> a <span class="token operator">=</span> ed<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>a<span class="token punctuation">;</span>
			<span class="token keyword">int</span> b <span class="token operator">=</span> ed<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>b<span class="token punctuation">;</span>
			<span class="token keyword">int</span> w <span class="token operator">=</span> ed<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>w<span class="token punctuation">;</span>
			a <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
			b <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">if</span><span class="token punctuation">(</span>a <span class="token operator">!=</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
				p<span class="token punctuation">[</span>a<span class="token punctuation">]</span> <span class="token operator">=</span> b<span class="token punctuation">;</span>
				ans <span class="token operator">+=</span> w<span class="token punctuation">;</span>
				cnt <span class="token operator">++</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>cnt <span class="token operator">&lt;</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
		<span class="token keyword">else</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">{</span>
		<span class="token class-name">BufferedReader</span> re <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> s <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		n <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		m <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span>  i <span class="token operator">&lt;</span> m <span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			s <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">int</span> w <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			ed<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Edge</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> w<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">boolean</span> f <span class="token operator">=</span> <span class="token function">check</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>ans<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">else</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"orz"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3366">P3366 【模板】最小生成树 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>
<ol>
<li><p>所有边按权重从小到大排序</p>
</li>
<li><p>枚举每条边a,b权重c if a,b不连通， 将这条边加入集合中</p>
</li>
</ol>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int n, m;       // n是点数，m是边数  
int p[N];       // 并查集的父节点数组  
  
struct Edge     // 存储边  
{  
    int a, b, w;  
  
    bool operator&lt; (const Edge &amp;W)const // 重载了 &lt;   
    {  
        return w &lt; W.w;  
    }  
}edges[M];  
  
int find(int x)     // 并查集核心操作  
{  
    if (p[x] != x) p[x] = find(p[x]);  
    return p[x];  
}  
  
int kruskal()  
{  
    sort(edges, edges + m);  
  
    for (int i = 1; i &lt;= n; i ++ ) p[i] = i;    // 初始化并查集  
  
    int res = 0, cnt = 0;  
    for (int i = 0; i &lt; m; i ++ )  
    {  
        int a = edges[i].a, b = edges[i].b, w = edges[i].w;  
  
        a = find(a), b = find(b);  
        if (a != b)     // 如果两个连通块不连通，则将这两个连通块合并  
        {  
            p[a] = b;  
            res += w;  
            cnt ++ ;  
        }  
    }  
  
    if (cnt &lt; n - 1) return INF;  
    return res;  
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="二分图-当且仅当图中没有奇数环"><a href="#二分图-当且仅当图中没有奇数环" class="headerlink" title="二分图 当且仅当图中没有奇数环"></a>二分图 当且仅当图中没有奇数环</h2><h3 id="染色法-O-n-m-判断是否是二分图"><a href="#染色法-O-n-m-判断是否是二分图" class="headerlink" title="染色法 O(n+m) 判断是否是二分图"></a>染色法 O(n+m) 判断是否是二分图</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int n;      // n表示点数  
int h[N], e[M], ne[M], idx;     // 邻接表存储图  
int color[N];       // 表示每个点的颜色，-1表示未染色，0表示白色，1表示黑色  
  
// 参数：u表示当前节点，c表示当前点的颜色  
bool dfs(int u, int c)  
{  
    color[u] = c;  
    for (int i = h[u]; i != -1; i = ne[i])  
    {  
        int j = e[i];  
        if (color[j] == -1)//未染色  
        {  
            if (!dfs(j, !c)) return false;//比如两种颜色， 0，1表示，那么这里就可以用 3- c,也就是用另一种颜色去染色  
        }  
        else if (color[j] == c) return false;  
    }  
  
    return true;  
}  
  
bool check()  
{  
    memset(color, -1, sizeof color);  
    bool flag = true;  
    //枚举所有点，去染色  
    for (int i = 1; i &lt;= n; i ++ )  
        if (color[i] == -1)  
            if (!dfs(i, 0))  
            {  
                flag = false;  
                break;  
            }  
    return flag;  
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="匈牙利算法-O-mn-实际运行时间一般小于这个值-稠密图不适合用邻接表，推荐使用临界矩阵"><a href="#匈牙利算法-O-mn-实际运行时间一般小于这个值-稠密图不适合用邻接表，推荐使用临界矩阵" class="headerlink" title="匈牙利算法 O(mn) 实际运行时间一般小于这个值 稠密图不适合用邻接表，推荐使用临界矩阵"></a>匈牙利算法 O(mn) 实际运行时间一般小于这个值 稠密图不适合用邻接表，推荐使用临界矩阵</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int n1, n2; &nbsp; &nbsp; // n1表示第一个集合中的点数，n2表示第二个集合中的点数  
int h[N], e[M], ne[M], idx; &nbsp; &nbsp; // 邻接表存储所有边，匈牙利算法中只会用到从第一个集合指向第二个集合的边，所以这里只用存一个方向的边  
int match[N]; &nbsp; &nbsp; &nbsp; // 存储第二个集合中的每个点当前匹配的第一个集合中的点是哪个  
bool st[N]; &nbsp; &nbsp; // 表示第二个集合中的每个点是否已经被遍历过  
​  
bool find(int x)  
{  
 &nbsp; &nbsp;for (int i = h[x]; i != -1; i = ne[i])  
 &nbsp;  {  
 &nbsp; &nbsp; &nbsp; &nbsp;int j = e[i];  
 &nbsp; &nbsp; &nbsp; &nbsp;if (!st[j])  
 &nbsp; &nbsp; &nbsp;  {  
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;st[j] = true;  
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if (match[j] == 0 || find(match[j]))//第二个集合的点未匹配，或者是可以为已经 匹配的第一个集合中的点找到别的集合二中的点  
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  {  
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;match[j] = x;  
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return true;  
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  }  
 &nbsp; &nbsp; &nbsp;  }  
 &nbsp;  }  
​  
 &nbsp; &nbsp;return false;  
}  
​  
// 求最大匹配数，依次枚举第一个集合中的每个点能否匹配第二个集合中的点  
int res = 0;  
for (int i = 1; i &lt;= n1; i ++ )  
{  
 &nbsp; &nbsp;memset(st, false, sizeof st);  
 &nbsp; &nbsp;if (find(i)) res ++ ;  
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>例题：<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3386">P3386 【模板】二分图最大匹配 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></strong></p>
<h2 id="邻接表的写法-稠密图会超时"><a href="#邻接表的写法-稠密图会超时" class="headerlink" title="邻接表的写法(稠密图会超时)"></a>邻接表的写法(稠密图会超时)</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits/stdc++.h&gt;  
using namespace std;  
const int N  = 505;  
int n1,n2,ed;//需要两个集合  
int h[N] , ne[N] , e[N] , idx;  
int match[N] ;  
bool vis[N];  
void init(){  
    memset(h,-1,sizeof h);  
    idx = 0;  
}  
void add(int a, int b){  
    e[idx] = b ;  
    ne[idx] = h[a];  
    h[a] = idx++;  
}  
bool find(int x){  
    for (int i = h[x] ; i != -1 ; i =ne[i]){  
        int j = e[i];  
        if(!vis[j]){  
            vis[j] = true;  
            if(match[j] == 0 || find(match[j])){  
                //如果终边的点未匹配，或者是可以为以匹配的起点找到另一个终点  
                match[j] = x;  
                return true;  
            }  
        }  
    }  
    return false;  
}  
int main(){  
    ios::sync_with_stdio(false);  
    cin.tie(nullptr);  
    cin &gt;&gt; n1 &gt;&gt; n2 &gt;&gt;ed;  
    init();  
    int u ,v;  
    for (int i = 1 ; i &lt;= ed ; i++){  
        cin &gt;&gt; u &gt;&gt; v;  
        if(v &lt;= n2){  
            add(u , v);  
        }  
         
    }  
    int ans = 0;  
    for (int i = 1 ; i &lt;= n1 ; i++){  
        memset(vis, false ,sizeof vis);  
        if(find(i)) ans++;  
    }  
    cout &lt;&lt; ans &lt;&lt;endl ;  
    return 0;  
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="邻接矩阵的写法："><a href="#邻接矩阵的写法：" class="headerlink" title="邻接矩阵的写法："></a>邻接矩阵的写法：</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits/stdc++.h&gt;  
using namespace std;  
const int N  = 505;  
int n1,n2,ed;//需要两个集合  
bool a[N][N];  
int match[N];  
bool vis[N];  
bool find(int x){  
    //枚举终边  
    for (int i = 1 ; i &lt;= n2 ; i ++){  
        if(!vis[i] &amp;&amp; a[x][i]){  
            vis[i] = true;  
            if(match[i] == 0 || find(match[i])){  
                //如果终边的点未匹配，或者是可以为以匹配的起点找到另一个终点  
                match[i] = x;  
                return true;  
            }  
        }  
    }  
    return false;  
}  
int main(){  
    ios::sync_with_stdio(false);  
    cin.tie(nullptr);  
    cin &gt;&gt; n1 &gt;&gt; n2 &gt;&gt;ed;  
    int u ,v;  
    for (int i = 1 ; i &lt;= ed ; i++){  
        cin &gt;&gt; u &gt;&gt; v;  
        if(v &lt;= n2){  
            a[u][v] = 1;  
        }  
         
    }  
    int ans = 0;  
    for (int i = 1 ; i &lt;= n1 ; i++){  
        ans+=find(i); // 这里不一样哦  
        memset(vis, false ,sizeof vis);  
    }  
    cout &lt;&lt; ans &lt;&lt;endl ;  
    return 0;  
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="数学知识"><a href="#数学知识" class="headerlink" title="数学知识"></a>数学知识</h2><blockquote>
<p>[!NOTE]</p>
<h2 id="当看见-0-的个数时考虑将结果分成-2-，-5-的个数-并且，末尾的0的个数一定是由5的个数决定的"><a href="#当看见-0-的个数时考虑将结果分成-2-，-5-的个数-并且，末尾的0的个数一定是由5的个数决定的" class="headerlink" title="当看见 0 的个数时考虑将结果分成 2 ， 5 的个数,并且，末尾的0的个数一定是由5的个数决定的"></a>当看见 0 的个数时考虑将结果分成 2 ， 5 的个数,并且，末尾的0的个数一定是由5的个数决定的</h2></blockquote>
<p><a target="_blank" rel="noopener" href="https://ac.nowcoder.com/acm/contest/57683/E">E-Kevin喜欢零(困难版本)_牛客小白月赛73 (nowcoder.com)</a></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits/stdc++.h&gt;  
​  
void solve() {#include &lt;bits/stdc++.h&gt;  
​  
void solve() {  
 &nbsp; &nbsp;int n, k;  
 &nbsp; &nbsp;std::cin &gt;&gt; n &gt;&gt; k;  
​  
 &nbsp; &nbsp;int64_t ans = 0;  
 &nbsp; &nbsp;std::unordered_map&lt;int, std::vector&lt;int&gt;&gt; tp, fp;  
 &nbsp; &nbsp;//tp 记录5的个数，fp记录2的个数  
 &nbsp; &nbsp;//两个是互补的  
 &nbsp; &nbsp;tp[0].push_back(0);  
 &nbsp; &nbsp;fp[0].push_back(0);  
​  
 &nbsp; &nbsp;for (int i = 0, t = 0, f = 0; i &lt; n; i++) {  
 &nbsp; &nbsp; &nbsp; &nbsp;int x;  
 &nbsp; &nbsp; &nbsp; &nbsp;std::cin &gt;&gt; x;  
 &nbsp; &nbsp; &nbsp; &nbsp;for (; x &amp;&amp; x % 2 == 0; x /= 2, t++) {  
 &nbsp; &nbsp; &nbsp;  }  
 &nbsp; &nbsp; &nbsp; &nbsp;for (; x &amp;&amp; x % 5 == 0; x /= 5, f++) {  
 &nbsp; &nbsp; &nbsp;  }  
 &nbsp; &nbsp; &nbsp; &nbsp;ans += std::max(  
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//需要 2^k &nbsp; * 5^k 即可满足 10^k 所以是动态规划  
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//每次计算出当前数据含有的2 和  5 的数量 和仍然需要 k  - 当前数量 &nbsp; 这一行的去更新  
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//因为同一个状态有可能对应多个数据， 所以只要找到第一个满足能凑出另一个2或者5的即可   
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//map不能使用upper_bound 但是 内部的vector 是可以使用的  
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;std::upper_bound(tp[t - k].begin(), tp[t - k].end(), f - k) - tp[t - k].begin(),  
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;std::upper_bound(fp[f - k].begin(), fp[f - k].end(), t - k) - fp[f - k].begin()  
 &nbsp; &nbsp; &nbsp;  );  
 &nbsp; &nbsp; &nbsp; &nbsp;tp[t].push_back(f);  
 &nbsp; &nbsp; &nbsp; &nbsp;fp[f].push_back(t);  
 &nbsp;  }  
​  
 &nbsp; &nbsp;std::cout &lt;&lt; ans &lt;&lt; "\n";  
}  
​  
int main() {  
 &nbsp; &nbsp;std::ios::sync_with_stdio(false);  
 &nbsp; &nbsp;std::cin.tie(nullptr);  
​  
 &nbsp; &nbsp;int t;  
 &nbsp; &nbsp;std::cin &gt;&gt; t;  
​  
 &nbsp; &nbsp;while (t--) {  
 &nbsp; &nbsp; &nbsp; &nbsp;solve();  
 &nbsp;  }  
​  
 &nbsp; &nbsp;return 0;  
}  
​  
 &nbsp; &nbsp;int n, k;  
 &nbsp; &nbsp;std::cin &gt;&gt; n &gt;&gt; k;  
​  
 &nbsp; &nbsp;int64_t ans = 0;  
 &nbsp; &nbsp;std::unordered_map&lt;int, std::vector&lt;int&gt;&gt; tp, fp;  
 &nbsp; &nbsp;//tp 记录5的个数，fp记录2的个数  
 &nbsp; &nbsp;//两个是互补的  
 &nbsp; &nbsp;tp[0].push_back(0);  
 &nbsp; &nbsp;fp[0].push_back(0);  
​  
 &nbsp; &nbsp;for (int i = 0, t = 0, f = 0; i &lt; n; i++) {  
 &nbsp; &nbsp; &nbsp; &nbsp;int x;  
 &nbsp; &nbsp; &nbsp; &nbsp;std::cin &gt;&gt; x;  
 &nbsp; &nbsp; &nbsp; &nbsp;for (; x &amp;&amp; x % 2 == 0; x /= 2, t++) {  
 &nbsp; &nbsp; &nbsp;  }  
 &nbsp; &nbsp; &nbsp; &nbsp;for (; x &amp;&amp; x % 5 == 0; x /= 5, f++) {  
 &nbsp; &nbsp; &nbsp;  }  
 &nbsp; &nbsp; &nbsp; &nbsp;ans += std::max(  
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//需要 2^k &nbsp; * 5^k 即可满足 10^k 所以是动态规划  
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//每次计算出当前数据含有的2 和  5 的数量 和仍然需要 k  - 当前数量 &nbsp; 这一行的去更新  
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//因为同一个状态有可能对应多个数据， 所以只要找到第一个满足能凑出另一个2或者5的即可   
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;std::upper_bound(tp[t - k].begin(), tp[t - k].end(), f - k) - tp[t - k].begin(),  
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;std::upper_bound(fp[f - k].begin(), fp[f - k].end(), t - k) - fp[f - k].begin()  
 &nbsp; &nbsp; &nbsp;  );  
 &nbsp; &nbsp; &nbsp; &nbsp;tp[t].push_back(f);  
 &nbsp; &nbsp; &nbsp; &nbsp;fp[f].push_back(t);  
 &nbsp;  }  
​  
 &nbsp; &nbsp;std::cout &lt;&lt; ans &lt;&lt; "\n";  
}  
​  
int main() {  
 &nbsp; &nbsp;std::ios::sync_with_stdio(false);  
 &nbsp; &nbsp;std::cin.tie(nullptr);  
​  
 &nbsp; &nbsp;int t;  
 &nbsp; &nbsp;std::cin &gt;&gt; t;  
​  
 &nbsp; &nbsp;while (t--) {  
 &nbsp; &nbsp; &nbsp; &nbsp;solve();  
 &nbsp;  }  
​  
 &nbsp; &nbsp;return 0;  
}  
​
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="数论"><a href="#数论" class="headerlink" title="数论"></a>数论</h1><ol>
<li><p>质数</p>
<ul>
<li><p>试除法判定质数，只枚举 d*d&lt;=n 即可`</p>
  <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token operator">/</span>i<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  
<span class="token comment">//不要担心	数据超过int  </span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>试除法分解质因子，质因数 ,求约数</p>
<ul>
<li>从小到大枚举所有的约数,n中最多只存在一个大于风雨根号n的质因子</li>
</ul>
</li>
</ul>
</li>
</ol>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">            <span class="token keyword">void</span> <span class="token function">divide</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span>  
            <span class="token punctuation">{</span>  
                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> x <span class="token operator">/</span> i<span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span>  
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">%</span> i <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>  
                    <span class="token punctuation">{</span>  
                        <span class="token keyword">int</span> s <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  
                        <span class="token keyword">while</span> <span class="token punctuation">(</span>x <span class="token operator">%</span> i <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> x <span class="token operator">/=</span> i<span class="token punctuation">,</span> s <span class="token operator">++</span> <span class="token punctuation">;</span>  
                        cout <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> <span class="token char">' '</span> <span class="token operator">&lt;&lt;</span> s <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>  
                    <span class="token punctuation">}</span>  
                <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span> cout <span class="token operator">&lt;&lt;</span> x <span class="token operator">&lt;&lt;</span> <span class="token char">' '</span> <span class="token operator">&lt;&lt;</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>  
                cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>  
            <span class="token punctuation">}</span>
            
```            

# 埃氏筛法： 枚举所有数据，然后把每个数的倍数筛去，留下的就是质数 <span class="token operator">*</span><span class="token operator">*</span>思想比较好<span class="token operator">*</span><span class="token operator">*</span> 思想太好了
``` cpp
	   <span class="token keyword">void</span> <span class="token function">get_primes</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>  
        	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  
        		<span class="token keyword">if</span><span class="token punctuation">(</span>st<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>  
                <span class="token comment">//删除所有质数的倍数  </span>
        		primes<span class="token punctuation">[</span>cnt<span class="token operator">++</span><span class="token punctuation">]</span><span class="token operator">=</span>i<span class="token punctuation">;</span>  
        		<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span>i<span class="token operator">+</span>i<span class="token punctuation">;</span>j<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>j<span class="token operator">+=</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>  
        			st<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span><span class="token boolean">true</span><span class="token punctuation">;</span>  
        		<span class="token punctuation">}</span>  
        	<span class="token punctuation">}</span>	  
        <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="线性筛法：-如果质数，把这个数加入集合中-最常用"><a href="#线性筛法：-如果质数，把这个数加入集合中-最常用" class="headerlink" title="线性筛法： 如果质数，把这个数加入集合中 最常用"></a><strong>线性筛法： 如果质数，把这个数加入集合中</strong> 最常用</h3> <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> primes<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span> cnt<span class="token punctuation">;</span>     <span class="token comment">// primes[]存储所有素数  </span>
<span class="token keyword">bool</span> st<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>         <span class="token comment">// st[x]存储x是否被筛掉  </span>
  
<span class="token keyword">void</span> <span class="token function">get_primes</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span>  
<span class="token punctuation">{</span>  
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span>  
    <span class="token punctuation">{</span>  
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>st<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> primes<span class="token punctuation">[</span>cnt <span class="token operator">++</span> <span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>  
        <span class="token comment">//枚举已有的质数，删除它的倍数  </span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> primes<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> n <span class="token operator">/</span> i<span class="token punctuation">;</span> j <span class="token operator">++</span> <span class="token punctuation">)</span>  
        <span class="token punctuation">{</span>  
            st<span class="token punctuation">[</span>primes<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">*</span> i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>  
            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">%</span> primes<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>  
        <span class="token punctuation">}</span>  
    <span class="token punctuation">}</span>  
<span class="token punctuation">}</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol start="2">
<li><p>约数</p>
<ul>
<li><p>试除法求所有约数</p>
<ul>
<li>只枚举较小的约数，较大的约数可以直接算出</li>
</ul>
</li>
</ul>
</li>
</ol>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>  
	vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> ans<span class="token punctuation">;</span>  
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token operator">/</span>i<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  
		<span class="token keyword">if</span><span class="token punctuation">(</span>n<span class="token operator">%</span>i<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  
			<span class="token comment">//从小到大枚举所有约数，并把n/i 得到的约数加入即可  </span>
			ans<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>  
			<span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">!=</span>n<span class="token operator">/</span>i<span class="token punctuation">)</span> ans<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>n<span class="token operator">/</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>  
		<span class="token punctuation">}</span>  
	<span class="token punctuation">}</span>  
	<span class="token function">sort</span><span class="token punctuation">(</span>ans<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>ans<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
	<span class="token keyword">return</span> ans<span class="token punctuation">;</span>  
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>约数个数,约数之和<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">        如果 N <span class="token operator">=</span> p1<span class="token operator">^</span>c1 <span class="token operator">*</span> p2<span class="token operator">^</span>c2 <span class="token operator">*</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token operator">*</span>pk<span class="token operator">^</span>ck  
        约数个数： <span class="token punctuation">(</span>c1 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>c2 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token operator">*</span> <span class="token punctuation">(</span>ck <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>  
        约数之和： <span class="token punctuation">(</span>p1<span class="token operator">^</span><span class="token number">0</span> <span class="token operator">+</span> p1<span class="token operator">^</span><span class="token number">1</span> <span class="token operator">+</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token operator">+</span> p1<span class="token operator">^</span>c1<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token operator">*</span> <span class="token punctuation">(</span>pk<span class="token operator">^</span><span class="token number">0</span> <span class="token operator">+</span> pk<span class="token operator">^</span><span class="token number">1</span> <span class="token operator">+</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token operator">+</span> pk<span class="token operator">^</span>ck
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;bits/stdc++.h&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
<span class="token keyword">typedef</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">long</span> ULL<span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> mod  <span class="token operator">=</span> <span class="token number">1e9</span> <span class="token operator">+</span> <span class="token number">7</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> n <span class="token punctuation">;</span>
    cin <span class="token operator">&gt;&gt;</span> n<span class="token punctuation">;</span>
    unordered_map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span><span class="token keyword">int</span><span class="token operator">&gt;</span> primes<span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>n<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> x<span class="token punctuation">;</span>
        <span class="token function">scanf</span> <span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> x <span class="token operator">/</span> i <span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">while</span><span class="token punctuation">(</span>x <span class="token operator">%</span> i <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                primes<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">++</span><span class="token punctuation">;</span>
                x <span class="token operator">/=</span> i<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span>  primes<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    ULL cnts <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span>res <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> <span class="token punctuation">[</span>prime<span class="token punctuation">,</span>cnt<span class="token punctuation">]</span><span class="token operator">:</span>primes<span class="token punctuation">)</span>  <span class="token punctuation">{</span>
        cnts <span class="token operator">=</span> <span class="token punctuation">(</span>cnts <span class="token operator">*</span> <span class="token punctuation">(</span>cnt <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">%</span> mod<span class="token punctuation">;</span>
        <span class="token comment">//求和</span>
        ULL t <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>cnt<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token comment">//秦九zhao算法</span>
            t <span class="token operator">=</span> <span class="token punctuation">(</span>t <span class="token operator">*</span>prime <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span>mod<span class="token punctuation">;</span>
        <span class="token punctuation">}</span> 
        res <span class="token operator">=</span> res <span class="token operator">*</span> t <span class="token operator">%</span> mod<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    cout <span class="token operator">&lt;&lt;</span> cnts <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> res<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
<ol start="3">
<li><p>欧几里得算法，辗转相除法，求最大公约数</p>
<ul>
<li>GCD(a,b) = =GCD(a.amodb)<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">        <span class="token keyword">int</span> <span class="token function">gcd</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span>  
        <span class="token punctuation">{</span>  
            <span class="token keyword">return</span> b <span class="token operator">?</span> <span class="token function">gcd</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> a <span class="token operator">%</span> b<span class="token punctuation">)</span> <span class="token operator">:</span> a<span class="token punctuation">;</span>  
        <span class="token punctuation">}</span>
        
```     
    <span class="token operator">-</span> LCM 最小公倍数 将两个数相乘再除以最大公因数即可得到最小公倍数
    ```cpp
        <span class="token keyword">int</span> <span class="token function">lcm</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span><span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">{</span>  
        	<span class="token keyword">return</span> a<span class="token operator">*</span>b<span class="token operator">/</span><span class="token function">gcd</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>  
        <span class="token punctuation">}</span>
        <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li>求ax+by=gcd(a,b)<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">        <span class="token keyword">int</span> <span class="token function">xGCD</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>x<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>y<span class="token punctuation">)</span> <span class="token punctuation">{</span>  
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>b<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//b = 0 时  </span>
                x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> y <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  
                <span class="token keyword">return</span> a<span class="token punctuation">;</span>  
            <span class="token punctuation">}</span>  
            <span class="token keyword">int</span> x1<span class="token punctuation">,</span> y10<span class="token punctuation">,</span> gcd <span class="token operator">=</span> <span class="token function">xGCD</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> a <span class="token operator">%</span> b<span class="token punctuation">,</span> x1<span class="token punctuation">,</span> y1<span class="token punctuation">)</span><span class="token punctuation">;</span>  
            x <span class="token operator">=</span> y1<span class="token punctuation">,</span> y <span class="token operator">=</span> x1 <span class="token operator">-</span> <span class="token punctuation">(</span>a <span class="token operator">/</span> b<span class="token punctuation">)</span> <span class="token operator">*</span> y1<span class="token punctuation">;</span>  
            <span class="token keyword">return</span> gcd<span class="token punctuation">;</span>  
        <span class="token punctuation">}</span>
        
```     
### 欧拉函数：小于x的整数中与x互质的数的个数<span class="token punctuation">]</span>
        
求出单个数的欧拉函数  
<span class="token function">f</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token operator">=</span> `n <span class="token operator">*</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">/</span> p1<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">/</span> p2a<span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>`
```cpp
        <span class="token keyword">int</span> <span class="token function">phi</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">{</span>  
        	<span class="token keyword">int</span> res<span class="token operator">=</span>x<span class="token punctuation">;</span>  
        	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>x<span class="token operator">/</span>i<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  
        		<span class="token keyword">if</span><span class="token punctuation">(</span>x<span class="token operator">%</span>i<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  
        			res<span class="token operator">=</span>res<span class="token operator">/</span>i<span class="token operator">*</span><span class="token punctuation">(</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
        			<span class="token keyword">while</span><span class="token punctuation">(</span>x<span class="token operator">%</span>i<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> x<span class="token operator">/=</span>i<span class="token punctuation">;</span>  
        		<span class="token punctuation">}</span>  
        	<span class="token punctuation">}</span>  
        	<span class="token keyword">if</span><span class="token punctuation">(</span>x<span class="token operator">&gt;</span><span class="token number">1</span><span class="token punctuation">)</span> res<span class="token operator">=</span>res<span class="token operator">/</span>x<span class="token operator">*</span><span class="token punctuation">(</span>x<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
        	<span class="token keyword">return</span> res<span class="token punctuation">;</span>  
        <span class="token punctuation">}</span>
        <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
</li>
</ol>
<p>筛法：求出1-n每个数的欧拉函数，在线性筛法的模板中加上三行</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> primes<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span> cnt<span class="token punctuation">;</span>     <span class="token comment">// primes[]存储所有素数  </span>
<span class="token keyword">int</span> euler<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>           <span class="token comment">// 存储每个数的欧拉函数  </span>
<span class="token keyword">bool</span> st<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>         <span class="token comment">// st[x]存储x是否被筛掉  </span>
  
  
<span class="token keyword">void</span> <span class="token function">get_eulers</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span>  
<span class="token punctuation">{</span>  
    euler<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span>  
    <span class="token punctuation">{</span>  
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>st<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>  
        <span class="token punctuation">{</span>  
            primes<span class="token punctuation">[</span>cnt <span class="token operator">++</span> <span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>  
            euler<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>  
        <span class="token punctuation">}</span>  
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> primes<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> n <span class="token operator">/</span> i<span class="token punctuation">;</span> j <span class="token operator">++</span> <span class="token punctuation">)</span>  
        <span class="token punctuation">{</span>  
            <span class="token keyword">int</span> t <span class="token operator">=</span> primes<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">*</span> i<span class="token punctuation">;</span>  
            st<span class="token punctuation">[</span>t<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>  
            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">%</span> primes<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>  
            <span class="token punctuation">{</span>  
                euler<span class="token punctuation">[</span>t<span class="token punctuation">]</span> <span class="token operator">=</span> euler<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">*</span> primes<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>  
                <span class="token keyword">break</span><span class="token punctuation">;</span>  
            <span class="token punctuation">}</span>  
            euler<span class="token punctuation">[</span>t<span class="token punctuation">]</span> <span class="token operator">=</span> euler<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token punctuation">(</span>primes<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
        <span class="token punctuation">}</span>  
    <span class="token punctuation">}</span>  
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="欧拉定理"><a href="#欧拉定理" class="headerlink" title="欧拉定理"></a>欧拉定理</h3><p>a ^f(n) % n = 1<br>a和n互质</p>
<h3 id="快速幂："><a href="#快速幂：" class="headerlink" title="快速幂："></a>快速幂：</h3>  <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">        把指数转为<span class="token number">2</span>进制就可以看出来有哪些含有了
        
        预处理时每一个结果都是前一个的平方再mod
        
        求 m<span class="token operator">^</span>k mod p，时间复杂度 <span class="token function">O</span><span class="token punctuation">(</span>logk<span class="token punctuation">)</span>。  
        ​  
        <span class="token keyword">int</span> <span class="token function">qmi</span><span class="token punctuation">(</span><span class="token keyword">int</span> m<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">,</span> <span class="token keyword">int</span> p<span class="token punctuation">)</span>  
        <span class="token punctuation">{</span>  
            <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">%</span> p<span class="token punctuation">,</span> t <span class="token operator">=</span> m<span class="token punctuation">;</span>  
            <span class="token keyword">while</span> <span class="token punctuation">(</span>k<span class="token punctuation">)</span>  
            <span class="token punctuation">{</span>  
                <span class="token keyword">if</span> <span class="token punctuation">(</span>k<span class="token operator">&amp;</span><span class="token number">1</span><span class="token punctuation">)</span> res <span class="token operator">=</span> res <span class="token operator">*</span> t <span class="token operator">%</span> p<span class="token punctuation">;</span>  
                t <span class="token operator">=</span> t <span class="token operator">*</span> t <span class="token operator">%</span> p<span class="token punctuation">;</span>  
                k <span class="token operator">&gt;&gt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>  
            <span class="token punctuation">}</span>  
            <span class="token keyword">return</span> res<span class="token punctuation">;</span>  
        <span class="token punctuation">}</span>
        
    
```      
### 快速幂求逆元
```cpp
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;bits/stdc++.h&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
<span class="token keyword">typedef</span> <span class="token keyword">long</span> <span class="token keyword">long</span> LL<span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">quick_mi</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span><span class="token keyword">int</span> b<span class="token punctuation">,</span><span class="token keyword">int</span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">%</span> p<span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>b<span class="token operator">&amp;</span><span class="token number">1</span><span class="token punctuation">)</span> res <span class="token operator">=</span> <span class="token punctuation">(</span>LL<span class="token punctuation">)</span> res<span class="token operator">*</span>a <span class="token operator">%</span>p<span class="token punctuation">;</span>
        b <span class="token operator">&gt;&gt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        a <span class="token operator">=</span> <span class="token punctuation">(</span>LL<span class="token punctuation">)</span> a <span class="token operator">*</span> a <span class="token operator">%</span> p<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> res<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> n<span class="token punctuation">;</span>
    <span class="token function">scanf</span> <span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>n<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> a<span class="token punctuation">,</span>p<span class="token punctuation">;</span>
        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d%d"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>a<span class="token punctuation">,</span><span class="token operator">&amp;</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>a <span class="token operator">%</span> p<span class="token punctuation">)</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span><span class="token function">quick_mi</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>p<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">,</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span> <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"impossible"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="扩展欧几里得算法-不会"><a href="#扩展欧几里得算法-不会" class="headerlink" title="扩展欧几里得算法(不会)"></a>扩展欧几里得算法(不会)</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">    <span class="token comment">// 求x, y，使得ax + by = gcd(a, b)  </span>
    <span class="token keyword">int</span> <span class="token function">exgcd</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>x<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>y<span class="token punctuation">)</span>  
    <span class="token punctuation">{</span>  
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>b<span class="token punctuation">)</span>  
        <span class="token punctuation">{</span>  
            x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> y <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  
            <span class="token keyword">return</span> a<span class="token punctuation">;</span>  
        <span class="token punctuation">}</span>  
        <span class="token keyword">int</span> d <span class="token operator">=</span> <span class="token function">exgcd</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> a <span class="token operator">%</span> b<span class="token punctuation">,</span> y<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>  
        y <span class="token operator">-=</span> <span class="token punctuation">(</span>a<span class="token operator">/</span>b<span class="token punctuation">)</span> <span class="token operator">*</span> x<span class="token punctuation">;</span>  
        <span class="token keyword">return</span> d<span class="token punctuation">;</span>  
    <span class="token punctuation">}</span>
```  
#### 高斯消元求解方程组的解
 ```cpp
	 <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;bits/stdc++.h&gt;</span>  </span>
    <span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>  
    <span class="token keyword">const</span> <span class="token keyword">int</span> N<span class="token operator">=</span><span class="token number">100</span><span class="token punctuation">;</span>  
    <span class="token keyword">int</span> n<span class="token punctuation">;</span>  
    <span class="token keyword">const</span> <span class="token keyword">double</span> eps<span class="token operator">=</span><span class="token number">1e-6</span><span class="token punctuation">;</span>  
    <span class="token keyword">double</span> a<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>  
    <span class="token comment">// a[N][N]是增广矩阵  </span>
    <span class="token comment">// a[N][N]是增广矩阵  </span>
    <span class="token keyword">int</span> <span class="token function">gauss</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  
    <span class="token punctuation">{</span>  
        <span class="token keyword">int</span> c<span class="token punctuation">,</span> r<span class="token punctuation">;</span>  
        <span class="token keyword">for</span> <span class="token punctuation">(</span>c <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> r <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> c <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> c <span class="token operator">++</span> <span class="token punctuation">)</span>  
        <span class="token punctuation">{</span>  
            <span class="token keyword">int</span> t <span class="token operator">=</span> r<span class="token punctuation">;</span>  
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> r<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span>   <span class="token comment">// 找到绝对值最大的行  </span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">fabs</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token function">fabs</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  
                    t <span class="token operator">=</span> i<span class="token punctuation">;</span>  
    ​  
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">fabs</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> eps<span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>  
    ​  
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> c<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token function">swap</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// 将绝对值最大的行换到最顶端  </span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n<span class="token punctuation">;</span> i <span class="token operator">&gt;=</span> c<span class="token punctuation">;</span> i <span class="token operator">--</span> <span class="token punctuation">)</span> a<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">/=</span> a<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">;</span>      <span class="token comment">// 将当前行的首位变成1  </span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> r <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span>       <span class="token comment">// 用当前行将下面所有的列消成0  </span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">fabs</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> eps<span class="token punctuation">)</span>  
                    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> n<span class="token punctuation">;</span> j <span class="token operator">&gt;=</span> c<span class="token punctuation">;</span> j <span class="token operator">--</span> <span class="token punctuation">)</span>  
                        a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">-=</span> a<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">*</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">;</span>  
    ​  
            r <span class="token operator">++</span> <span class="token punctuation">;</span>  
        <span class="token punctuation">}</span>  
    ​  
        <span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token operator">&lt;</span> n<span class="token punctuation">)</span>  
        <span class="token punctuation">{</span>  
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> r<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span>  
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">fabs</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> eps<span class="token punctuation">)</span>  
                    <span class="token keyword">return</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">// 无解  </span>
            <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 有无穷多组解  </span>
        <span class="token punctuation">}</span>  
    ​  
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">--</span> <span class="token punctuation">)</span>  
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j <span class="token operator">++</span> <span class="token punctuation">)</span>  
                a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">-=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">*</span> a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>  
    ​  
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 有唯一解  </span>
    <span class="token punctuation">}</span>  
    <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  
        cin<span class="token operator">&gt;&gt;</span>n<span class="token punctuation">;</span>  
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>  
            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  
                cin<span class="token operator">&gt;&gt;</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>  
            <span class="token punctuation">}</span>  
    ​  
    <span class="token keyword">int</span> t<span class="token operator">=</span><span class="token function">gauss</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
        <span class="token keyword">if</span><span class="token punctuation">(</span>t<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  
            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  
                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%.2lf "</span><span class="token punctuation">,</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
            <span class="token punctuation">}</span>  
        <span class="token punctuation">}</span>  
        <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>t<span class="token operator">==</span><span class="token number">2</span><span class="token punctuation">)</span> cout<span class="token operator">&lt;&lt;</span><span class="token string">"无解"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>  
        <span class="token keyword">else</span> cout<span class="token operator">&lt;&lt;</span><span class="token string">"有无数组解"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>  
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  
    <span class="token punctuation">}</span>
    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="递推求组合数，dp法-适合询问次数-gt-10w"><a href="#递推求组合数，dp法-适合询问次数-gt-10w" class="headerlink" title="递推求组合数，dp法 适合询问次数>10w"></a>递推求组合数，dp法 适合询问次数&gt;10w</h3> <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// c[a][b] 表示从a个苹果中选b个的方案数  </span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span>  
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> i<span class="token punctuation">;</span> j <span class="token operator">++</span> <span class="token punctuation">)</span>  
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>j<span class="token punctuation">)</span> c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  
        <span class="token keyword">else</span> c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>c<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> c<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">%</span> mod<span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="通过预处理逆元的方式求组合数-询问1w"><a href="#通过预处理逆元的方式求组合数-询问1w" class="headerlink" title="通过预处理逆元的方式求组合数 询问1w"></a>通过预处理逆元的方式求组合数 询问1w</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">    首先预处理出所有阶乘取模的余数fact<span class="token punctuation">[</span>N<span class="token punctuation">]</span>，以及所有阶乘取模的逆元infact<span class="token punctuation">[</span>N<span class="token punctuation">]</span>  
    如果取模的数是质数，可以用费马小定理求逆元  
    <span class="token keyword">int</span> <span class="token function">qmi</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">,</span> <span class="token keyword">int</span> p<span class="token punctuation">)</span>    <span class="token comment">// 快速幂模板  </span>
    <span class="token punctuation">{</span>  
        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  
        <span class="token keyword">while</span> <span class="token punctuation">(</span>k<span class="token punctuation">)</span>  
        <span class="token punctuation">{</span>  
            <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">)</span> res <span class="token operator">=</span> <span class="token punctuation">(</span>LL<span class="token punctuation">)</span>res <span class="token operator">*</span> a <span class="token operator">%</span> p<span class="token punctuation">;</span>  
            a <span class="token operator">=</span> <span class="token punctuation">(</span>LL<span class="token punctuation">)</span>a <span class="token operator">*</span> a <span class="token operator">%</span> p<span class="token punctuation">;</span>  
            k <span class="token operator">&gt;&gt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>  
        <span class="token punctuation">}</span>  
        <span class="token keyword">return</span> res<span class="token punctuation">;</span>  
    <span class="token punctuation">}</span>  
    ​  
    <span class="token comment">// 预处理阶乘的余数和阶乘逆元的余数  </span>
    fact<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> infact<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span>  
    <span class="token punctuation">{</span>  
        fact<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>LL<span class="token punctuation">)</span>fact<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">*</span> i <span class="token operator">%</span> mod<span class="token punctuation">;</span>  
        infact<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>LL<span class="token punctuation">)</span>infact<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token function">qmi</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> mod <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">,</span> mod<span class="token punctuation">)</span> <span class="token operator">%</span> mod<span class="token punctuation">;</span>  
    <span class="token punctuation">}</span>  
    ​
```    
### Lucas定理求组合数 <span class="token number">20</span>次询问以下
    
<span class="token operator">!</span><span class="token punctuation">[</span>image<span class="token operator">-</span><span class="token number">20230519193526425</span><span class="token punctuation">]</span><span class="token punctuation">(</span>file<span class="token operator">:</span><span class="token comment">//D:/typora%E7%94%A8%E5%9B%BE/Screenshots/image-20230519193526425.png?lastModify=1694256669)    </span>
```cpp
      <span class="token comment">//若p是质数，则对于任意整数 1 &lt;= m &lt;= n，有：  </span>
      <span class="token comment">//  C(n, m) = C(n % p, m % p) * C(n / p, m / p) (mod p)  </span>
    ​  
    <span class="token keyword">int</span> <span class="token function">qmi</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">,</span> <span class="token keyword">int</span> p<span class="token punctuation">)</span>  <span class="token comment">// 快速幂模板  </span>
    <span class="token punctuation">{</span>  
        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">%</span> p<span class="token punctuation">;</span>  
        <span class="token keyword">while</span> <span class="token punctuation">(</span>k<span class="token punctuation">)</span>  
        <span class="token punctuation">{</span>  
            <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">)</span> res <span class="token operator">=</span> <span class="token punctuation">(</span>LL<span class="token punctuation">)</span>res <span class="token operator">*</span> a <span class="token operator">%</span> p<span class="token punctuation">;</span>  
            a <span class="token operator">=</span> <span class="token punctuation">(</span>LL<span class="token punctuation">)</span>a <span class="token operator">*</span> a <span class="token operator">%</span> p<span class="token punctuation">;</span>  
            k <span class="token operator">&gt;&gt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>  
        <span class="token punctuation">}</span>  
        <span class="token keyword">return</span> res<span class="token punctuation">;</span>  
    <span class="token punctuation">}</span>  
    ​  
    <span class="token keyword">int</span> <span class="token function">C</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">,</span> <span class="token keyword">int</span> p<span class="token punctuation">)</span>  <span class="token comment">// 通过定理求组合数C(a, b)  </span>
    <span class="token punctuation">{</span>  
        <span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">&lt;</span> b<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  
    ​  
        LL x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> y <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">// x是分子，y是分母  </span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> a<span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> b<span class="token punctuation">;</span> i <span class="token operator">--</span><span class="token punctuation">,</span> j <span class="token operator">++</span> <span class="token punctuation">)</span>  
        <span class="token punctuation">{</span>  
            x <span class="token operator">=</span> <span class="token punctuation">(</span>LL<span class="token punctuation">)</span>x <span class="token operator">*</span> i <span class="token operator">%</span> p<span class="token punctuation">;</span>  
            y <span class="token operator">=</span> <span class="token punctuation">(</span>LL<span class="token punctuation">)</span> y <span class="token operator">*</span> j <span class="token operator">%</span> p<span class="token punctuation">;</span>  
        <span class="token punctuation">}</span>  
    ​  
        <span class="token keyword">return</span> x <span class="token operator">*</span> <span class="token punctuation">(</span>LL<span class="token punctuation">)</span><span class="token function">qmi</span><span class="token punctuation">(</span>y<span class="token punctuation">,</span> p <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">,</span> p<span class="token punctuation">)</span> <span class="token operator">%</span> p<span class="token punctuation">;</span>  
    <span class="token punctuation">}</span>  
    ​  
    <span class="token keyword">int</span> <span class="token function">lucas</span><span class="token punctuation">(</span>LL a<span class="token punctuation">,</span> LL b<span class="token punctuation">,</span> <span class="token keyword">int</span> p<span class="token punctuation">)</span>  
    <span class="token punctuation">{</span>  
        <span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">&lt;</span> p <span class="token operator">&amp;&amp;</span> b <span class="token operator">&lt;</span> p<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token function">C</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>  
        <span class="token keyword">return</span> <span class="token punctuation">(</span>LL<span class="token punctuation">)</span><span class="token function">C</span><span class="token punctuation">(</span>a <span class="token operator">%</span> p<span class="token punctuation">,</span> b <span class="token operator">%</span> p<span class="token punctuation">,</span> p<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token function">lucas</span><span class="token punctuation">(</span>a <span class="token operator">/</span> p<span class="token punctuation">,</span> b <span class="token operator">/</span> p<span class="token punctuation">,</span> p<span class="token punctuation">)</span> <span class="token operator">%</span> p<span class="token punctuation">;</span>  
    <span class="token punctuation">}</span>
    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="file://D:/typora%E7%94%A8%E5%9B%BE/Screenshots/image-20230519193254443.png?lastModify=1694256669" alt="image-20230519193254443"></p>
<h3 id="逆元："><a href="#逆元：" class="headerlink" title="逆元："></a>逆元：</h3><p>可以在快速幂中求出</p>
<p>也就是a的p-2次方的</p>
<blockquote>
<p>在模为素数p的情况下，有费马小定理 a^(p-1)=1（mod p） 那么a^(p-2)=a^-1(mod p) 也就是说a的逆元为a^(p-2)</p>
</blockquote>
<h4 id="分解质因数法求组合数"><a href="#分解质因数法求组合数" class="headerlink" title="分解质因数法求组合数"></a>分解质因数法求组合数</h4><p> &nbsp; </p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">    当我们需要求出组合数的真实值，而非对某个数的余数时，分解质因数的方式比较好用：  
        <span class="token number">1.</span> 筛法求出范围内的所有质数  
        <span class="token number">2.</span> 通过 <span class="token function">C</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token operator">=</span> a<span class="token operator">!</span> <span class="token operator">/</span> b<span class="token operator">!</span> <span class="token operator">/</span> <span class="token punctuation">(</span>a <span class="token operator">-</span> b<span class="token punctuation">)</span><span class="token operator">!</span> 这个公式求出每个质因子的次数。 n<span class="token operator">!</span> 中p的次数是 n <span class="token operator">/</span> p <span class="token operator">+</span> n <span class="token operator">/</span> p<span class="token operator">^</span><span class="token number">2</span> <span class="token operator">+</span> n <span class="token operator">/</span> p<span class="token operator">^</span><span class="token number">3</span> <span class="token operator">+</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  
        <span class="token number">3.</span> 用高精度乘法将所有质因子相乘  
      
    <span class="token keyword">int</span> primes<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span> cnt<span class="token punctuation">;</span>     <span class="token comment">// 存储所有质数  </span>
    <span class="token keyword">int</span> sum<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>     <span class="token comment">// 存储每个质数的次数  </span>
    <span class="token keyword">bool</span> st<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>     <span class="token comment">// 存储每个数是否已被筛掉</span>

    <span class="token keyword">void</span> <span class="token function">get_primes</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span>      <span class="token comment">// 线性筛法求素数  </span>
•        <span class="token punctuation">{</span>  
•            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span>  
•            <span class="token punctuation">{</span>  
•                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>st<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> primes<span class="token punctuation">[</span>cnt <span class="token operator">++</span> <span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>  
•                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> primes<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> n <span class="token operator">/</span> i<span class="token punctuation">;</span> j <span class="token operator">++</span> <span class="token punctuation">)</span>  
•                <span class="token punctuation">{</span>  
•                    st<span class="token punctuation">[</span>primes<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">*</span> i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>  
•                    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">%</span> primes<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>  
•                <span class="token punctuation">}</span>  
•            <span class="token punctuation">}</span>  
•        <span class="token punctuation">}</span>  
​  
​  
•          
•        <span class="token keyword">int</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> p<span class="token punctuation">)</span>       <span class="token comment">// 求n！中的次数  </span>
•        <span class="token punctuation">{</span>  
•            <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  
•            <span class="token keyword">while</span> <span class="token punctuation">(</span>n<span class="token punctuation">)</span>  
•            <span class="token punctuation">{</span>  
•                res <span class="token operator">+=</span> n <span class="token operator">/</span> p<span class="token punctuation">;</span>  
•                n <span class="token operator">/=</span> p<span class="token punctuation">;</span>  
•            <span class="token punctuation">}</span>  
•            <span class="token keyword">return</span> res<span class="token punctuation">;</span>  
•        <span class="token punctuation">}</span>  
​  
​  
•          
•        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">mul</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span>       <span class="token comment">// 高精度乘低精度模板  </span>
•        <span class="token punctuation">{</span>  
•            vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> c<span class="token punctuation">;</span>  
•            <span class="token keyword">int</span> t <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  
•            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> a<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span>  
•            <span class="token punctuation">{</span>  
•                t <span class="token operator">+=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">*</span> b<span class="token punctuation">;</span>  
•                c<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>t <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
•                t <span class="token operator">/=</span> <span class="token number">10</span><span class="token punctuation">;</span>  
•            <span class="token punctuation">}</span>  
•          
•            <span class="token keyword">while</span> <span class="token punctuation">(</span>t<span class="token punctuation">)</span>  
•            <span class="token punctuation">{</span>  
•                c<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>t <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
•                t <span class="token operator">/=</span> <span class="token number">10</span><span class="token punctuation">;</span>  
•            <span class="token punctuation">}</span>  
•          
•            <span class="token keyword">return</span> c<span class="token punctuation">;</span>  
•        <span class="token punctuation">}</span>  
•        

    <span class="token function">get_primes</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 预处理范围内的所有质数  </span>
      
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> cnt<span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span>     <span class="token comment">// 求每个质因数的次数  </span>
    <span class="token punctuation">{</span>  
        <span class="token keyword">int</span> p <span class="token operator">=</span> primes<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>  
        sum<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">get</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> p<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token function">get</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> p<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token function">get</span><span class="token punctuation">(</span>a <span class="token operator">-</span> b<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token punctuation">}</span>  
      
    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> res<span class="token punctuation">;</span>  
    res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
      
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> cnt<span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span>     <span class="token comment">// 用高精度乘法将所有质因子相乘  </span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> sum<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> j <span class="token operator">++</span> <span class="token punctuation">)</span>  
            res <span class="token operator">=</span> <span class="token function">mul</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> primes<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p>
<h2 id="动态规划DP"><a href="#动态规划DP" class="headerlink" title="动态规划DP"></a>动态规划DP</h2><p>思路：</p>
<ol>
<li><p>状态表示：需要几维的动态规划</p>
<ul>
<li><p>集合 所有选法</p>
<ol>
<li><p>所有选法</p>
</li>
<li><p>条件</p>
<ul>
<li><p>只从前i个物品中选择</p>
</li>
<li><p>总体积&lt;=j</p>
</li>
</ul>
</li>
</ol>
</li>
<li><p>属性 最大值？最小值?……</p>
</li>
</ul>
</li>
<li><p>状态计算：怎么得到结果</p>
</li>
</ol>
<h3 id="01背包-每个物品只能用一次"><a href="#01背包-每个物品只能用一次" class="headerlink" title="01背包 每个物品只能用一次"></a>01背包 每个物品只能用一次</h3><p>一维优化;</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">///f[N][N] 表示前i个物品，j的容量下的最大值  </span>
进行压缩，因为每次更新i是时只用到了i<span class="token operator">-</span><span class="token number">1</span> 这个位置的数据，所以可以使用滚动数组，实现每次i<span class="token operator">-</span><span class="token number">1</span>到i的更新<span class="token punctuation">;</span>  
所以编成  f<span class="token punctuation">[</span>N<span class="token punctuation">]</span> 表示j的背包容量下的最大值<span class="token punctuation">;</span>  
j<span class="token operator">=</span><span class="token number">0</span>的结果都为<span class="token number">0</span> 所以可以跳过<span class="token punctuation">;</span>i<span class="token operator">=</span><span class="token number">0</span>的结果也都为<span class="token number">0</span><span class="token punctuation">,</span>同时，如果当前的背包容量不足以把当前物品装入也不需要进行更新了，所以小于当前背包容量的就不要考虑了<span class="token punctuation">;</span>  
不能更新也就是f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>f<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> 所以可以直接去掉，变为  f<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>f<span class="token punctuation">[</span>j<span class="token punctuation">]</span>  
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//遍览物品  </span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span>m<span class="token punctuation">;</span>j<span class="token operator">&gt;=</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>j<span class="token operator">--</span><span class="token punctuation">)</span><span class="token comment">//m为最大背包容量  </span>
        f<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span><span class="token function">max</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>f<span class="token punctuation">[</span>j<span class="token operator">-</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">+</span>w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="多状态dp"><a href="#多状态dp" class="headerlink" title="多状态dp"></a>多状态dp</h2><p>示例：<br><a target="_blank" rel="noopener" href="https://www.lanqiao.cn/problems/2223/learning/?subject_code=2&amp;group_code=4&amp;match_num=13&amp;match_flow=2&amp;origin=cup">魔法背包</a><br><a target="_blank" rel="noopener" href="https://www.lanqiao.cn/problems/2224/learning/?subject_code=2&amp;group_code=4&amp;match_num=13&amp;match_flow=2&amp;origin=cup">修路</a><br><a target="_blank" rel="noopener" href="https://www.lanqiao.cn/problems/3542/learning/?subject_code=2&amp;group_code=4&amp;match_num=14&amp;match_flow=1&amp;origin=cup">魔法阵</a><br>存在多个状态，其中每一个状态内的转移是正常转移的，而状态之间是需要满足条件进行转移的。</p>
<h3 id="完全背包-每件物品有无限个"><a href="#完全背包-每件物品有无限个" class="headerlink" title="完全背包 每件物品有无限个"></a>完全背包 每件物品有无限个</h3><p>01背包：从f[i-1]转过来 f[i,h]=max(f[i-1,j],f[i-1,j-v]+w[i]) //优化后:f[j]=max(f[j],f[v-v[i]]+w[i])</p>
<p>完全背包：从f[i]转移 f[i,j]=max(f[i-1,j],f[i,j-v[i]]+w[i])</p>
<p>每次更新：k是每个物品可以有多少个，i是前i个物品，j是当前背包容量</p>
<p>f[i][j]=max(f[i][j],f[i-j][j-v[i]*k]+w[i]*k</p>
<p>优化思路：</p>
<p><img src="file://D:/typora%E7%94%A8%E5%9B%BE/Screenshots/image-20230521084412853.png?lastModify=1694256669" alt="image-20230521084412853"></p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">​  
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span> <span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> m <span class="token punctuation">;</span> j <span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// for (int k = 0 ; k * v[i] &lt;= j ; k ++) {</span>
            <span class="token comment">//     f[i][j] = max(f[i][j],f[i - 1][j - k *v[i]] + k * w[i]);</span>
            <span class="token comment">// }</span>
            <span class="token comment">//f[i][j] = max(f[i-1][j],f[i-1][j-v]+w,f[i-1][j-2v] + 2w , ......)</span>
            <span class="token comment">//f[i][j-v] = max(        ,f[i-1][j-v],f[i-1][j-2v]+2w,....)</span>
            <span class="token comment">//错位相减</span>
            <span class="token comment">// f[i][j] - f[i][j-v] = w</span>
            <span class="token comment">// f[i][j] = f[i][j-v] + w</span>
            <span class="token comment">//所以 </span>
            <span class="token comment">//f[i][j] = max(f[i-1][j],f[i][j-v] + w)</span>
            <span class="token comment">//根据递推，每一个max后面那个数都等于上一个的f[i][j-v] + w</span>
            <span class="token comment">//前提是要大于v[i]等式才成立</span>
            f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> f<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//前一个转移</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">&gt;=</span> v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">+</span>w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

一维优化：删去一维

<span class="token comment">//f[i][j]=f[i-1][j];  f[i]==f[i-1] 直接删去  </span>
​  
<span class="token comment">//if(j&gt;=v[i]){ 只有当前背包容量大于当前的物品时才能装入，采用从v[i]遍历背包容量  </span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>  
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>j<span class="token operator">&lt;=</span>m<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>  
    <span class="token comment">//f[i,j]=max(f[i-1,j],f[i,j-v[i]]+w[i])  </span>
        f<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span><span class="token function">max</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>f<span class="token punctuation">[</span>j<span class="token operator">-</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">+</span>w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
<span class="token comment">//}  </span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>01和完全背包区别：</p>
<p>背包容量的遍历不同</p>
<p>01:</p>
<p> for(int j=m;j&gt;=v[i];j–)//m为最大背包容量<br>        f[j]=max(f[j],f[j-v[i]+w[i]]);</p>
<p>完全：</p>
<p>for(int j=v[i],j&lt;=m;j++)<br>        f[j]=max(f[j],f[j-v[i]]+w[i]);</p>
<h3 id="多重背包问题-优化"><a href="#多重背包问题-优化" class="headerlink" title="多重背包问题 优化"></a>多重背包问题 优化</h3><p>每个物品有个数限制，但不是无限</p>
<ol>
<li><p>状态表示：f[ i ] [ j ]</p>
<ul>
<li><p>集合</p>
</li>
<li><p>属性</p>
</li>
</ul>
</li>
<li><p>状态计算：</p>
<p> f[i][j]=max(f[i-1][j-v[i]*k]+w[i]*k)  k有范围</p>
<p> 优化：将数量打包，比如打包成1个物品一起，2个物品一起……</p>
<p> 之后用01背包做即可</p>
</li>
</ol>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;bits/stdc++.h&gt;</span>  </span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>  
<span class="token keyword">const</span> <span class="token keyword">int</span> N <span class="token operator">=</span> <span class="token number">1001</span><span class="token punctuation">;</span>  
<span class="token keyword">int</span> f<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span>v<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span>w<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>  
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  
    <span class="token keyword">int</span> n<span class="token punctuation">,</span>m<span class="token punctuation">,</span>cnt<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>  
    cin<span class="token operator">&gt;&gt;</span>n<span class="token operator">&gt;&gt;</span>m<span class="token punctuation">;</span>  
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  
        <span class="token keyword">int</span> a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>s<span class="token punctuation">;</span><span class="token comment">//容量，价值  </span>
        cin<span class="token operator">&gt;&gt;</span>a<span class="token operator">&gt;&gt;</span>b<span class="token operator">&gt;&gt;</span>s<span class="token punctuation">;</span>  
        <span class="token keyword">int</span> k<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//用来打包  </span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>k<span class="token operator">&lt;=</span>s<span class="token punctuation">)</span><span class="token punctuation">{</span>  
            cnt<span class="token operator">++</span><span class="token punctuation">;</span>  
            v<span class="token punctuation">[</span>cnt<span class="token punctuation">]</span><span class="token operator">=</span>a<span class="token operator">*</span>k<span class="token punctuation">;</span>  
            w<span class="token punctuation">[</span>cnt<span class="token punctuation">]</span><span class="token operator">=</span>b<span class="token operator">*</span>k<span class="token punctuation">;</span>  
            s<span class="token operator">-=</span>k<span class="token punctuation">;</span>  
            k<span class="token operator">*=</span><span class="token number">2</span><span class="token punctuation">;</span>  
        <span class="token punctuation">}</span>  
        <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token operator">&gt;</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  
            cnt<span class="token operator">++</span><span class="token punctuation">;</span>  
            v<span class="token punctuation">[</span>cnt<span class="token punctuation">]</span><span class="token operator">=</span>a<span class="token operator">*</span>s<span class="token punctuation">;</span>  
            w<span class="token punctuation">[</span>cnt<span class="token punctuation">]</span><span class="token operator">=</span>b<span class="token operator">*</span>s<span class="token punctuation">;</span>  
        <span class="token punctuation">}</span>  
    <span class="token punctuation">}</span>  
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>cnt<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span>m<span class="token punctuation">;</span>j<span class="token operator">&gt;=</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>j<span class="token operator">--</span><span class="token punctuation">)</span>  
        f<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span><span class="token function">max</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>f<span class="token punctuation">[</span>j<span class="token operator">-</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">+</span>w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token punctuation">}</span>  
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="分组背包问题"><a href="#分组背包问题" class="headerlink" title="分组背包问题"></a>分组背包问题</h3><h2 id="线性DP"><a href="#线性DP" class="headerlink" title="线性DP"></a>线性DP</h2><p>递归方程有线性关系，具有求的先后顺序</p>
<p>具体有各种子序列</p>
<p>建议看leetcode101 里面的比较好</p>
<h1 id="数位统计DP"><a href="#数位统计DP" class="headerlink" title="数位统计DP"></a>数位统计DP</h1><p>给出两个数字 a, b</p>
<p>统计a到b 中每一位 的0~9的出现次数</p>
<p>思路：分情况讨论 + 前缀和思想</p>
<p><img src="file://D:/typora%E7%94%A8%E5%9B%BE/Screenshots/image-20230524164849922.png?lastModify=1694256669" alt="image-20230524164849922"></p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">include <span class="token operator">&lt;</span>iostream<span class="token operator">&gt;</span>  
<span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">include</span> <span class="token string">&lt;cmath&gt;</span>  </span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>  
  
<span class="token keyword">int</span> <span class="token function">dgt</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token comment">// 计算整数n有多少位  </span>
<span class="token punctuation">{</span>  
    <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  
    <span class="token keyword">while</span> <span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token operator">++</span> res<span class="token punctuation">,</span> n <span class="token operator">/=</span> <span class="token number">10</span><span class="token punctuation">;</span>  
    <span class="token keyword">return</span> res<span class="token punctuation">;</span>  
<span class="token punctuation">}</span>  
  
<span class="token keyword">int</span> <span class="token function">cnt</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token comment">// 计算从1到n的整数中数字i出现多少次   </span>
<span class="token punctuation">{</span>  
    <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> d <span class="token operator">=</span> <span class="token function">dgt</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> d<span class="token punctuation">;</span> j <span class="token operator">++</span><span class="token punctuation">)</span> <span class="token comment">// 从右到左第j位上数字i出现多少次，所有位上的次数加起来就是i出现的总次数  </span>
    <span class="token punctuation">{</span>  
        <span class="token comment">// l和r是第j位左边和右边的整数 (视频中的abc和efg); dj是第j位的数字  </span>
        <span class="token keyword">int</span> p <span class="token operator">=</span> <span class="token function">pow</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> l <span class="token operator">=</span> n <span class="token operator">/</span> p <span class="token operator">/</span> <span class="token number">10</span><span class="token punctuation">,</span> r <span class="token operator">=</span> n <span class="token operator">%</span> p<span class="token punctuation">,</span> dj <span class="token operator">=</span> n <span class="token operator">/</span> p <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">;</span>  
        <span class="token comment">// 计算第j位左边的整数小于l (视频中xxx = 000 ~ abc - 1)的情况  </span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>i<span class="token punctuation">)</span> res <span class="token operator">+=</span> l <span class="token operator">*</span> p<span class="token punctuation">;</span>   
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>i <span class="token operator">&amp;&amp;</span> l<span class="token punctuation">)</span> res <span class="token operator">+=</span> <span class="token punctuation">(</span>l <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> p<span class="token punctuation">;</span> <span class="token comment">// 如果i = 0, 左边高位不能全为0(视频中xxx = 001 ~ abc - 1)，并且&amp;&amp;l表示这时i也不能在最高位出现。  </span>
        <span class="token comment">// 计算第j位左边的整数等于l (视频中xxx = abc)的情况  </span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token punctuation">(</span>dj <span class="token operator">&gt;</span> i<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>i <span class="token operator">||</span> l<span class="token punctuation">)</span> <span class="token punctuation">)</span> res <span class="token operator">+=</span> p<span class="token punctuation">;</span>  <span class="token comment">//(i || l)表示i=0时，i不能出现在最高位（即l不能为0），因为这种数是不存在的  </span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token punctuation">(</span>dj <span class="token operator">==</span> i<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>i <span class="token operator">||</span> l<span class="token punctuation">)</span> <span class="token punctuation">)</span> res <span class="token operator">+=</span> r <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">//(i || l)表示i=0时，i不能出现在最高位（即l不能为0），因为这种数是不存在的  </span>
    <span class="token punctuation">}</span>  
    <span class="token keyword">return</span> res<span class="token punctuation">;</span>  
<span class="token punctuation">}</span>  
  
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  
<span class="token punctuation">{</span>  
    <span class="token keyword">int</span> a<span class="token punctuation">,</span> b<span class="token punctuation">;</span>  
    <span class="token keyword">while</span> <span class="token punctuation">(</span>cin <span class="token operator">&gt;&gt;</span> a <span class="token operator">&gt;&gt;</span> b <span class="token punctuation">,</span> a<span class="token punctuation">)</span>  
    <span class="token punctuation">{</span>  
        <span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">&gt;</span> b<span class="token punctuation">)</span> <span class="token function">swap</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>  
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">9</span><span class="token punctuation">;</span> <span class="token operator">++</span> i<span class="token punctuation">)</span> cout <span class="token operator">&lt;&lt;</span> <span class="token function">cnt</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> i<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token function">cnt</span><span class="token punctuation">(</span>a <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token char">' '</span><span class="token punctuation">;</span>  
        cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>  
    <span class="token punctuation">}</span>  
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="数位DP-重要"><a href="#数位DP-重要" class="headerlink" title="数位DP(重要)"></a>数位DP(重要)</h1><p>DP时间复杂度：状态个数*转移个数</p>
<p>相当于往空里填数字</p>
<p><strong>知识点1：</strong>mask集合</p>
<blockquote>
<p>集合和数字的替换，使用二进制转化集合来实现某些数字不选择</p>
<p>例： 10011 从高到低依次代表者 4 3 2 1 0 这几个数字选不选，1表示选择，那么，</p>
<p>集合mask &gt;&gt; d &amp; 1 d为这个数字，进行这样的运算就可以判断mask 对应的d数字这个位置上是1还是0</p>
<p>同理 mask|(1&lt;&lt;d) 将1移位到mask上 代表d这个数字的位置，进行或运算，即可将d加入集合中</p>
</blockquote>
<h2 id="模板：-1"><a href="#模板：-1" class="headerlink" title="模板："></a>模板：</h2><p>将问题转化为填数字受限问题：</p>
<blockquote>
<p>递归中的变量：</p>
<p>i 当前下标 当 i == 最大长度时，根据是否满足条件返回 0 或 1</p>
<p>mask 集合 代表着一种状态的记录，比如某位填了哪些数字，或者截止到上一位已经积累的某个要求满足条件的数据是多少，这个一般是变化的</p>
<p>is_limit 前一个位置是否收到原来的数字的限制：123 第一个填1 了后面一定受限，同时如果前面受限了，那么后面所有的都受限</p>
<p>is_num 前一个位置是否填数字，如果前一个没填数字，那么这一位无法填0了，如果填了可以填任意数字，当0对题目没影响时，可以不用这个东西</p>
</blockquote>
<p><strong>模板公式：</strong></p>
<ol>
<li><p>求出最大长度和memo，记忆数组，并初始化为-1 memo数组的一维是长度，二维是能包含所有枚举的最大长度，具体问题具体分析</p>
</li>
<li><p>递归函数</p>
<ul>
<li><p>结束递归条件<code>i == m 返回是否满足 满足为1 满足为0</code></p>
</li>
<li><p>记忆化剪枝：当is_limit 和 is_num 只有一个为真时，后面的数字也是可以任意填的，所以可以剪枝</p>
</li>
<li><p><code>!is_limit &amp;&amp; is_num &amp;&amp; memo[i][mask] != -1 return memo[i][mask]</code></p>
</li>
<li><p>设出res = 0 即为我们要求的答案</p>
</li>
<li><p>(可能不存在这种情况)这一位不填数字：<code>res = (i+1 , mask不改变, false , false)</code></p>
</li>
<li><p>求出这一位数字可以填写的上下界：根据is_limit来求 <code>up = is_limit ? s[i] - '0' : 9</code></p>
</li>
<li><p>枚举这一位数字，进行递归 (条件判断不一定需要)</p>
</li>
<li><p><code>for (int d = 初始 ; d &lt;= up ; d++) if(当前这个数字没使用) 把这个数字加入mask</code></p>
</li>
<li><p>循环内：<code>res = (i+1 , mask 的改变 , is_limit &amp;&amp; d == up , is_num的变化)</code></p>
</li>
<li><p>当is_limit 和 is_num 只有一个为真时将答案加入memo中 <code>if(!is_limit &amp;&amp; is_num) memo[i][mask] = res</code></p>
</li>
<li><p>返回res</p>
</li>
</ul>
</li>
</ol>
<p><strong>例题：</strong></p>
<ol>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/numbers-with-repeated-digits/description/">1012. 至少有 1 位重复的数字 - 力扣（Leetcode）</a></li>
</ol>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>  
<span class="token keyword">public</span><span class="token operator">:</span>  
    <span class="token keyword">int</span> <span class="token function">numDupDigitsAtMostN</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>  
        <span class="token comment">//将n转化为字符串，方便枚举每一位置上的数字  </span>
        <span class="token keyword">auto</span> s <span class="token operator">=</span><span class="token function">to_string</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//使用auto 防止爆int  </span>
        <span class="token comment">//记忆化数组，当dp到相同的情况时直接可以使用以前的的出来的  </span>
        <span class="token comment">//第一维为长度  </span>
        <span class="token comment">//第二位代表可以选择的数字有哪些  </span>
        <span class="token comment">//这题从高到低每一位代表着 9876543210 所以需要移动到第11位，才能出现10个数字都选择的情况  </span>
        <span class="token keyword">int</span> m <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>memo<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  
        <span class="token function">memset</span><span class="token punctuation">(</span>memo<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token punctuation">,</span><span class="token keyword">sizeof</span> memo<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//-1表示没有计算过这种情况  </span>
        <span class="token comment">//递归函数  </span>
        function<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span><span class="token keyword">int</span><span class="token punctuation">,</span><span class="token keyword">bool</span><span class="token punctuation">,</span><span class="token keyword">bool</span><span class="token punctuation">)</span><span class="token operator">&gt;</span> f <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token punctuation">,</span><span class="token keyword">int</span> mask<span class="token punctuation">,</span> <span class="token keyword">bool</span> is_limit <span class="token punctuation">,</span> <span class="token keyword">bool</span> is_num<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token keyword">int</span> <span class="token punctuation">{</span>  
            <span class="token comment">//i 下标  </span>
            <span class="token comment">//mask 是记录当前已经选择数字的集合  </span>
            <span class="token comment">//is_limit 代表当前位置是否受到n这个数字的制约，比如不能超过某个数字  </span>
            <span class="token comment">//is_num 代表前一位是否填数字了，这个是用来判断0是否可填的，如果0可不可填都无所谓就可以不使用这个了  </span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> m<span class="token punctuation">)</span> <span class="token comment">//如果dp到了最后一个位置了，要返回是否得到合法数字了  </span>
                 <span class="token keyword">return</span> is_num<span class="token punctuation">;</span><span class="token comment">//合法数字一定为true，因为长度到了前一个一定要填数字的  </span>
            <span class="token comment">//如果没收到限制或者没收到前一个的填数字的限制，后面可以任意填了，所以必定会有很小重复性的，所以可以直接返回  </span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>is_limit <span class="token operator">&amp;&amp;</span> is_num <span class="token operator">&amp;&amp;</span>memo<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>mask<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> memo<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>mask<span class="token punctuation">]</span><span class="token punctuation">;</span>  
            <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>is_num<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//前一个数字没填，这个数字当然也可以不填  </span>
                res <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span> <span class="token punctuation">,</span> mask <span class="token punctuation">,</span> <span class="token boolean">false</span> <span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
                <span class="token comment">//继续递归  </span>
            <span class="token punctuation">}</span>  
            <span class="token comment">//如果当前数字没收到限制，那么当然可以继续任意填  </span>
            <span class="token comment">//如果收到限制了，那么最多只能填当前这一位置上的数字  </span>
            <span class="token keyword">int</span> up <span class="token operator">=</span> is_limit <span class="token operator">?</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token char">'0'</span> <span class="token operator">:</span> <span class="token number">9</span><span class="token punctuation">;</span>  
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> d <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">-</span> is_num <span class="token punctuation">;</span> d <span class="token operator">&lt;=</span> up <span class="token punctuation">;</span> <span class="token operator">++</span>d<span class="token punctuation">)</span>  
                <span class="token comment">//枚举可以填入的数据，前一位没填数字 ，那么这一位只能从1开始，否则可以从0开始，那么可以填0，如果没被限制，那么要小心是否是第一位了，所以从1开始  </span>
                <span class="token comment">//当d == up 时，  </span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>mask <span class="token operator">&gt;&gt;</span> d <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">// d 不在 mask 中  </span>
                <span class="token comment">//d != up 时，所有的后面的位置都不会受限  </span>
                <span class="token comment">//d == up 时，如果前一位已经受限了，那么后面还会接着受限  </span>
                    res <span class="token operator">+=</span> <span class="token function">f</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> mask <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> d<span class="token punctuation">)</span><span class="token punctuation">,</span> is_limit <span class="token operator">&amp;&amp;</span> d <span class="token operator">==</span> up<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     
              
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>is_limit <span class="token operator">&amp;&amp;</span> is_num<span class="token punctuation">)</span>  
            <span class="token comment">//如果没收到限制或者没收到前一个的填数字的限制，后面可以任意填了  </span>
                memo<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>mask<span class="token punctuation">]</span> <span class="token operator">=</span> res<span class="token punctuation">;</span>  
            <span class="token keyword">return</span> res<span class="token punctuation">;</span>  
        <span class="token punctuation">}</span><span class="token punctuation">;</span>  
        <span class="token keyword">return</span> n <span class="token operator">-</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token number">0</span> <span class="token punctuation">,</span> <span class="token number">0</span> <span class="token punctuation">,</span> <span class="token boolean">true</span> <span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//第一个数字肯定受限了  </span>
    <span class="token punctuation">}</span>  
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token number">2.</span> <span class="token punctuation">[</span><span class="token number">6396.</span> 统计整数数目 <span class="token operator">-</span> 力扣（Leetcode）<span class="token punctuation">]</span><span class="token punctuation">(</span>https<span class="token operator">:</span><span class="token comment">//leetcode.cn/problems/count-of-integers/description/) 一种变形，好好理解</span>
    <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>  
    <span class="token keyword">public</span><span class="token operator">:</span>  
        <span class="token keyword">const</span> <span class="token keyword">int</span> mod <span class="token operator">=</span> <span class="token number">1e9</span> <span class="token operator">+</span> <span class="token number">7</span><span class="token punctuation">;</span>  
        <span class="token keyword">int</span> <span class="token function">cmp</span><span class="token punctuation">(</span>string s <span class="token punctuation">,</span> <span class="token keyword">int</span> min_sum <span class="token punctuation">,</span> <span class="token keyword">int</span> max_sum<span class="token punctuation">)</span><span class="token punctuation">{</span>  
            <span class="token comment">//memo数组最大有 n个9 或者是被迫的这个最大数字 记得 + 1  </span>
            <span class="token keyword">int</span> n <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">,</span> memo<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token function">min</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token operator">*</span>n<span class="token punctuation">,</span>max_sum<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  
            <span class="token function">memset</span><span class="token punctuation">(</span>memo <span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token punctuation">,</span> <span class="token keyword">sizeof</span> memo<span class="token punctuation">)</span><span class="token punctuation">;</span>  
            <span class="token comment">//因为0无影响，所以is_num可以不要了  </span>
            <span class="token comment">//sum 就是mask  </span>
            function <span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token punctuation">,</span><span class="token keyword">int</span> <span class="token punctuation">,</span><span class="token keyword">bool</span><span class="token punctuation">)</span><span class="token operator">&gt;</span> f <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token punctuation">,</span> <span class="token keyword">int</span> sum <span class="token punctuation">,</span> <span class="token keyword">bool</span> is_limit<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token keyword">int</span> <span class="token punctuation">{</span>  
            <span class="token comment">//1.非法情况  </span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>sum <span class="token operator">&gt;</span> max_sum<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//结束递归，sum是一直增加的，后面无法减小的  </span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> n<span class="token punctuation">)</span> <span class="token keyword">return</span> sum <span class="token operator">&gt;=</span> min_sum<span class="token punctuation">;</span><span class="token comment">//结束递归的时候如果数字合法且满足  </span>
            <span class="token comment">//少了一个is_num,只要后面不受限制，那么，后面一定重复  </span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>is_limit <span class="token operator">&amp;&amp;</span> memo<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>sum<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> memo<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>sum<span class="token punctuation">]</span><span class="token punctuation">;</span>  
            <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span> <span class="token comment">//计算所要的答案，也就是计数  </span>
            <span class="token keyword">int</span> up <span class="token operator">=</span> is_limit <span class="token operator">?</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token char">'0'</span> <span class="token operator">:</span> <span class="token number">9</span><span class="token punctuation">;</span><span class="token comment">//上界  </span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> d <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span> d <span class="token operator">&lt;=</span> up <span class="token punctuation">;</span> d<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//枚举位置上的数字  </span>
                <span class="token comment">//d == up的时候，如果前面受限了，后面继续受限，如果前面没受限，那么后面也不受限  </span>
                res <span class="token operator">=</span> <span class="token punctuation">(</span>res <span class="token operator">+</span> <span class="token function">f</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span> <span class="token punctuation">,</span> sum <span class="token operator">+</span> d  <span class="token punctuation">,</span> is_limit <span class="token operator">&amp;&amp;</span> d <span class="token operator">==</span> up<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">%</span> mod<span class="token punctuation">;</span>  
            <span class="token punctuation">}</span>  
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>is_limit<span class="token punctuation">)</span> memo<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>sum<span class="token punctuation">]</span> <span class="token operator">=</span> res <span class="token punctuation">;</span>  <span class="token comment">//与上面保持一致  </span>
            <span class="token keyword">return</span> res <span class="token punctuation">;</span><span class="token comment">//返回答案  </span>
            <span class="token punctuation">}</span><span class="token punctuation">;</span>  
            <span class="token keyword">return</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token number">0</span> <span class="token punctuation">,</span> <span class="token number">0</span> <span class="token punctuation">,</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//初始状态下，一定受限  </span>
        <span class="token punctuation">}</span>  
        <span class="token keyword">int</span> <span class="token function">count</span><span class="token punctuation">(</span>string num1<span class="token punctuation">,</span> string num2<span class="token punctuation">,</span> <span class="token keyword">int</span> min_sum<span class="token punctuation">,</span> <span class="token keyword">int</span> max_sum<span class="token punctuation">)</span> <span class="token punctuation">{</span>  
            <span class="token comment">//转化：  </span>
            <span class="token comment">/*  
                计算 &lt;= num2 的合法数字a和 &lt;= num2 的合法数字b 答案就等于 a - b  
                可以直接计算 &lt;= num1 的合法数字，最后单独判定 num1是否合法  
                套模板： mask 在这里指的是各位数字之和  
                递归结束条件：  
                sum &gt; max_sum 直接返回0 ，不成立，因为sum不能减小，所以继续递归下去也没有用  
                递归到就结束的时候，如果 sum &gt;= min_sum 那么就是满足的，可以直接返回1了  
                前导零对和没有影响，所以isnum可以不用  
                最后：取模运算  
                (a+b)mod m = ((a mod m) + (b mod m )) mod m  
                (a*b)mode m = ((a mod m) * (b mod m )) mod m  
            */</span>  
            <span class="token keyword">int</span> ans <span class="token operator">=</span> <span class="token function">cmp</span><span class="token punctuation">(</span>num2 <span class="token punctuation">,</span> min_sum <span class="token punctuation">,</span>max_sum<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token function">cmp</span><span class="token punctuation">(</span>num1 <span class="token punctuation">,</span> min_sum <span class="token punctuation">,</span>max_sum<span class="token punctuation">)</span><span class="token punctuation">;</span>  
            <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  
            <span class="token comment">//最后一个num1单独判断，因为上面计算的是 num1 &lt; x &lt;= num2的，和前缀和一样  </span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> c <span class="token operator">:</span> num1<span class="token punctuation">)</span> sum <span class="token operator">+=</span> c <span class="token operator">-</span> <span class="token char">'0'</span><span class="token punctuation">;</span>  
            ans <span class="token operator">+=</span> min_sum <span class="token operator">&lt;=</span> sum <span class="token operator">&amp;&amp;</span> sum <span class="token operator">&lt;=</span> max_sum <span class="token punctuation">;</span>  
            <span class="token keyword">return</span> ans <span class="token operator">%</span> mod<span class="token punctuation">;</span>  
        <span class="token punctuation">}</span>  
    <span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="状压DP-状态压缩-动态规划-利用二进制把状态记录成二进制数"><a href="#状压DP-状态压缩-动态规划-利用二进制把状态记录成二进制数" class="headerlink" title="状压DP 状态压缩+动态规划 利用二进制把状态记录成二进制数"></a>状压DP 状态压缩+动态规划 利用二进制把状态记录成二进制数</h2><p>291 91</p>
<pre class="line-numbers language-css" data-language="css"><code class="language-css"><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="树形DP-各层选择取最大值"><a href="#树形DP-各层选择取最大值" class="headerlink" title="树形DP 各层选择取最大值"></a>树形DP 各层选择取最大值</h2><p>将状态分为当前节点选择和不选择</p>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/287/">285. 没有上司的舞会 - AcWing题库</a></p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;bits/stdc++.h&gt;</span>  </span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>  
<span class="token keyword">const</span> <span class="token keyword">int</span> N <span class="token operator">=</span> <span class="token number">6010</span><span class="token punctuation">;</span>  
<span class="token keyword">int</span> happy<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>  
<span class="token keyword">int</span> n<span class="token punctuation">;</span>  
<span class="token keyword">int</span> e<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token comment">/*e存的是编号1*/</span> <span class="token punctuation">,</span> ne<span class="token punctuation">[</span>N<span class="token punctuation">]</span> <span class="token punctuation">,</span> idx <span class="token punctuation">,</span>h<span class="token punctuation">[</span>N<span class="token punctuation">]</span> <span class="token punctuation">,</span> dp<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>  
<span class="token keyword">bool</span> fa<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>  
<span class="token comment">/*  
    状态定义：dp[i][1] dp[i][0] 当前节点选不选  
    状态转移 ： dp[i][0] = sum(子树)   子树有可以分为选与不选  取最大值  
                dp[i][1] = sum(下一层子树不选)    
    属性： 最大值  
   
*/</span>  
<span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  
    idx <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  
    <span class="token function">memset</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token punctuation">,</span> <span class="token keyword">sizeof</span> h<span class="token punctuation">)</span><span class="token punctuation">;</span>  
<span class="token punctuation">}</span>  
<span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">{</span>  
    e<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> b<span class="token punctuation">;</span>  
    ne<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> h<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">;</span>  
    h<span class="token punctuation">[</span>a<span class="token punctuation">]</span> <span class="token operator">=</span> idx<span class="token operator">++</span><span class="token punctuation">;</span>  
<span class="token punctuation">}</span>  
<span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span> u<span class="token punctuation">)</span><span class="token punctuation">{</span>  
        <span class="token comment">//如果当前的节点要选择的话，要初始化数据  </span>
        dp<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> happy<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">;</span>  
        <span class="token comment">//遍历u的子树  </span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> h<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token punctuation">;</span> i <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token punctuation">;</span> i <span class="token operator">=</span> ne<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  
            <span class="token keyword">int</span> j <span class="token operator">=</span> e<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>  
            <span class="token comment">//递归到最低层，实现一层层的求和  </span>
            <span class="token function">dfs</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>  
            <span class="token comment">//当前不选，则是子树的最大值  </span>
            dp<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token punctuation">,</span> dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
            <span class="token comment">//当前选择，那么就是下一层子树不选  </span>
            dp<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+=</span> dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  
        <span class="token punctuation">}</span>  
<span class="token punctuation">}</span>  
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  
    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span> <span class="token punctuation">,</span><span class="token operator">&amp;</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  
        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>happy<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token punctuation">}</span>  
    <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token operator">-</span><span class="token number">1</span> <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  
        <span class="token keyword">int</span> a <span class="token punctuation">,</span> b <span class="token punctuation">;</span>  
        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d%d"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>a<span class="token punctuation">,</span><span class="token operator">&amp;</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>  
        fa<span class="token punctuation">[</span>a<span class="token punctuation">]</span> <span class="token operator">=</span><span class="token boolean">true</span><span class="token punctuation">;</span>  
        <span class="token function">add</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token punctuation">}</span>  
    <span class="token keyword">int</span> root <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  
    <span class="token keyword">while</span><span class="token punctuation">(</span>fa<span class="token punctuation">[</span>root<span class="token punctuation">]</span><span class="token punctuation">)</span> root<span class="token operator">++</span><span class="token punctuation">;</span>  
    <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span><span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>root<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>dp<span class="token punctuation">[</span>root<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="状态机："><a href="#状态机：" class="headerlink" title="状态机："></a>状态机：</h2><blockquote>
<p>通过表示出状态的转换方式即可自动得到答案</p>
</blockquote>
<h2 id="DP行-x2F-列问题"><a href="#DP行-x2F-列问题" class="headerlink" title="DP行/列问题"></a>DP行/列问题</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-strictly-increasing-cells-in-a-matrix/">6456. 矩阵中严格递增的单元格数 - 力扣（Leetcode）</a></p>
<h3 id="例题：股票买卖问题"><a href="#例题：股票买卖问题" class="headerlink" title="例题：股票买卖问题"></a>例题：股票买卖问题</h3><p><strong>含有冷却时间需要用四个状态，正常两个即可，具体问题具体分析</strong></p>
<ol>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/description/">714. 买卖股票的最佳时机含手续费 - 力扣（Leetcode）</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/solutions/2283535/zhuang-tai-ji-dp-by-hardcore-dubinsky348-1qew/">309. 最佳买卖股票时机含冷冻期 - 力扣（Leetcode）</a></p>
</li>
</ol>
<h2 id="通过stoi-和隔板法实现枚举每一个数字的任意子子串"><a href="#通过stoi-和隔板法实现枚举每一个数字的任意子子串" class="headerlink" title="通过stoi 和隔板法实现枚举每一个数字的任意子子串"></a>通过stoi 和隔板法实现枚举每一个数字的任意子子串</h2><p>stoi substr to_string 的妙用</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-the-punishment-number-of-an-integer/">6441. 求一个整数的惩罚数 - 力扣（LeetCode）</a></p>
<h2 id="子列和-x2F-字串问题："><a href="#子列和-x2F-字串问题：" class="headerlink" title="子列和/字串问题："></a>子列和/字串问题：</h2><ol>
<li><p>求任意子列的乘积最大 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-strength-of-a-group/">6393. 一个小组的最大实力值 - 力扣（Leetcode）</a></p>
</li>
<li><p>一个字符串匹配另一个字典求最大匹配长度问题：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/extra-characters-in-a-string/">6394. 字符串中的额外字符 - 力扣（Leetcode）</a></p>
</li>
<li><p>反转01得到相等字符串问题：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-cost-to-make-all-characters-equal/">6455. 使所有字符相等的最小成本 - 力扣（Leetcode）</a></p>
</li>
</ol>
<h1 id="暴力枚举法"><a href="#暴力枚举法" class="headerlink" title="暴力枚举法"></a>暴力枚举法</h1><p>使用于组合的数量少，但是需要找到最合适的组合的题目<br>例题<br><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-moves-to-spread-stones-over-grid/submissions/">3*3</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zuofw.github.io/2023/08/27/25/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="QingQiu">
      <meta itemprop="description" content="个人网站，学习记录，面试记录和经验总结、互联网中一块属于自己的小窝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="QingQiu'Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/08/27/25/" class="post-title-link" itemprop="url">Java基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-08-27 10:50:25" itemprop="dateCreated datePublished" datetime="2023-08-27T10:50:25+08:00">2023-08-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-09-08 22:40:20" itemprop="dateModified" datetime="2024-09-08T22:40:20+08:00">2024-09-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">语言</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>8k</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="面试常问："><a href="#面试常问：" class="headerlink" title="面试常问："></a>面试常问：</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><ul>
<li>概念辨别：<ul>
<li>JDK Java Development Kit 是Java的开发工具包，是Java的一个SDK</li>
<li>JRE Java Runtime Environment Java运行环境</li>
<li>SDK Software Development Kit 软件开发工具包</li>
<li>Java9 之后部分jdk和jre了</li>
<li>JIT 运行时编译，当JIT编译器第一次编译之后，会把字节码对应的机器码保存下来，下次可以直接使用，如果是热点代码就使用JIT进行编译启动，如果不是热点数据，就使用解释器来执行。</li>
<li>AOT：在程序执行前将其编译成机器码，属于静态编译。适合云原生场景</li>
<li><img src="/2023/08/27/25/%E6%AD%BB%E8%80%85%E5%85%B3%E7%B3%BB.png"></li>
</ul>
</li>
<li>基础数据类型：<ul>
<li>== 和 equals : == 比较的是内存地址是否一致，equals比较的是对象的内容是否相等，Object类中没有区别，Striing，Integer等就有区别了</li>
<li>基本数据类型：byte 8bit ,short 16 ,int 32 ,long 64,float 32 ,double 64,boolean 1,char , 注意char的默认值是 <code>\u0000</code> 也就是表示null的字符</li>
<li>StringBuffer可以看作是线程安全的StringBuilder</li>
<li>Map和Set:<ul>
<li>为什么HashMap的长度(桶的数量是2的幂次方)，因为可以优化哈希值的分布，哈希值与长度-1进行位运算而不是取模，可以加快效率，也能分布更均匀，方便扩容</li>
<li>HashSet的底层是是用来一个HashMap，key为set的元素,value为一个固定的Object对象</li>
<li>HashMap的查询：底层实现数组+链表 1.8之后多了红黑树<ol>
<li>没有哈希冲突，O(1)</li>
<li>有冲突，就会把冲突的键放在同一个桶的链表中，需要查询链表O(n);</li>
<li>Java8之后，当桶中的数据达到一定规模就会转为红黑树，O(logn)</li>
</ol>
<ul>
<li>put方法：<ol>
<li>判断key对数组table，是否为null，否则执行resize进行扩容（初始化）</li>
<li>根据key计算hash，得到数组索引</li>
<li>table[i] == null 直接添加</li>
<li>不成立：<ul>
<li>判断table[i] 的首个元素是否和key一样，如果相同直接覆盖value</li>
<li>table[i] 是否为treeNode ，也就是是否是红黑树，如果是直接在树种插入键值对</li>
<li>遍历table[i] 在尾部插入数据，如果长度大于8转为红黑树</li>
</ul>
</li>
<li>判断实际数量是否超过了最大容量*0.75，如果超过进行扩容</li>
</ol>
</li>
<li>如何扩容：<ul>
<li>每次到达数组长度* 0.75时扩容，，每次扩容长度是原来最大容量的两倍</li>
<li>扩容之后要把老数组移到新数组钟</li>
</ul>
</li>
<li>寻址算法：<ul>
<li>计算出key的hashCode，然后在这个值右移16位后的二进制及逆行按位异或运算，得到的hash</li>
</ul>
</li>
</ul>
</li>
<li>HashSet如何比较是否重复：根据hashcode来比较，如果相等，那么再调用equals方法来比较</li>
</ul>
</li>
<li>字节码：JVM可以理解的代码就是字节码，也就是.class文件<ul>
<li>Java代码先经过编译生成字节码，之后由java解释器来解释执行</li>
<li>面向对象三大特点：封装、继承、多态</li>
<li>比较对象比较的是内存地址，而equals()没有重写时，也是比较的地址</li>
<li>序列化：将数据结构或者对象转换成二进制字节流的过程</li>
<li>包装类型的常量池：包装类型保存了一定范围内的所有的实例，可以减少内存的使用</li>
</ul>
</li>
<li>引用类型：<ol>
<li>强引用：使用new </li>
<li>软引用：只有这个方式时，内存不足时会被回收</li>
<li>弱引用：只有这个方式是，内存重组也会被回收</li>
<li>虚引用：无法通过他获取对象</li>
</ol>
</li>
</ul>
</li>
<li>IO<ul>
<li>BIO同步阻塞IO一直等待内核把数据拷贝到用户空间</li>
<li>NIO非阻塞IO，可以看作多路复用IO</li>
<li>AIO异步IO</li>
<li>NIO非阻塞IO Netty使用</li>
</ul>
</li>
</ul>
<h3 id="多态的原理"><a href="#多态的原理" class="headerlink" title="多态的原理"></a>多态的原理</h3><p>动态绑定，运行时才将方法调用和方法实现关联起来。</p>
<h3 id="静态方法为什么不能调用非静态成员"><a href="#静态方法为什么不能调用非静态成员" class="headerlink" title="静态方法为什么不能调用非静态成员"></a>静态方法为什么不能调用非静态成员</h3><blockquote>
<p>静态方法在类加载时就会分配内存，而非静态成员属于实例对象，所以调用不到，属于非法操作</p>
</blockquote>
<h3 id="字符串常量池"><a href="#字符串常量池" class="headerlink" title="字符串常量池"></a>字符串常量池</h3><blockquote>
<p>对于编译期可以确定值的字符串，也就是常量字符串 ，jvm 会将其存入字符串常量池。并且，字符串常量拼接得到的字符串常量在编译阶段就已经被存放字符串常量池，这个得益于编译器的优化。<br><strong>字符串使用&nbsp;<code>final</code>&nbsp;关键字声明之后，可以让编译器当做常量来处理。</strong></p>
</blockquote>
<h3 id="String为什么不可变"><a href="#String为什么不可变" class="headerlink" title="String为什么不可变"></a>String为什么不可变</h3><ol>
<li>String中的byte数组被private和final修饰，并且没有具体的方法暴露</li>
<li>String对象使用final修饰，不可被继承，保证不会被子类破坏不可变性<img src="/2023/08/27/25/String%E4%B8%8D%E5%8F%AF%E5%8F%98.png"></li>
</ol>
<h3 id="x3D-x3D-和-equals区别"><a href="#x3D-x3D-和-equals区别" class="headerlink" title="== 和 equals区别"></a>== 和 equals区别</h3><p>== ：<br>基本数据类型是比较的值，对象比较的是地址<br>equals：<br>没重写的话比较的是地址，String是专门重写过的，比较的是具体的值是否相同</p>
<h3 id="三种拷贝方式的区别"><a href="#三种拷贝方式的区别" class="headerlink" title="三种拷贝方式的区别"></a>三种拷贝方式的区别</h3><ol>
<li>引用拷贝：不同的引用指向相同的对象</li>
<li>浅拷贝：外部对象是new 出来的新对象，内部对象仍然是指向一个</li>
<li>深拷贝：外部对象和内部对象都是新new 出来的<br><img src="/2023/08/27/25/%E4%B8%89%E7%A7%8D%E6%8B%B7%E8%B4%9D%E6%96%B9%E5%BC%8F.png"></li>
</ol>
<h3 id="concurrenthashmap和hashmap和hashtable的区别"><a href="#concurrenthashmap和hashmap和hashtable的区别" class="headerlink" title="concurrenthashmap和hashmap和hashtable的区别"></a>concurrenthashmap和hashmap和hashtable的区别</h3><p>HashMap线程不安全<br>HashTable和concurrentHashMap是线程安全的HashMap，HashTable上锁时，会锁住整个表，而ConcurrentHashMap只会锁对应的段，使用的是分段锁。</p>
<h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><h4 id="SerialVersionUID"><a href="#SerialVersionUID" class="headerlink" title="SerialVersionUID"></a>SerialVersionUID</h4><p>即使被static修饰，也会被序列化进二进制流中，用来判断序列化对象的版本一致性。</p>
<h3 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h3><p>代理模式是使用代理对象来替代真实对象，从而在不修改原目标的前提下提供额外的功能操作，拓展对象功能。</p>
<h4 id="动态代理和静态代理的区别"><a href="#动态代理和静态代理的区别" class="headerlink" title="动态代理和静态代理的区别"></a>动态代理和静态代理的区别</h4><ol>
<li>静态代理在编译阶段就将接口、实现类、代理类都变成一个个实际的class文件。对于每一个被代理的对象都需要单独写一个代理类，非常不方便</li>
<li>动态代理：是在运行时动态生成字节码，并加载到JVM中。核心是 <strong><code>InvocationHandler</code>&nbsp;接口和&nbsp;<code>Proxy</code>&nbsp;类</strong></li>
</ol>
<h3 id="JDK和CGLIB的区别"><a href="#JDK和CGLIB的区别" class="headerlink" title="JDK和CGLIB的区别"></a>JDK和CGLIB的区别</h3><p>JDK是面向接口的，而CGLib是通过直接吗底层继承要代理的类来实现的，底层是asm</p>
<blockquote>
<p>Spring AOP的底层实现主要基于动态代理模式。具体来说，有两种主要的实现方式：JDK 动态代理和 CGLIB 动态代理。Spring AOP 在运行时会根据目标对象的类型和配置来选择使用 JDK 动态代理还是 CGLIB 动态代理。如果目标对象实现了接口，并且没有强制要求使用 CGLIB 代理，Spring 会优先使用 JDK 动态代理。如果目标对象没有实现接口，或者通过配置强制使用 CGLIB 代理，那么 Spring 会使用 CGLIB 动态代理来实现 AOP。</p>
</blockquote>
<h3 id="BigDecimal工具类"><a href="#BigDecimal工具类" class="headerlink" title="BigDecimal工具类"></a>BigDecimal工具类</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>math<span class="token punctuation">.</span></span><span class="token class-name">BigDecimal</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>math<span class="token punctuation">.</span></span><span class="token class-name">RoundingMode</span></span><span class="token punctuation">;</span>

<span class="token comment">/**
 * 简化BigDecimal计算的小工具类
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BigDecimalUtil</span> <span class="token punctuation">{</span>

    <span class="token comment">/**
     * 默认除法运算精度
     */</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">DEF_DIV_SCALE</span> <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>

    <span class="token keyword">private</span> <span class="token class-name">BigDecimalUtil</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/**
     * 提供精确的加法运算。
     *
     * @param v1 被加数
     * @param v2 加数
     * @return 两个参数的和
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">double</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">double</span> v1<span class="token punctuation">,</span> <span class="token keyword">double</span> v2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">BigDecimal</span> b1 <span class="token operator">=</span> <span class="token class-name">BigDecimal</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>v1<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">BigDecimal</span> b2 <span class="token operator">=</span> <span class="token class-name">BigDecimal</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>v2<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> b1<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>b2<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">doubleValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/**
     * 提供精确的减法运算。
     *
     * @param v1 被减数
     * @param v2 减数
     * @return 两个参数的差
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">double</span> <span class="token function">subtract</span><span class="token punctuation">(</span><span class="token keyword">double</span> v1<span class="token punctuation">,</span> <span class="token keyword">double</span> v2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">BigDecimal</span> b1 <span class="token operator">=</span> <span class="token class-name">BigDecimal</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>v1<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">BigDecimal</span> b2 <span class="token operator">=</span> <span class="token class-name">BigDecimal</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>v2<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> b1<span class="token punctuation">.</span><span class="token function">subtract</span><span class="token punctuation">(</span>b2<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">doubleValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/**
     * 提供精确的乘法运算。
     *
     * @param v1 被乘数
     * @param v2 乘数
     * @return 两个参数的积
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">double</span> <span class="token function">multiply</span><span class="token punctuation">(</span><span class="token keyword">double</span> v1<span class="token punctuation">,</span> <span class="token keyword">double</span> v2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">BigDecimal</span> b1 <span class="token operator">=</span> <span class="token class-name">BigDecimal</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>v1<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">BigDecimal</span> b2 <span class="token operator">=</span> <span class="token class-name">BigDecimal</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>v2<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> b1<span class="token punctuation">.</span><span class="token function">multiply</span><span class="token punctuation">(</span>b2<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">doubleValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/**
     * 提供（相对）精确的除法运算，当发生除不尽的情况时，精确到
     * 小数点以后10位，以后的数字四舍五入。
     *
     * @param v1 被除数
     * @param v2 除数
     * @return 两个参数的商
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">double</span> <span class="token function">divide</span><span class="token punctuation">(</span><span class="token keyword">double</span> v1<span class="token punctuation">,</span> <span class="token keyword">double</span> v2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">divide</span><span class="token punctuation">(</span>v1<span class="token punctuation">,</span> v2<span class="token punctuation">,</span> <span class="token constant">DEF_DIV_SCALE</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/**
     * 提供（相对）精确的除法运算。当发生除不尽的情况时，由scale参数指
     * 定精度，以后的数字四舍五入。
     *
     * @param v1    被除数
     * @param v2    除数
     * @param scale 表示表示需要精确到小数点以后几位。
     * @return 两个参数的商
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">double</span> <span class="token function">divide</span><span class="token punctuation">(</span><span class="token keyword">double</span> v1<span class="token punctuation">,</span> <span class="token keyword">double</span> v2<span class="token punctuation">,</span> <span class="token keyword">int</span> scale<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>scale <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span>
                    <span class="token string">"The scale must be a positive integer or zero"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token class-name">BigDecimal</span> b1 <span class="token operator">=</span> <span class="token class-name">BigDecimal</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>v1<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">BigDecimal</span> b2 <span class="token operator">=</span> <span class="token class-name">BigDecimal</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>v2<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> b1<span class="token punctuation">.</span><span class="token function">divide</span><span class="token punctuation">(</span>b2<span class="token punctuation">,</span> scale<span class="token punctuation">,</span> <span class="token class-name">RoundingMode</span><span class="token punctuation">.</span><span class="token constant">HALF_EVEN</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">doubleValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/**
     * 提供精确的小数位四舍五入处理。
     *
     * @param v     需要四舍五入的数字
     * @param scale 小数点后保留几位
     * @return 四舍五入后的结果
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">double</span> <span class="token function">round</span><span class="token punctuation">(</span><span class="token keyword">double</span> v<span class="token punctuation">,</span> <span class="token keyword">int</span> scale<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>scale <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span>
                    <span class="token string">"The scale must be a positive integer or zero"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token class-name">BigDecimal</span> b <span class="token operator">=</span> <span class="token class-name">BigDecimal</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">BigDecimal</span> one <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BigDecimal</span><span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> b<span class="token punctuation">.</span><span class="token function">divide</span><span class="token punctuation">(</span>one<span class="token punctuation">,</span> scale<span class="token punctuation">,</span> <span class="token class-name">RoundingMode</span><span class="token punctuation">.</span><span class="token constant">HALF_UP</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">doubleValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/**
     * 提供精确的类型转换(Float)
     *
     * @param v 需要被转换的数字
     * @return 返回转换结果
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">float</span> <span class="token function">convertToFloat</span><span class="token punctuation">(</span><span class="token keyword">double</span> v<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">BigDecimal</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BigDecimal</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> b<span class="token punctuation">.</span><span class="token function">floatValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/**
     * 提供精确的类型转换(Int)不进行四舍五入
     *
     * @param v 需要被转换的数字
     * @return 返回转换结果
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">convertsToInt</span><span class="token punctuation">(</span><span class="token keyword">double</span> v<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">BigDecimal</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BigDecimal</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> b<span class="token punctuation">.</span><span class="token function">intValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/**
     * 提供精确的类型转换(Long)
     *
     * @param v 需要被转换的数字
     * @return 返回转换结果
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">long</span> <span class="token function">convertsToLong</span><span class="token punctuation">(</span><span class="token keyword">double</span> v<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">BigDecimal</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BigDecimal</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> b<span class="token punctuation">.</span><span class="token function">longValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/**
     * 返回两个数中大的一个值
     *
     * @param v1 需要被对比的第一个数
     * @param v2 需要被对比的第二个数
     * @return 返回两个数中大的一个值
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">double</span> <span class="token function">returnMax</span><span class="token punctuation">(</span><span class="token keyword">double</span> v1<span class="token punctuation">,</span> <span class="token keyword">double</span> v2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">BigDecimal</span> b1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BigDecimal</span><span class="token punctuation">(</span>v1<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">BigDecimal</span> b2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BigDecimal</span><span class="token punctuation">(</span>v2<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> b1<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>b2<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">doubleValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/**
     * 返回两个数中小的一个值
     *
     * @param v1 需要被对比的第一个数
     * @param v2 需要被对比的第二个数
     * @return 返回两个数中小的一个值
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">double</span> <span class="token function">returnMin</span><span class="token punctuation">(</span><span class="token keyword">double</span> v1<span class="token punctuation">,</span> <span class="token keyword">double</span> v2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">BigDecimal</span> b1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BigDecimal</span><span class="token punctuation">(</span>v1<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">BigDecimal</span> b2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BigDecimal</span><span class="token punctuation">(</span>v2<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> b1<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>b2<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">doubleValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/**
     * 精确对比两个数字
     *
     * @param v1 需要被对比的第一个数
     * @param v2 需要被对比的第二个数
     * @return 如果两个数一样则返回0，如果第一个数比第二个数大则返回1，反之返回-1
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">compareTo</span><span class="token punctuation">(</span><span class="token keyword">double</span> v1<span class="token punctuation">,</span> <span class="token keyword">double</span> v2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">BigDecimal</span> b1 <span class="token operator">=</span> <span class="token class-name">BigDecimal</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>v1<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">BigDecimal</span> b2 <span class="token operator">=</span> <span class="token class-name">BigDecimal</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>v2<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> b1<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>b2<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="UnSafe类"><a href="#UnSafe类" class="headerlink" title="UnSafe类"></a>UnSafe类</h2><p>提供一些很底层的操作，JUC中经常使用。<br>核心功能：</p>
<ol>
<li>内存操作</li>
<li>[[多线程#内存屏障|内存屏障]]</li>
<li>对象操作</li>
<li>数据操作</li>
<li>CAS操作</li>
<li>线程调度</li>
<li>Class操作</li>
<li>系统信息</li>
</ol>
<h2 id="并发相关"><a href="#并发相关" class="headerlink" title="并发相关"></a>并发相关</h2><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><h4 id="线程池的原理"><a href="#线程池的原理" class="headerlink" title="线程池的原理"></a>线程池的原理</h4><p>初始化一个线程池，指定线程池的大小，也就是线程池中的线程数量<br>然后每次向线程池中提交任务，线程池中的线程循环从任务队列中去除任务并且执行<br>如果一个线程执行完一个任务之后，就会回到线程池，而不是销毁</p>
<p>线程池通过循环利用线程，而不是销毁避免了频繁创建和销毁线程池的开销</p>
<h4 id="线程池中关于时间的参数起什么作用"><a href="#线程池中关于时间的参数起什么作用" class="headerlink" title="线程池中关于时间的参数起什么作用"></a>线程池中关于时间的参数起什么作用</h4><ol>
<li>空闲线程存活时间：当线程中的线程数量超过核心线程数量时，这些额外的线程在超过空闲线程存活时间就会被中止</li>
<li>任务超时时间：执行任务执行的最大时间，如果</li>
</ol>
<ul>
<li>多线程：<ul>
<li>线程不安全的集合：<ul>
<li>ArrayList,HashMap,HashSet,LinkedList等<ul>
<li>ArrayList的实现：<ul>
<li>add方法：确保数组在已使用长度(size) + 1之后能够存下洗一个数据</li>
<li>计算数组的容量，如果当前数组已使用的长度+1后的大于当前数组的长度，使用grow方法扩容，扩大约1.5倍</li>
<li>确保新增的数据有地方存储之后奖新元素加到位于size的位置上</li>
<li>返回bool值</li>
</ul>
</li>
<li>ArrayList list=new ArrayList(10)中的list 不会扩容</li>
<li>使用asList后，原数组修改会改变新生成的List，因为他们最终指向的都是一个内存地址</li>
<li>如何处理linkedlist和arraylist的线程不安全：<ol>
<li>优先在方法内使用，定义为局部变量</li>
<li>使用synchornizedList来替换ConcurrentLinkedQueue</li>
</ol>
</li>
</ul>
</li>
<li>使用toArray后，修改List的内容，数组的内容不会改变</li>
<li>Vector和ArrayList的区别：Vector是线程安全的，大部分方法是同步到，性能上ArrayList好一点，以为不需要同步，扩容的时候，A增加50%，V怎加100%</li>
<li>ConcurrentHashMap如何保证线程安全：<ol>
<li>使用CAS(Compare and Swap)，每次更新时，对比内存位置的值与预期的原值相同则更新，否则不更新，这是一种无锁的操作</li>
<li>使用synchorinized，ConcurrentHashMap的每个桶(也即是哈希表种的链表或者红黑树)，都可以当作一个锁，线程访问时，锁住这个桶，而不是锁住整个哈希表</li>
</ol>
</li>
</ul>
</li>
<li>6种状态：</li>
<li>synchronized:<ul>
<li>作用：把证同一时刻只能有一个线程来执行该段代码，保证线程的同步</li>
<li>原理：使用了JVM种的监视器锁monitor，每个对象都有一个内治所，当线程调用synchronized方法时，就获得了这个锁，</li>
<li>JDK1.6 之后的优化：引入了偏向锁、和轻量级锁，逐步升级到重量级锁</li>
<li><strong>synchronized和volatile的区别</strong>：volatile只能保证线程的可见性，当一个线程修改了这个变量的值，其他线程立刻可见这个修改</li>
<li>并发编程的三个重要特性：原子性(全做or全部做)，可见性(共享变量可见)，有序性(按照先后顺序)</li>
<li>ThreadLocal原理：维护一个ThreadLocalMap，key为ThreadLocal对，值为变量<ul>
<li>内存泄漏：key是弱引用，value是强引用，所以外部没有使用强引用时，ThreadLocal会被回收，但是value会继续使用内存，可以使用ThreadLocal.remove()来解决这个问题</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>JUC：<ul>
<li>Java Util Concurrent是并发编程的一个工具包，常用：<ul>
<li>Executor框架</li>
<li>ConcurrentHashMap并发集合</li>
<li>CountDownLatch同步工具</li>
<li>Locks 比synchronized更灵活的锁机制</li>
<li>原子变量：AtomicInteger</li>
<li>并发工具类：ForkJoinPool</li>
</ul>
</li>
<li>volatile关键字：保证变量的可见性，要求每次使用它时都需要从主存中重新读取，但不能保证原子性</li>
<li>单例模式示例代码：<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> uniqueInstance<span class="token punctuation">;</span>

    <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span>  <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getUniqueInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token comment">//先判断对象是否已经实例过，没有实例化过才进入加锁代码</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>uniqueInstance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">//类对象加锁</span>
            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token class-name">Singleton</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>uniqueInstance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    uniqueInstance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> uniqueInstance<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
</li>
</ul>
<h2 id="集合相关"><a href="#集合相关" class="headerlink" title="集合相关"></a>集合相关</h2><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><ul>
<li>HashSet底层使用的是HashMap</li>
<li>LinkedHashSet通过LinkedHashMap实现的</li>
<li>TreeSet：红黑树(自平衡的排序二叉树)实现</li>
</ul>
<h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>ArrayList是动态数组，可以扩容、缩容，同时可以使用泛型来保证，线程不安全，适用于频繁的查找工作。可添加null值<br>Vector是老实现，底层使用Object [   ]存储，线程安全</p>
<h3 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h3><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><h4 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h4><p>JDK1.8之前由数组+链表组成。JDK1.8之后当链表长度大于阈值，会转化为红黑树(当前数组的长度小于64时，会先进行数组扩容，而不是转化为红黑树)<br>LinkedHashMap：继承HashMap，增加了 一条双向链表。<br>JDK1.7时，HashMap在多线程环境下，扩容操作使用的是头插法，导致链表中的节点指向错误的位置。JDK1.8使用的是为尾插法，但是有可能会出现数据覆盖的问题，并发环境下推荐使用ConcurrentHashMap</p>
<h3 id="Queue-1"><a href="#Queue-1" class="headerlink" title="Queue"></a>Queue</h3><h4 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h4><p>使用二叉堆实现，底层使用可变长的数据来存储数据，非线程安全，不知处NULL值和不可排序的对象，默认是小顶堆</p>
<h4 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h4><p>阻塞队列</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zuofw.github.io/2023/08/02/58/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="QingQiu">
      <meta itemprop="description" content="个人网站，学习记录，面试记录和经验总结、互联网中一块属于自己的小窝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="QingQiu'Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/08/02/58/" class="post-title-link" itemprop="url">数据库</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-08-02 15:36:58" itemprop="dateCreated datePublished" datetime="2023-08-02T15:36:58+08:00">2023-08-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-09-14 14:31:12" itemprop="dateModified" datetime="2024-09-14T14:31:12+08:00">2024-09-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>39k</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><p>数据库同步问题：</p>
<h2 id="Mysql面试指南"><a href="#Mysql面试指南" class="headerlink" title="Mysql面试指南"></a>Mysql面试指南</h2><p><a target="_blank" rel="noopener" href="https://javabetter.cn/interview/mysql-60.html">60 道 MySQL 精选面试题👍 | 二哥的Java进阶之路 (javabetter.cn)</a></p>
<h3 id="InnoDB为什么是默认的引擎"><a href="#InnoDB为什么是默认的引擎" class="headerlink" title="InnoDB为什么是默认的引擎"></a>InnoDB为什么是默认的引擎</h3><ol>
<li>是mysql中唯一支持事务的引擎</li>
<li>锁机制：使用行级锁，而不是表级锁</li>
<li>支持外键约束</li>
<li>具有崩溃恢复</li>
</ol>
<h3 id="索引为什么使用B-树"><a href="#索引为什么使用B-树" class="headerlink" title="索引为什么使用B+树"></a>索引为什么使用B+树</h3><ol>
<li>支出快速查找：B+树高度相对较低，查找效率高</li>
<li>有序性：节点的键值是有序排列的</li>
<li>支持高效插入和删除操作：叶子节点之间使用双向链表链接，可以快读定位到要插入和删除的位置</li>
<li>适应硬盘存储：B+树节点被控制在硬盘大小的范围内</li>
<li>支持数据点有序存储和范围查找</li>
</ol>
<h3 id="如何进行回滚的"><a href="#如何进行回滚的" class="headerlink" title="如何进行回滚的"></a>如何进行回滚的</h3><ol>
<li>使用Undo Log进行回滚，</li>
<li>混滚时，按照事务的执行的逆序进行回滚。</li>
<li>Undo Log记录了事务对数据库的修改操作</li>
</ol>
<h3 id="慢查询如何考虑优化"><a href="#慢查询如何考虑优化" class="headerlink" title="慢查询如何考虑优化"></a>慢查询如何考虑优化</h3><p><img src="/2023/08/02/58/%E6%85%A2%E6%9F%A5%E8%AF%A2%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96.png"></p>
<h3 id="数据库中的CAP"><a href="#数据库中的CAP" class="headerlink" title="数据库中的CAP"></a>数据库中的CAP</h3><p>C：Consistency强一致性，系统在执行某项操作之后，仍然能够保持一致。更新操作执行成功，所有的用户都应该读到最新的值<br>A：Availabliy可用性，每个操作总是能够在一定时间内返回结果。结果可以是成功或者失败<br>P：分区容错性，出现网络分区时，系统能够正常运行。</p>
<h3 id="怎么对plan进行优化"><a href="#怎么对plan进行优化" class="headerlink" title="怎么对plan进行优化"></a>怎么对plan进行优化</h3><ol>
<li>谓词下推：查询时，竟遭过滤掉不需要的数据<code>SELECT * FROM orders WHERE order_date &gt; '2023-01-01';</code></li>
<li>索引下推：使用索引来加速查询，尤其是在索引覆盖查询中</li>
<li>表达式优化：简化和重写表达式来提高效率</li>
<li>最左匹配优化选择索引：使用索引的最左前缀原则来优化查询</li>
<li>避免SELECT * </li>
<li>使用适当的JOIN类型</li>
<li>使用索引覆盖：创建包含所有查询列的索引避免回表</li>
<li></li>
</ol>
<h3 id="介绍一下MySQL的索引"><a href="#介绍一下MySQL的索引" class="headerlink" title="介绍一下MySQL的索引"></a>介绍一下MySQL的索引</h3><p>MySQL的索引是一种数据结构，可以帮助MySQL快速搞笑的查询，更新数据库中的数据。</p>
<h3 id="B-树的特征，为什么-MySQL-要使用-B-树"><a href="#B-树的特征，为什么-MySQL-要使用-B-树" class="headerlink" title="B+树的特征，为什么 MySQL 要使用 B+树"></a>B+树的特征，为什么 MySQL 要使用 B+树</h3><p>特点： </p>
<ol>
<li>只有叶子节点会存放实际的数据，包括索引+记录，非叶子节只存放索引</li>
<li>所有索引都在叶子节点中出现，叶子节点之间构成一个有序链表</li>
<li>非叶子节点的索引也会同时存在叶子节点中，并且是叶子节点中索引中的最大值或者最小值</li>
<li>非叶子节点有多少个子节点，就有多少个索引</li>
</ol>
<p>看看几个隔离级别和解决办法<br>GBKh和UTF-8不是一种编码方式<br>mysql中使用的utf-8是utf8mb3 使用1<del>3个字节来表示一个字符<br>而utf-8使用1</del>4<br>MVCC （Multi-Version Concurrency Control ，多版本并发控制）MVCC （Multi-Version Concurrency Control ，多版本并发控制）指的就是在使用 READ COMMITTD 、 REPEATABLE READ 这两种隔离级别的事务在执行普通的 SEELCT 操作时访问记录的版本链的过程，这样子可以使不同事务的 读-写 、 写-读 操作并发执行，从而提升系统性能。</p>
<ul>
<li>sql语句的执行过程：mysql8.0 client发送sql语句-&gt;sql解析-&gt;执行优化和执行计划生成-&gt;执行-&gt;返回结果</li>
<li>隔离等级：<img src="/2023/08/02/58/%E9%9A%94%E7%A6%BB%E7%AD%89%E7%BA%A7.png" alt="|575"><ul>
<li>MySQL默认是可重复读，可以解决幻读。然后串行化是基于锁实现的，可重复读和读已提交都是基于MVCC实现的，可重复读在当前读的情况下需要加锁才能保证不会出现幻读，所以仅仅使用MVCC不能解决幻读</li>
</ul>
</li>
<li>日志：<ul>
<li>种类：错误日志，查询日志，慢查询日志，Binary Log, 中继日志，事务日志</li>
</ul>
<ol>
<li>undo log 有两种<ul>
<li>insert undo log 执行insert 操作产生的undo log isnert只对事务本身可见，其他事务不可见，所以事务提交之后可以直接删除</li>
<li>update undo log 提供MVCC机制，提交时放入undo log 链表，等待purge线程进行最后的删除<ul>
<li>purge：会定期检查 undo log 和数据行，找出那些已经不再需要的，然后将它们从磁盘上删除，从而回收磁盘空间。</li>
</ul>
</li>
</ul>
</li>
<li>慢查询日志：记录执行时间查过指定阈值的所有SQL查询，</li>
<li>Binlog: 主要记录了数据库的修改操作，事务信息和一些特殊事件：服务器的启动和停止，主从复制状态变更事件等</li>
<li>redo log 如何保证事务的持久性？ <ul>
<li>事务执行时，首先记录在redo log而不是直接修改数据文件，redo log 保存在内存中的log buffer，然后被异步刷新到磁盘中的redo log file中</li>
<li>事务提交时，相关的数据还没有没刷新到磁盘中，只要保证redo log 被刷新到磁盘中，即使系统在事务提交后崩溃了，也可以在系统重启之后通过redo log 里恢复数据，</li>
<li>为什么要先写入redo log ，因为redo log 时顺序写入的，而写数据需要涉及随机I/O，能够提高数据库的性能</li>
</ul>
</li>
<li>页表修改之后为什么不直接刷盘？因为刷新到磁盘中非常耗时，所以使用预写式日志的技术，先写入redolog，之后异步刷新内存中的redolog到磁盘中，之后写入数据到内存中的数据页中，之后写入binlog，内存中的数据页会在适当实际刷新到磁盘中。</li>
<li>binlog和redolog的区别：<ul>
<li>用途上：binlog用于主从复制和数据恢复，复制时会把主服务器上的binlog发给从服务器，然后从服务器根据binlog中的记录来更新;而redo log 用于保证事务的持久性</li>
<li>格式：binlog:可以是语句格式或者行格式，语句记录SQL执行的语句，行格式记录每一行的数据变化。redo log以物理格式记录数据页的修改，记录的是某个数据页的某个位置，将某个数据修改为了什么</li>
<li>写入时机：binlog 事务提交时，redo log 事务执行过程中就开始写入，事务提交时确保已经将redo log 写入磁盘中</li>
<li>清理方式：binlog 需手动清理或者设置过期时间清理； redo log 当数据页的修改刷新到磁盘中之后，redo log 即可被覆盖重新使用</li>
</ul>
</li>
<li>undo log 如何保证事务的原子性：事务开始执行时，udno log 中会记录修改前的数据，如果事务体骄傲成功，undo log 即可以被清理，如果失败就会使用undo log 回滚事务。</li>
<li>MVCC(乐观锁)如何实现：每个数据行中都有两个隐藏列：一个用于记录改行创建时的事务ID，一个记录删除该行的事务ID，当事务开始时，他会根据当前所有活跃的事务产生Read View ，其中记录了：<ul>
<li>创建这个Read View时下个即将被分配的事务ID m_low_limit_id</li>
<li>活跃列表中最小的事务ID m_up_limit_id</li>
<li>Read View创建时，其他未提交的活跃事务ID列表 m_ids</li>
<li>创建该Read View 的事务ID m_creator_trx_id<br> 之后对数据行进行读取时，检查该行的创建事务ID和删除事务ID <img src="/2023/08/02/58/ReadView%E5%8F%AF%E8%A7%81%E6%80%A7.png" alt="ReadView可见性|525"></li>
<li>如果创建ID大于m_low_limit_id，说明是在当前事务之后创建的，不可见</li>
<li>如果删除ID小于m_up_limit_id，说明在当前事务开始前就已经被删除了，不可见</li>
<li>如果创建事务ID小于m_low_limit_id但删除ID大于m_up_limit_id，需要与m_ids列表中比对，如果存在于m_ids列表中，则不可见</li>
</ul>
</li>
<li></li>
</ol>
</li>
<li>外键：<ul>
<li>不建议使用外键，外键应该在应用层中保证，而不是在数据库上使用外键，因为外键对分库分表无法生效，同时需要维护外键，当我们做一些涉及外键的CUD操作时，需要触发相关的操作去检查，保证数据的一致性和正确性，从而消耗额外资源，</li>
</ul>
</li>
<li>集群：<ul>
<li>redo log 和 undo log都是由InnoDB引擎实现的</li>
<li>bin log 是由mysql级别的日志<ul>
<li>redo和bin 的区别：Redo log是记录了数据的修改，大小到一定程度，新的日志会覆盖，先写redo再写bin，目的是为了保证事务的持久性</li>
<li>Binlog是记录了执行了什么sql语句，不会覆盖旧日志，用于实现mysql的主从复制</li>
</ul>
</li>
<li>redolog的优势：顺序写，预写入，磁盘同步过程中可以一次同步多个事务的Redo log：先把修改写入redolog，再修改内存中的数据，事务提交时再入bin log，之后再将数据写入磁盘中 </li>
<li>主从复制：<ul>
<li>master节点会不断将sql命令写入Binary Log，子节点使用I/O线程读入master节点中的Bin Log</li>
<li>字节点使用SQL线程执行Bin Log的语句</li>
</ul>
</li>
</ul>
</li>
<li>存储引擎的区别：MyISAM 和 InnoDB 的区别<ul>
<li>MySQL的存储引擎采用的是插件式架构，支持多种存储引擎，我们甚至可以为不同的数据库表设计不同的存储引擎，存储引擎是基于表而不是数据库的。</li>
<li>InnodDB支持事务</li>
<li>InnoDB支持行级锁定，MyISAM操作时直接锁定整个表</li>
<li>InnoDB支持外键和级联删除/更新</li>
<li>InnoBD存储数据更大</li>
<li>崩溃恢复更好</li>
<li>InnoDB以聚簇的方式存储数据，MyISAM是将数据和索引分开存储</li>
<li>InnoDB支持MVCC</li>
</ul>
</li>
<li>事务：<ul>
<li>并发事务带来了哪些问题：<ol>
<li>脏读：一个事务读到了另一个事务修改后回滚的数据</li>
<li>丢失修改:两个事务同时修改一个数据，先提交的会丢失修改</li>
<li>不可重复读：执行相同的两个语句，结果不一样</li>
<li>幻读：多了记录或者是少了记录<ul>
<li>3和4的区别：3是记录被修改，4是记录条数变化</li>
</ul>
</li>
</ol>
</li>
<li>mysql中的隔离等级： 默认是可重复读，能够防止幻读 实现是通过 <strong>锁和MVCC(多版本控制并发控制)</strong> 实现的<ol>
<li>读未提交：允许事务读取未提交的事务的修改，会出现脏读，幻读，不可重复读</li>
<li>读已提交：只能读到提交的事务的修改，避免脏读，但是还有幻读 （读数据时加上共享锁，读取后立刻释放）</li>
<li>可重复读：同一事务中，多次读取统一数据返回结果要一致 (事务结束才释放锁，同时使用MVCC来保证每个事务都看到一个一致的快照)</li>
<li>可串行化：强制事务串行执行，影响效率</li>
</ol>
</li>
<li>MVCC的原理：</li>
<li>这两个隐藏的列就是undo log日志<img src="/2023/08/02/58/undolog.png" alt="|700"><ul>
<li>这俩就是隐藏列，trx_id当前修改之后的事务id，roll_pointer指向修改之前的信息</li>
<li><img src="/2023/08/02/58/undolog%E8%A1%A8.png" alt="|725"></li>
<li>MVCC实现原理：ReadView<ul>
<li>主要内容：<ul>
<li>m_ids:生成ReadView时当前系统活跃的读写事务id列表</li>
<li>min_trx_id:在生成ReadView时当前系统活跃的读写事务中最小的事务id，也就是min (m_ids)</li>
<li>max_trx_id:表示生成ReadVeiw时系统应该分配给下下一个事务的id值</li>
<li>creator_trx_id：表示生成该ReadView的事务id</li>
</ul>
</li>
<li>原理：在访问某条记录时根据以下方式来判断：<ol>
<li>trx_id == creator_trx_id，表示是自己修改过的记录，可见</li>
<li>trx_id &lt; min_trx_id 可以被访问</li>
<li>trx_id &gt; max_trx_id，不可被访问</li>
<li>trx_id &gt; min  &amp;&amp; trx_id &lt; max 需要判断：如果trx_id在m_ids中，表示仍然活跃，不可访问，不在表示已经被提交，可以访问了</li>
<li>如果某个版本对当前事务不可见，则顺着版本连找下一个版本的数据，直到最后，如果最后一个版本也不可见的话，意味着这条记录对这个事务完全不可见，查询结果不返回这个记录</li>
</ol>
</li>
<li>读已提交每次读都会生成一个ReadView，而可重复读智慧在第一次执行查询语句时生成一个ReadView</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>索引常问：<ul>
<li>覆盖索引：查询使用了索引，并且查询过程中已经找到了所有需要的列，不需要继续回表了</li>
<li>索引失效问题：<ol>
<li>使用了!= &lt; &gt; LIKE ，函数操作或者表达式操作</li>
<li>联合索引中没有遵循最左前缀，跳过了中间的索引字段</li>
<li></li>
</ol>
</li>
</ul>
</li>
<li>SQL语句：<ul>
<li>常见函数：<ol>
<li>Concat()把多列拼接在一起</li>
<li>RTrim() 去除多有空格</li>
<li>AS给列起别名</li>
</ol>
</li>
<li>存储过程：存储过程是一种在数据库中存储的预编译的SQL语句集合，可以通过调用它的名字来执行。存储过程可以接收参数，并且可以返回值，长哟个与进行批处理<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">USE test;
CREATE PROCEDURE productpricing()
BEGIN
	SELECT * FROM hello;
END;

调用
CALL productpricing()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
</li>
</ul>
<h3 id="InooDB详解"><a href="#InooDB详解" class="headerlink" title="InooDB详解"></a>InooDB详解</h3><ol>
<li>InooDB大小一般为16kb</li>
<li>InooDB页表:<img src="/2023/08/02/58/InnoDB%E6%95%B0%E6%8D%AE%E9%A1%B5.png"></li>
<li>File Header：<img src="/2023/08/02/58/FileHeader.png"></li>
<li>Page Header：<img src="/2023/08/02/58/PageHeader.png"></li>
<li>infimumu+supremum 最小记录和最大记录。不存放真是数据<img src="/2023/08/02/58/%E6%95%B0%E6%8D%AE%E9%A1%B5%E8%AF%A6%E8%A7%A3.png"><ul>
<li>heap_no分别为0和1， record_type分为4种，0普通记录，1表示B+树非叶节点记录，2最小记录，3最大记录。</li>
<li>next_record 由当前真实数据指向吓一跳记录的真实数据。吓一跳记录不是按照插入顺序的下一条，而是根据主键排序之后的下一条。infimum的下一条记录是用户记录中主键最小的，用户记录中主键最大的下一条指向supremum</li>
<li>为什么指向的是真是数据的开头？<ul>
<li>因为向左读取为记录头信息，向右读取真实数据。 记录头信息刚好是<strong>逆序的！</strong></li>
</ul>
</li>
<li><img src="/2023/08/02/58/next_record%E7%A4%BA%E4%BE%8B.png"></li>
</ul>
</li>
<li>User Record ： <ul>
<li>由额外记录信息和实际信息组成</li>
<li>额外记录：<ul>
<li>变长字段的真实数据的字节长度都放在记录的开头，逆序存放。不存放NULL的字节长度</li>
<li>NULLL值列表，NULL值存储在这里，并且是逆序存储，如果存在NULL值就不会存在这个列表</li>
<li>记录头信息：<img src="/2023/08/02/58/%E8%AE%B0%E5%BD%95%E5%A4%B4%E4%BF%A1%E6%81%AF.png"><ul>
<li>delete_mask标记的记录不会理科删除，而是会放在垃圾列表中，等待覆盖。</li>
<li>heap_no是根据主键的大小来确定的</li>
</ul>
</li>
</ul>
</li>
<li>真实信息：<ul>
<li><img src="/2023/08/02/58/%E9%9A%90%E8%97%8F%E5%88%97.png"></li>
<li>如果未指定主键，会生成row_id隐藏列</li>
</ul>
</li>
</ul>
</li>
<li>Page  Directory ：<ul>
<li>将正常的所有记录划分为几个组，包括最大和最小记录，不包括已删除的记录,最小记录所在的分组只包括自己。</li>
<li>每组最后一个记录的头信息中的n_ownd来表示该组中记录数。</li>
<li>将每组的最后一条记录的地址偏移量拿出来放入PageDirectory中，偏移量被称为槽(slot)</li>
<li><img src="/2023/08/02/58/PageDirectory%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F.png"></li>
</ul>
</li>
<li>File Trailer: 用于检验一个页是否完整：</li>
</ol>
<h3 id="索引："><a href="#索引：" class="headerlink" title="索引："></a>索引：</h3><h4 id="回表问题"><a href="#回表问题" class="headerlink" title="回表问题"></a>回表问题</h4><p>当查询的数据在索引树中找不到时，就需要回到主键索引树种去获取。<br>覆盖索引：<br>查询时从索引列就能够获取了，就不需要回到主键树中查找了</p>
<ul>
<li>前提<ol>
<li>数据页链表中的前后保证前一个数据页中的主键的最大值大于后一个页表中主键的最小值，也就主键递增，每一个页表内，主键也递增</li>
<li>建立一个目录项：包括 key:页中主键最小值 page_no:页号。</li>
<li><img src="/2023/08/02/58/%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86.png"></li>
</ol>
</li>
<li>mysql中的实现：<ol>
<li>使用用户记录的数据页来存储目录项，并且使用record_type = 1来标明，只包含key和page_no即可</li>
<li>使用双向列表来维护多个目录项</li>
<li>使用树的结构来重复建立索引，加快访问<img src="/2023/08/02/58/%E7%B4%A2%E5%BC%95.png"><img src="/2023/08/02/58/B+%E6%A0%91.png"></li>
<li>真正的数据页都放在最底层的叶子节点</li>
</ol>
<ul>
<li>聚簇索引：1. 使用主键值大小进行记录和排序 2. 叶子节点是完整的用户记录。索引即数据，数据即索引</li>
<li>二级索引：1.使用非主键值来进行记录和排序 2. 叶子节点存储的是索引键和主键的值 3. 查询到叶子节点之后需要再查找一变主键的索引来找到真正的用户记录。 优点是节省空间。<img src="/2023/08/02/58/%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95.png"></li>
<li>联合索引：1.使用多个列的大小来进行排序。先按照一个列排序，列大小相同时，使用下一个列大小来排序。2. 对于这多个列只需要建立一个B+树即可，节省了空间3.实质上也是二级索引</li>
<li>对比：MyISAM<ul>
<li>存储在一个文件中，按照插入顺序，有行号</li>
<li>索引放在另一个文件中，使用主键值+行号作为索引，所以全是二级索引，而且不能二分查找。</li>
</ul>
</li>
<li>SQL建立索引：每一个表会自动为主键或者unique建立一个聚簇索引，可使用语句指定建立其他列的索引<img src="/2023/08/02/58/sql%E5%BB%BA%E7%AB%8B%E7%B4%A2%E5%BC%95.png"></li>
<li>删除索引：ALTER TABLE index_demo DROP INDEX idx_c2_c3;</li>
</ul>
</li>
<li>独立表空间：<ol>
<li>区：表空间分为多个区，区包含多个页</li>
</ol>
</li>
</ul>
<h3 id="指令执行过程"><a href="#指令执行过程" class="headerlink" title="指令执行过程"></a>指令执行过程</h3><ul>
<li>select <ol>
<li>使用连接器连接mysql server,期间通过三次握手 show processlist来查看多少个客户端连接了</li>
<li>查询缓存(8.0) 已抛弃</li>
<li>解析SQL ：<ol>
<li>词法分析，根据字符串识别关键词，分类字符串</li>
<li>语法分析，语法解析器会根据语法规则来判断是否符合MySQL语法秒如果没问题就会构出SQL语法树</li>
</ol>
</li>
<li>执行SQL语句，<code>SELECT</code>&nbsp;查询语句流程主要可以分为下面这三个阶段：<ul>
<li>prepare 阶段，也就是预处理阶段；检查表和字段是否存在，将* 扩展为表上的列</li>
<li>optimize 阶段，也就是优化阶段；<strong>优化器主要负责将 SQL 查询语句的执行方案确定下来</strong>，比如在表里面有多个索引的时候，优化器会基于查询成本的考虑，来决定选择使用哪个索引。</li>
<li>execute 阶段，也就是执行阶段；根据执行计划执行 SQL 查询语句，从存储引擎读取记录，返回给客户端；</li>
</ul>
</li>
</ol>
</li>
<li>MySQL一行记录如何<ul>
<li>每建立一个数据库都会咋/var.lib/mysql/下建立一个同名的文件夹</li>
<li>文件夹中有三个文件</li>
<li>db.opt 用来存储数据库的默认字符集和字符检验规则</li>
<li>tableNaem.frm 对应的表结构会保存在这个文件，主要包含表结构的定义</li>
<li>tableName.ibd 表中的数据会保存在这个文件中</li>
</ul>
</li>
<li>表空间文件的结构 ：<ul>
<li><img src="/2023/08/02/58/%E8%A1%A8%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84.png"></li>
<li>段 <ul>
<li>索引段：存放 B + 树的非叶子节点的区的集合；</li>
<li>数据段：存放 B + 树的叶子节点的区的集合；</li>
<li>回滚段：存放的是回滚数据的区的集合，之前讲<a target="_blank" rel="noopener" href="https://xiaolincoding.com/mysql/transaction/mvcc.html">事务隔离&nbsp;(opens new window)</a>的时候就介绍到了 MVCC 利用了回滚段实现了多版本查询数据。</li>
</ul>
</li>
<li>区 InnoDB 使用的是B+树 以页为单位来来分配空间时，链表中相邻的两个页的物理位置是不连续的，为了防止随机I/O，可以按照区来分配，一个区可以包含多个页，这样页在位置上就是相邻的了可以使用顺序I/O</li>
<li>页 读取数据以页为单位，当读取一行时，会将一页一同读取出来，放入内存中 默认页 16kb ,页是 InnoDB 存储引擎磁盘管理的最小单元，</li>
<li>行 记录按照行<ul>
<li>行格式：COMPACT <img src="/2023/08/02/58/compact.png"><ul>
<li>变长字段长度列表，用于保存数据占用的大小， 在列表中采用逆序存放数据占用的实际字节，当一行中没有变长字段时，例如全int时，就不会存在变长字段列表了。</li>
<li>NULL列表，数据中为NULL 的数据会放在NULL值列表中的。NULL值也是按照逆序存储的，使用二进制 0 1 来表示是否为NULL值，1 为是  <strong>当数据表的字段都定义成 NOT NULL 的时候，这时候表里的行格式就不会有 NULL 值列表了</strong>。</li>
<li>记录头信息</li>
<li>delete_mask ：标识此条数据是否被删除。从这里可以知道，我们执行 detele 删除记录的时候，并不会真正的删除记录，只是将这个记录的 delete_mask 标记为 1。</li>
<li>next_record：下一条记录的位置。从这里可以知道，记录与记录之间是通过链表组织的。在前面我也提到了，指向的是下一条记录的「记录头信息」和「真实数据」之间的位置，这样的好处是向左读就是记录头信息，向右读就是真实数据，比较方便。</li>
<li>record_type：表示当前记录的类型，0表示普通记录，1表示B+树非叶子节点记录，2表示最小记录，3表示最大记录</li>
</ul>
</li>
<li>真实数据部分<ul>
<li>row_id 未指定主键或者唯一约束列时，会有，占用6个字节</li>
<li>trx_id事务id表示数据由哪个事务生成的，必需</li>
<li>roll_pointer 记录上一个版本的指针，必需</li>
</ul>
</li>
</ul>
</li>
<li><strong>一行数据的最大字节数 65535(不包含 TEXT、BLOBs 这种大对象类型)，其实是包含「变长字段长度列表」和 「NULL 值列表」所占用的字节数的</strong></li>
<li>如果一个数据页存不了一条记录，InnoDB 存储引擎会自动将溢出的数据存放到「溢出页」中。</li>
</ul>
</li>
</ul>
<p>Compact 行格式针对行溢出的处理是这样的：当发生行溢出时，在记录的真实数据处只会保存该列的一部分数据，而把剩余的数据放在「溢出页」中，然后真实数据处用 20 字节存储指向溢出页的地址，从而可以找到剩余数据所在的页。</p>
<p>Compressed 和 Dynamic 这两种格式采用完全的行溢出方式，记录的真实数据处不会存储该列的一部分数据，只存储 20 个字节的指针来指向溢出页。而实际的数据都存储在溢出页中。<br>索引分类：</p>
<ul>
<li>按「数据结构」分类：<strong>B+tree索引、Hash索引、Full-text索引</strong>。</li>
<li>按「物理存储」分类：<strong>聚簇索引（主键索引）、二级索引（辅助索引）</strong>。</li>
<li>按「字段特性」分类：<strong>主键索引、唯一索引、普通索引、前缀索引</strong>。</li>
<li>按「字段个数」分类：<strong>单列索引、联合索引</strong>。</li>
</ul>
<h3 id="MySql查询优化"><a href="#MySql查询优化" class="headerlink" title="MySql查询优化"></a>MySql查询优化</h3><ul>
<li>单表 <ol>
<li>根据搜索条件，找出所有可能使用的索引</li>
<li>计算全表扫描的代价</li>
<li>计算使用不同索引执行查询的代价</li>
<li>对比各种执行方案的代价，找出成本最低的那一个</li>
</ol>
</li>
<li>多表连接：<ol>
<li>单次查询驱动表的成本</li>
<li>多次查询被驱动表的成本（具体查询多少次取决于对驱动表查询的结果集中有多少条记录）</li>
</ol>
</li>
<li>连接查询成本占大头的其实是 驱动表扇出数 x 单次访问被驱动表的成本 ，所以我们的优化<ol>
<li>重点其实是下边这两个部分：</li>
<li>尽量减少驱动表的扇出</li>
<li>对被驱动表的访问成本尽量低</li>
</ol>
</li>
</ul>
<h3 id="Buffer-Pool-缓冲池"><a href="#Buffer-Pool-缓冲池" class="headerlink" title="Buffer Pool 缓冲池"></a>Buffer Pool 缓冲池</h3><p>脏页：缓冲池中的数据已经修改但是没有同步到磁盘中</p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h3><ul>
<li>模式: 逻辑模式，是开发者可见的模式，是数据库中全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图。</li>
<li>外模式:子模式，用户模式，用户可见</li>
<li>内模式: 存储模式，是物理存储模式</li>
</ul>
<h2 id="schema-和-database-区别"><a href="#schema-和-database-区别" class="headerlink" title="schema 和 database 区别"></a>schema 和 database 区别</h2><p>database 是一栋楼，schema(模式) 是一个个房间，但是在mysql中两种没有区别。</p>
<ul>
<li>视图和表的区别：视图是表的子集，常用于将查询结果保存在视图中，方便再次调用</li>
<li>语法：’CREATE VIEW viewName AS 查询出来的表’</li>
</ul>
<h2 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h2><ul>
<li>1NF 保证原子性即可，不可再分割了</li>
<li>2NF 要有主键，且不存在部份依赖，也就是其他非主键的部分要治理来于主键即可</li>
<li>3NF 非主键之间不存在传递依赖，例如 学号, 姓名, 年龄, 学院名称, 学院电话，满足第二范式，因为后面几个属性都要和主键相关联，不能独立存在，但是通过 学号 -&gt; 学生 -&gt; 所在院 -&gt; 院电话 ，所以存在传递依赖应修改为：学生：(学号, 姓名, 年龄, 所在学院)；学院：(学院，学院名称， 电话)。</li>
<li>BCNF 消除几个主键之间的传递依赖</li>
</ul>
<h2 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a><a target="_blank" rel="noopener" href="https://xiaolincoding.com/mysql/transaction/mvcc.html#%E4%BA%8B%E5%8A%A1%E6%9C%89%E5%93%AA%E4%BA%9B%E7%89%B9%E6%80%A7">ACID</a></h2><ul>
<li><p>Atomicity（原子性）：一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被恢复（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。</p>
</li>
<li><p>Consistency（一致性）：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。</p>
</li>
<li><p>Isolation（隔离性）：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。</p>
</li>
<li><p>Durability（持久性）：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</p>
</li>
</ul>
<h2 id="E-R模型"><a href="#E-R模型" class="headerlink" title="E-R模型"></a>E-R模型</h2><p>E-R模型是Entity-Relationship模型的缩写，是一种用于数据库设计的概念性数据模型。它用来描述现实世界中的数据之间的关系，以及这些数据的属性。E-R模型提供了一种图形化的方式来表示数据模型，使数据库设计师能够更容易地理解和规划数据库结构。</p>
<p>E-R模型包括以下几个核心概念：</p>
<ol>
<li><p>实体（Entity）：实体是现实世界中可以被识别的独立对象，例如人、物品、地点或概念。每个实体都有一些属性，用来描述这个实体的特征。</p>
</li>
<li><p>属性（Attribute）：属性是描述实体的特征或属性，它们用来存储有关实体的信息。例如，对于一个”人”实体，属性可以包括姓名、年龄、性别等。</p>
</li>
<li><p>关系（Relationship）：关系表示不同实体之间的联系或连接。关系可以是一对一、一对多或多对多的。例如，一个”雇员”实体可以与一个”部门”实体之间有一个”属于”关系，表示雇员属于某个部门。</p>
</li>
<li><p>主键（Primary Key）：主键是一个属性或属性组合，用来唯一标识实体集中的每个实体。它确保了每个实体都具有唯一的标识。</p>
</li>
<li><p>外键（Foreign Key）：外键是一个实体中的属性，它引用了另一个实体的主键，用于建立实体之间的关联。</p>
</li>
</ol>
<p>通过使用E-R模型，数据库设计师可以更好地理解数据之间的关系，从而规划数据库的结构，包括表的设计、关系的建立和数据的存储。一旦E-R模型完成，它可以用作设计数据库架构的基础，进而创建物理数据库模式（如关系模型），以实际存储和管理数据。这有助于确保数据库能够有效地存储和检索信息，并满足应用程序的需求。</p>
<h2 id="自联结，变量不会，补一补去"><a href="#自联结，变量不会，补一补去" class="headerlink" title="自联结，变量不会，补一补去"></a>自联结，变量不会，补一补去</h2><p>打开</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mysql <span class="token parameter variable">-u</span> root <span class="token parameter variable">-p</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><strong>数据类型</strong></p>
<p>关系型数据库：建立在关系模型基础上，由多张相互链接的二维表组成的数据库</p>
<h2 id="SQL语句"><a href="#SQL语句" class="headerlink" title="SQL语句"></a>SQL语句</h2><ol>
<li><p><strong>数值类型</strong></p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">TINYINT 1byte -128 - 127  0 - 255 /*后面加上unsigned 即可指定为无符号*/
SMALLINT 2
MEDIUMINT 3
INT 4
BIGINT 8
FLOAT 4
DOUBLE 8
DECIMAL 看精度和标度  125.25 精度为5 标度为2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

</li>
<li><p><strong>字符串类型</strong></p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">CHAR() 定长字符串
VARCHAR 根据内容计算字符串长度
TINYTEXT 短文本字符串<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li>
<li><p><strong>日期类</strong></p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">DATE YYYY-MM-DD
TIME HH:MM:SS
YEAR YYYY
DATETIME YYYY-MM-DD HH:MM:SS
TIMESTAMP YYYY-MM-DD HH:MM:SS 时间戳<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>常用函数</p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">DATE_FORMAT()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<blockquote>
<p><strong>时间戳记</strong>或称为<strong>时间标记</strong>（英语：timestamp）是指字符串或编码信息用于辨识记录下来的时间日期。国际标准为<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/ISO_8601" title="ISO 8601">ISO 8601</a>。</p>
<p>时间戳记的范例如下：</p>
<ul>
<li>2016-12-25T00:15:22Z</li>
<li>2005-10-30 10:45&nbsp;<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/UTC" title="UTC">UTC</a></li>
<li>Sat Jul 23 02:16:57 2005</li>
<li>2016年12月25日 (日) 00:14 (UTC)</li>
</ul>
</blockquote>
</li>
</ol>
<p>注释 # 或者 /**/</p>
<ol>
<li>DDL (Data Definition Language 数据定义语言）用于操作对象及对象本身，这种对象包括数据库,表对象，及视图对象，表头 ^c501f6</li>
<li>DML （Data Manipulation Language 数据操控语言) 用于操作数据库对象对象中包含的数据</li>
<li>DQL (Data Query Language 数据查询语言 )用于查询数据</li>
<li>DCL （Data Control Language 数据控制语句） 用于操作数据库对象的权限</li>
</ol>
<h3 id="DDL-Data-Definition-Language-数据定义语言）用于操作对象及对象本身，这种对象包括数据库-表对象，及视图对象，表头"><a href="#DDL-Data-Definition-Language-数据定义语言）用于操作对象及对象本身，这种对象包括数据库-表对象，及视图对象，表头" class="headerlink" title="DDL (Data Definition Language 数据定义语言）用于操作对象及对象本身，这种对象包括数据库,表对象，及视图对象，表头"></a>DDL (Data Definition Language 数据定义语言）用于操作对象及对象本身，这种对象包括数据库,表对象，及视图对象，表头</h3><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SHOW DATABASES 查询所有的数据库
SELECT DATABASE(); 查询当前所处数据库
CREATE DATABASE  创建
DROP DATABASE XXX 删除
USE xxx  使用数据库
SHOW TABLES 查询当前数据库的所有表
DESC 表名   查询表结构
SHOW CREATE TABLE 表明 查询指定表的建表语句
	字段1 字段1类型 COMMENT 'XXX',/*注释*/
     ........
    
) COMMENTT 'XXX'/*注释可以省略*/
/*字符串类型是varchar(指定的字符长度)*/
/*修改表*/
ALTER TABLE tablename 
1.ADD字段名 类型 comment xxx 添加表头
2.CHANGE 旧 新 类型 comment xxx 修改
3.DROP name
4.RENAME TO name 修改表名

DROP TABLE name 删除
TRUNCATE TABLE name 删除并重新创建同名表，数据依旧会删除<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="DML-（Data-Manipulation-Language-数据操控语言-用于操作数据库对象对象中包含的数据"><a href="#DML-（Data-Manipulation-Language-数据操控语言-用于操作数据库对象对象中包含的数据" class="headerlink" title="DML （Data Manipulation Language 数据操控语言) 用于操作数据库对象对象中包含的数据"></a>DML （Data Manipulation Language 数据操控语言) 用于操作数据库对象对象中包含的数据</h3><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">/*添加数据*/
INSERT INTO 表名(字段名) VALUES (数值) 给指定字段添加数据
INSERT INTO 表名  VALUES (数值) 给所有字段加上数据
INSERT INTO 表明(字段名) VALUES (数据) ,(数据)
INSERT INTO 表明 VALUE (数据),(数据)...
/*修改*/
UPDATE 表名 SET 字段名=值, .... WHERE 条件
DELETE 表名 (WHERE 条件) /*删除*/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><p>语句：INSERT</p>
<p>前提:<em><strong><u>获得权限</u></strong></em></p>
<p>用法：</p>
<blockquote>
<p> 插入完整的行；</p>
<p> 插入行的一部分；</p>
<p> 插入某些查询的结果。</p>
</blockquote>
<p>语法：</p>
   <pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">INSERT INTO Customers 
VALUES('1000000006', 
 'Toy Land', 
 '123 Any Street', 
 'New York', 
 'NY', 
 '11111', 
 'USA', 
 NULL, 
 NULL);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>   更加安全的操作,将要插入的列也列出</p>
   <pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">INSERT INTO Customers(cust_id, 
 cust_name, 
 cust_address, 
 cust_city, 
 cust_state, 
 cust_zip, 
 cust_country, 
 cust_contact, 
 cust_email) 
VALUES('1000000006', 
 'Toy Land', 
 '123 Any Street', 
 'New York', 
 'NY', 
 '11111', 
 'USA', 
 NULL, 
 NULL);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ol start="2">
<li><p>插入列的一部分，语法和上面一样，只是不需要插入的列可以省略不写，列名不写，对应的数据也不写</p>
</li>
<li><p>插入检索出的数据</p>
<p>语法：</p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SELECT cust_id, 
 cust_contact, 
 cust_email, 
 cust_name, 
 cust_address, 
 cust_city, 
 cust_state, 
 cust_zip, 
 cust_country 
FROM CustNew;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><u>它使用的是列的位置，因此 SELECT 中的第一列（不管</u></p>
<p><u>其列名）将用来填充表列中指定的第一列，第二列将用来填充表列中</u></p>
<p><u>指定的第二列，如此等等</u></p>
<p>INSERT SELECT 中 SELECT 语句可以包含 WHERE 子句，以过滤插入的数据。</p>
<p>INSERT 通常只插入一行。要插入多行，必须执行多个 INSERT 语句。</p>
<p>INSERT SELECT是个例外，它可以用一条INSERT插入多行，不管SELECT</p>
<p>语句返回多少行，都</p>
</li>
<li><p>从一个表复制到另一个表</p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">CREATE TABLE CustCopy AS 
SELECT * FROM Customers;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p><u>SELECT INTO 是试验新 SQL 语句前进行表复制的很好工具。先进行复</u></p>
<p><u>制，可在复制的数据上测试 SQL 代码，而不会影响实际的数据。</u></p>
<h2 id="更新与删除"><a href="#更新与删除" class="headerlink" title="更新与删除"></a>更新与删除</h2><h3 id="更新：UPDATE-注意要用WHERE-否则会出事"><a href="#更新：UPDATE-注意要用WHERE-否则会出事" class="headerlink" title="更新：UPDATE 注意要用WHERE 否则会出事"></a>更新：UPDATE 注意要用WHERE 否则会出事</h3><ol>
<li><p>更新特定行</p>
<p>语法：</p>
<p> 要更新的表；</p>
<p> 列名和它们的新值；</p>
<p> 确定要更新哪些行的过滤条件。</p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">UPDATE Customers 
SET cust_email = 'kim@thetoystore.com' 
WHERE cust_id = '1000000005';<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>UPDATE 语句以 WHERE 子句结束，它告诉 DBMS 更新哪一行。没有 WHERE</p>
<p>子句，DBMS 将会用这个电子邮件地址更新 Customers 表中的所有行，</p>
<p>这不是我们希望的。</p>
</blockquote>
</li>
<li><p>更新特定列</p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">UPDATE Customers 
SET cust_contact = 'Sam Roberts', 
 cust_email = 'sam@toyland.com' 
WHERE cust_id = '1000000006';<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>在更新多个列时，只需要使用一条 SET 命令，每个“列=值”对之间用</p>
<p>UPDATE 语句中可以使用子查询，使得能用 SELECT 语句检索出的数据</p>
<p>更新列数据</p>
<p>要删除某个列的值，可设置它为 NULL（假如表定义允许 NULL 值）</p>
</blockquote>
</li>
</ol>
</li>
</ol>
<h4 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h4><p>DELETE  注意WHERE 缺少是会出事的</p>
<p> 从表中删除特定的行</p>
<p> 从表中删除所有行。</p>
<ol>
<li><p>删除特定行</p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">DELETE FROM Customers 
WHERE cust_id = '1000000006';<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<blockquote>
<p>DELETE 语句从表中删除行，甚至是删除表中所有行。但是，DELETE</p>
<p>不删除表本身</p>
<p>果想从表中删除所有行，不要使用 DELETE。可使用 TRUNCATE +TABLE +表名</p>
<p>语句，它完成相同的工作，而速度更快（因为不记录数据的变动）。</p>
</blockquote>
</li>
<li><p>删除全部行</p>
<blockquote>
<p>如果执行 DELETE 语句而不带 WHERE</p>
<p>子句，表的所有数据都将被删除</p>
</blockquote>
</li>
</ol>
<h3 id="DQL-Data-Query-Language-数据查询语言-用于查询数据"><a href="#DQL-Data-Query-Language-数据查询语言-用于查询数据" class="headerlink" title="DQL (Data Query Language 数据查询语言 )用于查询数据"></a>DQL (Data Query Language 数据查询语言 )用于查询数据</h3><blockquote>
<p>SELECT + 字段列表<br>FROM  表名列表<br>WHERE 条件列表<br>[[数据库#^aa4a30|GROUP BY 分组字段列表]]<br>HAVING 分组后条件列表<br>ORDER BY 排序<br>LIMIT  分页参数<br>[[数据库#^1cd456|AS 设置别名]]<br>WHRER 和 HAVING 的区别，WHERE 在分组之前起作用，HAVING在分组之后起作用</p>
</blockquote>
<h4 id="SELECT"><a href="#SELECT" class="headerlink" title="SELECT"></a>SELECT</h4><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SELECT 字段1，... FROM 表 或者 SELECT * FROM
SELECT DISTINCT 去重
SELECT 字段 AS 别名  ... FROM 设置字段的别名
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>条件</p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SELECT XXX FROM XXX WHERE +
&gt; &gt;= &lt; &lt;= = &lt;&gt;(不等于，相当于!=) BETWEEN ... AND ... 
IN (...) 满足列表中的其一
LIKE 包含这个字符 模糊匹配
'%a'     //以a结尾的数据
'a%'     //以a开头的数据
'%a%'    //含有a的数据
'_a_'    //三位且中间字母是a的
'_a'     //两位且结尾字母是a的
'a_'     //两位且开头字母是a的
'___'    //含有三个字符的
'[]'     //类似正则表达式
'[^]'    //不包含括号之内的单个字符<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>聚合函数:将一列数据作为一个整体，进行纵向计算</p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SELECT +
count 
max
min
avg 平均值
sum
+ 字段列表
+  FROM 表名<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>分组查询 ^aa4a30</p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SELECT 字段名 FROM 表 WHERE GROUP BY 分组字段名 HAVING 分组之后的过滤条件<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>排序查询</p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SELECT xx FROM 表名 ORDER BY 字段1 排序方式(ASC升序，DESC 降序)
，字段2 XXX <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><u>分页查询</u></p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SELECT xx FROM XXX LIMIT (起始索引，查询记录数)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>等于OFFSET n ROWS<br>FETCH NEXY M ROWS ONLY 跳过n行，并返回接下来的m行</p>
<h3 id="DCL-（Data-Control-Language-数据控制语句）-用于操作数据库对象的权限"><a href="#DCL-（Data-Control-Language-数据控制语句）-用于操作数据库对象的权限" class="headerlink" title="DCL （Data Control Language 数据控制语句） 用于操作数据库对象的权限"></a>DCL （Data Control Language 数据控制语句） 用于操作数据库对象的权限</h3><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SELECT * FORM user
CREATE USER '用户名'@'主机名' IDENTIFIED BY '/'/*使用%来指定任意主机都可以访问*/
ALTER USER '用户名' @ '主机名' IDENTIFIED WITH  mysql_native_password BY '新密码'  修改密码
DROP USER '用户名' @ '主机名' 删除用户
/*权限控制*/
SHOW GRANT FOR '用户名'@'主机名'
GRANT 权限列表 ON 数据库名 表名 TO '用户名'@'主机名'
取消权限
REVOKE 权限列表 ON 数据库名 表名 FROM '用户名'@'主机名'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="函数-配合SELECT-使用"><a href="#函数-配合SELECT-使用" class="headerlink" title="函数 配合SELECT 使用"></a>函数 配合SELECT 使用</h2><h3 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h3><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">CONCAT (s1,s2...) 拼接
LOWER(str)
UPPER(str)
LPAD(str,n,pad) 左填充，用pad来填充原字符串，填充n次
RPAD 右填充
TRIM(str) 去掉首位的空格
SUBSTRING(str,start,len) <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="数值函数"><a href="#数值函数" class="headerlink" title="数值函数"></a>数值函数</h3><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">CEIL() 向上取整
FLOOR() 向下取整
MOD(x,y) x % y
RAND() 0-1内的随机数
ROUND(x,y) 四舍五入保留y位小数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a><em>日期函数</em></h3><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">CURDATE() 返回当前日期
CURTIME()
NOW() 当前日期和时间
YEAR(date) 获取指定日期的年份
MONTH(date)
DAY(date)
DATE_ADD(date,interval expr type) 返回一个日期/时间加上时间间隔expr后的时间
DATEDIFF(date1,date2) 返回两个日期相差的天数
timestampdiff(间隔类型，前一个时间，后一个时间) 计算日期查
例如: timestampdiff(YEAR,hiredate,now()))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="流程函数"><a href="#流程函数" class="headerlink" title="流程函数"></a><em>流程函数</em></h3><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">if (value,t,f) 如果value true 返回t 否则返回f
IFNULL(v1,v2) 如果v1不为空返回v1,否则返回v2
CASE WHEN (v1) THEN (res1)
WHEN (v2) THEN (res2)
....
ELSE default END
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="约束-作用域表中字段上的规则，用于限制存储在表中的数据"><a href="#约束-作用域表中字段上的规则，用于限制存储在表中的数据" class="headerlink" title="约束 作用域表中字段上的规则，用于限制存储在表中的数据"></a>约束 作用域表中字段上的规则，用于限制存储在表中的数据</h2><p>目的是未来保证数据库中数据的正确性和完整性有效性<br>分类</p>
<blockquote>
<p>非空约束，字段不能为null     关键字: NOT NULL<br>唯一约束 字段不能重复           UNIQUE<br>主键约束 主键是一行数据的唯一表示，要求非空且唯一 PRIMARY KEY<br>默认约束 使用默认值 DEFAULT<br>检查约束 保证字段值满足某一个条件 CHECK<br>外键约束 来让两整表之间建立练习，保证数据的一致性 FOREIGN KEY</p>
</blockquote>
<p>示例：</p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">create table user  
(  
    name   varchar(10) not null unique comment '姓名不为空且不能重复',  
    age    int check ( age &gt; 0 &amp;&amp; age &lt;= 120) comment '年龄检查为0-120',  
    status char(1) default '1' comment '状态默认为1',  
    gender char(1) comment '性别'  
) comment '用户表';
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>外键</p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">1.建表时
CREATE TABLE (
 ....
 ....
 CONSTRAINT 外键名称 FOREGIN KEY (外键字段名) REFERENCES 主表列名
)
2. ALTER TABLE 表 ADD CONSTRAINT 外键名(自定义) FOREIGN KEY (本表)字段名 REFERENCES 外表+(字段名)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>删除/更新</p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">ALTER TABLE 表 ADD CONSTRAINT 外键名(自定义) FOREIGN KEY (本表)字段名 REFERENCES 外表+(字段名) ON UPDATE 更新时的操作  ON DELETE 删除时要执行的操作
操作有
NO ACTION 在父表中删除/更新时，首先检查，该记录是否有外键，如果有则不允许更新或者删除
RESTRICT  同 NO ACTION 
CASCADE 可以删除/更新外键在子表中的记录
SET NULL 设置子表中的外键记录为NULL
SET DEFAULT 设置为一个默认值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h2><blockquote>
<p>多表关系：<br>一对多 多的一方建立外键指向一<br>多对多 建立第三张中间表，中间表至少包含两个外键，分别关联两方<br>一对一 任意一方加上外键并设置为UNIQUE</p>
</blockquote>
<h3 id="子查询："><a href="#子查询：" class="headerlink" title="子查询："></a>子查询：</h3><p>查询嵌套，括号内的查询结果作为括号外的条件 例子：</p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SELECT cust_id 
FROM Orders 
WHERE order_num IN (SELECT order_num 
 FROM OrderItems 
 WHERE prod_id = 'RGAN01');			<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>或者</p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SELECT cust_name, 
 cust_state, 
 (SELECT COUNT(*) 
 FROM Orders 
 WHERE Orders.cust_id = Customers.cust_id) AS orders 
FROM Customers 
ORDER BY cust_name;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>标量子查询<br>子查询返回单个值<br>列子查询，返回结果是一列或者多行<br>常用操作符号</p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">IN
NOT IN
ANY
SOME  和ANY相同
ALL <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>行子查询，返回一行或者是多列</p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">= &lt; &gt; IN NOT IN <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>表子查询<br>返回多行多列<br>常用IN 来进行查询</p>
<h2 id="联结表"><a href="#联结表" class="headerlink" title="联结表"></a>联结表</h2><ol>
<li>内联结</li>
</ol>
<p>比如</p>
<p>进行数据存储的时候，会指定一种联系方式</p>
<p>可以类比为散列表或者map</p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SELECT vend_name, prod_name, prod_price 
FROM Vendors, Products 
WHERE Vendors.vend_id = Products.vend_id;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>正式用法</p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SELECT vend_name, prod_name, prod_price 
FROM Vendors INNER JOIN Products 
 ON Vendors.vend_id = Products.vend_id;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>on之后的式匹配规则，同时为了防止冲突，尽量用点来获取每个不同的库的数据</p>
<p>联结多个表</p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SELECT prod_name, vend_name, prod_price, quantity 
FROM OrderItems, Products, Vendors 
WHERE Products.vend_id = Vendors.vend_id 
 AND OrderItems.prod_id = Products.prod_id 
 AND order_num = 20007;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>2.自联结</p>
<p><u>联结中仍然可以使用内聚函数</u></p>
<p>例如</p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SELECT Customers.cust_id, 
 COUNT(Orders.order_num) AS num_ord 
FROM Customers INNER JOIN Orders 
 ON Customers.cust_id = Orders.cust_id 
GROUP BY Customers.cust_id;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p>统一表内联结自己</p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SELECT c1.cust_id, c1.cust_name, c1.cust_contact 
FROM Customers AS c1, Customers AS c2 
WHERE c1.cust_name = c2.cust_name 
 AND c2.cust_contact = 'Jim Jones';<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>



<p>3.自然联结</p>
<blockquote>
<p>自然联结排除多次出现，使每一列只返回一次。</p>
</blockquote>
<blockquote>
<p>自然联结要求你只能选择那些唯一的列，一般通过对一个表使用通配符</p>
<p>（SELECT *），而对其他表的列使用明确的子集来完成。</p>
</blockquote>
<p>要自己完成，系统不提供</p>
<p>事实上，我们迄今为止建立的每个内联结都是自然联结，很可能永远都</p>
<p>不会用到不是自然联结的内联结。</p>
<p>4.外联结</p>
<blockquote>
<p>联结包含了那些在相关表中没有关联行的行。这种联结</p>
<p>称为外联结。</p>
</blockquote>
<p>语法：</p>
<p>內联结：</p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SELECT Customers.cust_id, Orders.order_num 
FROM Customers INNER JOIN Orders 
 ON Customers.cust_id = Orders.cust_id;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>外联结：<br>使用场景</p>
<ul>
<li><p><input disabled="" type="checkbox"> 
对每个顾客下的订单进行计数，包括那些至今尚未下订单的顾客；</p>
</li>
<li><p><input disabled="" type="checkbox"> 
列出所有产品以及订购数量，包括没有人订购的产品；</p>
</li>
<li><p><input disabled="" type="checkbox"> 
计算平均销售规模，包括那些至今尚未下订单的顾客。</p>
</li>
</ul>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SELECT Customers.cust_id, Orders.order_num 
FROM Customers LEFT OUTER JOIN Orders 
 ON Customers.cust_id = Orders.cust_id;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>在使用 OUTER </p>
<p>JOIN 语法时，必须使用 RIGHT 或 LEFT 关键字指定包括其所有行的表</p>
<p>（RIGHT 指出的是 OUTER JOIN 右边的表，而 LEFT 指出的是 OUTER JOIN</p>
<p>左边的表）。</p>
<p>也就是left 将要联结左侧的那个表全部选出</p>
<p>right 将右侧的那个表全选出</p>
</blockquote>
<p><strong>全外联结</strong></p>
<p><u><em>Access、MariaDB、MySQL、Open Office Base 和 SQLite 不支持 FULL</em></u></p>
<blockquote>
<p>还存在另一种外联结，就是全外联结（full outer join），它检索两个表中</p>
<p>的所有行并关联那些可以关联的行。与左外联结或右外联结包含一个表</p>
<p>的不关联的行不同，全外联结包含两个表的不关联的行。</p>
</blockquote>
<h2 id="联结使用条件"><a href="#联结使用条件" class="headerlink" title="联结使用条件"></a>联结使用条件</h2><blockquote>
<p><strong><u> 注意所使用的联结类型。一般我们使用内联结，但使用外联结也有效。</u></strong></p>
<p><u><strong> 关于确切的联结语法，应该查看具体的文档，看相应的 DBMS 支持何</strong></u><u><strong>种语法（大多数 DBMS 使用这两课中描述的某种语法）。</strong></u></p>
<p><u><strong> 保证使用正确的联结条件（不管采用哪种语法），否则会返回不正确</strong></u></p>
<p><u><strong>的数据。</strong></u></p>
<p><u><strong> 应该总是提供联结条件，否则会得出笛卡儿积。</strong></u></p>
<p><u><strong> 在一个联结中可以包含多个表，甚至可以对每个联结采用不同的联结</strong></u></p>
<p><u><strong>类型。虽然这样做是合法的，一般也很有用，但应该在一起测试它们</strong></u></p>
<p><strong><u><strong>前分别测试每个联结。这会使故障排除更为简单。</strong></u></strong> </p>
</blockquote>
<h3 id="join区别"><a href="#join区别" class="headerlink" title="join区别"></a>join区别</h3><p><strong>普通的join是笛卡尔积，即为两张表的排列组合</strong></p>
<p><img src="/2023/08/02/58/join.jpg"></p>
<h2 id="起别名"><a href="#起别名" class="headerlink" title="起别名"></a>起别名</h2><p>在使用时直接用AS +别名就可以用了 ^1cd456</p>
<p><strong>只能每次用的时候起一次别名并且当时使用</strong></p>
<p>下一个语句别名就不能用了，要重新起名字</p>
<h2 id="UNION"><a href="#UNION" class="headerlink" title=" UNION "></a><u> UNION </u></h2><p>语法：</p>
<p>适用于从多个不同的表中挑选不同的列</p>
<blockquote>
<p>UNION 中的每个查询必须包含相同的列、表达式或聚集函数（不过，</p>
<p>各个列不需要以相同的次序列出）</p>
</blockquote>
<blockquote>
<p>UNION 从查询结果集中自动去除了重复的行；换句话说，它的行为与一</p>
<p>条 SELECT 语句中使用多个 WHERE 子句条件一样。</p>
<p>这是 UNION 的默认行为，如果愿意也可以改变它。事实上，如果想返回</p>
<p>所有的匹配行，可使用 UNION ALL 而不是 UNION</p>
</blockquote>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SELECT cust_name, cust_contact, cust_email 
FROM Customers 
WHERE cust_state IN ('IL','IN','MI') 
UNION 
SELECT cust_name, cust_contact, cust_email 
FROM Customers 
WHERE cust_name = 'Fun4All';<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><blockquote>
<p>SELECT 语句的输出用 ORDER BY 子句排序。在用 UNION 组合查询时，只</p>
<p>能使用一条 ORDER BY 子句，它必须位于最后一条 SELECT 语句之后。对</p>
<p>于结果集，不存在用一种方式排序一部分，而又用另一种方式排序另一部分的情况，因此不允许使用多条 ORDER BY 子句</p>
<p>用它来排序所有 SELECT 语句返回的所有结果。</p>
</blockquote>
<h2 id="建表"><a href="#建表" class="headerlink" title="建表"></a>建表</h2><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">CREATE TABLE A
( 
 prod_id CHAR(10) NOT NULL, 
 vend_id CHAR(10) NOT NULL, 
 prod_name CHAR(254) NOT NULL, 
 prod_price DECIMAL(8,2) NOT NULL, 
 prod_desc VARCHAR(1000) NULL 
);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>要指定行列,并且后跟列的数据</p>
<p>类型</p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">CREATE TABLE Orders 
( 
 order_num INTEGER NOT NULL, 
 order_date DATETIME NOT NULL, 
 cust_id CHAR(10) NOT NULL 
);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>不要把 NULL 值与空字符串相混淆。NULL 值是没有值，不是空字符串。</p>
<p>如果指定’’（两个单引号，其间没有字符），这在 NOT NULL 列中是允</p>
<p>许的。空字符串是一个有效的值，它不是无值。NULL 值用关键字 NULL</p>
<p>而不是空字符串</p>
<p>默认值在 CREATE TABLE 语句的列定义中用关键字 DEFAULT 指定</p>
</blockquote>
<p>更新表定义，可以使用 ALTER TABLE 语句。</p>
<blockquote>
<p>使用 ALTER TABLE 更改表结构，必须给出下面的信息：</p>
<p> 在 ALTER TABLE 之后给出要更改的表名（该表必须存在，否则将</p>
<p>出错）；</p>
<p> 列出要做哪些更改</p>
</blockquote>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">ALTER TABLE Vendors 
ADD vend_phone CHAR(20);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<blockquote>
<p>更改或删除列、增加约束或增加键，这些操作也使用类似的语法（注意，</p>
<p>下面的例子并非对所有 DBMS 都有效）：</p>
<p>输入▼</p>
<p>ALTER TABLE Vendors </p>
<p>DROP COLUMN vend_phone; </p>
</blockquote>
<blockquote>
<p><u><em><strong>使用 ALTER TABLE 要极为小心，应该在进行改动前做完整的备份（表</strong></em></u></p>
<p><u><em><strong>结构和数据的备份）。数据库表的更改不能撤销，如果增加了不需要的</strong></em></u></p>
<p><u><em><strong>列，也许无法删除它们。类似地，如果删除了不应该删除的列，可能</strong></em></u></p>
<p><u><em><strong>会丢失该列中的所有数据。</strong></em></u></p>
</blockquote>
<p>删除表（删除整个表而不是其内容）非常简单，使用 DROP TABLE 语句即可：</p>
<p>DELETE  只删除表的内容不删除表本身</p>
<h2 id="重新命名"><a href="#重新命名" class="headerlink" title="重新命名"></a>重新命名</h2><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">ALTER TABLE oldname RENAME TO newname;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><blockquote>
<p><u><em><strong>视图为虚拟的表。它们包含的不是数据而是根据需要检索数据的查询。</strong></em></u></p>
<p><u><em><strong>视图提供了一种封装 SELECT 语句的层次，可用来简化数据处理，重新</strong></em></u></p>
<p><u><em><strong>格式化或保护基础数据。</strong></em></u></p>
</blockquote>
<p>用视图将联结集合起来，也就是一个子查询，相当于一个API</p>
<p>创建 视图用 CREATE VIEW 语句来创建。与 CREATE TABLE 一样，CREATE VIEW</p>
<p>删除 删除视图，可以使用 DROP 语句，其语法为 DROP VIEW viewname;。</p>
<p>覆盖（或更新）视图，必须先删除它，然后再重新创建。</p>
<p>用法：</p>
<p>建立视图</p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">CREATE VIEW ProductCustomers AS 
SELECT cust_name, cust_contact, prod_id 
FROM Customers, Orders, OrderItems 
WHERE Customers.cust_id = Orders.cust_id 
 AND OrderItems.order_num = Orders.order_num;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这条语句创建一个名为 ProductCustomers 的视图，它联结三个表，返</p>
<p>回已订购了任意产品的所有顾客的列表。</p>
<p>使用视图</p>
<p>使用时，</p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SELECT cust_name, cust_contact 
FROM ProductCustomers 
WHERE prod_id = 'RGAN01';<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>也可以用于统一格式</p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">CREATE VIEW VendorLocations AS 
SELECT RTRIM(vend_name) || ' (' || RTRIM(vend_country) || ')' 
 AS vend_title 
FROM Vendors;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>之后可用</p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SELECT * 
FROM VendorLocations;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>用于过滤也一样</p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">CREATE VIEW CustomerEMailList AS 
SELECT cust_id, cust_name, cust_email 
FROM Customers 
WHERE cust_email IS NOT NULL;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>之后</p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SELECT * 
FROM CustomerEMailList;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>计算字段</p>
<pre class="line-numbers language-none"><code class="language-none">CREATE VIEW OrderItemsExpanded AS 
SELECT order_num, 
 prod_id, 
 quantity,
 item_price, 
 quantity*item_price AS expanded_price 
FROM OrderItems;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>之后</p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SELECT * 
FROM OrderItemsExpanded 
WHERE order_num = 20008;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<h2 id="存储（不会）"><a href="#存储（不会）" class="headerlink" title="存储（不会）"></a>存储（<u><em><strong>不会</strong></em></u>）</h2><blockquote>
<p>可以创建存储过程。简单来说，存储过程就是为以后使用而保存的一条</p>
<p>或多条 SQL 语句。可将其视为批文件，虽然它们的作用不仅限于批处理</p>
<p> 通过把处理封装在一个易用的单元中，可以简化复杂的操作（如前面</p>
<p>例子所述）。</p>
<p> 由于不要求反复建立一系列处理步骤，因而保证了数据的一致性。如</p>
<p>果所有开发人员和应用程序都使用同一存储过程，则所使用的代码都</p>
<p>是相同的。</p>
</blockquote>
<blockquote>
<p>EXECUTE AddNewProduct( ‘JTS01’, </p>
<p>‘Stuffed Eiffel Tower’, </p>
<p>6.49, </p>
<p>‘Plush stuffed toy with the text La </p>
<p>➥Tour Eiffel in red white and blue’ ); </p>
</blockquote>
<h2 id="管理事务处理（不会深入学习的时候再看）"><a href="#管理事务处理（不会深入学习的时候再看）" class="headerlink" title="管理事务处理（不会深入学习的时候再看）"></a>管理事务处理（不会深入学习的时候再看）</h2><blockquote>
<p>使用事务处理（transaction processing），通过确保成批的 SQL 操作要么</p>
<p>完全执行，要么完全不执行，来维护数据库的完整性</p>
</blockquote>
<blockquote>
<p> 事务（transaction）指一组 SQL 语句；</p>
<p> 回退（rollback）指撤销指定 SQL 语句的过程；</p>
<p> 提交（commit）指将未存储的 SQL 语句结果写入数据库表；</p>
<p> 保留点（savepoint）指事务处理中设置的临时占位符（placeholder），</p>
<p>可以对它发布回退（与回退整个事务处理不同）。</p>
</blockquote>
<p><strong>事务处理用来管理 INSERT、UPDATE 和 DELETE 语句。不能回退 SELECT</strong></p>
<p><strong>语句（回退 SELECT 语句也没有必要），也不能回退 CREATE 或 DROP 操</strong></p>
<p><strong>作。事务处理中可以使用这些语句，但进行回退时，这些操作也不撤销。</strong></p>
<h2 id="游标"><a href="#游标" class="headerlink" title="游标"></a>游标</h2><blockquote>
<p>有时，需要在检索出来的行中前进或后退一行或多行，这就是游标的用</p>
<p>途所在。游标（cursor）是一个存储在 DBMS 服务器上的数据库查询，</p>
<p>它不是一条 SELECT 语句，而是被该语句检索出来的结果集。在存储了</p>
<p>游标之后，应用程序可以根据需要滚动或浏览其中的数据。</p>
</blockquote>
<p>游标的选项和特性</p>
<blockquote>
<p> 能够标记游标为只读，使数据能读取，但不能更新和删除。</p>
<p> 能控制可以执行的定向操作（向前、向后、第一、最后、绝对位置、</p>
<p>相对位置等）。</p>
<p> 能标记某些列为可编辑的，某些列为不可编辑的。</p>
<p> 规定范围，使游标对创建它的特定请求（如存储过程）或对所有请求</p>
<p>可访问。</p>
<p> 指示 DBMS 对检索出的数据（而不是指出表中活动数据）进行复制，</p>
<p>使数据在游标打开和访问期间不变化。</p>
</blockquote>
<p>游标使用</p>
<blockquote>
<p> 在使用游标前，必须声明（定义）它。这个过程实际上没有检索数据，</p>
<p>它只是定义要使用的 SELECT 语句和游标选项。</p>
<p> 一旦声明，就必须打开游标以供使用。这个过程用前面定义的 SELECT</p>
<p>语句把数据实际检索出来。</p>
<p> 对于填有数据的游标，根据需要取出（检索）各行。</p>
<p> 在结束游标使用时，必须关闭游标，可能的话，释放游标（有赖于具</p>
<p>体的 DBMS）。</p>
<p>声明游标后，可根据需要频繁地打开和关闭游标。在游标打开时，可根</p>
<p>据需要频繁地执行取操作。</p>
</blockquote>
<p>创建游标</p>
<blockquote>
<p>使用 DECLARE 语句创建游标，这条语句在不同的 DBMS 中有所不同。</p>
<p>DECLARE 命名游标，并定义相应的 SELECT 语句，根据需要带 WHERE 和</p>
<p>其他子句。为了说明，我们创建一个游标来检索没有电子邮件地址的所</p>
<p>有顾客，作为应用程序的组成部分，帮助操作人员找出空缺的电子邮件</p>
<p>地址</p>
</blockquote>
<p>语法</p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">DECLARE CustCursor CURSOR 
FOR 
SELECT * FROM Customers 
WHERE cust_email IS NULL<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>使用游标</p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">OPEN CURSOR CustCursor<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>关闭游标</p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">CLOSE CustCursor 
DEALLOCATE CURSOR CustCursor<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>



<h2 id="约束（不会捏）"><a href="#约束（不会捏）" class="headerlink" title="约束（不会捏）"></a>约束（不会捏）</h2><blockquote>
<p>DBMS 通过在数据库表上施加约束来实施引用完整性。大多数约束是在</p>
<p>表定义中定义的，如第 17 课所述，用 CREATE TABLE 或 ALTER TABLE</p>
<p>语句。</p>
</blockquote>
<p>主键</p>
<blockquote>
<p>我们在第 1 课简单提过主键。主键是一种特殊的约束，用来保证一列（或</p>
<p>一组列）中的值是唯一的，而且永不改动。换句话说，表中的一列（或</p>
<p>多个列）的值唯一标识表中的每一行。这方便了直接或交互地处理表中</p>
<p>的行。没有主键，要安全地 UPDATE 或 DELETE 特定行而不影响其他行会</p>
<p>非常困难。</p>
<p>表中任意列只要满足以下条件，都可以用于主键。</p>
<p> 任意两行的主键值都不相同。</p>
<p> 每行都具有一个主键值（即列中不允许 NULL 值）。</p>
<p> 包含主键值的列从不修改或更新。（大多数 DBMS 不允许这么做，但</p>
<p>如果你使用的 DBMS 允许这样做，好吧，千万别！）</p>
<p> 主键值不能重用。如果从表中删除某一行，其主键值不分配给新行。</p>
<p>一种定义主键的方法是创建它，如下所示</p>
</blockquote>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">CREATE TABLE Vendors 
( 
 vend_id CHAR(10) NOT NULL PRIMARY KEY, 
 vend_name CHAR(50) NOT NULL, 
 vend_address CHAR(50) NULL, 
 vend_city CHAR(50) NULL, 
 vend_state CHAR(5) NULL, 
 vend_zip CHAR(10) NULL, 
 vend_country CHAR(50) NULL 
);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在此例子中，给表的 vend_id 列定义添加关键字 PRIMARY KEY，使其成</p>
<p>为主键。</p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">ALTER TABLE Vendors 
ADD CONSTRAINT PRIMARY KEY (vend_id);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>



<p>这里定义相同的列为主键，但使用的是 CONSTRAINT 语法。此语法也可</p>
<p>以用于 CREATE TABLE 和 ALTER TABLE 语句</p>
<h3 id="外键"><a href="#外键" class="headerlink" title="外键"></a>外键</h3><p>外键是表中的一列，其值必须列在另一表的主键中。外键是保证引用完</p>
<p>整性的极其重要部分。我们举个例子来理解外键</p>
<blockquote>
<p>如第 6 课所述，除帮助保证引用完整性外，外键还有另一个重要作用。</p>
<p>在定义外键后，DBMS 不允许删除在另一个表中具有关联行的行。例</p>
<p>如，不能删除关联订单的顾客。删除该顾客的唯一方法是首先删除相</p>
<p>关的订单（这表示还要删除相关的订单项）。由于需要一系列的删除，</p>
<p>因而利用外键可以防止意外删除数据。</p>
<p>有的 DBMS 支持称为级联删除（cascading delete）的特性。如果启用，</p>
<p>该特性在从一个表中删除行时删除所有相关的数据。例如，如果启用</p>
<p>级联删除并且从 Customers 表中删除某个顾客，则任何关联的订单行</p>
<p>也会被自动删除。</p>
</blockquote>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">CREATE TABLE Orders 
( 
 order_num INTEGER NOT NULL PRIMARY KEY, 
 order_date DATETIME NOT NULL, 
cust_id CHAR(10) NOT NULL REFERENCES 
➥Customers(cust_id) 
);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">CREATE [ UNIQUE | FULLTEXT ] INDEX index_name ON table_name (inex_col_name,... ) ; UNIQUE 代表的是一个唯一的索引，不可重复
SHOW INDEX FROM table_name ;
iDROP INDEX index_name ON table_name ;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-none"><code class="language-none">
触发器

&gt; 触发器是特殊的存储过程，它在特定的数据库活动发生时自动执行。触发
&gt;
&gt; 器可以与特定表上的 INSERT、UPDATE 和 DELETE 操作（或组合）相关联。
&gt;
&gt; 与存储过程不一样（存储过程只是简单的存储 SQL 语句），触发器与单
&gt;
&gt; 个的表相关联。与 Orders 表上的 INSERT 操作相关联的触发器只在
&gt;
&gt; Orders 表中插入行时执行。类似地，Customers 表上的 INSERT 和
&gt;
&gt; UPDATE 操作的触发器只在表上出现这些操作时执行。

&gt; 触发器内的代码具有以下数据的访问权：
&gt;
&gt;  INSERT 操作中的所有新数据；
&gt;
&gt;  UPDATE 操作中的所有新数据和旧数据；
&gt;
&gt;  DELETE 操作中删除的数据。
&gt;
&gt; 根据所使用的 DBMS的不同，触发器可在特定操作执行之前或之后执行。
&gt;
&gt; 下面是触发器的一些常见用途。
&gt;
&gt;  保证数据一致。例如，在 INSERT 或 UPDATE 操作中将所有州名转换
&gt;
&gt; 为大写。
&gt;
&gt;  基于某个表的变动在其他表上执行活动。例如，每当更新或删除一行
&gt;
&gt; 时将审计跟踪记录写入某个日志表。

```mysql
CREATE TRIGGER customer_state 
ON Customers 
FOR INSERT, UPDATE 
AS 
UPDATE Customers 
SET cust_state = Upper(cust_state) 
WHERE Customers.cust_id = inserted.cust_id;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="case-来进行多条件判断-不要忘记END"><a href="#case-来进行多条件判断-不要忘记END" class="headerlink" title="case 来进行多条件判断 不要忘记END"></a>case 来进行多条件判断 不要忘记END</h2><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">CASE WHEN XXX条件 THEN 满足的结果 ELSE 不满足结果 END<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>多行耦合</p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">CASE WHEN XXX条件1 THEN Y1
	 WHEN XXX 条件2 THEN  Y2
	 WHEN XXX 条件3 THEN Y3 ELSE Y4 END 
	 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><blockquote>
<p>一组操作的集合，不可分割，这些操作要么同时成功，要么同时失败，mysql默认提交方式是自动提交的，所以要改为手动提交才行</p>
</blockquote>
<p>方式1</p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">select @@autocommit; 查看提交方式，返回为1则为自动提交，否则为手动提交
set @@autocommit = 0 ; 设置为手动提交

commit 提交

rollback 回滚
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>方式二<br>事务操作</p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">start transaction 或者 begin 开启事务
commit 提交
rollback 回滚 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>事务特点</p>
<ul>
<li><p><strong>原子性</strong> 一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。</p>
</li>
<li><p><strong>一致性</strong> 在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。</p>
</li>
<li><p><strong>隔离性</strong> 数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。</p>
</li>
<li><p><strong>持久性</strong> 事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</p>
</li>
</ul>
<h3 id="并发事务问题"><a href="#并发事务问题" class="headerlink" title="并发事务问题"></a>并发事务问题</h3><ul>
<li>脏读 一个事务读到另一个事务还没有提交的数据</li>
<li>不可重复读，一个事务先后读取一条重复记录，但两次读取的数据不同，成为不可重复读</li>
<li>幻读 一个事务按照条件查询时，没有对应的数据行但是在插入数据时，这行数据已经存在了，出现了幻影<br>事务隔离级别<br><img src="/2023/08/02/58/1.png"><br>可以手动设置系统的隔离级别</li>
</ul>
<h2 id="引擎"><a href="#引擎" class="headerlink" title="引擎"></a>引擎</h2><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">CREATE TABLE 表名(

字段1 字段1类型 [ COMMENT 字段1注释 ] ,

......

字段n 字段n类型 [COMMENT 字段n注释 ]

) ENGINE = INNODB [ COMMENT 表注释 ] ;
show engines;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>InnoDB特点<br>支持事务，行级锁，外键约束</p>
<h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><blockquote>
<p>全局锁：锁定数据库中的所有表。<br>表级锁：每次操作锁住整张表。<br>行级锁：每次操作锁住对应的行数据。</p>
</blockquote>
<h2 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h2><blockquote>
<p>　1）、length()：mysql里面的length()函数是一个用来获取字符串长度的内置函数。<br>　　2）、char_length()：在mysql内置函数里面查看字符串长度的还有一个函数是char_length()。<br>　　3）、这两个函数的区别是：<br>　　　　a）、length()： 单位是字节，utf8编码下,一个汉字三个字节，一个数字或字母一个字节。gbk编码下,一个汉字两个字节，一个数字或字母一个字节。<br>　　　　b）、char_length()：单位为字符，不管汉字还是数字或者是字母都算是一个字符。</p>
</blockquote>
<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">^：表示一个字符串或行的开头

[a-z]：表示一个字符范围，匹配从 a 到 z 的任何字符。

[0-9]：表示一个字符范围，匹配从 0 到 9 的任何字符。

[a-zA-Z]：这个变量匹配从 a 到 z 或 A 到 Z 的任何字符。请注意，你可以在方括号内指定的字符范围的数量没有限制，您可以添加想要匹配的其他字符或范围。

[^a-z]：这个变量匹配不在 a 到 z 范围内的任何字符。请注意，字符 ^ 用来否定字符范围，它在方括号内的含义与它的方括号外表示开始的含义不同。

[a-z]*：表示一个字符范围，匹配从 a 到 z 的任何字符 0 次或多次。

[a-z]+：表示一个字符范围，匹配从 a 到 z 的任何字符 1 次或多次。

.：匹配任意一个字符。

\.：表示句点字符。请注意，反斜杠用于转义句点字符，因为句点字符在正则表达式中具有特殊含义。还要注意，在许多语言中，你需要转义反斜杠本身，因此需要使用\\.。

$：表示一个字符串或行的结尾。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h2><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">//导包
import com.mysql.jdbc.Driver;  
  
import javax.swing.plaf.nimbus.State;  
import java.sql.*;  
public class Name {  
public static void main(String[] args) throws Exception {  
//注册驱动程序  
Class.forName("com.mysql.jdbc.Driver");  
//获取连接  
String url = "jdbc:mysql://localhost:3306/t";  
String username = "root";  
String password = "hutao1224";  
Connection conn = DriverManager.getConnection(url,username,password);  
//获取执行sql语句的对象  
String sql = "insert into employees (name)value ('Amy');";  
Statement stmt = conn.createStatement();  
//执行sql语句  
int count = stmt.executeUpdate(sql);  
//处理结果  
System.out.println(count);  
//释放资源  
stmt.close();  
conn.close();
}  
  
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>防止sql注入使用</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">
 <span class="token annotation punctuation">@Test</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testPreparedStatement</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span>  <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
    <span class="token comment">//2. 获取连接：如果连接的是本机mysql并且端口是默认的 3306 可以简化书写</span>
    <span class="token class-name">String</span> url <span class="token operator">=</span> <span class="token string">"jdbc:mysql:///db1?useSSL=false"</span><span class="token punctuation">;</span>
    <span class="token class-name">String</span> username <span class="token operator">=</span> <span class="token string">"root"</span><span class="token punctuation">;</span>
    <span class="token class-name">String</span> password <span class="token operator">=</span> <span class="token string">"1234"</span><span class="token punctuation">;</span>
    <span class="token class-name">Connection</span> conn <span class="token operator">=</span> <span class="token class-name">DriverManager</span><span class="token punctuation">.</span><span class="token function">getConnection</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span> username<span class="token punctuation">,</span> password<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 接收用户输入 用户名和密码</span>
    <span class="token class-name">String</span> name <span class="token operator">=</span> <span class="token string">"zhangsan"</span><span class="token punctuation">;</span>
    <span class="token class-name">String</span> pwd <span class="token operator">=</span> <span class="token string">"' or '1' = '1"</span><span class="token punctuation">;</span>

    <span class="token comment">// 定义sql</span>
    <span class="token class-name">String</span> sql <span class="token operator">=</span> <span class="token string">"select * from tb_user where username = ? and password = ?"</span><span class="token punctuation">;</span>
    <span class="token comment">// 获取pstmt对象</span>
    <span class="token class-name">PreparedStatement</span> pstmt <span class="token operator">=</span> conn<span class="token punctuation">.</span><span class="token function">prepareStatement</span><span class="token punctuation">(</span>sql<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 设置？的值</span>
    pstmt<span class="token punctuation">.</span><span class="token function">setString</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//?的位置和参数</span>
    pstmt<span class="token punctuation">.</span><span class="token function">setString</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span>pwd<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 执行sql</span>
    <span class="token class-name">ResultSet</span> rs <span class="token operator">=</span> pstmt<span class="token punctuation">.</span><span class="token function">executeQuery</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 不需要传递sql语句了</span>
    <span class="token comment">// 判断登录是否成功</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>rs<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"登录成功~"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"登录失败~"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//7. 释放资源</span>
    rs<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    pstmt<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    conn<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="变量的使用"><a href="#变量的使用" class="headerlink" title="变量的使用"></a>变量的使用</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">占位符？只能用来取代sql语句中的常变量，而不能取代列名或者表名
select <span class="token operator">?</span> from <span class="token operator">?</span> where  <span class="token operator">?</span>   前两个<span class="token operator">?</span>不成立，只能用 <span class="token string">"+variable+"</span> 的方式<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><h3 id="面试常问"><a href="#面试常问" class="headerlink" title="面试常问"></a>面试常问</h3><ul>
<li>一致性哈希：整个哈希值的空间被视为一个环形，每个节点或数据都被映射到整个环上，当需要查找某个键时，会沿着环查找第一个匹配的节点。</li>
<li>数据结构：<ul>
<li>SkipList跳表，ZSet中如果保存到键值对数量&lt;128 &amp;&amp; 每个元素的长度小于64B就使用ziplist，否则则使用skiplist<ul>
<li>数据按照升序排序存储</li>
<li>节点可能包含多个指针，指针跨度不同</li>
</ul>
</li>
<li>SortedSet是有序集合，底层存储的每个数据都包含element和score两个值，score是得分，element是字符串值，会根据element和score值排序，形成有序集合，基于SkipList实现的</li>
<li>Redis如何判断KEY是否过期呢？<ul>
<li><strong>答</strong>：在Redis中会有两个Dict，也就是HashTable，其中一个记录KEY-VALUE键值对，另一个记录KEY和过期时间。要判断一个KEY是否过期，只需要到记录过期时间的Dict中根据KEY查询即可。</li>
</ul>
</li>
</ul>
</li>
<li>集群问题：<ol>
<li>Sentinel是哨兵：监控节点状态并自动实现故障转移 <img src="/2023/08/02/58/%E5%93%A8%E5%85%B5%E5%8E%9F%E7%90%86.png" alt="|400"><ul>
<li>哨兵的作用：状态监控，故障转移，状态通知</li>
<li>主观下线是某一个sentinel节点发现某个节点没在规定时间内响应，客观下线是指的是有一半以上的sentinel都认为下线了才行</li>
<li>选举新的master: </li>
<li>选举规则：判断优先级，判断offset值，越高越优先，判断id，越小越优先<ol>
<li>故障检测：sentinel检测主节点和从节点的在线情况，如果有半数以上的sentinel认为主节点故障，就会开始选举</li>
<li>sentinel选举出一个leader节点，每个sentinel都有资格，sentinel确定master下线之后就会请求其他sentinel同意自己成为leader，票数大于一半的sentinel即可成为leader,如果没有选出，就重复直到选出</li>
<li>选举根据 数据复制的偏移量更大(数据最新)，运行id更小(运行时间更长 )，节点的优先级进行选举</li>
<li>通知所有的从节点设置新的主节点，并且进行复制</li>
<li>通知客户端重新连接主节点</li>
</ol>
</li>
<li>主从复制：<ul>
<li>全量同步，当slave第一次连接到master或者slave断开太久了，repl_baklog(复制积压缓冲区)的offset已经被覆盖了，同步过程中收到的读写命令都会先执行然后记录在repl_baklog中，逐个发送给slave <img src="/2023/08/02/58/%E5%85%A8%E9%87%8F%E5%90%8C%E6%AD%A5.png" alt="|550"><ol>
<li>从节点保存主节点信息，与主节点建立连接，主节点判断是否是第一次请求，是就与从节点同步版本信息</li>
<li>主节点fork一个子进程保存当前所有的数据，2.发送数据快照3.之后主节点每次执行其他的操作都会同步给从节点<ul>
<li><p>**<code>Replication Id</code>**：简称<code>replid</code>，是数据集的标记，replid一致则是同一数据集。每个<code>master</code>都有唯一的<code>replid</code>，<code>slave</code>则会继承<code>master</code>节点的<code>replid</code></p>
</li>
<li><p>**<code>offset</code>**：偏移量，随着记录在<code>repl_baklog</code>中的数据增多而逐渐增大。<code>slave</code>完成同步时也会记录当前同步的<code>offset</code>。如果<code>slave</code>的<code>offset</code>小于<code>master</code>的<code>offset</code>，说明<code>slave</code>数据落后于<code>master</code>，需要更新。</p>
</li>
</ul>
</li>
</ol>
</li>
<li>增量同步：<img src="/2023/08/02/58/%E5%A2%9E%E9%87%8F%E5%90%8C%E6%AD%A5.png" alt="|750"><ul>
<li>根据offset来进行同步</li>
<li>具体的比较是通过<code>repl_baklog</code>，记录Redis处理过的命令及<code>offset</code>，包括master当前的<code>offset</code>，和slave已经拷贝到的<code>offset</code>发送的是命令： <img src="/2023/08/02/58/%E7%8E%AF%E5%BD%A2%E6%95%B0%E7%BB%84.png"></li>
</ul>
</li>
</ul>
</li>
<li>防止脑裂问题：设置主节点最少需要的从节点数，小于这个数量主节点就会禁止写数据，设置主从复制和同步的最大延迟，如果时间超过这个延迟就会禁止写数据。同时可以用主观下线和客观下线，当出现网络分区时，有部分的节点仍然能够连接上主节点，于是就不会出现重新选举主节点。</li>
<li>offset复制偏移量：主从各自维护自己的offset，子节点把自己的offset上报，master保存offset ，部分复制使用二者的偏移量来同步缺失的数据</li>
</ul>
</li>
<li>分片集群：<img src="/2023/08/02/58/%E5%88%86%E7%89%87%E9%9B%86%E7%BE%A4.png"><ul>
<li>每个master保存不同的数据，然后每个master都可以有多个slave节点，之后master之间通过ping来检测彼此之间的健康状态，客户端请求可以访问集群任意节点，最终都会被转发到数据所在的节点</li>
<li>故障转移：每个master转移到自己的slave即可</li>
<li>为什么插槽的数量是16384,16384是2的14次方，是一个平衡性、行呢个和兼容性之间取得折衷的结果</li>
<li>如何将同一类数据固定的保存在同一个Redis实例？<ul>
<li>Redis计算key的插槽值时会判断key中是否包含<code>{}</code>，如果有则基于<code>{}</code>内的字符计算插槽</li>
<li>所以只要用{key} 作为前缀即可把相同的类型的数据计算的插槽一定相同</li>
</ul>
</li>
</ul>
</li>
<li>常见的缓存有几种：<ul>
<li>旁路缓存：使用应用程序来保证缓存和数据库的一致性<ol>
<li>先写DB然后直接删除cache<ul>
<li>为何删除？ 1.如果db频繁更改，导致cache中的数据很少被访问，删除可以节省服务端的资源 2. 更新cache更容易造成缓存不一致的现象</li>
<li>为何不能先删除cache? 因为 如果有两个请求同时访问，请求1先把cache中的数据删除了，请求二就会从db中读取数据，然后请求一再更改db，会导致请求2读到的是旧值</li>
<li>写cache的速度要比写db快很多，所以很少会造成不一致</li>
</ul>
</li>
<li>从cache中读取数据，读不到再从db中读入并返回，然后放到cache中</li>
<li>缺点：<ul>
<li>首次请求不在cache中：可以将热点数据提前放入</li>
</ul>
</li>
</ol>
</li>
<li>读写穿透：以cache为主，让cache服务操作，不需要<ul>
<li>写:先写cache,cache没有时直接写db,有的话先更新cache,之后更新db 同步更新</li>
<li>读：直接读cache,cache没有直接读db，然后放入cache.</li>
</ul>
</li>
<li>异步缓存写入：也是由cache服务来处理,但是更新时，只更新cache,由异步处理来更新db<ul>
<li>缺点：容易造成数据不一致</li>
<li>适合对数据一致性要求没那么 高的</li>
</ul>
</li>
</ul>
</li>
<li>Redis单线程模型：Redis对于每一个客户端的连接都关联一个指令队列和响应队列<ul>
<li>为何单线程性能还这么高？ <ol>
<li>使用纯内存访问，</li>
<li>单线程避免不必要的上下文切换和竞争</li>
<li>IO多路复用，对于多个IO，Redis每次处理其中一个IO然后暂停对其他的IO事件。使用一个线程来监听多个socket某个socket可读时及逆行读写<ul>
<li>实现：select(文件描述符有上限)，poll这俩只会通知用户有有Socket就绪，不确定具体的是哪个，需要轮询来找</li>
<li>epoll会通知用户的时候把哪个socket也直接写入用户空间 </li>
<li>详细介绍一下为什么I/O复用</li>
</ul>
<ol start="2">
<li>Redis是纯内存的，所以性能取决于网络延迟，I/O多路复用实现了高效的网络请求<ol>
<li>常见的IO有 阻塞，非阻塞，多路复用</li>
<li>非阻塞式IO，读到多少就都多少，写多少，不会等待满足字节要求</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>优点：避免了线程切换的消耗。</li>
</ul>
</li>
</ol>
<ul>
<li>主从复制： 主服务器执行写操作时，会将写操作同步给从服务器，从服务器只读，并执行主服务器同步过来的指令 缺点：主服务器宕机时必须手动恢复</li>
<li>哨兵模式： 监控主从服务器，提供主从节点故障转移的功能</li>
<li>切片集群：将数据分布在不同的服务器上，以此来降低系统对单主节点的依赖，从而提高 Redis 服务的读写性能。</li>
<li>脑裂问题： 由于网络问题，集群节点之间失去联系。主从数据不同步；重新平衡选举，产生两个主服务。等网络恢复，旧主节点会降级为从节点，再与新主节点进行同步复制的时候，由于会从节点会清空自己的缓冲区，所以导致之前客户端写入的数据丢失了。 解决： 当主节点发现从节点下线或者通信超时的总数量大于阈值时，那么禁止主节点进行写数据，直接把错误返回给客户端。</li>
</ul>
</li>
<li>数据相关：<ul>
<li>数据淘汰策略：<ul>
<li>如何保证Redis中的数据是热点数据？ 答案是可以使用LRU删除策略，每次删除数据时删除最近最少使用的键，同时也可以主动去更新热点数据</li>
<li>其余的各种内存淘汰机制：1.内存到达限制时返回错误，不删除，2.删除最近最少使用键，3.lru但是只删除设置了过期时间的键，4.随机删除一些 5. 随机删除一些设置了过期时间的键6. 对访问频率来进行删除<img src="/2023/08/02/58/redis%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5.png"></li>
</ul>
</li>
<li>持久化：<ul>
<li>RDB：创建数据的快照，存的是实际的数据<ul>
<li>redis建立新的子进程，父进程继续处理请求，子进程负责将内存内容写到临时文件，os的实时复写copy-on-write会使得父进程和子进程共享一个物理页面，所以会为父进程要修改的页面创建副本，所以子进程内的数据就是fork时的快照。 子进程写完文件之后，使用临时文件代替原来的快照文件，之后子进程quit, <strong>进行的是全量快照，会把整个数据全部保存</strong></li>
</ul>
</li>
<li>AOF：<ul>
<li>重写：AOF重写会调用一个子进程，由子进程去进行重写，会读取数据库中的键值对为每一个键值对生成一个或多个写命令，这些写命令足以恢复这个键值对的状态。然后把他们写入一个新的AOF文件中，同时Redis会维护一个AOF缓冲区，把重写期间进行的数据库写操作记录到缓冲区中，重写完毕之后会把新的AOF文件发给主进程，然后退出，主进程把缓冲区中的写命令写入其中并使用新的AOF文件替换旧的AOF文件</li>
</ul>
</li>
</ul>
</li>
<li>注意：实现原理是操作系统会为进程<ul>
<li>AOF：记录操作命令而不是副本。<ol>
<li>fork,子进程向临时文件中写入重建数据库状态的命令</li>
<li>父进程接收到请求后，把写命令写入到原来的aof文件中，然后缓存起来这些命令</li>
<li>子进程搞完之后，通知父进程，父进程把缓存起来的命令写入临时文件</li>
<li>使用临时文件替代老文件,注意不会读取老文件</li>
</ol>
</li>
<li>混合持久化：两者结合，惰性删除：只有在访问这个键的时候才检查是否过期</li>
</ul>
<ol>
<li>读写分离问题：读占比较大时可以把一部分的流量摊到从节点，只对主节点进行写服务。</li>
</ol>
</li>
<li>过期策略：惰性删除和定时删除，Redis使用了两种结合的方式：当某个key被访问时，会定期检查是否过期，如果过期就删除，同时会定期对一部分key进行检查，如果过期就删除<ul>
<li>周期删除的模式：<ol>
<li>SLOW模式：通过定时任务定期抽样部分带有TTL的key，判断是否过期。如果过期key比例较高会多次抽象</li>
<li>FAST模式：Redis每次处理NIO事件之前，都会抽样部分带有TTL的key，判断是否过程，因此频率较高。如果时间充足并且过期key比例过高，也会多次抽样。</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="缓存问题"><a href="#缓存问题" class="headerlink" title="缓存问题"></a>缓存问题</h2><ul>
<li><strong>缓存问题</strong>:<ul>
<li>缓存雪崩：<strong>大量缓存</strong> 在同一时间失效或者Redis宕机导致后面的请求都直接落到了db<ul>
<li>修改key的TTL，设置随机TTL<ol>
<li>将缓存失效时间打散，在失效时间基础上加一个随机值</li>
<li>设置缓存不过期</li>
</ol>
</li>
<li>搭建Redis的集群，哨兵模式，集群模式<ul>
<li>给业务限流，nginx和spring cloud gateway</li>
</ul>
</li>
<li>使用多级缓存，Guava和Caffeine + Redis， 前面这俩是缓存在服务中的JVM中的，分布式项目中不能跨服务，但是请求速度是最快的，因为是本地的缓存</li>
<li>给缓存业务添加降级限流策略</li>
</ul>
</li>
<li><strong>缓存击穿</strong>：热点key过期，大量的请求直接给数据库压力<ul>
<li>互斥锁方案，保证同一时间只能有一个业务线程请求业务缓存</li>
<li>不给热点数据设置过期时间，由异步更新缓存，或者在热点数据要过期的时候，提前通知前台线程更新缓存或者重新设置过期时间，保证高可用，数据不会是绝对一致的</li>
</ul>
</li>
<li>缓存穿透：访问的数据不在缓存中，每次都直接查询数据库，给数据库很大压力 ，解决方案是使用布隆过滤器<ul>
<li>非法请求的限制，当有大量恶意请求访问不存在的数据时，在API入口要判断请求参数是否合理</li>
<li>设置空值或者默认值</li>
<li>使用<strong>布隆过滤器快速判断数据是否存在，避免通过查询数据库来判断数据是否存在</strong>：</li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/94433082">布隆过滤器</a>对一个数据用多个哈希函数来映射，当查询时，如果多个哈希函数的映射后任何一个索引都为0，则一定不存在，如果所有的映射后的位置都是1时，则可能存在集合中。使用的是位图<img src="/2023/08/02/58/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8.png"></li>
</ul>
</li>
<li>数据一致性<ul>
<li><strong>双写一致问题：</strong><ul>
<li>保证一致性<br>  1. 写使用的<strong>延迟双删</strong>，删两次缓存，等数据库修改完之后再删除一次缓存，用于解决数据库主从一致性问题，与缓存同步为u管。<br>  2. Cache Aside 旁路缓存策略<br>      - 写策略：先更新数据库再删除缓存中的数据<br>      - 读策略：如果命中了缓存，直接返回，否则从数据库中读入数据并写入缓存，返回给用户<br>  3. Read/Write Through 读穿/写穿策略: 应用程序只与缓存交互，由缓存组件和数据库交互，<br>      - 读为名周直接查数据库然后写入缓存<br>      - 写未命中，缓存存在直接写缓存，然后由缓存组件去更新数据库。缓存不存在则直接更新数据库<br>  4. Write Back（写回）策略<ul>
<li>使用读锁(共享锁)和写锁(排他锁)</li>
</ul>
</li>
<li>允许短暂不一致：<ul>
<li>使用消息队列，先修改数据库，数据库修改完之后向MQ发送消息，由cahe服务接受消息来对缓存进行更新</li>
<li>取决于mq的可靠性</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>延时队列： 把当前要做的事情推迟一段时间再做，如下单未付款取消<ul>
<li>可以使用 Zset来纯理，Score属性来存储延迟执行的时间</li>
<li>zadd score1 value1;</li>
<li>大key  value的值很大</li>
</ul>
</li>
<li>分布式问题：<ol>
<li>分布式锁：setnx 实际使用应该使用 set key value nx ex time 因为这个可以直接在原子性指定时间</li>
<li>Reddsion来续锁：使用lua脚本，来保证原子性<ol>
<li>一个线程获得锁，然后在事务中调用了另一个事务，另一个事务也同样对相同的锁加锁，会发生什么？<ul>
<li>如果是直接使用Redis，会阻塞，然后等锁过期后，被调用的函数可以执行，被调用的函数执行之后会释放锁，返回到第一个函数执行，第一个函数执行之后就会重复释放这个锁，无法保证原子性了。</li>
<li>如果使用Redssion，Redssion的RLock数据结构实现了可重入锁：<ul>
<li>key，status持有还是释放 ，UUID标识线程 ， 持有时间(最长的存活时间)</li>
<li>Redis中存的value字段为锁的次数</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
</ul>
<pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">{</span>
  <span class="token property">"myLock"</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token property">"status"</span><span class="token operator">:</span> <span class="token string">"LOCKED"</span><span class="token punctuation">,</span>
    <span class="token property">"owner"</span><span class="token operator">:</span> <span class="token string">"some-unique-uuid"</span><span class="token punctuation">,</span>
    <span class="token property">"hold_count"</span><span class="token operator">:</span> <span class="token number">2</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>			<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre><code>        - 这个问题中就会直接判断出是同一个线程的调用，所以只会给锁的持有技术+1，不会阻塞
</code></pre>
<ul>
<li><p>multi开始事务，discard取消事务redis的事务在出错时，只会回滚出错的命令</p>
</li>
<li><p>使用watch key 来对某一个key加上乐观锁</p>
</li>
<li><p>Redis 与 Memcached&nbsp;<strong>区别</strong>：</p>
<ol>
<li>Redis支持的数据类型更丰富：Sting Hash List Set Zset， M只支持key-value数据类型</li>
<li>Redis支持数据的持久化，可以将内存中的数据保存在磁盘中。</li>
<li>Redis原生支持集群模式</li>
<li>Redis支持发布订阅模型，LUa吉奥本，事务等</li>
</ol>
</li>
<li><p>数据类型</p>
<ul>
<li>String 类型的应用场景：SDS，可以存任何类型，直接存在二进制buf数组里</li>
<li>List 实现是：</li>
<li>Hash 类型：缓存对象、购物车等。</li>
<li>Set 类型：聚合计算（并集、交集、差集）场景，比如点赞、共同关注、抽奖活动等。</li>
<li>Zset 类型：排序场景，比如排行榜、电话和姓名排序等。</li>
<li>BitMap（2.2 版新增）：二值状态统计的场景，比如签到、判断用户登陆状态、连续签到用户总数等；</li>
<li>HyperLogLog（2.8 版新增）：海量数据基数统计的场景，比如百万级网页 UV 计数等；</li>
<li>GEO（3.2 版新增）：存储地理位置信息的场景，比如滴滴叫车；</li>
<li>Stream（5.0 版新增）：消息队列，相比于基于 List 类型实现的消息队列，有这两个特有的特性：自动生成全局唯一消息ID，支持以消费组形式消费数据。</li>
</ul>
</li>
<li><h3 id="Redis在执行命令的时候是单线程，但是也使用了多线程的来处理网络IO操作"><a href="#Redis在执行命令的时候是单线程，但是也使用了多线程的来处理网络IO操作" class="headerlink" title="Redis在执行命令的时候是单线程，但是也使用了多线程的来处理网络IO操作"></a>Redis在执行命令的时候是单线程，但是也使用了多线程的来处理网络IO操作</h3><ul>
<li>不是，Redis会启动后台： 三个线程各自有自己的任务队列,<ol>
<li>处理关闭文件</li>
<li>处理AOF刷盘</li>
<li>异步释放Redis内存，也就是lazyfree线程</li>
<li>主线程，负责执行命令</li>
<li>三个I/O线程来分担网络I/O压力</li>
</ol>
</li>
<li>这些任务的操作都是很耗时的，如果把这些任务都放在主线程来处理，那么 Redis 主线程就很容易发生阻塞，这样就无法处理后续的请求了。</li>
</ul>
</li>
<li><p>过期删除和内存淘汰： Redis使用懒惰性删除和定期删除。 惰性删除时指不主动删除过期键，每次反问key时检查是否过期，如果过期，则删除。 优点是：减少对系统资源的使用，缺点是：不能及时释放内存</p>
<ul>
<li>定期删除：每过一段时间，从数据库中取出一定数量的key来进行检查，删除其中的过期key，如果过期key超过一定比例，重复执行定期删除</li>
<li>当 Redis 运行在主从模式下时，<strong>从库不会进行过期扫描，从库对过期的处理是被动的</strong>。也就是即使从库中的 key 过期了，如果有客户端访问从库时，依然可以得到 key 对应的值，像未过期的键值对一样返回。</li>
<li>从库的过期键处理依靠主服务器控制，<strong>主库在 key 到期时，会在 AOF 文件里增加一条 del 指令，同步到所有的从库</strong>，从库通过执行这条 del 指令来删除过期的 key。REmote DIctionary Server(Redis) 是一个由 Salvatore Sanfilippo 写的 key-value 存储系统，是跨平台的非关系型数据库，非关系型数据库，</li>
</ul>
</li>
<li><p>内存淘汰： 随机淘汰，LRU最近最少使用，根据最后一次访问的时间 , LFU最近最不常使用，根据访问次数来淘汰</p>
</li>
<li><p>Lua :Redis 在执行 Lua 脚本时，可以以原子性的方式执行</p>
</li>
<li><p>Lua脚本使用</p>
<ol>
<li>EVAL执行脚本<code> EVAL script numkeys key [key …] arg [arg …]</code></li>
<li>SCRIPT LOAD script.lua 把脚本加载到redis-serve中，返会一个&nbsp;SHA1校验和，之后无论是哪个客户端都可以使用这个校验和来运行脚本。</li>
<li>EVALSHA sha1校验和  numkeys key [key …] arg [arg …]</li>
<li>SCRIPT EXISTS sha1来检验这个脚本是否还在</li>
<li>SCRIPT FLUSH刷新所有已经保存的脚本</li>
<li>redis-cli -a 密码 –eval lua脚本内容</li>
</ol>
</li>
<li><p>对于基本数据类型的操作</p>
<ol>
<li>string <ul>
<li>redis中的string可以包含任何数据，包括jpg和序列化的对象，因为string是byte [] 数组</li>
<li>setrange key number string 从number开始的下标处替换string,从0开始</li>
<li>mset 设置多个</li>
<li>xxnx not exit 不存在的话在设置</li>
<li>getrange key begin end</li>
<li>incryby key 增量 修改数据</li>
<li>append key 加</li>
<li>strlen 获取长度</li>
</ul>
</li>
<li>hash: string类型的 field 和 value的映射表,占用内存更少，方便取整个对象<ul>
<li>hset/hsetnx key field1 value1</li>
<li>hmget 获取多个fields</li>
<li>hexists key field 测试field是否存在</li>
<li>hlen key 有多少field</li>
<li>hkeys key 获取所有的field</li>
<li>hvals 获取所有的value</li>
<li>hgetall == hvals + hkeys</li>
</ul>
</li>
<li>list 底层是链表，可当作queue使用，有序，可重复，key为链表的名字<ul>
<li>lpush 头部添加 rpush尾部添加,linsert key</li>
<li>lset 重新设定指定位置的数据 </li>
<li>lrem key count value 从头开始删除count个和value一样值的数据， count &gt; 0 从头开始,count &lt; 0从尾部开始，count == 0 删除所有的</li>
<li>ltrim 只保留给定范围的数据</li>
<li>lpop/rpop</li>
<li>rpoplpush key1 key2 将key1的尾部移除并加入key2的头部，原子操作</li>
<li>lindex下标访问</li>
<li>llen获取长度</li>
</ul>
</li>
<li>set<ul>
<li>便于求集合的交并差,无序集合，不可重复</li>
<li>sadd key value</li>
<li>srem key value</li>
<li>spop key 随机删除并返回一个元素</li>
<li>sdiff 求交集 一个key1 多个key2 , key3，也就是在其他key中与其他key不同元素</li>
<li>sdiffstore 将diff的结果保存到另一个key中</li>
<li>sinter(store) 交集(存储)</li>
<li>sunion(store) 并集</li>
<li>smove 将key1 中的删除添加给第二个</li>
<li>scard 统计元素个数</li>
<li>sismember测试是否为key的元素</li>
<li>srandmember随机返回不删除</li>
</ul>
</li>
<li>sorted sets<ul>
<li>有序，不可重复，会关联一个double类型score来进行排序,是skip list 和 hash table的混合，score越小的越在前面</li>
<li>zadd key score value</li>
<li>zrem</li>
<li>zincrby key score value 给这个元素的score添加</li>
<li>zrank 按照从小到大排序返回某个member的排名</li>
<li>zrerank反向排序</li>
<li>zcount 返回给定区间score内的数量</li>
<li>zcarf 返回元素数量</li>
<li>zscore 返回score</li>
</ul>
</li>
</ol>
<ul>
<li>常用指令：keys ， del , expire,move转移把当前数据库中的数据转移到其他数据中,persist移除给定key的过期时间，randomkey随机返回一个key,rename,type</li>
<li>ping,echo,select(0~15),dbsize返回当前数据库中所有的key数量,info获取服务器统计信息</li>
<li>monitor实时转存收到的请求</li>
<li>flushdb删除所选择的数据库的所有key</li>
<li>fushall 删除所有数据库的所有key</li>
</ul>
</li>
</ul>
<h3 id="Redis-脚本命令"><a href="#Redis-脚本命令" class="headerlink" title="Redis 脚本命令"></a>Redis 脚本命令</h3><h3 id="dockercompose快速搭建一主二从一哨兵的redis集群"><a href="#dockercompose快速搭建一主二从一哨兵的redis集群" class="headerlink" title="dockercompose快速搭建一主二从一哨兵的redis集群"></a>dockercompose快速搭建一主二从一哨兵的redis集群</h3><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token property">version</span><span class="token punctuation">:</span> <span class="token string">'3'</span>
<span class="token property">services</span><span class="token punctuation">:</span>
  <span class="token property">redis-master</span><span class="token punctuation">:</span> # 主节点
    <span class="token property">image</span><span class="token punctuation">:</span> <span class="token property">redis</span><span class="token punctuation">:</span>latest
    <span class="token property">command</span><span class="token punctuation">:</span> redis-server --appendonly yes --requirepass bronya # 设置密码
    <span class="token property">volumes</span><span class="token punctuation">:</span>
      - ./data/<span class="token property">master</span><span class="token punctuation">:</span>/data
    <span class="token property">ports</span><span class="token punctuation">:</span>
      - <span class="token string">"6379:6379"</span>
    <span class="token property">networks</span><span class="token punctuation">:</span>
      - redis-network

  <span class="token property">redis-slave1</span><span class="token punctuation">:</span>
    <span class="token property">image</span><span class="token punctuation">:</span> <span class="token property">redis</span><span class="token punctuation">:</span>latest
    <span class="token property">command</span><span class="token punctuation">:</span> redis-server --slaveof redis-master 6379 --appendonly yes --masterauth bronya
    <span class="token property">depends_on</span><span class="token punctuation">:</span>
      - redis-master
    <span class="token property">volumes</span><span class="token punctuation">:</span>
      - ./data/<span class="token property">slave1</span><span class="token punctuation">:</span>/data
    <span class="token property">networks</span><span class="token punctuation">:</span>
      - redis-network

  <span class="token property">redis-slave2</span><span class="token punctuation">:</span>
    <span class="token property">image</span><span class="token punctuation">:</span> <span class="token property">redis</span><span class="token punctuation">:</span>latest
    <span class="token property">command</span><span class="token punctuation">:</span> redis-server --slaveof redis-master 6379 --appendonly yes --masterauth bronya
    <span class="token property">depends_on</span><span class="token punctuation">:</span>
      - redis-master
    <span class="token property">volumes</span><span class="token punctuation">:</span>
      - ./data/<span class="token property">slave2</span><span class="token punctuation">:</span>/data
    <span class="token property">networks</span><span class="token punctuation">:</span>
      - redis-network

  <span class="token property">redis-sentinel</span><span class="token punctuation">:</span>
    <span class="token property">image</span><span class="token punctuation">:</span> <span class="token property">redis</span><span class="token punctuation">:</span>latest
    <span class="token property">command</span><span class="token punctuation">:</span> redis-sentinel /etc/redis/sentinel.conf
    <span class="token property">depends_on</span><span class="token punctuation">:</span>
      - redis-master
    <span class="token property">volumes</span><span class="token punctuation">:</span>
      - ./sentinel.<span class="token property">conf</span><span class="token punctuation">:</span>/etc/redis/sentinel.conf
    <span class="token property">networks</span><span class="token punctuation">:</span>
      - redis-network

<span class="token property">networks</span><span class="token punctuation">:</span>
  <span class="token property">redis-network</span><span class="token punctuation">:</span>
    <span class="token property">driver</span><span class="token punctuation">:</span> bridge<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>下表列出了 redis 脚本常用命令：</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>命令及描述</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td><a target="_blank" rel="noopener" href="https://www.runoob.com/redis/scripting-eval.html">EVAL script numkeys key [key …] arg [arg …]</a>  <br>执行 Lua 脚本。</td>
</tr>
<tr>
<td>2</td>
<td><a target="_blank" rel="noopener" href="https://www.runoob.com/redis/scripting-evalsha.html">EVALSHA sha1 numkeys key [key …] arg [arg …]</a>  <br>执行 Lua 脚本。</td>
</tr>
<tr>
<td>3</td>
<td><a target="_blank" rel="noopener" href="https://www.runoob.com/redis/scripting-script-exists.html">SCRIPT EXISTS script [script …]</a>  <br>查看指定的脚本是否已经被保存在缓存当中。</td>
</tr>
<tr>
<td>4</td>
<td><a target="_blank" rel="noopener" href="https://www.runoob.com/redis/scripting-script-flush.html">SCRIPT FLUSH</a>  <br>从脚本缓存中移除所有脚本。</td>
</tr>
<tr>
<td>5</td>
<td><a target="_blank" rel="noopener" href="https://www.runoob.com/redis/scripting-script-kill.html">SCRIPT KILL</a>  <br>杀死当前正在运行的 Lua 脚本。</td>
</tr>
<tr>
<td>6</td>
<td><a target="_blank" rel="noopener" href="https://www.runoob.com/redis/scripting-script-load.html">SCRIPT LOAD script</a>  <br>将脚本 script 添加到脚本缓存中，但并不立即执行这个脚本。</td>
</tr>
</tbody></table>
<ul>
<li>选择数据库和登录<br>如果你想在Redis服务器启动时指定要使用的数据库和密码，可以通过命令行参数进行设置，例如：</li>
</ul>
<p><code>redis-server --port 6379 --requirepass your_password --db 3</code><br>redis默认有0-15个数据库，直接选择即可</p>
<p>info 来获得服务器和数据库信息</p>
<h2 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h2><p>是一种源代码可用的文档数据库，以序列化的 JSON 格式存储数据。MongoDB 将数据存储在外部存储器中，但在企业版中包含内存存储引擎。<br>常用于应对高并发、海量数据存储、数据库的高可扩展性<br>例如：社交场景保存用户信息，通过地理位置索引来实现附近的人<br>游戏场景存储用户信息，方便高效<br>日志</p>
<h4 id="基本概念："><a href="#基本概念：" class="headerlink" title="基本概念："></a>基本概念：</h4><ol>
<li>文档：数据存储的基本单位</li>
<li>索引：<ul>
<li>单字段索引：索引建立的顺序无所谓，MongoDB会可以从头/尾开始遍历</li>
<li>复合索引：建立在多个字段之上的索引,顺序很重要</li>
<li>多键索引：如果一个字段是数组，对数组建立的索引就是多键索引，相当于会对数组的每个值都建立单字段索引，举例：给Tags建立索引，搜索时只需要tags数组即可筛选出带有tags的所有文档</li>
<li>哈希索引：按照数据的哈希值进行索引，用在哈希分片集群上</li>
<li>文本索引：不建议使用，性能低下</li>
<li>地理位置索引：</li>
<li>唯一索引：确保索引字段不会存储重复值</li>
<li>TTL索引：提供一个过期机制，允许为每一个文档设置一个过期时间，当文档达到过期时间就会被删除，示例代码：`    @Indexed(expireAfterSeconds = 60 * 60 * 24 * 30)private Date createdAt;<ul>
<li>TTL索引只能用于单字段</li>
<li><code>_id</code> 不支持TTL索引</li>
<li>不能在上限集合(上限集合（Capped Collections）是一种特殊类型的集合，它有固定的大小。当集合达到其最大大小时，MongoDB会自动覆盖最旧的文档。)中删除文档</li>
</ul>
</li>
<li>覆盖索引查询：<ol>
<li>所有查询字段都要求是索引的一部分</li>
<li>结果中返回的所有字段都在同一个索引中</li>
<li>查询中没有字段为null</li>
</ol>
</li>
</ul>
</li>
<li>集合：集合是动态的，可以把不同类型的文档归为一个集合<ul>
<li>盖子集合: 有上限的集合，用于日志，不支持crud,当超过上限时，会从最老的文档开始删除<ul>
<li><code>db.createCollection("users.actions",{capped:true,size:16384,max:100})</code></li>
</ul>
</li>
<li>TTL集合: MongoDB也允许在特定的时间后废弃文档数据，有时候叫做生存时间time-to-live (TTL）集合这个功能实际上是通过一个特殊的索引实现的 创建TTL索引的方式如下：<ul>
<li><code>db.reviews.createIndex({time_field:1},{expireAfterSeconds:3600})</code></li>
<li>time_field字段会定期检查时间戳，与当前时间比较，如果时间差大于设置的时间，文档会被自动删除，单位是s</li>
</ul>
</li>
</ul>
</li>
<li>文档-&gt;集合-&gt;数据库-&gt;MongoDB</li>
<li>mongosh是一个js解释器，可以使用js标准库或者运行函数</li>
<li>使用js语法，db变量代表当前选用的数据库</li>
</ol>
<ul>
<li>CRUD:<ul>
<li>查询可以使用正则表达式</li>
<li>建立数据库直接use一个新的数据库即可</li>
<li>变量 = {…},之后db.集合.insertOne(变量)或者insertMany()</li>
<li>db.集合.find()或者findOne()</li>
<li>updateOne()</li>
<li>db.集合.deleteOne/Many()</li>
<li>db.dropDatabase()删除当前数据库</li>
<li>db.collection.drop() 删除指定集合</li>
<li>db.col.update({‘title’:’MongoDB 教程’},{$set:{‘title’:’MongoDB’}}) 对应的变量名({ “nMatched” : 1, “nUpserted” : 0, “nModified” : 1 },{multi:true}) 设置multi : true可以修改选定的所有文档</li>
<li>想显式创建集合：db.createCollection(xxx),通过size字段可以预分配空间的字节大小</li>
</ul>
</li>
<li>创建索引:db.products.createIndex({slug: 1}, {unique: true})<ul>
<li>1代表是升序，unique是指定索引的选项，指定了索引是唯一的，slug一般用于存储URL</li>
</ul>
</li>
<li>聚合管道： 类似stream流和channel管道，可以执行一系列的handler,最后返回结果 <img src="/2023/08/02/58/%E8%81%9A%E5%90%88%E7%AE%A1%E9%81%93.png"><ol>
<li><img src="/2023/08/02/58/SQL%E5%AF%B9%E6%AF%94%E8%81%9A%E5%90%88.png"></li>
</ol>
</li>
</ul>
<h2 id="Mybatis面试"><a href="#Mybatis面试" class="headerlink" title="Mybatis面试"></a>Mybatis面试</h2><ul>
<li>mybatis执行流程：<ul>
<li>读取配置文件</li>
<li>构建会话工厂：会话工厂全局一个，生产sqlSession</li>
<li>创建会话：项目与数据库的会话，包含了执行sql语句的所有方法，每次操作一个会话，有多个</li>
<li>Executor执行器</li>
<li>返回结果</li>
</ul>
</li>
<li>延迟加载：懒加载，旨在需要使用数据的时候才进行实际的SQL查询<ul>
<li>比如我们在关联查询中，我们会自动的把关联的用户数据也查询出来了，但是我们并不需要用户的信息，所以我们可以使用延迟加载，只有在我们使用用户信息的时候才会把结果查询出来</li>
</ul>
</li>
<li>缓存：本地缓存<ul>
<li>一级缓存：sqlsession ，实现方式是PerpertualCache,当Session进行flush或者close时会刷新缓存</li>
<li>二级缓存：mapper级别的</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zuofw.github.io/2023/07/04/56/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="QingQiu">
      <meta itemprop="description" content="个人网站，学习记录，面试记录和经验总结、互联网中一块属于自己的小窝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="QingQiu'Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/07/04/56/" class="post-title-link" itemprop="url">Tools</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-07-04 10:42:56" itemprop="dateCreated datePublished" datetime="2023-07-04T10:42:56+08:00">2023-07-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-07-31 10:23:50" itemprop="dateModified" datetime="2024-07-31T10:23:50+08:00">2024-07-31</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>22k</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="虚拟机设置静态ip"><a href="#虚拟机设置静态ip" class="headerlink" title="虚拟机设置静态ip"></a>虚拟机设置静态ip</h2><p><a target="_blank" rel="noopener" href="https://wangyi.one/vmware%E4%B8%AD%E9%85%8D%E7%BD%AEubuntu%E9%9D%99%E6%80%81ip/">https://wangyi.one/vmware%E4%B8%AD%E9%85%8D%E7%BD%AEubuntu%E9%9D%99%E6%80%81ip/</a><br><del>Emacs后续学习</del><br>常用键位</p>
<pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token property">替换</span>  <span class="token punctuation">:</span> %s/原/修改之后的/g   g代表修改整个文件
<span class="token property">查找</span>  <span class="token punctuation">:</span> 使用 n 查找下一个<span class="token punctuation">,</span> N <span class="token property">下一个</span>
<span class="token punctuation">:</span> 首行<span class="token punctuation">,</span>尾行 s/原/新/<span class="token property">g</span>
<span class="token punctuation">:</span> .<span class="token punctuation">,</span>+ns/旧/新/g 当前行和接下来的n行
. 重复之前的操作   ###<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-css" data-language="css"><code class="language-css">
<span class="token selector">快捷键之类的，大部分都是可以组合使用的

键位练习：命令行输入 vimtutor #####
COMMAND模式
:set ic / noic  查找时不/区分大小写
使用v选中之后使用:
会看见'&lt;'&gt;之后可以通过 w + filename 将选中的字保存为新的文件
:! + shell 命令，在不退出vim的情况下使用shell指令 ######
:! + sh 再开一终端，暂时退出当前文件的页面，使用ctrl- d返回文件 #########
:r + filename 将filename文件中的文字写入当前光标所在位置
:set number 显示行号
:s/old/new/g  替换一行中的old为new,加上g会对整行都起作用，不加g只会修改第一个old
:sp 打开当前文件打开多个窗口
:qa 关闭所有窗口
normal模式
A        		append  移动到末尾进行insert ###
I                        移动到这一行的开头进行insert ###
J                        将下一行和这一行连接在一起
a                光标之后插入内容
ctrl + r redo
u   撤销
hjkl 左下上右
v     			进入选中块模式
V    			选中模式，每次选中一行
ctrl + w         切换window 
ctrl + v         选中一个矩形
~				选中之后，使得大小写互换 ### 
f + 要查找的字符   find 这一行中光标之后第一个关键字
F + xxx           find 反向查找
t + xxx           移动到这个字符的前面一个字符
T + xxx           反向查找，移动到字符之后一个字符
d + 移动的键位     删除  d + $ 删除到(一行)结尾， d + 0 删除到(一行)开头
c + 移动的键位     change 删除并进入insert进行修改
dd       		 删除一行
cc				删除一行并进入insert
x            	 删除当前字符
r + 字符          替换当前一个字符
R                 连续替换 ###
w  word 向后移动一个单词
b  向前移动一个单词
e  end 移动到下一个单词的最后一个字母
o  下方开一个新行
O  上方开一个新行
0  移动到行首
%  从</span><span class="token punctuation">{</span>/[/<span class="token punctuation">(</span> 移动到<span class="token punctuation">)</span>/]/<span class="token punctuation">}</span>
<span class="token selector">$  移动到行末
数字 + G         跳转到指定行
ctrl + g         显示当前的行数
G  最后一行
gg 第一行
y + 移动的键位   复制
yy     		    复制一行
p			   粘贴
L/M/H 当前页面的lowest/middle/highest
ctrl + u / d 向上滚动/向下滚动
数字 + 键位   执行几次这个键位操作
例如:
7dw          删除七个单词
修饰词
a 删除所在的整体
例如：</span>
<span class="token punctuation">{</span>djsafljaflsjlf<span class="token punctuation">}</span><span class="token selector">123
使用di</span><span class="token punctuation">{</span>
<span class="token selector">只剩下了
123F
i 内部，例如</span>
<span class="token punctuation">{</span>skdajsldjas<span class="token punctuation">}</span><span class="token selector">想要删除</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token selector">内的东西只需要
ci</span><span class="token punctuation">{</span>

/ + 内容      全文查找
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>好用的操作</li>
</ul>
<ol>
<li>一键取消注释,ctrl + v进入块选择模式，然后使用方向键选择所有的注释，按d删除即可</li>
</ol>
<h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><p>切换分支和版本号实际上就是指针的切换</p>
<p>工作区：磁盘目录</p>
<p>使用git add把工作区代码加入暂存区 临时储存</p>
<p>git commit</p>
<p>将暂存区代码提交到本地库，得到历史版本(代码删除不了了)</p>
<p>push </p>
<p>推送到远程库</p>
<p>github是远程库</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> init 初始化仓库
<span class="token function">git</span> status 查看仓库状态
<span class="token comment">##Untracked files: 是未追踪的文件，也就是文件只处于工作区，不处于暂存区和本地库，红色的文字</span>
<span class="token comment">##绿色的文件名是存在于暂存区</span>
<span class="token function">git</span> <span class="token function">add</span> + filename 添加到暂存区
<span class="token function">git</span> <span class="token function">add</span> <span class="token parameter variable">-A</span>    全部提交
<span class="token function">git</span> <span class="token function">add</span> <span class="token parameter variable">-i</span>    添加到暂存区，但是会有提问
<span class="token function">git</span> <span class="token function">rm</span> <span class="token parameter variable">--cached</span> filename 删除暂存区的文件
<span class="token function">git</span> commit <span class="token parameter variable">-m</span> <span class="token string">"日志信息"</span> filenaem 提交到本地库
<span class="token function">git</span> commit <span class="token parameter variable">--amend</span> + 日志 <span class="token comment">#覆盖最新的一次提交日志</span>
<span class="token comment">##提交之后git status 会显示为没有提交</span>
<span class="token function">git</span> reflog 查看提交记录
<span class="token function">git</span> log    查看日志，包括提交记录和提交用户
<span class="token function">git</span> log <span class="token parameter variable">--author</span><span class="token operator">=</span>xxx  只查看某人的提交记录
<span class="token function">git</span> log <span class="token parameter variable">--pretty</span><span class="token operator">=</span>oneline 每一个提交记录只占一行
<span class="token function">git</span> log <span class="token parameter variable">--graph</span> <span class="token parameter variable">--oneline</span> <span class="token parameter variable">--decorate</span> <span class="token parameter variable">--all</span> 通过 ASCII 艺术的树形结构来展示所有的分支
<span class="token function">git</span> log --name-status 看哪个文件改变了
<span class="token parameter variable">-n</span> n为数字 //最新n个提交
<span class="token comment">##版本穿越，修改HEAD指针 本地原文件一并会被修改</span>
<span class="token function">git</span> reset <span class="token parameter variable">--hard</span> + 版本号
<span class="token function">git</span> tag xxx 提交ID前10个字符，创建一个标签   
<span class="token function">git</span> cherry-pick +xx xxx xx 把某几个分支复制到当前分支上<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>分支操作</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> branch 创建分支
<span class="token function">git</span> branch <span class="token parameter variable">-v</span> 查看有哪些分支
<span class="token parameter variable">-m</span> 改名
<span class="token parameter variable">-d</span> 删除
<span class="token function">git</span> checkout  + name 切换分支
<span class="token function">git</span> merge  + name    将当name合并在当前分支
<span class="token function">git</span> reset    撤销提交记录,但是撤销之前的还是存在的，只是处于未加入缓冲区的状态，仅限本地
<span class="token function">git</span> revert   撤销更改分享给别人<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>分支冲突：两个人同时对同一个内容 进行了两个不同的修改，git无法决定新的文件手</p>
<p>手动修改后，commit 不要再加上文件名了</p>
<p>HEAD指向的是当前分支</p>
<p>远程开发：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> remote <span class="token parameter variable">-v</span> 查看所有远程地址别名
<span class="token function">git</span> remote <span class="token function">add</span> 别名 + 远程地址    给远程地址起一个别名，方便切换
<span class="token function">git</span> push +别名/库地址 + 分支名    把这个分支推送到远程库
<span class="token function">git</span> pull +别名/库地址 + 分支名    把远程的分支名拉取
<span class="token function">git</span> clone + 库地址               克隆到本地  会进行：1.拉取代码2.初始化本地库3.创建别名
<span class="token comment">###############</span>
<span class="token function">git</span> clone <span class="token parameter variable">-b</span> <span class="token operator">&lt;</span>branchname<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>remote-repo-url<span class="token operator">&gt;</span> 克隆指定分支
<span class="token comment">###############</span>
<span class="token function">git</span> fetch + xxx 
<span class="token function">git</span> reset <span class="token parameter variable">--hard</span> origin/master  获取服务器上最后一次改动，并将本地主分支指向它，实现放弃本地所有改动<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>其他知识</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">gitk 内建的图形化
<span class="token comment">##显示历史记录时，每个提交的信息只显示一行：</span>
<span class="token function">git</span> config format.pretty oneline<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>其他：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> count-objects <span class="token parameter variable">-vH</span> <span class="token comment">#查看仓库大小</span>
<span class="token function">git</span> log <span class="token parameter variable">--reverse</span>  <span class="token comment">#从旧到新查看提交记录</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>



<h2 id="gitignore配置"><a href="#gitignore配置" class="headerlink" title=".gitignore配置"></a>.gitignore配置</h2><ul>
<li>所有以#开头的行会被忽略</li>
<li>可以使用glob模式匹配</li>
<li>匹配模式后跟反斜杠（/）表示要忽略的是目录</li>
<li>如果不要忽略某模式的文件在模式前加”!”</li>
</ul>
<p>　　比如：</p>
<blockquote>
<p># 此为注释 – 将被 Git 忽略<br><em>.a # 忽略所有 .a 结尾的文件<br>!lib.a # 但 lib.a 除外<br>/TODO # 仅仅忽略项目根目录下的 TODO 文件,不包括 subdir/TODO<br>build/ # 忽略 build/ 目录下的所有文件<br>doc/</em>.txt # 会忽略 doc/notes.txt 但不包括 doc/server/arch.txt</p>
</blockquote>
<h3 id="工作中常用"><a href="#工作中常用" class="headerlink" title="工作中常用"></a>工作中常用</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> stash //将当前的工作暂存，但是不进行提交
<span class="token function">git</span> stash show //显示暂存的内容，哪些被修改了，可指定序号
<span class="token function">git</span> stash list //已经暂存的列表和序号
<span class="token function">git</span> stash apply + stash@<span class="token punctuation">{</span>数字<span class="token punctuation">}</span> //切换回来继续工作 
//可以加上--index 来回到原来文件的暂存状态
<span class="token function">git</span> stash drop //丢弃指定的stash
<span class="token function">git</span> stash pop //apply + drop<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h1 id="Scoop"><a href="#Scoop" class="headerlink" title="Scoop"></a>Scoop</h1><blockquote>
<p>Scoop是一个Windows系统管理包的开源软件，相比从百度上搜索，从几十条垃圾信息中筛选出一个能用的安装链接，Scoop可以只使用一行代码进行安装</p>
</blockquote>
<h2 id="安装环境："><a href="#安装环境：" class="headerlink" title="安装环境："></a>安装环境：</h2><p>本人使用的是Windows11系统，已经内置PowerShell了，如果是Windows7系统，需要手动安装新版本的PowerShell</p>
<p>Scoop 源文件在GitHub上，推荐使用<strong>魔法</strong></p>
<h2 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h2><p>使用快捷键win+ x 打开 Windows终端，<strong>不要打开管理员的终端</strong></p>
<p><img src="/2023/07/04/56/Scoop.png" alt="Scoop"></p>
<p>之后输入</p>
<pre class="line-numbers language-shel" data-language="shel"><code class="language-shel"># 设置 PowerShell 执行策略
Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser
# 下载安装脚本
irm get.scoop.sh -outfile 'install.ps1'
# 执行安装, --ScoopDir 参数指定 Scoop 安装路径 ' ' 内的是自定义的安装目录
.\install.ps1 -ScoopDir 'D:\Scoop'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="使用技巧"><a href="#使用技巧" class="headerlink" title="使用技巧"></a>使用技巧</h2><p><a target="_blank" rel="noopener" href="https://github.com/ScoopInstaller/Scoop">官方文档</a> 或 <a target="_blank" rel="noopener" href="https://github.com/ScoopInstaller/Scoop/wiki/Quick-Start">快速入门</a> </p>
<p><a target="_blank" rel="noopener" href="https://p3terx.com/archives/scoop-the-best-windows-package-manager.html">大佬的博客</a></p>
<p>scoop社区维护的安装路径大部分在国外，所以下载时建议使用魔法</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">scoop <span class="token builtin class-name">help</span>  命令参考说明
scoop + 动作 + 对象， 对象可以省略
scoop +
search 搜索软件名
<span class="token function">install</span> 安装软件
update  更新软件
status  查看软件装填
uninstall 卸载软件
info     查看软件详情
home     打开软件主页<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>举例：</p>
<ul>
<li>查看本机有无安装typora</li>
</ul>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">scoop search typora<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><strong>Scoop下载软件的安装路径是自定义下载路径中的apps文件夹</strong></p>
<h2 id="正则表达式："><a href="#正则表达式：" class="headerlink" title="正则表达式："></a>正则表达式：</h2><pre class="line-numbers language-none"><code class="language-none">$ 匹配末尾位置  
^ 匹配开头位置
* 匹配前一个字符的0次或n次  例如： zo* 会匹配z zo zoo zooo z......  等
+ 匹配前一个字符一次或多次u        zo+ 匹配 zo zoo zooo zo...... 等
? 匹配前一个字符0次或1次           zo?      z  zo
{n,m}  匹配 n 到 m 次
{n}      n 次
? + 其他限定符，表示匹配非贪心，默认的匹配会尽力匹配较长的满足条件的字符串，使用这个后尽力匹配较短的字符串
.  匹配任意单个字符
//
(pattern) 匹配pattern 并捕获他的子表达式
(?:pattern) 不捕获子表达式
(?=pattern) 前面的字符匹配到之后，判断后面的是否能够匹配pattern 如果能那么就捕获，否则不匹配
(?!pattern) 反向捕获，不捕获包含patter的字符串
//规则集
x|y 匹配x或y
[xyz] 字符集，匹配三者的任一字符
[^xyz] 反向捕获
[a-z]  匹配a-z 中的任一字符
[^a-z] 反向匹配不包含的
//
\b     border 以这个符号之前的字符(串)为边界的匹配
\B     非边界匹配
\cx    x 为[a-z] 或 [A-Z] 匹配ctrl + x
\d     数字匹配，十进制[0-9]
\D     [^0-9]
\f     匹配换页符
\n     换行符
\r     匹配回车
\w     匹配字类字符 [A-Za-z0-9]
\W     非字类字符
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<h1 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h1><h2 id="坐标"><a href="#坐标" class="headerlink" title="坐标"></a>坐标</h2><ul>
<li><strong>groupId</strong>(必须): 定义了当前 Maven 项目隶属的组织或公司。groupId 一般分为多段，通常情况下，第一段为域，第二段为公司名称。域又分为 org、com、cn 等，其中 org 为非营利组织，com 为商业组织，cn 表示中国。以 apache 开源社区的 tomcat 项目为例，这个项目的 groupId 是 org.apache，它的域是 org（因为 tomcat 是非营利项目），公司名称是 apache，artifactId 是 tomcat。</li>
<li><strong>artifactId</strong>(必须)：定义了当前 Maven 项目的名称，项目的唯一的标识符，对应项目根目录的名称。</li>
<li><strong>version</strong>(必须)：定义了 Maven 项目当前所处版本。</li>
<li><strong>packaging</strong>（可选）：定义了 Maven 项目的打包方式（比如 jar，war…），默认使用 jar。</li>
<li><strong>classifier</strong>(可选)：常用于区分从同一 POM 构建的具有不同内容的构件，可以是任意的字符串，附加在版本号之后。</li>
</ul>
<hr>
<h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><ul>
<li>dependencies：一个 pom.xml 文件中只能存在一个这样的标签，是用来管理依赖的总标签。</li>
<li>dependency：包含在 dependencies 标签中，可以有多个，每一个表示项目的一个依赖。</li>
<li>groupId,artifactId,version(必要)：依赖的基本坐标，对于任何一个依赖来说，基本坐标是最重要的，Maven 根据坐标才能找到需要的依赖。我们在上面解释过这些元素的具体意思，这里就不重复提了。</li>
<li>type(可选)：依赖的类型，对应于项目坐标定义的 packaging。大部分情况下，该元素不必声明，其默认值是 jar。</li>
<li>scope(可选)：依赖的范围，默认值是 compile。</li>
<li>optional(可选)：标记依赖是否可选</li>
<li>exclusions(可选)：用来排除传递性依赖,例如 jar 包冲突</li>
</ul>
<hr>
<p>著作权归JavaGuide(javaguide.cn)所有 基于MIT协议 原文链接：<a target="_blank" rel="noopener" href="https://javaguide.cn/tools/maven/maven-core-concepts.html">https://javaguide.cn/tools/maven/maven-core-concepts.html</a></p>
<p>著作权归JavaGuide(javaguide.cn)所有 基于MIT协议 原文链接：<a target="_blank" rel="noopener" href="https://javaguide.cn/tools/maven/maven-core-concepts.html">https://javaguide.cn/tools/maven/maven-core-concepts.html</a></p>
<h1 id="xml"><a href="#xml" class="headerlink" title="xml"></a>xml</h1><p>eXtensible Markup Language 即可扩展标记语言。<br>一般用于做数据存储，支持自定义标签</p>
<blockquote>
<p>通过 XML，数据能够存储在独立的 XML 文件中。这样您就可以专注于使用 HTML/CSS 进行显示和布局，并确保修改底层数据不再需要对 HTML 进行任何的改变。<br>通过使用几行 JavaScript 代码，您就可以读取一个外部 XML 文件，并更新您的网页的数据内容。</p>
</blockquote>
<h2 id="基础语法："><a href="#基础语法：" class="headerlink" title="基础语法："></a>基础语法：</h2><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">//文档声明:
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>?xml</span> <span class="token attr-name">version</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">"</span>xxx<span class="token punctuation">"</span></span> <span class="token attr-name">?</span> <span class="token attr-name">encodiing</span> <span class="token attr-name">standlone</span><span class="token punctuation">&gt;</span></span>
encoding 指定文档的编码 UTF-8等
standalone 文档是否独立 yes or no

注释：
<span class="token comment">&lt;!--comment --&gt;</span>

标签内要包含要传递的信息
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>message</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>message</span><span class="token punctuation">/&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>示例: Bob写个Tom的信<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>?xml</span> <span class="token attr-name">version</span> <span class="token attr-name">"1.0"</span> <span class="token attr-name">encoding</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span> <span class="token comment">&lt;!--声明--&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>note</span><span class="token punctuation">&gt;</span></span> <span class="token comment">&lt;!-- 根元素，来表示本文档的类型--&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>to</span><span class="token punctuation">&gt;</span></span> Tom <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>to</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>from</span><span class="token punctuation">&gt;</span></span> Bob <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>from</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>heading</span><span class="token punctuation">&gt;</span></span> Reminder <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>heading</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span> Dont' forget me this weekend <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>note</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li>xml文档必须包含一个根元素，且只能有一个根元素，其他所有元素都是根元素的子元素</li>
<li>所有的标签都有一个闭标签 &lt;/…&gt;</li>
<li>xml 标签对大小写敏感</li>
<li>属性值必须加引号<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>note</span> <span class="token attr-name">date</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>12/11/2023<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
<li>实体引用，用于转义某些符号</li>
</ul>
<pre class="line-numbers language-XML" data-language="XML"><code class="language-XML">
&lt;  &lt;  less than
&gt;  &gt;  greater than
&amp; &amp;  ampersand
&amp;apos; ' apostrophe
" " quotation mark<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>标签命名： 尽量用 __ 来进行命名 first_name</li>
<li>属性Attribute : 提供有关元素的额外信息 (尽量减少属性的使用，将属性作为一个新的标签即可)</li>
<li>DTD 用于定义xml文档结构 Schema 基于xml的DTD替代</li>
<li>XSLT来显示XML</li>
</ul>
<h2 id="XMLHttpRequest-对象-JavaScript"><a href="#XMLHttpRequest-对象-JavaScript" class="headerlink" title="XMLHttpRequest 对象(JavaScript)"></a>XMLHttpRequest 对象(JavaScript)</h2><p>功能：</p>
<blockquote>
<p>在不重新加载页面的情况下更新网页<br>在页面已加载后从服务器请求数据<br>在页面已加载后从服务器接收数据<br>在后台向服务器发送数据</p>
</blockquote>
<h1 id="yaml"><a href="#yaml" class="headerlink" title="yaml"></a>yaml</h1><p>特点:</p>
<ol>
<li>使用缩进表示层级关系</li>
<li>缩进不能使用tab键</li>
<li>只要相同层级的元素左对齐即可，不需要控制多少空格数</li>
<li><h1 id="表示注释"><a href="#表示注释" class="headerlink" title="表示注释"></a>表示注释</h1></li>
</ol>
<p>示例:</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">key</span><span class="token punctuation">:</span>
	<span class="token key atrule">child-key</span><span class="token punctuation">:</span> value <span class="token comment"># 给予值的时候要空一个额格</span>

<span class="token comment">#较为复杂的对象格式，可以使用问号加一个空格代表一个复杂的 key，配合一个冒号加一个空格代表一个 value：</span>

<span class="token punctuation">?</span>  
    <span class="token punctuation">-</span> complexkey1
    <span class="token punctuation">-</span> <span class="token key atrule">complexkey2</span>
<span class="token punctuation">:</span>
    <span class="token punctuation">-</span> complexvalue1
    <span class="token punctuation">-</span> complexvalue2

意思即对象的属性是一个数组 <span class="token punctuation">[</span>complexkey1<span class="token punctuation">,</span>complexkey2<span class="token punctuation">]</span>，对应的值也是一个数组 <span class="token punctuation">[</span>complexvalue1<span class="token punctuation">,</span>complexvalue2<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>数组<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"> <span class="token comment"># 多维数组</span>
<span class="token punctuation">-</span> a
<span class="token punctuation">-</span> b
<span class="token punctuation">-</span> c
  <span class="token punctuation">-</span> d
  <span class="token punctuation">-</span> e
    <span class="token punctuation">-</span> f


<span class="token key atrule">companies</span><span class="token punctuation">:</span>
    <span class="token punctuation">-</span>
        <span class="token key atrule">id</span><span class="token punctuation">:</span> <span class="token number">1</span>
        <span class="token key atrule">name</span><span class="token punctuation">:</span> company1
        <span class="token key atrule">price</span><span class="token punctuation">:</span> 200W
    <span class="token punctuation">-</span>
        <span class="token key atrule">id</span><span class="token punctuation">:</span> <span class="token number">2</span>
        <span class="token key atrule">name</span><span class="token punctuation">:</span> company2
        <span class="token key atrule">price</span><span class="token punctuation">:</span> 500W
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
<h3 id="复合结构"><a href="#复合结构" class="headerlink" title="复合结构"></a>复合结构</h3><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">数组和对象可以构成复合结构，例：

<span class="token key atrule">languages</span><span class="token punctuation">:</span>
  <span class="token punctuation">-</span> Ruby
  <span class="token punctuation">-</span> Perl
  <span class="token punctuation">-</span> Python 
<span class="token key atrule">websites</span><span class="token punctuation">:</span>
  <span class="token key atrule">YAML</span><span class="token punctuation">:</span> yaml.org 
  <span class="token key atrule">Ruby</span><span class="token punctuation">:</span> ruby<span class="token punctuation">-</span>lang.org 
  <span class="token key atrule">Python</span><span class="token punctuation">:</span> python.org 
  <span class="token key atrule">Perl</span><span class="token punctuation">:</span> use.perl.org

转换为 json 为：

<span class="token punctuation">{</span> 
  <span class="token key atrule">languages</span><span class="token punctuation">:</span> <span class="token punctuation">[</span> <span class="token string">'Ruby'</span><span class="token punctuation">,</span> <span class="token string">'Perl'</span><span class="token punctuation">,</span> <span class="token string">'Python'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token key atrule">websites</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>
    <span class="token key atrule">YAML</span><span class="token punctuation">:</span> <span class="token string">'yaml.org'</span><span class="token punctuation">,</span>
    <span class="token key atrule">Ruby</span><span class="token punctuation">:</span> <span class="token string">'ruby-lang.org'</span><span class="token punctuation">,</span>
    <span class="token key atrule">Python</span><span class="token punctuation">:</span> <span class="token string">'python.org'</span><span class="token punctuation">,</span>
    <span class="token key atrule">Perl</span><span class="token punctuation">:</span> <span class="token string">'use.perl.org'</span> 
  <span class="token punctuation">}</span> 
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><ol>
<li>安装，并修改安装路径(windows)<br>此方法官方文档里有<br>先下载安装包<br>在想安装的地方建立文件夹Docker即可<br>然后打开cmd，输入<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token string">"Docker Desktop Installer.exe"</span> <span class="token function">install</span> --installation-dir<span class="token operator">=</span><span class="token string">"E:\Program Files\Docker"</span>
后面的是你自己的路径，根据实际修改即可，等待安装完毕即可<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li>
</ol>
<h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><p>容器是镜像的实例化，容器是一个小型的os，包含应用和其本身所需要的环境，镜像是只读的，而容器是可以运行的可写的，其中的容器处于运行状态</p>
<h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><p><img src="/2023/07/04/56/docker%E5%91%BD%E4%BB%A4.webp"></p>
<ul>
<li>基础镜像命令(与git类似)</li>
<li>ls , tag , inspect<pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">docker tag 旧 新
docker inspect 获得该镜像的详细信息.
-f 后面加上想获得的某一项的key就可以单独获得这一项的内容了
格式为</span><span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token string">".key名"</span><span class="token punctuation">}</span><span class="token punctuation">}</span>
docker history 查看某一镜像的历史
docker search -f=is-official=true --limit 5 --no-trunc  nginx  
-f 过滤条件
limit 限制输出的数量
--no-trunc 不截断输出结果
docker rmi  -f  myubuntu 当存在多个标签时，删除的只是标签，当仅仅剩下一个标签时会把这个镜像直接删除 -f
强制删除
docker image prune 清理临时镜像文件<span class="token punctuation">,</span>虚悬文件，指的是docker images 中没有名字的文件
-a 删除所有无用image 不光是临时镜像
-filter 只删除符合过滤条件的镜像
	- `until`<span class="token punctuation">:</span> 根据镜像的创建时间来筛选。例如，`until=24h`将删除24小时之前创建的镜像。
    
	- `label`<span class="token punctuation">:</span> 根据标签来筛选。例如，`label=myapp`将删除带有标签为<span class="token string">"myapp"</span>的镜像。
    
	- `dangling`<span class="token punctuation">:</span> 筛选出悬挂（无用）镜像。使用`dangling=true`来删除悬挂镜像。
-f 强制删除

创建镜像
docker commit [OPTIONS] CONTAINER [REPOSITORY[<span class="token punctuation">:</span>TAG]]
docker commit [选项] &lt;容器ID或容器名&gt; [&lt;仓库名&gt;[<span class="token punctuation">:</span>&lt;标签&gt;]]
 docker commit \
    --author <span class="token string">"Tao Wang &lt;twang2218@gmail.com&gt;"</span> \
    --message <span class="token string">"修改了默认网页"</span> \
    webserver \
    <span class="token property">nginx</span><span class="token punctuation">:</span>v2
//
- `CONTAINER`是要保存状态的容器的名称或容器ID。
- `REPOSITORY[<span class="token punctuation">:</span>TAG]`是新镜像的名称和标签。如果不提供标签，将默认使用<span class="token string">"latest"</span>标签。
docker commit -m <span class="token string">"xxx"</span> 被提交的容器

//导入导出镜像
docker save -o my_images.tar <span class="token property">image1</span><span class="token punctuation">:</span>tag <span class="token property">image2</span><span class="token punctuation">:</span>tag <span class="token property">image3</span><span class="token punctuation">:</span>tag  保存多个到镜像到指定的文件夹

docker load -i my_image.tar <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
<p>容器操作</p>
<pre class="line-numbers language-css" data-language="css"><code class="language-css">docker create  xxx
可选。。。
-i 默认打开标准输入
-t分配一个伪终端
docker start xx  启动一个容器
docker run --name 新名字 options 镜像 创建并启动一个容器
可选
-d 以守护态后台运行，容器是否会长久运行，是和 `docker run` 指定的命令有关，和 `-d` 参数无关。
-t 分配一个伪终端
-i 让容器的标准输入保持打开
docker restart 关闭容器并重新启动
docker logs 
-details
-f follow 持续保持输出
since string 从某一个时间开始日志
-tail string 输出最近的若干日志
-t timestamps 显示时间戳信息
-until string 输出某个时间段之前的信息

docker exec -it xxx 进入一个后台的容器 使用这个之后再容器内部执行exit 时不会导致容器停止，但是使用 docker attach 进入容器并退出的话会导致容器停止并退出
docker rm 
-f 强制终止并删除一个容器
-l 删除容器的链接，但保留容器
-v 删除容器挂在的数据卷
docker top 容器名称 查看容器的进程
docker inspect 容器名称 查看容器信息
docker cp &lt;本地文件/目录路径&gt; &lt;容器ID或名称&gt;<span class="token punctuation">:</span>&lt;容器内部路径&gt;
docker cp &lt;容器ID或名称&gt;<span class="token punctuation">:</span>&lt;容器内部路径&gt; &lt;本地文件/目录路径&gt;
-a 打包
-L 跟随软连接
docker pause id 暂停<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li><ol>
<li><strong>创建卷</strong>： 您可以使用以下命令创建一个卷：</li>
</ol>
<p>  bashCopy code</p>
<p>  <code>docker volume create my_volume</code></p>
<p>  这将创建一个名为 <code>my_volume</code> 的卷。</p>
</li>
</ul>
<ol start="2">
<li><p><strong>查看卷列表</strong>： 要查看系统中的所有卷，可以运行：</p>
<p> bashCopy code</p>
<p> <code>docker volume ls</code></p>
</li>
<li><p><strong>删除卷</strong>： 要删除一个不再需要的卷，可以运行：</p>
<p> bashCopy code</p>
<p> <code>docker volume rm my_volume</code></p>
</li>
<li><p><strong>挂载卷到容器</strong>： 在运行容器时，使用 <code>-v</code> 或 <code>--volume</code> 标志来将卷挂载到容器内部。例如：</p>
<p> bashCopy code</p>
<p> <code>docker run -d -v my_volume:/path/in/container my_image</code></p>
<p> 这将把 <code>my_volume</code> 卷挂载到容器内部的 <code>/path/in/container</code> 目录。</p>
</li>
<li><p><strong>挂载主机目录到容器</strong>： 您还可以将主机上的目录挂载到容器内。例如：</p>
<p> bashCopy code</p>
<p> <code>docker run -d -v /host/path:/path/in/container my_image</code></p>
<p> 这将把主机上的 <code>/host/path</code> 目录挂载到容器内的 <code>/path/in/container</code>。</p>
</li>
<li><p><strong>查看容器的挂载卷</strong>： 要查看正在运行的容器挂载了哪些卷，可以使用以下命令：</p>
<p> bashCopy code</p>
<p> <code>docker inspect -f '{{ .Mounts }}' container_name_or_id</code></p>
</li>
<li><p><strong>复制文件到卷</strong>： 如果需要将文件复制到卷中，可以运行一个临时容器，然后将文件复制到挂载卷的路径。例如：</p>
<p> bashCopy code</p>
<p> <code>docker run --rm -v my_volume:/path/in/container -v /local/path/to/file:/data busybox cp /local/path/to/file /path/in/container</code></p>
<p> 这将复制 <code>/local/path/to/file</code> 到 <code>my_volume</code> 卷的 <code>/path/in/container</code>。</p>
</li>
<li><p><strong>卷数据备份和恢复</strong>： 您可以使用工具如 <code>docker cp</code> 或 <code>docker export</code> 来备份卷数据，然后使用 <code>docker create</code> 和 <code>docker start</code> 来恢复它们。备份和恢复数据的确切方法取决于您的需求和容器的情况。</p>
<pre class="line-numbers language-css" data-language="css"><code class="language-css">挂载数据卷
1.建立数据卷
docker run -it -v /db --name db0 ubuntu
docker run -it --volume-from db --name db1 ubuntu
docker run -it --volume-from db --name db2 ubuntu<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ol>
<ul>
<li>VOLUME 的使用<br>将数据读写存储在数据卷中，使得容器尽量不发生读写操作，dockerfile 中的VOLUME是可以呗docker run覆盖的</li>
</ul>
<h3 id="dockerfile"><a href="#dockerfile" class="headerlink" title="dockerfile"></a>dockerfile</h3><h2 id="指令详解"><a href="#指令详解" class="headerlink" title="指令详解"></a>指令详解</h2><table>
<thead>
<tr>
<th>Dockerfile 指令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>FROM</td>
<td>指定基础镜像，用于后续的指令构建。</td>
</tr>
<tr>
<td>LABEL</td>
<td>添加镜像的元数据，使用键值对的形式，方便后续进行filter来筛选。</td>
</tr>
<tr>
<td>RUN</td>
<td>在构建过程中在镜像中执行命令。</td>
</tr>
<tr>
<td>CMD</td>
<td>指定容器创建时的默认命令。（可以被覆盖）</td>
</tr>
<tr>
<td>ENTRYPOINT</td>
<td>设置容器创建时的主要命令。（不可被覆盖），</td>
</tr>
<tr>
<td>EXPOSE</td>
<td>声明容器运行时监听的特定网络端口，不会自动映射，只是声明，需要自己配置</td>
</tr>
<tr>
<td>ENV</td>
<td>在容器内部设置环境变量。</td>
</tr>
<tr>
<td>ADD</td>
<td>将文件、目录或远程URL复制到镜像，自动解压</td>
</tr>
<tr>
<td>COPY</td>
<td>将文件或目录复制到镜像中。</td>
</tr>
<tr>
<td>VOLUME</td>
<td>为容器创建挂载点或声明卷。</td>
</tr>
<tr>
<td>WORKDIR</td>
<td>设置后续指令的工作目录。</td>
</tr>
<tr>
<td>USER</td>
<td>指定后续指令的用户上下文。</td>
</tr>
<tr>
<td>ARG</td>
<td>定义在构建过程中传递给构建器的变量，可使用 “docker build” 命令设置。</td>
</tr>
<tr>
<td>ONBUILD</td>
<td>当该镜像被用作另一个构建过程的基础时，添加触发器。</td>
</tr>
<tr>
<td>STOPSIGNAL</td>
<td>设置发送给容器以退出的系统调用信号。</td>
</tr>
<tr>
<td>HEALTHCHECK</td>
<td>定义周期性检查容器健康状态的命令</td>
</tr>
<tr>
<td>SHELL</td>
<td>覆盖Docker中默认的shell，用于RUN、CMD和ENTRYPOINT指令。</td>
</tr>
<tr>
<td>RUN</td>
<td>运行指定命令</td>
</tr>
<tr>
<td>CMD</td>
<td>启动容器时指定默认执行的命令</td>
</tr>
<tr>
<td>ADD</td>
<td>添加内容到镜像</td>
</tr>
<tr>
<td>COPY</td>
<td>复制内容到镜像</td>
</tr>
</tbody></table>
<h3 id="实际操作"><a href="#实际操作" class="headerlink" title="实际操作"></a>实际操作</h3><p>推荐使用基础镜像：<br>BusyBox 集成Linux的命令<br>Alpine  在BusyBox基础上减小体积和消耗，并提供了apt管理工具</p>
<ul>
<li>使用dockerfile为镜像添加ssh服务<pre class="line-numbers language-css" data-language="css"><code class="language-css">#设置继承镜像
FROM myub

#提供作者信息
MAINTAINER docker_user <span class="token punctuation">(</span>user@docker.com<span class="token punctuation">)</span>

#执行命令
RUN apt-get update
RUN apt-get install -y openssh-server
RUN mkdir -p /var/run/sshd
RUN mkdir -p /root/.ssh
RUN sed -ri <span class="token string">'s/session required pam_loginid.so/#session required pam_loginuid.so/g'</span> /etc/pam.d/sshd

#复制配置文件到对应位置，并赋予其可执行权限
ADD authorized_keys /root/.ssh/authorized_eys
ADD run.sh /run.sh
RUN chmod 755 /run.sh
#开放端口
EXPOSE 22
#设置自启动命令
CMD [<span class="token string">"/run.sh"</span>]
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
<p>FROM scratch</p>
<p>如果你以 <code>scratch</code> 为基础镜像的话，意味着你不以任何镜像为基础，接下来所写的指令将作为镜像第一层开始存在。</p>
<p>不以任何系统为基础，直接将可执行文件复制进镜像的做法并不罕见，对于 Linux 下静态编译的程序来说，并不需要有操作系统提供运行时支持，所需的一切库都已经在可执行文件里了，因此直接 <code>FROM scratch</code> 会让镜像体积更加小巧。使用 <a target="_blank" rel="noopener" href="https://golang.google.cn/">Go 语言</a> 开发的应用很多会使用这种方式来制作镜像，这也是有人认为 Go 是特别适合容器微服务架构的语言的原因之一。</p>
<p>每一个RUN会建立一层，所以要进行多重操作的时候不要每一行都建立一个RUN而是将他们合在一层</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">FROM debian:stretch

RUN <span class="token builtin class-name">set</span> -x<span class="token punctuation">;</span> <span class="token assign-left variable">buildDeps</span><span class="token operator">=</span><span class="token string">'gcc libc6-dev make wget'</span> <span class="token punctuation">\</span>
    <span class="token operator">&amp;&amp;</span> <span class="token function">apt-get</span> update <span class="token punctuation">\</span>
    <span class="token operator">&amp;&amp;</span> <span class="token function">apt-get</span> <span class="token function">install</span> <span class="token parameter variable">-y</span> <span class="token variable">$buildDeps</span> <span class="token punctuation">\</span>
    <span class="token operator">&amp;&amp;</span> <span class="token function">wget</span> <span class="token parameter variable">-O</span> redis.tar.gz <span class="token string">"http://download.redis.io/releases/redis-5.0.3.tar.gz"</span> <span class="token punctuation">\</span>
    <span class="token operator">&amp;&amp;</span> <span class="token function">mkdir</span> <span class="token parameter variable">-p</span> /usr/src/redis <span class="token punctuation">\</span>
    <span class="token operator">&amp;&amp;</span> <span class="token function">tar</span> <span class="token parameter variable">-xzf</span> redis.tar.gz <span class="token parameter variable">-C</span> /usr/src/redis --strip-components<span class="token operator">=</span><span class="token number">1</span> <span class="token punctuation">\</span>
    <span class="token operator">&amp;&amp;</span> <span class="token function">make</span> <span class="token parameter variable">-C</span> /usr/src/redis <span class="token punctuation">\</span>
    <span class="token operator">&amp;&amp;</span> <span class="token function">make</span> <span class="token parameter variable">-C</span> /usr/src/redis <span class="token function">install</span> <span class="token punctuation">\</span>
    <span class="token operator">&amp;&amp;</span> <span class="token function">rm</span> <span class="token parameter variable">-rf</span> /var/lib/apt/lists/* <span class="token punctuation">\</span>
    <span class="token operator">&amp;&amp;</span> <span class="token function">rm</span> redis.tar.gz <span class="token punctuation">\</span>
    <span class="token operator">&amp;&amp;</span> <span class="token function">rm</span> <span class="token parameter variable">-r</span> /usr/src/redis <span class="token punctuation">\</span>
    <span class="token operator">&amp;&amp;</span> <span class="token function">apt-get</span> purge <span class="token parameter variable">-y</span> --auto-remove <span class="token variable">$buildDeps</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li><p>docker 不是虚拟机不存在后台运行，其中的所有应用都是在前台运行的，所以dockerfile 中直接执行这个应用即可，然后退出容器，让容器在后台运行即可</p>
<pre class="line-numbers language-docker" data-language="docker"><code class="language-docker"><span class="token instruction"><span class="token keyword">CMD</span> [<span class="token string">"nginx"</span>, <span class="token string">"-g"</span>, <span class="token string">"daemon off;"</span>]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>这是因为当存在 <code>ENTRYPOINT</code> 后，<code>CMD</code> 的内容将会作为参数传给 <code>ENTRYPOINT</code>，而这里 <code>-i</code> 就是新的 <code>CMD</code>，因此会作为参数传给 <code>curl</code>，从而达到了我们预期的效果。</p>
</li>
<li><p>ENV 设置</p>
<pre class="line-numbers language-docker" data-language="docker"><code class="language-docker"><span class="token instruction"><span class="token keyword">ENV</span> key1=value1 key2=value2 .....</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
<li><p>ARG 设置变量 等于 <code>docker build</code> 中用 <code>--build-arg &lt;参数名&gt;=&lt;值&gt;</code></p>
</li>
<li><p>ARG 指令有生效范围，如果在 <code>FROM</code> 指令之前指定，那么只能用于 <code>FROM</code> 指令中。</p>
<pre class="line-numbers language-docker" data-language="docker"><code class="language-docker"><span class="token comment"># 只在 FROM 中生效</span>
<span class="token instruction"><span class="token keyword">ARG</span> DOCKER_USERNAME=library</span>

<span class="token instruction"><span class="token keyword">FROM</span> <span class="token variable">${DOCKER_USERNAME}</span>/alpine</span>

<span class="token comment"># 要想在 FROM 之后使用，必须再次指定</span>
<span class="token instruction"><span class="token keyword">ARG</span> DOCKER_USERNAME=library</span>

<span class="token instruction"><span class="token keyword">RUN</span> set -x ; echo <span class="token variable">${DOCKER_USERNAME}</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

</li>
<li><p>HEALTHCHECK</p>
</li>
<li><p><code>--interval=&lt;间隔&gt;</code>：两次健康检查的间隔，默认为 30 秒；</p>
</li>
<li><p><code>--timeout=&lt;时长&gt;</code>：健康检查命令运行超时时间，如果超过这个时间，本次健康检查就被视为失败，默认 30 秒；</p>
</li>
<li><p><code>--retries=&lt;次数&gt;</code>：当连续失败指定次数后，则将容器状态视为 <code>unhealthy</code>，默认 3 次。</p>
</li>
</ul>
<pre class="line-numbers language-docker" data-language="docker"><code class="language-docker"><span class="token instruction"><span class="token keyword">FROM</span> nginx</span>
<span class="token instruction"><span class="token keyword">RUN</span> apt-get update &amp;&amp; apt-get install -y curl &amp;&amp; rm -rf /var/lib/apt/lists/*</span>
<span class="token instruction"><span class="token keyword">HEALTHCHECK</span> <span class="token options"><span class="token property">--interval</span><span class="token punctuation">=</span><span class="token string">5s</span> <span class="token property">--timeout</span><span class="token punctuation">=</span><span class="token string">3s</span></span> <span class="token operator">\</span>
  <span class="token keyword">CMD</span> curl -fs http://localhost/ || exit 1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>多阶段构造镜像<ol>
<li>多个FROM 和 构造过程写在一个dockerfile 中</li>
<li>使用as 来为某一阶段的构造命名 FROM golang:alpine as builder之后构造时直接指定名字即可, $ docker build –target builder -t username/imagename:tag .</li>
</ol>
</li>
<li>docker 导入导出容器<br>示例：<pre class="line-numbers language-css" data-language="css"><code class="language-css">docker export 7691a814370e &gt; ubuntu.tar
cat ubuntu.tar | docker import - test/<span class="token property">ubuntu</span><span class="token punctuation">:</span>v1.0 # 将文件读入到标准输入流，再将其导入到镜像中
# 或者使用URL 来导入也行<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li>
</ul>
<h3 id="docker-查看容器ip"><a href="#docker-查看容器ip" class="headerlink" title="docker 查看容器ip"></a>docker 查看容器ip</h3><pre class="line-numbers language-none"><code class="language-none">docker inspect 容器ID | grep IPAddress<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h3 id="Nexus-容器"><a href="#Nexus-容器" class="headerlink" title="Nexus 容器"></a>Nexus 容器</h3><p>可以方便进行对Maven , Docker ,Yum,PyPI的管理</p>
<h1 id="Lua-一种可以嵌入程序的简便语言"><a href="#Lua-一种可以嵌入程序的简便语言" class="headerlink" title="Lua 一种可以嵌入程序的简便语言"></a>Lua 一种可以嵌入程序的简便语言</h1><p>一般只适合在linux上使用<br>安装：<br><code>apt-get install luaxxx(版本号)</code><br>执行<br><code>lua xxx.lua</code></p>
<h2 id="交互式编程"><a href="#交互式编程" class="headerlink" title="交互式编程"></a>交互式编程</h2><p>Lua 提供了交互式编程模式。我们可以在命令行中输入程序并立即查看效果。</p>
<p>Lua 交互式编程模式可以通过命令&nbsp;<strong>lua -i</strong>&nbsp;或&nbsp;<strong>lua</strong>&nbsp;来启用</p>
<ol>
<li>基本语法<ul>
<li>注释 – 单行  <code>--[[xxxx --]]</code> 多行注释</li>
<li>默认为全局变量，全局变量不需要声明，不需要时置为nil即可,局部变量使用 local 来指定</li>
<li>基本数据类型: nil ,boolean , number(为double类型) , string ,userdata (任意存储在变量中的数据结构)</li>
<li>userdata 是一种用户自定义数据，用于表示一种由应用程序或 C/C++ 语言库所创建的类型。 可以将任意 C/C++ 的任意数据类型的数据（通常是 struct 和 指针）存储到 Lua 变量中调用</li>
<li>function(由C 或Lua编写的函数) , thread(线程), table(关联数组)</li>
<li>使用<code>[[]]</code> 来跨越多行赋值</li>
<li>Lua可以对多个变量同时赋值，变量列表和值列表的各个元素用逗号分开，赋值语句右边的值会依次赋给左边的变量<pre class="line-numbers language-Lua" data-language="Lua"><code class="language-Lua">html = [[
&lt;html&gt;
&lt;head&gt;&lt;/head&gt;
&lt;body&gt;
    &lt;a href="https://www.twle.cn/"&gt;简单编程&lt;/a&gt;
&lt;/body&gt;
&lt;/html&gt;
]]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
</li>
</ol>
<ul>
<li>lua会尝试将字符数字转化为数字来进行数字计算，字符串连接符是 <code>..</code></li>
<li><h1 id="string-来计算字符串的长度"><a href="#string-来计算字符串的长度" class="headerlink" title="string 来计算字符串的长度"></a>string 来计算字符串的长度</h1></li>
<li><strong>默认索引是从1开始</strong></li>
<li>function 可以以匿名函数（anonymous function）的方式通过参数传递<pre class="line-numbers language-lua" data-language="lua"><code class="language-lua"><span class="token comment">-- !/usr/bin/lua</span>
<span class="token comment">-- -*- encoding:utf-8 -*-</span>
<span class="token comment">-- filename: main.lua</span>
<span class="token comment">-- author: 简单教程(www.twle.cn)</span>
<span class="token comment">-- Copyright © 2015-2065 www.twle.cn. All rights reserved.</span>

<span class="token keyword">function</span> <span class="token function">testFun</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span>fun<span class="token punctuation">)</span>
    <span class="token keyword">for</span> k <span class="token punctuation">,</span>v <span class="token keyword">in</span> <span class="token function">pairs</span><span class="token punctuation">(</span>tab<span class="token punctuation">)</span> <span class="token keyword">do</span>
        <span class="token function">print</span><span class="token punctuation">(</span><span class="token function">fun</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">end</span>
<span class="token keyword">end</span>

tab<span class="token operator">=</span><span class="token punctuation">{</span>key1<span class="token operator">=</span><span class="token string">"val1"</span><span class="token punctuation">,</span>key2<span class="token operator">=</span><span class="token string">"val2"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token function">testFun</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span>
<span class="token keyword">function</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span>val<span class="token punctuation">)</span><span class="token comment">--匿名函数</span>
    <span class="token keyword">return</span> key<span class="token operator">..</span><span class="token string">"="</span><span class="token operator">..</span>val<span class="token punctuation">;</span>
<span class="token keyword">end</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li>table变量可以使用索引，key，或者 . 来获取值</li>
<li>注意 : Lua 中 0 为 true</li>
<li><strong>多返回值</strong>Lua 中的函数可以返回<strong>多个结果值</strong>，例如&nbsp;<strong>string.find</strong>&nbsp;返回匹配串 “开始和结束的下标”（如果不存在匹配串返回 nil ）<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token operator">&gt;</span> s, e <span class="token operator">=</span> string.find<span class="token punctuation">(</span><span class="token string">"www.twle.cn"</span>, <span class="token string">"twle"</span><span class="token punctuation">)</span> 
<span class="token operator">&gt;</span> print<span class="token punctuation">(</span>s, e<span class="token punctuation">)</span>
<span class="token number">5</span>   <span class="token number">10</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li>
<li>可变参数 使用 … 来代表</li>
<li>算术运算符 有 ^ 幂运算哦 </li>
<li>不等于是 -= 不是 != </li>
<li>逻辑运算 and , or ,not</li>
<li><h1 id="返回字符串个数或者传入参数个数"><a href="#返回字符串个数或者传入参数个数" class="headerlink" title="返回字符串个数或者传入参数个数.."></a>返回字符串个数或者传入参数个数..</h1></li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>\a</td>
<td>响铃(BEL)</td>
<td>007</td>
</tr>
<tr>
<td>\b</td>
<td>退格(BS) ，将当前位置移到前一列</td>
<td>008</td>
</tr>
<tr>
<td>\f</td>
<td>换页(FF)，将当前位置移到下页开头</td>
<td>012</td>
</tr>
<tr>
<td>\n</td>
<td>换行(LF) ，将当前位置移到下一行开头</td>
<td>010</td>
</tr>
<tr>
<td>\r</td>
<td>回车(CR) ，将当前位置移到本行开头</td>
<td>013</td>
</tr>
<tr>
<td>\t</td>
<td>水平制表(HT) （跳到下一个TAB位置）</td>
<td>009</td>
</tr>
<tr>
<td>\v</td>
<td>垂直制表(VT)</td>
<td>011</td>
</tr>
<tr>
<td>\</td>
<td>代表一个反斜线字符’’'</td>
<td>092</td>
</tr>
<tr>
<td>'</td>
<td>代表一个单引号（撇号）字符</td>
<td>039</td>
</tr>
<tr>
<td>"</td>
<td>代表一个双引号字符</td>
<td>034</td>
</tr>
<tr>
<td>\0</td>
<td>空字符(NULL)</td>
<td>000</td>
</tr>
<tr>
<td>\ddd</td>
<td>1到3位八进制数所代表的任意字符</td>
<td>三位八进制</td>
</tr>
<tr>
<td>\xhh</td>
<td>1到2位十六进制所代表的任意字符</td>
<td>二位十六进制</td>
</tr>
</tbody></table>
<ul>
<li><p>常用字符串方法 string + . +</p>
<ul>
<li>upper 大写 lower 小写</li>
<li>gsub(string , findstring , replacestring ,num) 从string中查找findstring,并替换为replacestring ，num是替换的次数</li>
<li>find ()  返回首次出现该字符串的前后位置，包括开始和结束的位置</li>
<li>reverse 反转</li>
<li>char(num1,num2…) 将数字变为字母，ascii码</li>
<li>byte(字母串,指定某个字符) 将字母变为数字</li>
<li>len 长度</li>
<li>rep(string,num) 返回重复num次的string</li>
<li>gmatch(string,pattern) 返回一个迭代器，返回一个符合pattern的字串，可以使用 </li>
<li>format ()格式化 <a target="_blank" rel="noopener" href="https://www.twle.cn/l/yufei/lua53/lua-basic-strings-format.html">转义码</a></li>
</ul>
</li>
<li><p>数组 lua的数组可以从负数开始遍历索引从1开始</p>
<ul>
<li><code>for i= -1 , 10 do ...</code></li>
<li>迭代器: <pre class="line-numbers language-lua" data-language="lua"><code class="language-lua"><span class="token comment">-- pairs用于匹配键值对</span>
<span class="token keyword">local</span> myTable <span class="token operator">=</span> <span class="token punctuation">{</span>a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">,</span> c <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">}</span>
<span class="token keyword">for</span> key<span class="token punctuation">,</span> value <span class="token keyword">in</span> <span class="token function">pairs</span><span class="token punctuation">(</span>myTable<span class="token punctuation">)</span> <span class="token keyword">do</span>
    <span class="token function">print</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span>
<span class="token keyword">end</span>

<span class="token comment">--ispairs 用于遍历数组，字符串等</span>
<span class="token keyword">local</span> myArray <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">}</span>
<span class="token keyword">for</span> index<span class="token punctuation">,</span> value <span class="token keyword">in</span> <span class="token function">ipairs</span><span class="token punctuation">(</span>myArray<span class="token punctuation">)</span> <span class="token keyword">do</span>
    <span class="token function">print</span><span class="token punctuation">(</span>index<span class="token punctuation">,</span> value<span class="token punctuation">)</span>
<span class="token keyword">end</span>
<span class="token comment">--自定义迭代器，实际就是自己写的遍历算法。。</span>
<span class="token keyword">function</span> <span class="token function">myIterator</span><span class="token punctuation">(</span>collection<span class="token punctuation">)</span>
    <span class="token keyword">local</span> index <span class="token operator">=</span> <span class="token number">1</span>
    <span class="token keyword">local</span> size <span class="token operator">=</span> <span class="token operator">#</span>collection
    <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">if</span> index <span class="token operator">&lt;=</span> size <span class="token keyword">then</span>
            <span class="token keyword">local</span> value <span class="token operator">=</span> collection<span class="token punctuation">[</span>index<span class="token punctuation">]</span>
            index <span class="token operator">=</span> index <span class="token operator">+</span> <span class="token number">1</span>
            <span class="token keyword">return</span> value
        <span class="token keyword">end</span>
    <span class="token keyword">end</span>
<span class="token keyword">end</span>

<span class="token keyword">local</span> myArray <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">,</span> <span class="token number">300</span><span class="token punctuation">}</span>
<span class="token keyword">local</span> iter <span class="token operator">=</span> <span class="token function">myIterator</span><span class="token punctuation">(</span>myArray<span class="token punctuation">)</span>
<span class="token keyword">for</span> value <span class="token keyword">in</span> iter <span class="token keyword">do</span>
    <span class="token function">print</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span>
<span class="token keyword">end</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
</li>
<li><p>table常用方法 table + . +</p>
<ul>
<li>concat 是 concatenate (连锁, 连接) 的缩写. table.concat() 函数列出参数中指定 table 的数组部分从 start 位置到 end 位置的所有元素, 元素间以指定的分隔符(sep)隔开</li>
<li>insert(table,pos,value) 在指定位置添加一个value ,如果未指定位置，默认从尾部加入</li>
<li>remove(table,post) 返回并移除table 位于pos位置的元素，后面的元素会自动向前</li>
<li>sort 进行升序排序</li>
</ul>
</li>
<li><p>lua的模式匹配<br><a target="_blank" rel="noopener" href="https://tool.oschina.net/uploads/apidocs/jquery/regexp.html">开源中国中正则表达式列表</a><br><a target="_blank" rel="noopener" href="https://www.twle.cn/l/yufei/lua53/lua-basic-strings-match.html">lua模式匹配</a></p>
</li>
<li><p>% 用于将后面的字符转义为字面量而不是特殊字符，例如</p>
</li>
<li><p>%。 匹配的是。而不是其他的</p>
</li>
<li><p>有时也会有特殊含义: %a 代表的是匹配一个字母，%d 代表匹配一个数字</p>
</li>
<li><p>字符类 %d 匹配任意数字，所以可以使用模式串 ‘%d%d/%d%d/%d%d%d%d’ 搜索 dd/mm/yyyy 格式</p>
</li>
<li><p>模块和导包</p>
</li>
<li><p>导包require(模块名)，甚至可以加个.var赋给一个变量来调用模块</p>
</li>
<li><p>元表？</p>
</li>
<li><p>协程</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.twle.cn/l/yufei/lua53/lua-basic-file-io.html">文件</a></p>
</li>
</ul>
<h1 id="nginx"><a href="#nginx" class="headerlink" title="nginx"></a>nginx</h1><p>一种高性能的 HTTP 和&nbsp;反向代理的服务器，<strong>默认监听端口是80</strong>不是8080</p>
<ul>
<li>基本命令<pre class="line-numbers language-css" data-language="css"><code class="language-css">nginx 启动
nginx -s quit 优雅的退出，完成所有任务后退出
nginx -s stop 强制退出
nginx -s reload 重启，来刷新配置文件
nginx -t 测试配置文件是否可用，同时会显示配置文件的路径
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><strong>配置文件</strong><br>配置文件分为三类</li>
</ul>
<ol>
<li>全局块,服务器配置，日志存放等</li>
<li>events 主要影响服务器和用户的网络连接</li>
<li>http 可以分很多块<ul>
<li><p>server块  全局块 本机监听配置和ip配置</p>
</li>
<li><p>location 局部块  控制地址定向，转发等 ， 在server块内来匹配新的转发路径</p>
</li>
</ul>
</li>
</ol>
<p>用法一：反向代理，作为另一个服务器的转发服务器来隐藏另一个服务器<br>使用docker 启动一个tomcat服务器，并进入并启动服务</p>
<pre class="line-numbers language-css" data-language="css"><code class="language-css">docker run -itd tomcat /bin/sh
进入tomcat/bin目录
./startup.sh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>错误情况：</p>
<p>docker tomcat无法启动</p>
<ol>
<li>可能没有映射端口或者没有关闭防火墙</li>
<li>把webapps.dist目录换成webapps</li>
<li>将文件扔到webapps即可</li>
</ol>
<p>测试第一个方法，解决问题！</p>
<p>进入容器内部</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">docker exec <span class="token operator">-</span>it mytomcat <span class="token operator">/</span>bin<span class="token operator">/</span>bash<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>复制</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">rm <span class="token operator">-</span>rf webapps
mv webapps<span class="token punctuation">.</span>dist webapps<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>复制</p>
<p>重启tomcat</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">docker restart mytomcat<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>查看docker的tomcat ip<br><code>docker inspect ID | grep IPAddress</code><br>配置文件:</p>
<pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">server</span> <span class="token punctuation">{</span>
    listen       8888 <span class="token punctuation">;</span> ##设置我们nginx监听端口为8888
    server_name  [服务器的ip地址]<span class="token punctuation">;</span> # 不带http

    # Load configuration files for the default server block.
    include /etc/nginx/default.d/*.conf<span class="token punctuation">;</span>

    <span class="token selector">location /</span> <span class="token punctuation">{</span>
        proxy_pass <span class="token property">http</span><span class="token punctuation">:</span>//<span class="token property">tomcat服务器ip</span><span class="token punctuation">:</span>8080<span class="token punctuation">;</span> ##需要代理的服务器地址
        index index.html<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    error_page 404 /404.html<span class="token punctuation">;</span>
        <span class="token selector">location = /40x.html</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>

    error_page 500 502 503 504 /50x.html<span class="token punctuation">;</span>
        <span class="token selector">location = /50x.html</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>打开浏览器输入服务器的ip和代理端口，就可以看到docker容器中tomcat的主界面</p>
<ul>
<li><p>实现服务器分发<br>配置</p>
<pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">server</span> <span class="token punctuation">{</span>
    listen       8888 <span class="token punctuation">;</span> ##设置我们nginx监听端口为8888
    server_name  [服务器的ip地址]<span class="token punctuation">;</span>

    # Load configuration files for the default server block.
    include /etc/nginx/default.d/*.conf<span class="token punctuation">;</span>

    <span class="token selector">location /hi/</span> <span class="token punctuation">{</span>
        proxy_pass <span class="token property">http</span><span class="token punctuation">:</span>//服务器2<span class="token punctuation">;</span> ##需要代理的服务器地址
        index index.html<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
    <span class="token selector">location /hello/</span> <span class="token punctuation">{</span>
        proxy_pass <span class="token property">http</span><span class="token punctuation">:</span>//服务器2<span class="token punctuation">;</span> ##需要代理的服务器地址
        index index.html<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    error_page 404 /404.html<span class="token punctuation">;</span>
        <span class="token selector">location = /40x.html</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>

    error_page 500 502 503 504 /50x.html<span class="token punctuation">;</span>
        <span class="token selector">location = /50x.html</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000022315733">location 匹配</a></p>
<pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">location [ = | ~ | ~* | ^~ ] /URI</span> <span class="token punctuation">{</span> … <span class="token punctuation">}</span>
<span class="token selector">location @/name/</span> <span class="token punctuation">{</span> … <span class="token punctuation">}</span>
########### 顺序
1. location =    # 精准匹配
2. location ^~   # 带参前缀匹配
3. location ~    # 正则匹配（区分大小写）
4. location ~*   # 正则匹配（不区分大小写）
5. location /a   # 普通前缀匹配，优先级低于带参数前缀匹配。
6. location /    # 任何没有匹配成功的，都会匹配这里处理<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<table>
<thead>
<tr>
<th>参数</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><strong><code>空</code></strong></td>
<td>location 后没有参数直接跟着&nbsp;<strong>标准 URI</strong>，表示前缀匹配，代表跟请求中的 URI 从头开始匹配。</td>
</tr>
<tr>
<td><strong><code>=</code></strong></td>
<td>用于<strong>标准 URI</strong>&nbsp;前，要求请求字符串与其精准匹配，成功则立即处理，nginx停止搜索其他匹配。</td>
</tr>
<tr>
<td><strong><code>^~</code></strong></td>
<td>用于<strong>标准 URI</strong>&nbsp;前，并要求一旦匹配到就会立即处理，不再去匹配其他的那些个正则 URI，一般用来匹配目录</td>
</tr>
<tr>
<td><strong><code>~</code></strong></td>
<td>用于<strong>正则 URI</strong>&nbsp;前，表示 URI 包含正则表达式，&nbsp;<strong>区分</strong>大小写</td>
</tr>
<tr>
<td><strong><code>~*</code></strong></td>
<td>用于<strong>正则 URI</strong>&nbsp;前， 表示 URI 包含正则表达式，&nbsp;<strong>不区分</strong>大小写</td>
</tr>
<tr>
<td><strong><code>@</code></strong></td>
<td>@ 定义一个命名的 location，@ 定义的locaiton名字一般用在内部定向，例如error_page, try_files命令中。它的功能类似于编程中的goto。</td>
</tr>
</tbody></table>
</li>
<li><p>顺序</p>
</li>
</ul>
<ol>
<li>先精准匹配&nbsp;<strong><code>=</code></strong>&nbsp;，精准匹配成功则会立即停止其他类型匹配；</li>
<li>没有精准匹配成功时，进行前缀匹配。先查找带有&nbsp;<strong><code>^~</code></strong>&nbsp;的前缀匹配，带有&nbsp;<strong><code>^~</code></strong>&nbsp;的前缀匹配成功则立即停止其他类型匹配，普通前缀匹配（不带参数&nbsp;<strong><code>^~</code></strong>&nbsp;）成功则会暂存，继续查找正则匹配；</li>
<li><strong><code>=</code></strong>&nbsp;和&nbsp;<strong><code>^~</code></strong>&nbsp;均未匹配成功前提下，查找正则匹配&nbsp;<strong><code>~</code></strong>&nbsp;和&nbsp;<strong><code>~*</code></strong>&nbsp;。当同时有多个正则匹配时，按其在配置文件中出现的先后顺序优先匹配，命中则立即停止其他类型匹配；</li>
<li>所有正则匹配均未成功时，返回步骤 2 中暂存的普通前缀匹配（不带参数&nbsp;<strong><code>^~</code></strong>&nbsp;）结果</li>
</ol>
<ul>
<li>负载均衡<br>配置文件(server块)<pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">http</span> <span class="token punctuation">{</span>

<span class="token selector">###此处省略一大堆没有改的配置


    ##自定义我们的服务列表
    upstream myserver</span><span class="token punctuation">{</span>
	    #### 可以使用 ip_hash 来进行hash 分配，可以与weight一起使用
	   ip_hash<span class="token punctuation">;</span>
       server 服务器1及端口<span class="token punctuation">;</span> # 可加权值来表示优先级，server 服务器1及端口 + weight = 数字<span class="token punctuation">;</span> 数字越大，权重越高
       server 服务器2及接口<span class="token punctuation">;</span>
	   ……
     <span class="token punctuation">}</span>


   <span class="token selector">server</span> <span class="token punctuation">{</span>
       listen       8888 <span class="token punctuation">;</span> ##设置我们nginx监听端口为8888
       server_name  [服务器的ip地址]<span class="token punctuation">;</span>

       # Load configuration files for the default server block.
       include /etc/nginx/default.d/*.conf<span class="token punctuation">;</span>

       <span class="token selector">location /</span> <span class="token punctuation">{</span>
           proxy_pass <span class="token property">http</span><span class="token punctuation">:</span>//myserver<span class="token punctuation">;</span> ##叮，核心配置在这里
           proxy_connect_timeout 10<span class="token punctuation">;</span> #超时时间，单位秒
       <span class="token punctuation">}</span>

       error_page 404 /404.html<span class="token punctuation">;</span>
           <span class="token selector">location = /40x.html</span> <span class="token punctuation">{</span>
       <span class="token punctuation">}</span>

       error_page 500 502 503 504 /50x.html<span class="token punctuation">;</span>
           <span class="token selector">location = /50x.html</span> <span class="token punctuation">{</span>
       <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>

<span class="token punctuation">}</span>

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li>关闭一个tomcat之后，发现仍然可以访问，但关闭所有的tomcat时发现无法访问了，说明实现了负载均衡</li>
</ul>
<h1 id="Linux基本操作"><a href="#Linux基本操作" class="headerlink" title="Linux基本操作"></a>Linux基本操作</h1><h2 id="常用操作："><a href="#常用操作：" class="headerlink" title="常用操作："></a>常用操作：</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">lsof</span> <span class="token parameter variable">-i:9999</span> 查看端口占用情况
top/htop 查看系统资源占用情况<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h2 id="Bash界面"><a href="#Bash界面" class="headerlink" title="Bash界面"></a>Bash界面</h2><p>快捷键</p>
<pre class="line-numbers language-css" data-language="css"><code class="language-css">Ctl-U   删除光标到行首的所有字符<span class="token punctuation">,</span>在某些设置下<span class="token punctuation">,</span>删除全行
Ctl-W   删除当前光标到前边的最近一个空格之间的字符
Ctl-H   backspace<span class="token punctuation">,</span>删除光标前边的字符
Ctl-R   匹配最相近的一个文件，然后输出<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="用户操作"><a href="#用户操作" class="headerlink" title="用户操作"></a>用户操作</h2><pre class="line-numbers language-css" data-language="css"><code class="language-css">useradd -m username 创建用户，-m是会创建对应的用户目录到/home下，不加的话不会创建这个目录，-d 参数用来指定用户目录的位置
userdel -r 直接把用户目录删掉了不加r就不删除目录
who am i 看当前账号是什么
groupadd 创建一个用户组
useradd -g 用户组 用户名   把这个用户加入到用户组
usermod -g 用户组 用户名  修改
usermod -d 目录名 用户名 改变该用户登录的初始目录
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其他指令</p>
<pre class="line-numbers language-css" data-language="css"><code class="language-css">mkdir -p 创建多级目录
cp -r 递归的复制整个文件夹
cat -n 显示行
head -n 数字 默认看前10行 ， 加上-n 之后可以指定查看多少行
tial -n 数字 查看最后几行 
tail -f 实时追踪该文件的所有更新
&gt; 将内容覆盖在文件中
&gt;&gt; 在后面追加
ln -s 文件 链接的地方 
history 
! + history 中的指令编号，重新执行这条指令
date
cal 日历
find 路径 
-name 匹配文件名
-user 属于某个用户的
-size +n /-n /n 匹配文件大小 + 代表大于，-代表小于，不加代表等于 可加单位 K/M/G
locate 通过自建的数据库来进行查找，速度迅速，但是需要自己更新数据库
限制性updatedb


grep 
|grep + -n 显示行号/ -i 忽略字母大小写匹配 + 要匹配的关键字
权限
1-9位依次是 user group other的武安县
chown  -R 用户 文件 改变所属 -R来把里面的文件也执行这种修改
chgrp  组名 文件名 改变所有组<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="任务按时调度"><a href="#任务按时调度" class="headerlink" title="任务按时调度"></a>任务按时调度</h2><pre class="line-numbers language-css" data-language="css"><code class="language-css">crond -l 显示当前用户的定时任务
crontab -e 来编辑内容
语法：
* * * * * /path/to/command 也可以直接写一行shell脚本

1. 第一个星号：分钟（0-59）
2. 第二个星号：小时（0-23）
3. 第三个星号：日期（1-31）
4. 第四个星号：月份（1-12或使用缩写，如1代表一月，2代表二月，以此类推）
5. 第五个星号：星期几（0-7或使用缩写，0和7都代表星期日，1代表星期一，以此类推）

使用这些星号，您可以定义定时任务的执行时间。例如，以下是一些示例：

- `* * * * *`：每分钟都执行任务。
- `0 * * * *`：每小时的开始时执行任务。
- `0 0 * * *`：每天的午夜（凌晨12点）执行任务。
- `0 0 1 * *`：每个月的第一天（日期1）的午夜执行任务。
- `0 0 * * 5`：每个星期五的午夜执行任务。

如果您想要更具体的时间表，可以将具体的数字替换星号，例如 `30 8 * * 1-5` 表示每个工作日的上午8点30分执行任务。

at 执行一次性任务只会在指定的时间点执行但是不会重复执行措辞
用法
1. at + 时间  <span class="token property">hh</span><span class="token punctuation">:</span>mm
2. 输入要执行的指令然后按 ctrl + d 保存
atq 查看计划中的任务
删除计划任务
atrm  id 
crontab -r 删除定时任务<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="磁盘操作"><a href="#磁盘操作" class="headerlink" title="磁盘操作"></a>磁盘操作</h2><pre class="line-numbers language-css" data-language="css"><code class="language-css">lsblk 显示所有的磁盘和分区和挂载情况
fdisk 指定目录下的磁盘
mkfs 格式化磁盘
mount 磁盘目录 挂载目录 挂载分区
umount 取消挂载
df-h 查看磁盘状态 -T 查看磁盘类型<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><pre class="line-numbers language-css" data-language="css"><code class="language-css">ifconfig 查看ip
netstat  查看系统网络情况
-an 按照一定顺序排序输出
-p  不加参数 显示哪个进程在调用
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>进程管理</p>
<pre class="line-numbers language-css" data-language="css"><code class="language-css">ps 
-a 显示当前所有进程信息
-u 以用户的格式显示进程信息
-x 显示后台运行的参数
-e 显示所有进程 包括父进程等等
-f 全格式
kill  + pid 删除进程
-9 强制
killall 进程名称<span class="token punctuation">(</span>支持通配符匹配<span class="token punctuation">)</span>
pstree 查看进程树
-p 显示pid
-u 显示进程所属用户
<span class="token comment">/*service*/</span>
systemctl +
start xxx 
stop
restart
status 查看某个服务的状态
enable 启动一个服务，使其自启动
list-unit-files --type=service | grep enabled 查看所有已启动的服务
get-default 查看系统的默认目标
set-default 设置默认目标
list-units 列出正在运行的单元

top 和ps相似，但是可以实时更新正在运行的的进程
-d + 秒数 每隔多少秒更新一次
-i 使top不显示任何僵死进程
-p + pid 监视某个指定进程的状态
top中使用
P 按照cpu使用率排序，默认
M 以内存使用率
N 以PID
q 退出<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h1 id="shell-编程"><a href="#shell-编程" class="headerlink" title="shell 编程"></a>shell 编程</h1><ul>
<li>重定向</li>
<li>here document<pre class="line-numbers language-css" data-language="css"><code class="language-css">#!/bin/bash
cat &lt;&lt; END
<span class="token string">"这里是ls的使用方法"</span>
END
ls /root/shell_test

输出&gt;&gt;&gt;
<span class="token string">"这里是ls的使用方法"</span>
hell.sh  ls.sh	say.sh
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li>管道<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token operator">|</span><span class="token operator">&amp;</span>    将标准输出和错误信息一起传递给后面的命令<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
<li>命令分组<pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token punctuation">{</span>
	commands
	.......
<span class="token punctuation">}</span> &gt; 文件
使用 <span class="token punctuation">(</span><span class="token punctuation">)</span> 会将命令由子shell来进行执行<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><code>:</code> 等于true</li>
<li>echo<pre class="line-numbers language-css" data-language="css"><code class="language-css">echo 
-e 后面就可以加上换行符和制表符等特殊符号了<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li>
<li>printf<pre class="line-numbers language-css" data-language="css"><code class="language-css">printf 格式<span class="token punctuation">(</span>%s等<span class="token punctuation">)</span> 参数<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
<li>set / unset 设置/取消 环境变量</li>
<li>read 从标准输入读入放入后面给出的变量</li>
<li>wait 控制多进程</li>
<li>eval , exec , sed</li>
<li>source 执行shell脚本</li>
</ul>
<h1 id="k8s-kubernetes"><a href="#k8s-kubernetes" class="headerlink" title="k8s kubernetes"></a>k8s kubernetes</h1><blockquote>
<p>解决容器编排问题，实现分布式部署和替换，实现服务器集群</p>
</blockquote>
<p>kubernetes组件<br>一个kubernetes集群主要是由控制节点(master)、**工作节点(node)**构成，每个节点上都会安装不同的组件。  </p>
<ul>
<li>master：集群的控制平面，负责集群的决策 ( 管理 )</li>
</ul>
<p>ApiServer : 资源操作的唯一入口，接收用户输入的命令，提供认证、授权、API注册和发现等机制  </p>
<p>Scheduler : 负责集群资源调度，按照预定的调度策略将Pod调度到相应的node节点上  </p>
<p>ControllerManager : 负责维护集群的状态，比如程序部署安排、故障检测、自动扩展、滚动更新等  </p>
<p>Etcd ：负责存储集群中各种资源对象的信息  </p>
<ul>
<li>node：集群的数据平面，负责为容器提供运行环境 ( 干活 )</li>
</ul>
<p>Kubelet : 负责维护容器的生命周期，即通过控制docker，来创建、更新、销毁容器  </p>
<p>KubeProxy : 负责提供集群内部的服务发现和负载均衡  </p>
<p>Docker : 负责节点上容器的各种操作</p>
<ul>
<li>基础概念<br>Master：集群控制节点，每个集群需要至少一个master节点负责集群的管控</li>
</ul>
<p>Node：工作负载节点，由master分配容器到这些node工作节点上，然后node节点上的docker负责容器的运行  </p>
<p>Pod：kubernetes的最小控制单元，容器都是运行在pod中的，一个pod中可以有1个或者多个容器  </p>
<p>Controller：控制器，通过它来实现对pod的管理，比如启动pod、停止pod、伸缩pod的数量等等  </p>
<p>Service：pod对外服务的统一入口，下面可以维护者同一类的多个pod  </p>
<p>Label：标签，用于对pod进行分类，同一类pod会拥有相同的标签  </p>
<p>NameSpace：命名空间，用来隔离pod的运行环境</p>
<h1 id="Jenkins"><a href="#Jenkins" class="headerlink" title="Jenkins"></a>Jenkins</h1><p>Jenkins原理<img src="/2023/07/04/56/jenkins%E5%8E%9F%E7%90%86.png"></p>
<h1 id="Gradle"><a href="#Gradle" class="headerlink" title="Gradle"></a>Gradle</h1><p>与Maven相比，Maven更侧重于包的管理，而Gradle侧重于大项目构建</p>
<h1 id="SVN"><a href="#SVN" class="headerlink" title="SVN"></a>SVN</h1><p>一种不同于git 的版本控制系统<br>SVN主要是集中式的版本控制系统：所有的文件版本信息都存储在中央服务器，用户进行工作时是创建一个副本，所以版本的历史是线性的<br>目录也是版本控制的一部分，分支和标签是目录的复制<br>而git是每个人的电脑上都是一个具体的版本库，版本的历史不是线性的，分支处理更加高效。<br>SVN的分支实际上就是新建一个目录，然后把原来的文件复制一份进去。<br>优缺点对比：</p>
<ul>
<li>SVN：<ul>
<li>优点 更加高效的处理二进制文件，版本历史线性，容易理解，更好的处理权限访问和控制。</li>
<li>缺点：提交和更改需要联网，然后分支合并更加麻烦，速度慢，每次操作都需要与服务器通信。</li>
</ul>
</li>
<li>Git <ul>
<li>优点：分布式控制，离线也可以进行开发，速度更快</li>
<li>缺点：学习比SVN复杂，对二进制的处理不好，容易造成性能问题。</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zuofw.github.io/2023/06/28/59/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="QingQiu">
      <meta itemprop="description" content="个人网站，学习记录，面试记录和经验总结、互联网中一块属于自己的小窝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="QingQiu'Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/06/28/59/" class="post-title-link" itemprop="url">Go</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-06-28 14:14:59" itemprop="dateCreated datePublished" datetime="2023-06-28T14:14:59+08:00">2023-06-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-07-02 14:29:12" itemprop="dateModified" datetime="2024-07-02T14:29:12+08:00">2024-07-02</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>9k</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Go学习"><a href="#Go学习" class="headerlink" title="Go学习"></a>Go学习</h1><h1 id="面经"><a href="#面经" class="headerlink" title="面经"></a>面经</h1><h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><p>bool,string,int,byte(int8),int16,rune(int32),float32,float64,complex64/128</p>
<p>Go比起Java和C++ ，他与C的关系更密切</p>
<h2 id="变量："><a href="#变量：" class="headerlink" title="变量："></a>变量：</h2><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">//声明多个变量</span>
<span class="token keyword">var</span> <span class="token punctuation">(</span>
	v1
    v2
<span class="token punctuation">)</span>
<span class="token comment">//变量初始化，无需声明变量类型</span>
v1 <span class="token operator">:=</span> <span class="token number">1</span>
<span class="token comment">//多重赋值</span>
v1 <span class="token punctuation">,</span> v2 <span class="token operator">=</span> v2 <span class="token punctuation">,</span> v1 <span class="token comment">//实现交换两个变量，但是只能交换两个同一类型的变量</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>^75e37b</p>
<h2 id="类型"><a href="#类型" class="headerlink" title="类型:"></a>类型:</h2><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token builtin">float32</span> <span class="token comment">//等于c中的float</span>
<span class="token builtin">float64</span> <span class="token comment">// double</span>
<span class="token comment">//复数类型，和数学上的表达一样</span>
<span class="token keyword">var</span> <span class="token punctuation">(</span>
		v1 <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">+</span> <span class="token number">5i</span>
		v2 <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">6i</span>
	<span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>v1 <span class="token operator">+</span> v2<span class="token punctuation">)</span>
<span class="token comment">//输出为</span>
<span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">-</span><span class="token number">1i</span><span class="token punctuation">)</span>
<span class="token comment">//中文字符在UTF-8中占三个字节</span>
s <span class="token operator">:=</span> <span class="token string">"你好"</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">len</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span> 
<span class="token comment">//数组通过range来遍历，range有两个返回值所以，第一个返回的是数组的下标，第二个是返回的数组的数值，所以要用两个变量来存储</span>
s <span class="token operator">:=</span> <span class="token string">"0123456"</span>
	<span class="token keyword">for</span> i<span class="token punctuation">,</span> value <span class="token operator">:=</span> <span class="token keyword">range</span> s <span class="token punctuation">{</span>
		fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> value<span class="token operator">-</span><span class="token char">'0'</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
<span class="token comment">// 单个字符</span>
<span class="token keyword">var</span> b <span class="token builtin">byte</span> <span class="token operator">=</span> <span class="token char">'a'</span>
注意：禁止字符串转<span class="token builtin">int</span>
<span class="token builtin">rune</span> 是单个Unicode 字符
<span class="token comment">//同时注意数组的初始化的方式是这这样的</span>
s <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">}</span> 
<span class="token comment">//当不需要某个返回类型时使用_来跳过这个返回类型即可</span>
<span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> value <span class="token operator">:=</span> <span class="token keyword">range</span> s <span class="token punctuation">{</span>
		fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>类似 type of的方法</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> 别名 <span class="token operator">=</span> 原来的类型名
<span class="token keyword">const</span> 常量声明<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>itoa 用于记录常量</p>
<h3 id="字符转换"><a href="#字符转换" class="headerlink" title="字符转换"></a>字符转换</h3><pre class="line-numbers language-none"><code class="language-none">strconv.xxxx即可<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>



<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>数组定于的一种方式，会根据给定的初始化的元素决定数组的长度</p>
<p><code>a := [...]int{1}</code></p>
<p>数组切片，类似于vector</p>
<p>切片创建方式有：</p>
<ol>
<li><p>基于原有的数组来创建</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">a <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">}</span>
<span class="token keyword">var</span> s <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span> <span class="token operator">=</span> a<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">]</span>
<span class="token comment">//需要使用Var 来声明切片数组的类型，等号的右侧可以时 array[first , end] ,想要截取的首位位置</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><u><strong>直接创建</strong></u></p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">//使用make进行直接创建</span>
s <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span> <span class="token punctuation">,</span> <span class="token number">5</span> <span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token comment">//建立一个初始原为5个但是预留十个元素的空间的切片</span>
<span class="token comment">//直接在建立的过程中赋予初值</span>
s <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li>
</ol>
<p>切片的部分常用函数</p>
<ul>
<li>len() 返回已经存储的元素的个数</li>
<li>cap() 返回切片分配的空间大小</li>
<li>append() 追加元素</li>
<li>copy() 复制</li>
</ul>
<p>数组也可以定为接口数组，结构体数组，管道数组等等</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">//接口数组</span>
<span class="token keyword">var</span> unknown <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">var</span> unknown <span class="token punctuation">[</span><span class="token operator">...</span><span class="token punctuation">]</span> <span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token number">123</span><span class="token punctuation">,</span><span class="token string">"你好"</span><span class="token punctuation">}</span>
<span class="token comment">//管道数组</span>
<span class="token keyword">var</span> chanList <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>定义空数组:</p>
<p><code>var a [0] int</code></p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">a <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token operator">...</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">}</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h3 id="map类型"><a href="#map类型" class="headerlink" title="map类型"></a><u>map类型</u></h3><p>Go中将其变为基本类型，可以直接使用，不需要引入库</p>
<p>声明:</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> myMap <span class="token keyword">map</span><span class="token punctuation">[</span>键的类型<span class="token punctuation">]</span>值的类型<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>创建:初始化创建时要注意在初始化的最后一个数据的后面加上逗号才代表初始化完成，否则会报错</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">//指定容量</span>
myMap <span class="token operator">=</span> <span class="token builtin">make</span> <span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">[</span>键<span class="token punctuation">]</span>值 <span class="token punctuation">,</span> capacity<span class="token punctuation">)</span>
<span class="token comment">//直接初始化</span>
myMap <span class="token operator">=</span> <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span>
		<span class="token string">"1234"</span><span class="token punctuation">:</span> <span class="token number">1234</span><span class="token punctuation">,</span> <span class="token comment">//一定要加上逗号</span>
<span class="token punctuation">}</span>
<span class="token comment">//直接声明＋初始化一起</span>
myMap <span class="token operator">:=</span> <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span>
		<span class="token string">"1234"</span><span class="token punctuation">:</span> <span class="token number">1234</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>删除</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token builtin">delete</span> <span class="token punctuation">(</span>myMap <span class="token punctuation">,</span> key<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>查找</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">value<span class="token punctuation">,</span> ok <span class="token operator">:=</span> myMap<span class="token punctuation">[</span><span class="token string">"4"</span><span class="token punctuation">]</span>
	<span class="token keyword">if</span> ok <span class="token punctuation">{</span>
		fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> ok<span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	<span class="token punctuation">{</span>
		fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"No"</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>		<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><ol>
<li><p>if else 结构</p>
<ul>
<li><p>if else 的括号必须在一行，否则编译失败，当出现else时，else 必须和 ‘’} ‘’在一行</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">//正确</span>
<span class="token keyword">if</span> ok <span class="token punctuation">{</span>
		fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> ok<span class="token punctuation">)</span>
	<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
		fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"No"</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
<span class="token comment">//错误</span>
<span class="token keyword">if</span> ok <span class="token punctuation">{</span>
		fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> ok<span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">else</span> <span class="token punctuation">{</span>
		fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"No"</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
<span class="token comment">//所以也推荐使用省略else的语句</span>
<span class="token keyword">if</span> ok <span class="token punctuation">{</span>
		fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> ok<span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	<span class="token punctuation">{</span>
		fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"No"</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>		<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>条件不需要使用括号</p>
</li>
<li><p>花括号必须存在</p>
</li>
</ul>
</li>
<li><p>switch : 不需要显性的使用break来退出判断，默认的已经带有break了</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">t <span class="token operator">:=</span> time<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">switch</span> <span class="token punctuation">{</span><span class="token comment">//用来替代if 语句，比起嵌套if更好判断代码</span>
<span class="token keyword">case</span> t<span class="token punctuation">.</span><span class="token function">Hour</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">12</span> <span class="token punctuation">:</span>
    xxxx<span class="token punctuation">;</span>
<span class="token keyword">default</span> <span class="token punctuation">:</span>
    xxxx<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


</li>
<li><p>循环 </p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">for</span> i<span class="token operator">:=</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">{</span>
                      
<span class="token punctuation">}</span>
<span class="token comment">// while循环</span>
<span class="token keyword">for</span> a <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token punctuation">{</span>

        fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"a = %d\n"</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span>

        a<span class="token operator">--</span>

   <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>更强大的break break后面可以加上标签，使用方法与goto一致</p>
</li>
<li><p>函数 </p>
<p>Go的函数拥有多重返回值，可以更方便的把函数的执行结果返回</p>
<p>注意：小写字母开头的函数只有本包可见，而大写字母开头的函数才可以被其他包使用</p>
<p>一般语法</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> 函数名 <span class="token punctuation">(</span>参数<span class="token punctuation">)</span><span class="token punctuation">(</span>返回列表<span class="token punctuation">)</span><span class="token punctuation">{</span>
    
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>不定参数 在写形参列表的时候使用…来省略参数即可达到不定参数的作用</p>
<p>例:</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">name</span><span class="token punctuation">(</span>a <span class="token operator">...</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">{</span>
	<span class="token keyword">return</span> <span class="token number">1</span>
<span class="token punctuation">}</span>
<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>概念: 这种使用方式是语法糖，语法糖对语言的功能没有用影响但是可以方便使用，也能够增加程序的可读性，减少出错的机会</p>
<p>这里的 … 相当于一个数组切片，等价于下面的语句</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">name</span><span class="token punctuation">(</span>args <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">{</span>
	<span class="token keyword">return</span> <span class="token number">1</span>
<span class="token punctuation">}</span>
<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//调用的时候必须使用这种方式进行调用了</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>匿名函数：Go支持随时随地定义匿名函数</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">//在定义的时候进行调用</span>
<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token keyword">func</span><span class="token punctuation">(</span>a <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">{</span>
		<span class="token keyword">return</span> a
	<span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token comment">//匿名函数赋给变量</span>
<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

	f <span class="token operator">:=</span> <span class="token keyword">func</span><span class="token punctuation">(</span>a <span class="token operator">...</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">{</span>
		<span class="token keyword">return</span> a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token comment">// 注意此处的a相当于 args [] 所以a不是int型不可以直接返回</span>
	<span class="token punctuation">}</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>闭包</strong></p>
<p>闭包是由函数及其相关的引用环境组合而成的实体(即：闭包=函数+引用环境)。</p>
<p>匿名函数是一类闭包</p>
<ul>
<li>包含自由变量的代码块，这些变量不在这个代码块内或者任何全局上下文中定义，而是在定义代码块中的环境中进行定义的。要执行的代码块为自由变量提供绑定的计算环境(作用域)</li>
<li>闭包每次调用都是新的实例</li>
<li>闭包中的变量会保存，即使调用结束也会保存，，可以保证闭包中的变量的安全性，不会被外部函数修改</li>
</ul>
<p>闭包可以获得所在函数内的作用域，但是外部不可修改闭包的数据</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	b <span class="token operator">:=</span> <span class="token number">0</span>
    <span class="token comment">//闭包</span>
	f <span class="token operator">:=</span> <span class="token keyword">func</span><span class="token punctuation">(</span>b <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		b<span class="token operator">++</span>
		<span class="token function">println</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	<span class="token function">f</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span>
	<span class="token function">f</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token comment">//每一次调用都是新的实例</span>
	<span class="token function">println</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p>返回函数的函数</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token string">"fmt"</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	f <span class="token operator">:=</span> <span class="token function">Add1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token comment">//fmt.Println(Add1()(1, 2)) 另一种方式</span>
<span class="token punctuation">}</span>
<span class="token comment">//返回了一个 匿名函数</span>
<span class="token keyword">func</span> <span class="token function">Add1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">func</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">{</span>
	<span class="token keyword">return</span> <span class="token keyword">func</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">{</span>
		<span class="token keyword">return</span> a <span class="token operator">+</span> b
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


</li>
<li><p>错误处理</p>
<p>error接口是内置的，里面只有一个方法：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> <span class="token builtin">error</span> <span class="token keyword">interface</span> <span class="token punctuation">{</span>  
    <span class="token function">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">string</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>defer</p>
<p>类似于析构函数，遵循先进后出，用于函数执行之后进行一些资源释放的收尾工作</p>
<p>使用语法：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">defer</span> <span class="token operator">+</span> 执行语句
要执行语句很多时可以写一个匿名函数来进行处理
<span class="token keyword">defer</span> <span class="token keyword">func</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    回收工作
<span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//调用</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>panic() 和 recover()</p>
<p>panic ( ) 用于立刻终止程序，但是defer不影响，会正常执行，panic可以接受任意类型的数据</p>
<p>recover ( ) 用于终止错误处理流程，一般放在defer中来截取错误信息</p>
</li>
</ol>
<h2 id="面型对象编程-OOP-Object-Oriented-Programming"><a href="#面型对象编程-OOP-Object-Oriented-Programming" class="headerlink" title="面型对象编程(OOP , Object Oriented Programming)"></a>面型对象编程(OOP , Object Oriented Programming)</h2><ol>
<li><p>类型系统</p>
<p>Go可以给任意类型(包括内置类型，但不包括指针类型)添加相应的方法</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> Integer <span class="token builtin">int</span>
<span class="token comment">//Integer 与int 并无区别，只是我们认为给他加上了一个自带的方法</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>a Integer<span class="token punctuation">)</span> <span class="token function">less</span><span class="token punctuation">(</span>b Integer<span class="token punctuation">)</span> <span class="token builtin">bool</span> <span class="token punctuation">{</span>
	<span class="token keyword">return</span> a <span class="token operator">&lt;</span> b
<span class="token punctuation">}</span>
<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">var</span> a Integer <span class="token operator">=</span> <span class="token number">5</span>
	<span class="token keyword">defer</span> fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"回收了"</span><span class="token punctuation">)</span>
	<span class="token keyword">if</span> a<span class="token punctuation">.</span><span class="token function">less</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		fmt<span class="token punctuation">.</span><span class="token function">Print</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token string">"&lt;"</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
		<span class="token keyword">defer</span> fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"错误回收"</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>

<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


</li>
<li><p>面向对象只是换了一种方式来表达语法，所以实质上也是语法糖</p>
<p>Go没有隐藏的指针</p>
<ul>
<li>方法的对象显式传递</li>
<li>方法的对象不需要是指针，也不需要是this</li>
</ul>
</li>
<li><p>对于public 类， 需要采用类名首字母大写</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token string">"fmt"</span>

<span class="token keyword">type</span> Base <span class="token keyword">struct</span> <span class="token punctuation">{</span>
	Name <span class="token builtin">string</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>base <span class="token operator">*</span>Base<span class="token punctuation">)</span> <span class="token function">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>base <span class="token operator">*</span>Base<span class="token punctuation">)</span> <span class="token function">Bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token keyword">type</span> Foo <span class="token keyword">struct</span> <span class="token punctuation">{</span>
	Base
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>foo <span class="token operator">*</span>Foo<span class="token punctuation">)</span> <span class="token function">Foo</span><span class="token punctuation">(</span>name <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	foo<span class="token punctuation">.</span>Name <span class="token operator">=</span> name
<span class="token punctuation">}</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>foo <span class="token operator">*</span>Foo<span class="token punctuation">)</span> <span class="token function">Bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token function">println</span><span class="token punctuation">(</span>foo<span class="token punctuation">.</span>Name<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	base <span class="token operator">:=</span> <span class="token function">new</span><span class="token punctuation">(</span>Base<span class="token punctuation">)</span>
	base<span class="token punctuation">.</span><span class="token function">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	foo <span class="token operator">:=</span> <span class="token function">new</span><span class="token punctuation">(</span>Foo<span class="token punctuation">)</span>
	foo<span class="token punctuation">.</span><span class="token function">Foo</span><span class="token punctuation">(</span><span class="token string">"123"</span><span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>foo<span class="token punctuation">.</span>Name<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><strong>接口</strong></p>
<p>其他语言在使用接口时必须要先从接口进行继承，才能进行实现接口</p>
<p>简言之，必须知道接口要实现什么才能定义接口，但实际情况是，不知道接口要实现什么</p>
<p>例如</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//	Java 语法</span>
<span class="token keyword">interface</span> <span class="token class-name">IFoo</span><span class="token punctuation">{</span>
    <span class="token keyword">void</span> <span class="token class-name">Bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token keyword">implements</span> <span class="token class-name">IFoo</span> <span class="token punctuation">{</span>
    <span class="token comment">//....</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>问题：</p>
<ol>
<li>提供哪些接口好呢？</li>
<li>如果两个类实现了相同的接口，应该把接口放进哪个包内？</li>
</ol>
<p>Go的接口是非侵入式的，只要类实现了接口要求的所有函数，就算是实现了这个接口，可以直接进行赋值</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token string">"fmt"</span>
<span class="token comment">//实现接口的类</span>
<span class="token keyword">type</span> File <span class="token keyword">struct</span> <span class="token punctuation">{</span>
<span class="token punctuation">}</span>

<span class="token comment">// 实现类方法，也就是接口的方法</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>f <span class="token operator">*</span>File<span class="token punctuation">)</span> <span class="token function">Print</span><span class="token punctuation">(</span>str <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token comment">//两个以后出现的接口</span>
<span class="token keyword">type</span> IFile <span class="token keyword">interface</span> <span class="token punctuation">{</span>
	<span class="token function">Print</span><span class="token punctuation">(</span>str <span class="token builtin">string</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">type</span> IPrint <span class="token keyword">interface</span> <span class="token punctuation">{</span>
	<span class="token function">Print</span><span class="token punctuation">(</span>str <span class="token builtin">string</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">var</span> file1 IFile <span class="token operator">=</span> <span class="token function">new</span><span class="token punctuation">(</span>File<span class="token punctuation">)</span>
	<span class="token keyword">var</span> file2 IPrint <span class="token operator">=</span> <span class="token function">new</span><span class="token punctuation">(</span>File<span class="token punctuation">)</span>
	file3 <span class="token operator">:=</span> <span class="token function">new</span><span class="token punctuation">(</span>File<span class="token punctuation">)</span>
	file1<span class="token punctuation">.</span><span class="token function">Print</span><span class="token punctuation">(</span><span class="token string">"IFile接口实现"</span><span class="token punctuation">)</span>
	file2<span class="token punctuation">.</span><span class="token function">Print</span><span class="token punctuation">(</span><span class="token string">"IPrint接口实现"</span><span class="token punctuation">)</span>
	file3<span class="token punctuation">.</span><span class="token function">Print</span><span class="token punctuation">(</span><span class="token string">"实现接口的类，并不需要提前知道有哪些接口，只要能够实现了以后会出现的接口的函数即可直接使用"</span><span class="token punctuation">)</span>

<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>但是 Go 语言里有非常灵活的 <strong>接口</strong> 概念，通过它可以实现很多面向对象的特性。接口提供了一种方式来 <strong>说明</strong> 对象的行为：如果谁能搞定这件事，它就可以用在这儿。</p>
<p>接口定义了一组方法（方法集），但是这些方法不包含（实现）代码：它们没有被实现（它们是抽象的）。接口里也不能包含变量。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> Namer <span class="token keyword">interface</span> <span class="token punctuation">{</span>
    <span class="token function">Method1</span><span class="token punctuation">(</span>param_list<span class="token punctuation">)</span> return_type
    <span class="token function">Method2</span><span class="token punctuation">(</span>param_list<span class="token punctuation">)</span> return_type
    <span class="token operator">...</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>使用接口时，如果某个类实现了接口的方法，那么接口类型的变量可以赋值为这个类的变量</p>
<p>如果接口接口A和接口B的方法是一致的，那么在Go中属于完全等价</p>
<p>如果A接口的方法是B接口方法的子集，那么B接口可以赋值给A接口，而A接口不能赋值给B接口</p>
<p>接口查询：用于查询某个接口是否属于某个类型</p>
<blockquote>
<p>实例 <code>num2</code> 是否属于接口 <code>Number1</code>，可以这么做：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> num1 Number <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> num2 Number2 <span class="token operator">=</span> <span class="token operator">&amp;</span>num1<span class="token punctuation">;</span>
<span class="token keyword">if</span> num3<span class="token punctuation">,</span> ok <span class="token operator">:=</span> num2<span class="token punctuation">.</span><span class="token punctuation">(</span>Number1<span class="token punctuation">)</span><span class="token punctuation">;</span> ok <span class="token punctuation">{</span>
    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>num3<span class="token punctuation">.</span><span class="token function">Equal</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>如果num2 实例所指的对象是属于Number1的，那么ok值为1 ，num3 转化为 Number1的一个实例，之后执行条件内的代码</p>
</blockquote>
<p>类型查询：用于查询接口指向的对象实例的类型</p>
<p>语法:</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">switch</span> v <span class="token operator">:=</span> v1<span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token keyword">type</span><span class="token punctuation">)</span><span class="token punctuation">{</span> 	
	<span class="token keyword">case</span> <span class="token builtin">int</span><span class="token punctuation">:</span>
    <span class="token keyword">case</span> <span class="token builtin">string</span><span class="token punctuation">:</span>
    <span class="token operator">...</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>两者一般搭配使用</p>
<p>Any类型</p>
<p>任何对象实例都满足空接口 interface { } 所以interface { } 可以作为一个可以指向任何对象的Any类型，当函数可以接受任何实例时，可以将其声明为interface { } </p>
<p>例如： fmt库中的Print函数</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> Print <span class="token punctuation">(</span>fmt <span class="token builtin">string</span> <span class="token punctuation">,</span> args <span class="token operator">...</span><span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
</ol>
<h2 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h2><p>主流实现模型:</p>
<ol>
<li><p>多进程</p>
<p>操作系统层面进行的</p>
</li>
<li><p>多线程</p>
<p>操作系统之上的调度</p>
</li>
<li><p>基于回调的非阻塞/异步IO</p>
<p>通过事件驱动的方式使用异步IO，使服务器持续运转并且尽可能的少用线程，降低开销，代表有Node.js，会对流程进行分割</p>
</li>
<li><p>协程</p>
<p>本质是用户态线程，不需要抢占式调度，寄存于线程，缺点是需要语言支持</p>
</li>
</ol>
<p> <strong><u>gorountine</u></strong></p>
<p>通过在代码中加上go关键字启用协程，主程序结束时，写成会被结束</p>
<p>通信方式：消息机制和共享内存</p>
<p>消息机制：每个并发单位都是自包含、独立的个体，都有自己的变量，并且单元间的变量不共享，每个单元的输入输出只有一种那就是消息。不同进程依靠消息来进行通信，他们不会共享内存</p>
<p><strong><u>channel</u></strong></p>
<p>Go提供的goroutine间的通信方式，是进程内的通信方式，不适合进程之间进行通信</p>
<p>一个channel 只能传递一种类型的值</p>
<p>基本语法</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">//声明</span>
<span class="token keyword">var</span> chanName <span class="token keyword">chan</span> ElemenType 
<span class="token comment">//例如 声明一个传递类型为int的channel</span>
<span class="token keyword">var</span> ch <span class="token keyword">chan</span> <span class="token builtin">int</span> 
<span class="token comment">//定义</span>
ch <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span>
ch <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span> <span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token comment">//缓冲大小为2</span>
<span class="token comment">//写入channel</span>
ch <span class="token operator">&lt;-</span> value <span class="token comment">//写入数据会导致陈孤虚阻塞，直到有其他goroutine 从channel中读取数据</span>
<span class="token comment">//读取</span>
value <span class="token operator">:=</span> <span class="token operator">&lt;-</span> ch <span class="token comment">// 如果channel中没有数据也会进行堵塞</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>示例：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token string">"fmt"</span>

<span class="token keyword">func</span> <span class="token function">Count</span><span class="token punctuation">(</span>ch <span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Counting"</span><span class="token punctuation">)</span>
	ch <span class="token operator">&lt;-</span> <span class="token number">1</span> <span class="token comment">//写入数据,导致这个goroutine阻塞，直到有其他goroutine从中读取数据</span>
<span class="token punctuation">}</span>
<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	chs <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token comment">// 储存十个goroutine的channel数组</span>
	<span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>
		chs<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span>
		<span class="token comment">//启动十个协程</span>
		<span class="token keyword">go</span> <span class="token function">Count</span><span class="token punctuation">(</span>chs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> ch <span class="token operator">:=</span> <span class="token keyword">range</span> chs <span class="token punctuation">{</span>
		<span class="token operator">&lt;-</span>ch <span class="token comment">//读取channel</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>select</p>
<p>文件发生IO动作，select会被调用并返回</p>
<p>语法： 条件必须是IO操作</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">select</span> <span class="token punctuation">{</span>
    <span class="token keyword">case</span> <span class="token operator">&lt;-</span> chan1 <span class="token punctuation">:</span> <span class="token comment">//从chan1成功读取到数据</span>
    <span class="token keyword">case</span> chan2 <span class="token operator">&lt;-</span> <span class="token number">1</span> <span class="token punctuation">:</span> <span class="token comment">//成功向chan2写入数据</span>
    <span class="token keyword">default</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>示例：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token string">"fmt"</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	ch <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>
	<span class="token keyword">for</span> j <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> j<span class="token operator">++</span> <span class="token punctuation">{</span>
		<span class="token comment">//随机向ch 中写入一个1或者是0</span>
		<span class="token keyword">select</span> <span class="token punctuation">{</span>
		<span class="token keyword">case</span> ch <span class="token operator">&lt;-</span> <span class="token number">0</span><span class="token punctuation">:</span>
		<span class="token keyword">case</span> ch <span class="token operator">&lt;-</span> <span class="token number">1</span><span class="token punctuation">:</span>
		<span class="token punctuation">}</span>
		i <span class="token operator">:=</span> <span class="token operator">&lt;-</span>ch
		fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Value Received :"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>缓冲机制</p>
<p>建立channel数组即可实现缓冲</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">ch <span class="token operator">:=</span> <span class="token builtin">make</span> <span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span> <span class="token punctuation">,</span> <span class="token number">1024</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>超时机制</p>
<p>Go中没有提供查实处理机制，但是可以使用select来处理，因为select只要有一个case已经完成即可继续进行下去</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
	<span class="token string">"fmt"</span>
	<span class="token string">"time"</span>
<span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	ch <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token comment">//未写入任何数据，所以会把程序堵塞</span>
	timeout <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">bool</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>
	<span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token comment">//等待一秒钟</span>
		time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">1e9</span><span class="token punctuation">)</span>
		timeout <span class="token operator">&lt;-</span> <span class="token boolean">true</span>
	<span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token keyword">select</span> <span class="token punctuation">{</span>
	<span class="token keyword">case</span> <span class="token operator">&lt;-</span>ch<span class="token punctuation">:</span>
		fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"读取中"</span><span class="token punctuation">)</span>
	<span class="token keyword">case</span> <span class="token operator">&lt;-</span>timeout<span class="token punctuation">:</span>
		fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"超时了"</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><u>channel 传递，可以用来实现pipe 待补充</u></p>
<p>单向channel  用于防止写入某些不需要的数据或者被不需要的函数读取</p>
<p>只能读或者只能写</p>
<p>定义</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> ch1 <span class="token keyword">chan</span> <span class="token builtin">int</span> <span class="token comment">//正常的channel</span>
<span class="token keyword">var</span> ch2 <span class="token keyword">chan</span> <span class="token operator">&lt;-</span> <span class="token builtin">float64</span> <span class="token comment">// 只能写</span>
<span class="token keyword">var</span> ch3 <span class="token operator">&lt;-</span> <span class="token keyword">chan</span> <span class="token builtin">int</span> <span class="token comment">//只能读</span>
<span class="token comment">//初始化</span>
ch4 <span class="token operator">:=</span> <span class="token builtin">make</span> <span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token comment">// 正常</span>
ch5 <span class="token operator">:=</span>  <span class="token operator">&lt;-</span> <span class="token keyword">chan</span> <span class="token builtin">int</span> <span class="token punctuation">(</span>ch4<span class="token punctuation">)</span> <span class="token comment">// 从正常的channel进行类型转化为单项读取的channel</span>
ch6 <span class="token operator">:=</span>  <span class="token keyword">chan</span> <span class="token operator">&lt;-</span> <span class="token builtin">int</span> <span class="token punctuation">(</span>ch4<span class="token punctuation">)</span> <span class="token comment">// 转化为单项写入的channel</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>关闭channel</p>
<p>使用close()即可</p>
<p>如何判断已经关闭?</p>
<p>多重返回值的方式进行帕努的那</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">x <span class="token punctuation">,</span> ok <span class="token operator">:=</span> <span class="token operator">&lt;-</span> ch
<span class="token comment">//只需要看ok即可，如果ch已经关闭，那么读取失败，ok的返回值为false </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h4 id="同步问题"><a href="#同步问题" class="headerlink" title="同步问题"></a>同步问题</h4><p>同步锁</p>
<p>sync包中提供</p>
<p>Mutex锁</p>
<p>当一个goroutine 获得了Mutex 后，其他的goroutine 只能等待这个释放锁</p>
<p>RWMutex 锁 </p>
<p>单写多读 ， 在读锁占用时，会阻止写，但是不会阻止读</p>
<p>全局唯一性操作</p>
<p>使用Once类型，当别的goroutine </p>
<h2 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h2><h3 id="Socket编程-IP-层"><a href="#Socket编程-IP-层" class="headerlink" title="Socket编程  IP 层"></a>Socket编程  IP 层</h3><p>socket是什么？</p>
<blockquote>
<p>Socket是对TCP/IP协议的封装，自身并非协议而是一套调用的接口规范（API）。通过套接字Socket，才能使用TCP/IP协议。</p>
</blockquote>
<p>传统的Socket编程主要步骤：</p>
<ol>
<li>建立Socket： 使用socket() 函数</li>
<li>绑定Socket :使用bind() 函数</li>
<li>监听： 使用listen() 函数，或者connec() 函数</li>
<li>接受连接： accept() 函数</li>
<li>接收： receive() 函数 ，发送send() 函数</li>
</ol>
<p>Go的：</p>
<p>Go语言标准库对此过程进行了抽象和封装，无论我们期望使用什么形式的连接，只需要调用net.Dial()即可</p>
<p>Dial原型</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> Dial <span class="token punctuation">(</span> net <span class="token punctuation">,</span> addr <span class="token builtin">string</span> <span class="token punctuation">)</span> <span class="token punctuation">(</span> Conn <span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> 
<span class="token comment">/*
net : 网路协议名称
addr IP地址或域名，端口以":" 的形式跟在后面，端口号可选
Conn 是否成功连接
*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="工程管理"><a href="#工程管理" class="headerlink" title="工程管理"></a>工程管理</h2><p>代码格式化</p>
<p>格式化之前的：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token string">"fmt"</span>

<span class="token keyword">func</span> Foo <span class="token punctuation">(</span> a <span class="token punctuation">,</span> b <span class="token builtin">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span>ret <span class="token builtin">int</span> <span class="token punctuation">,</span>err <span class="token builtin">error</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
<span class="token keyword">if</span> a<span class="token operator">&gt;</span>b <span class="token punctuation">{</span>
<span class="token keyword">return</span> a <span class="token punctuation">,</span> <span class="token boolean">nil</span>	
<span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span>
	<span class="token keyword">return</span> b <span class="token punctuation">,</span> <span class="token boolean">nil</span>
<span class="token punctuation">}</span>
<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">,</span><span class="token boolean">nil</span>
<span class="token punctuation">}</span>
<span class="token keyword">func</span> 
<span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>
	i <span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token operator">:=</span> <span class="token function">Foo</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Hello,word"</span> <span class="token punctuation">,</span>i<span class="token punctuation">)</span>	
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>使用命令行: go fmt xxx.go得到的代码,也可以直接go fmt 会格式化所有*.go的文件</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token string">"fmt"</span>

<span class="token keyword">func</span> <span class="token function">Foo</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>ret <span class="token builtin">int</span><span class="token punctuation">,</span> err <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">if</span> a <span class="token operator">&gt;</span> b <span class="token punctuation">{</span>
		<span class="token keyword">return</span> a<span class="token punctuation">,</span> <span class="token boolean">nil</span>
	<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
		<span class="token keyword">return</span> b<span class="token punctuation">,</span> <span class="token boolean">nil</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token boolean">nil</span>
<span class="token punctuation">}</span>
<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	i<span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token operator">:=</span> <span class="token function">Foo</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Hello,word"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>gotool</p>
<p>生成exe</p>
<p>gobuild 后面可以加上-o + name 指定执行文件的名字</p>
<p><strong>格式化输出</strong>: Printf</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token operator">%</span>v	按值的本来值输出
<span class="token operator">%</span><span class="token operator">+</span>v	在 <span class="token operator">%</span>v 基础上，对结构体字段名和值进行展开<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>生成随机数需要设置随机数种子</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	v <span class="token operator">:=</span> <span class="token number">100</span>
	rand<span class="token punctuation">.</span><span class="token function">Seed</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">UnixNano</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	a <span class="token operator">:=</span> rand<span class="token punctuation">.</span><span class="token function">Intn</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h2><h1 id="Gin"><a href="#Gin" class="headerlink" title="Gin"></a>Gin</h1>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zuofw.github.io/2023/06/18/28/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="QingQiu">
      <meta itemprop="description" content="个人网站，学习记录，面试记录和经验总结、互联网中一块属于自己的小窝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="QingQiu'Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/06/18/28/" class="post-title-link" itemprop="url">Github学生包/学生认证申请那些事</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-06-18 19:51:28" itemprop="dateCreated datePublished" datetime="2023-06-18T19:51:28+08:00">2023-06-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-06-26 21:08:36" itemprop="dateModified" datetime="2024-06-26T21:08:36+08:00">2024-06-26</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.2k</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><blockquote>
<p>Github对学生有很多优惠，<del>至于哪些可太多了，所以有必要申请一个</del>，</p>
<p>这个大佬写的很详细了，我在这里加一些我踩得坑，如果跟大佬的步骤走没通过的话，可以回来看看有没有我踩过的坑</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/617001126">2023.3申请github copilot x 学生认证以及Jetbrain专业版学生教育免费教程 - 知乎 (zhihu.com)</a></p>
</blockquote>
<h2 id="前提条件："><a href="#前提条件：" class="headerlink" title="前提条件："></a>前提条件：</h2><blockquote>
<ol>
<li>一个好的浏览器(支持定位的浏览器)</li>
<li>一份学信网学籍认证 和 一个教育邮箱(更容易通过 ，可以去企业微信里看看有没有开通)</li>
<li>修改pdf文件中的信息</li>
<li>github profile 中修改个人信息</li>
<li>认证并且全程不要挂梯子</li>
</ol>
</blockquote>
<h2 id="1-好的浏览器"><a href="#1-好的浏览器" class="headerlink" title="1.好的浏览器"></a>1.好的浏览器</h2><p><strong>这是重中之重，我在申请的时候不知道Chrome怎么了，一直定位不成功，换成 edge之后就成功了</strong></p>
<h2 id="2-学信网认证"><a href="#2-学信网认证" class="headerlink" title="2.学信网认证"></a>2.学信网认证</h2><p>进入学信网，下载电子报告即可，网上都有教程，这里不做赘述了</p>
<p><a target="_blank" rel="noopener" href="https://www.chsi.com.cn/">中国高等教育学生信息网（学信网） (chsi.com.cn)</a></p>
<h2 id="3-修改pdf文件信息"><a href="#3-修改pdf文件信息" class="headerlink" title="3.修改pdf文件信息"></a>3.修改pdf文件信息</h2><p>因为github不是国内的，所以中文档案是不能通过的，而且pdf编辑好像很难搞，这里给一个下载链接，使用这个进行编辑会方便些</p>
<p>密码：tko9</p>
<p><a target="_blank" rel="noopener" href="https://cloud.189.cn/web/share?code=ZNbamiEziq6z">Adobe CC 2022 免费高速下载 | 天翼云盘 珍藏美好生活 家庭云|网盘|文件备份|资源分享 (189.cn)</a></p>
<p><img src="/2023/06/18/28/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618200641.png" alt="下载安装即可"></p>
<p>修改内容：</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/617001126">2023.3申请github copilot x 学生认证以及Jetbrain专业版学生教育免费教程 - 知乎 (zhihu.com)</a></p>
<p>可以看这篇文章</p>
<h2 id="4-修改github-profile-中的信息"><a href="#4-修改github-profile-中的信息" class="headerlink" title="4.修改github profile 中的信息"></a>4.修改github profile 中的信息</h2><ul>
<li>名字改为英文名</li>
<li>Bio 修改为   student of 学校英文名 + @ 学校英文名</li>
<li>company 修改为学校英文名</li>
</ul>
<h2 id="5-申请："><a href="#5-申请：" class="headerlink" title="5.申请："></a>5.申请：</h2><p>网站：<a target="_blank" rel="noopener" href="https://education.github.com/discount_requests/application">Request a discount - GitHub Education</a></p>
<p><strong><u>全程不要挂梯子</u></strong></p>
<ol>
<li><p>添加教育邮箱 </p>
<p><img src="/2023/06/18/28/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618201441.png" alt="添加邮箱"></p>
</li>
<li><p>填写申请理由，理由随便写，可以参考我的</p>
<pre class="line-numbers language-none"><code class="language-none">I would like to use the Github Student Pack to further explore more features of Github, such as Github Copilot and Educative's learning courses.<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p>点击continue </p>
<blockquote>
<p>点击之后会询问你是否允许访问位置，同意即可</p>
<p><strong><u>如果点击之后，一直卡在这个页面，那么是浏览器的问题，可以换个浏览器试试或者过几天再试试</u></strong> </p>
<p><del>我就是换了好几个不成功，最后莫名其妙就能访问了</del></p>
<p>之后进入上传图片的页面，右下角有上传图片 <strong>(如果你没有的话，说明你上梯子了或者离学校太远了，直接重新认证一遍吧)</strong></p>
<p>上传修改之后的学信网认证截图</p>
<p><strong>注意：上传图片格式是jpg 不支持png！！！</strong></p>
</blockquote>
</li>
<li><p>点击提交，如果按以上流程走的话应该是秒通过的，看看邮箱是否收到邮件，或者返回认证申请的第一页，看看右侧是否通过</p>
<p><a target="_blank" rel="noopener" href="https://education.github.com/discount_requests/application">Request a discount - GitHub Education</a></p>
</li>
</ol>
<h2 id="写在最后："><a href="#写在最后：" class="headerlink" title="写在最后："></a>写在最后：</h2><p>一定要有耐心，不挂梯子的话，github的访问基本上是时有时无的，所以要有耐心，多试试，过几天再试试，推荐在学校里申请，或者使用学校的vpn访问网站</p>
<p>祝通过！！！</p>
<p><img src="/2023/06/18/28/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230618202519.png" alt="Elysia会祝福你的"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zuofw.github.io/2023/06/17/01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="QingQiu">
      <meta itemprop="description" content="个人网站，学习记录，面试记录和经验总结、互联网中一块属于自己的小窝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="QingQiu'Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/06/17/01/" class="post-title-link" itemprop="url">Web学习</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-06-17 14:38:01" itemprop="dateCreated datePublished" datetime="2023-06-17T14:38:01+08:00">2023-06-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-10-03 19:37:13" itemprop="dateModified" datetime="2023-10-03T19:37:13+08:00">2023-10-03</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>25k</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="新坑-到P83页了。。。"><a href="#新坑-到P83页了。。。" class="headerlink" title="新坑  到P83页了。。。"></a>新坑  到P83页了。。。</h1><h2 id="HTML5基本语法"><a href="#HTML5基本语法" class="headerlink" title="HTML5基本语法"></a>HTML5基本语法</h2><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>hr</span><span class="token punctuation">&gt;</span></span> 一个横线
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>label</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>label</span><span class="token punctuation">&gt;</span></span> 用于为input 元素进行标注 其 for 属性应与要绑定的元素的id相同，form属性用于规定其属于哪个或者多个表单
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>



<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">&gt;</span></span> <span class="token comment">&lt;!--文档声明，目的是让浏览器知道这是什么类型的文件--&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token punctuation">&gt;</span></span> <span class="token comment">&lt;!--文档的开始，没有什么实际含义--&gt;</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span> <span class="token comment">&lt;!--头标记，放在html 内来防止这个文件中的信息，比如提供索引信息或者定义CSS样式等--&gt;</span>
         <span class="token comment">&lt;!--标题标记，网页的标题，也就是上方的标~ 题，不是内容的标题--&gt;</span>            
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">&gt;</span></span> 
           
        我的测试文件
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span> <span class="token comment">&lt;!--文档正文的开始--&gt;</span> <span class="token comment">&lt;!--文本属性中可以加入text 来表示文本的颜色，bgcolor来表示背景的颜色--&gt;</span>
        <span class="token comment">&lt;!-- &lt;body text="red" bgcolor="blue"&gt;--&gt;</span>
        <span class="token comment">&lt;!--hn 各种大小标题--&gt;</span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>font</span> <span class="token attr-name">color</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">"</span>blue<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span> <span class="token comment">&lt;!--设置字体颜色--&gt;</span>
                蓝色的一级标题
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>font</span><span class="token punctuation">&gt;</span></span>
            
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>
            <span class="token comment">&lt;!--段落标记--&gt;</span>
            这是我的第一个测试文件
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>
        <span class="token comment">&lt;!--文字样式标记--&gt;</span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>b</span><span class="token punctuation">&gt;</span></span> <span class="token comment">&lt;!--加粗--&gt;</span>
         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>i</span><span class="token punctuation">&gt;</span></span>
            <span class="token comment">&lt;!--斜体--&gt;</span>
            这是加粗斜体字
         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>i</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>b</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">&gt;</span></span>
        <span class="token comment">&lt;!--删除线--&gt;</span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>s</span><span class="token punctuation">&gt;</span></span>删除线<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>s</span><span class="token punctuation">&gt;</span></span> 
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">&gt;</span></span>
        <span class="token comment">&lt;!--下划线--&gt;</span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>u</span><span class="token punctuation">&gt;</span></span>下划线<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>u</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">&gt;</span></span>
        <span class="token comment">&lt;!--放大缩小，加强强调，强调，现实电子邮件或者地址，写代码--&gt;</span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>big</span><span class="token punctuation">&gt;</span></span>放大<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>big</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>small</span><span class="token punctuation">&gt;</span></span>缩小<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>small</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">&gt;</span></span>
        <span class="token comment">&lt;!--加强强调--&gt;</span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>strong</span><span class="token punctuation">&gt;</span></span>加强强调<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>strong</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>em</span><span class="token punctuation">&gt;</span></span>强调<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>em</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>address</span><span class="token punctuation">&gt;</span></span>2354796263@qq.com<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>address</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>code</span><span class="token punctuation">&gt;</span></span>
            #include &lt;bits/stdc++.h&gt;
            using namespace std;
            int main(){
                cout &lt;&lt; "Hello World!"&lt;&lt; endl;
                return 0;
            }
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>code</span><span class="token punctuation">&gt;</span></span>
        <span class="token comment">&lt;!--文字上浮和下浮--&gt;</span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>文字<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>sup</span><span class="token punctuation">&gt;</span></span>上浮<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>sup</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>sub</span><span class="token punctuation">&gt;</span></span>下浮<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>sub</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>
        <span class="token comment">&lt;!--文字样式标记--&gt;</span>

        <span class="token comment">&lt;!--文本的位置--&gt;</span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>center</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>font</span> <span class="token attr-name">color</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">"</span>red<span class="token punctuation">"</span></span> <span class="token attr-name">face</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">"</span>宋体<span class="token punctuation">"</span></span> <span class="token attr-name">size</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">"</span>7<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span> 实现居中<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>font</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>center</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">&gt;</span></span> <span class="token comment">&lt;!--font 还可以设置字体和大小，属性是 face 和 size--&gt;</span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h4</span>  <span class="token attr-name">align</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">"</span>right<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>font</span> <span class="token attr-name">color</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">"</span>blue<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>实现右侧<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>font</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h4</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">&gt;</span></span>
        <span class="token comment">&lt;!--照片的操作--&gt;</span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>source/image/Elysia.jpg<span class="token punctuation">"</span></span> <span class="token attr-name">alt</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>图片丢失时显示<span class="token punctuation">"</span></span> <span class="token attr-name">title</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>鼠标放在上面可以看到<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>导航菜单</strong></p>
<pre class="line-numbers language-css" data-language="css"><code class="language-css">使用
&lt;ul&gt; + &lt;li&gt; + &lt;a&gt; 即可，之后在css中进行设置样式<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p><strong>设置表格:</strong></p>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>table</span><span class="token punctuation">&gt;</span></span>表格 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tr</span><span class="token punctuation">&gt;</span></span> 定义一行 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>col</span><span class="token punctuation">&gt;</span></span> 定义一列 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">&gt;</span></span> 定义一个单元格  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>caption</span><span class="token punctuation">&gt;</span></span> 表格的大标题 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>th</span><span class="token punctuation">&gt;</span></span> 表头，主要用于行或列的名称，<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>th</span><span class="token punctuation">&gt;</span></span> 与<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">&gt;</span></span> 相似
实例:
     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>table</span> <span class="token attr-name">border</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>2<span class="token punctuation">"</span></span> <span class="token attr-name">cellspacing</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>2<span class="token punctuation">"</span></span> <span class="token attr-name">bgcolor</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">"</span>#eeeeee<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>caption</span><span class="token punctuation">&gt;</span></span>成绩表<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>caption</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tr</span><span class="token punctuation">&gt;</span></span> <span class="token comment">&lt;!--开始定义表头--&gt;</span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>th</span><span class="token punctuation">&gt;</span></span>姓名<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>th</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>th</span><span class="token punctuation">&gt;</span></span>性别<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>th</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>th</span><span class="token punctuation">&gt;</span></span>成绩<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>th</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tr</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tr</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>th</span><span class="token punctuation">&gt;</span></span>张三<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>th</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">&gt;</span></span>男<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">&gt;</span></span>114<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tr</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tr</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>th</span><span class="token punctuation">&gt;</span></span>李四<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>th</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">&gt;</span></span>男<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">&gt;</span></span>514<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tr</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>table</span><span class="token punctuation">&gt;</span></span>
    使用<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">&gt;</span></span> 中的rowspan 和 colspan 来合并单元格<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>设置表单</strong></p>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>form</span><span class="token punctuation">&gt;</span></span> 和 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span><span class="token punctuation">&gt;</span></span> 两个标签
实例：
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>form</span> <span class="token attr-name">action</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
        姓名：<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>form</span><span class="token punctuation">&gt;</span></span>
    type = "text"
    name 设定文本框的名称，在交互程序中可以用到
    size 数值，设定此一栏位要显示的宽度
    value 预设内容
    maxlength 设置文本可输入的最大最大文字长度 
    type 属性内容:
    type = "radio“ 单选
    可选属性：
    checked 设置某个选项为默认选
    name  name属性内容相同的两个选项只能选中一个
    type = "checkbox" 多选
    可选
    checked
    name 需要将一组选中中的所有复选按钮设置为相同的名称才能让服务器处理时知道这几个选项是一个组的
    type = "password" 密码框
    属性与文本类型相同
    type = "submit" 提交按钮
    type = "reset"  重置按钮
    type = "image"  提交图片
    type = "textarea" 多行文本框
	可选：
    cols 定义文本框的宽度，字符的列数
    rows 字符行数
    wrap 定义换行方式 主要有 off 文字不自动换行， virtual 输入文字时会自动换行，但是如果没有自己按下回车键换行，提交到服务器时结果就时没有换行
    physical 自动换行，提交到服务器结果也是换行
    列表框：
    在form中使用 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span><span class="token punctuation">&gt;</span></span> 标签
    在<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span><span class="token punctuation">&gt;</span></span> 中使用<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>option</span><span class="token punctuation">&gt;</span></span>来设置选项<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>option</span><span class="token punctuation">&gt;</span></span>

## class 的用法：

- 一个对象可以包含多个class(方便了在CSS中定义)

  ```css
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text/css<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token style"><span class="token language-css">
          <span class="token selector">.Ely</span><span class="token punctuation">{</span>
              <span class="token property">font-size</span><span class="token punctuation">:</span>larger<span class="token punctuation">;</span>
          <span class="token punctuation">}</span>
          <span class="token selector">.red</span><span class="token punctuation">{</span>
              <span class="token property">color</span> <span class="token punctuation">:</span> purple<span class="token punctuation">;</span>
          <span class="token punctuation">}</span>
      </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">&gt;</span></span>
  
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span> <span class="token attr-name">class</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Ely red<span class="token punctuation">"</span></span> <span class="token attr-name">align</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">"</span>center<span class="token punctuation">"</span></span> <span class="token punctuation">&gt;</span></span>Elysia  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>small</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>small</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><ol>
<li><p>基本规则:</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">张飞{
    身高：
    体重：
    性别
    民族
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>选择器</p>
<blockquote>
<p>对网页中指定的对象进设置</p>
</blockquote>
<ul>
<li><p>标记选择器：所有同名的标签都会被选择</p>
<p>使用html 的标记标签进行选择，例如：<code>&lt;p&gt;</code></p>
<p>基本语法：</p>
<pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">&lt;style&gt;
h1</span> <span class="token punctuation">{</span>     标签选择
    声明
    <span class="token property">color</span> <span class="token punctuation">:</span>red <span class="token punctuation">;</span>  属性 + 值
    <span class="token property">font_size</span> <span class="token punctuation">:</span>25px<span class="token punctuation">;</span>
    
<span class="token punctuation">}</span>
&lt;/style&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>类别选择器：实现只修改指定的标签class</p>
<p>基本语法：</p>
<pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">.class</span> <span class="token punctuation">{</span> . + 类别名<span class="token punctuation">(</span>自定义的名字<span class="token punctuation">)</span>
 	声明   
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>ID选择器，**<u>id在HTML中具有唯一性，不可重复，尽量做到一个标签一个id</u>**</p>
<p><strong><u>ヽ（≧□≦）ノ</u></strong></p>
</li>
</ul>
</li>
<li><p>HTML中使用方法：</p>
<ul>
<li><p>行内央视，直接使用 <code>&lt;style&gt;</code>属性 <strong><u>注意，每一个声明之后要加入分号</u></strong></p>
<pre class="line-numbers language-css" data-language="css"><code class="language-css">&lt;p style=<span class="token string">"color : purple; font-size :larger"</span> align = <span class="token string">"center"</span>&gt;Elysia    &lt;/p&gt; <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p>内嵌式一般放在 <code>&lt;head&gt;</code> 标签之间</p>
</li>
</ul>
<pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">&lt;head&gt;
    &lt;style type="text/css"&gt;
        .Ely</span><span class="token punctuation">{</span>
            <span class="token property">font-size</span><span class="token punctuation">:</span>larger<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token selector">.red</span><span class="token punctuation">{</span>
            <span class="token property">color</span> <span class="token punctuation">:</span> purple<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    &lt;/style&gt;
&lt;/head&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li><p>链接式，将CSS与HTML文件分离 在html中使用 <code>&lt;link&gt;</code> 标签进行 导入</p>
<pre class="line-numbers language-css" data-language="css"><code class="language-css">&lt;link rel=<span class="token string">"stylesheet"</span> href=<span class="token string">"文件地址"</span>&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p>导入式 使用@import 在html初始化时就会进行导入，而使用链接式只有在需要格式时才进行导入</p>
<pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token comment">/*需要放在style 标签中*/</span>
&lt;style&gt;
        <span class="token atrule"><span class="token rule">@import</span> <span class="token string">"1.css"</span><span class="token punctuation">;</span></span>
    &lt;/style&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
</li>
<li><p>Tips:CSS中遵循覆盖规则，对于同一个被选择的对象，后面的定义会覆盖前面的定义，所以可以使用标签进行全局定义，在使用class 来对指定的对象进行微调</p>
</li>
<li><p>Tips2:优先级</p>
<p>最后面导入的样式    &gt;   最后面的连接式 ， 链接式与  <code>&lt;style&gt;</code> 遵循先后顺序， 同一个 <code>&lt;style&gt;</code> 中内嵌式   &gt;    导入式</p>
</li>
<li><p>CSS3新特性：</p>
<p>交集选择器：</p>
<pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">Ely</span><span class="token punctuation">{</span>
    <span class="token property">color</span> <span class="token punctuation">:</span>purple<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector">p</span><span class="token punctuation">{</span>
    <span class="token property">color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector">p.Ely</span><span class="token punctuation">{</span>
    <span class="token property">color</span> <span class="token punctuation">:</span>blue<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>并集选择器：使用  ， 进行隔开即可</p>
<pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">p,.Ely,h5</span><span class="token punctuation">{</span>
    <span class="token property">color</span> <span class="token punctuation">:</span>blue<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>全局选择器：*  使得所有HTML标签都遵循这个规则</p>
<pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">*</span><span class="token punctuation">{</span>
    <span class="token property">color</span> <span class="token punctuation">:</span>blue<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>后代选择器，空格隔开即可</p>
<pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">li ul</span> <span class="token punctuation">{</span>
    <span class="token property">color</span> <span class="token punctuation">:</span>blue<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector">li ul ul</span> <span class="token punctuation">{</span>
    <span class="token property">color</span> <span class="token punctuation">:</span> red<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector">li ul ul ul</span> <span class="token punctuation">{</span>
    <span class="token property">color</span> <span class="token punctuation">:</span> purple<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


</li>
<li><p>只对直接后代有用的选择器： p &gt;   可搭配*使用</p>
</li>
<li><p>ID 选择器：#+id</p>
</li>
<li><p>相邻选择器：A+B 直接兄弟，紧跟着的后面那个</p>
</li>
<li><p>相邻兄弟组选择器：A~B 后面的所有兄弟</p>
</li>
<li><p>属性选择器： 使用中括号进行选择，属性是自定义的</p>
<pre class="line-numbers language-css" data-language="css"><code class="language-css">&lt;p ely = <span class="token string">"123"</span>&gt;最喜欢爱莉希雅了&lt;/p&gt;  <span class="token comment">/*这里ely是自定义的属性，它的值是123*/</span>




<span class="token selector">p[ely]</span><span class="token punctuation">{</span> <span class="token comment">/*使用这个进行选择，即可*/</span>
    <span class="token property">color</span> <span class="token punctuation">:</span> red<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">/*也可以使用属性+属性的值来进行选择*/</span>
<span class="token comment">/*需要属性的值必须是给定的这个值*/</span>
<span class="token selector">p[ely = "123"]</span><span class="token punctuation">{</span>
    <span class="token property">color</span> <span class="token punctuation">:</span> red<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">/*属性包含选择器，只需要属性的值包含给定的值的即可*/</span>
<span class="token selector">p[ely *= "1"]</span><span class="token punctuation">{</span>
    <span class="token property">color</span> <span class="token punctuation">:</span> red<span class="token punctuation">;</span>
<span class="token punctuation">}</span>


&lt;p ely = <span class="token string">"123 4 5 6"</span>&gt;最喜欢爱莉希雅了&lt;/p&gt;
<span class="token comment">/*单词包含选择器 ， 只要包含给定单词即可*/</span>
<span class="token selector">p[ely ~= "123"]</span><span class="token punctuation">{</span>
    <span class="token property">color</span> <span class="token punctuation">:</span> red<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">/*以某个单词或者字母开开头的选择器*/</span>
<span class="token selector">p[ely ^= "1"]</span><span class="token punctuation">{</span>
    <span class="token property">color</span> <span class="token punctuation">:</span> red<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">/*以什么结尾的选择器，只要以某个单词结尾或则和某个字母结尾即可，数字也行*/</span>
<span class="token selector">p[ely $= "6"]</span><span class="token punctuation">{</span>
    <span class="token property">color</span> <span class="token punctuation">:</span> red<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><strong><u>结构伪类选择器</u></strong></p>
<pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token comment">/*
基本语法： E是父元素
E : nth - child 第几个元素
E : root 		根元素，HTML中根元素始终为html
还有很多。。。自己去看吧 
给个链接：https://juejin.cn/post/7001869576069873695
*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><strong><u>伪元素选择器  <del>待补</del></u></strong></p>
</li>
</ol>
<h3 id="CSS继承和层叠特性"><a href="#CSS继承和层叠特性" class="headerlink" title="CSS继承和层叠特性"></a>CSS继承和层叠特性</h3><p>子标记会继承夫标记的所有样式风格，但是子标记的改变不会影响父标记</p>
<p>层叠是出现冲突时的处理方式，越特殊的样式，优先级越高，</p>
<p>层叠优先级：行内样式&gt; ID 样式 &gt; 类别样式 &gt;  标记样式</p>
<h2 id="CSS设置文本样式"><a href="#CSS设置文本样式" class="headerlink" title="CSS设置文本样式"></a>CSS设置文本样式</h2><h3 id="单位："><a href="#单位：" class="headerlink" title="单位："></a>单位：</h3><ol>
<li><p>相对类型：</p>
<p>px : 像素，根据设备类分辨率来进行调整，最常用的</p>
<p>em: 设置以目前字符的高度为单位</p>
<p>rem: root em 设置以网页跟元素HTML 字符的高度为单位， 一般浏览器莫默认单位为 <u><strong>1rem = 16px</strong></u></p>
<p>vw 和 vh 基于视图窗口的相对单， 1vw 等于视口宽度的1% 1vh 等于窗口高度的的1%</p>
</li>
<li><p>绝对类型</p>
<p>in 英尺</p>
<p>cm 厘米</p>
<p>mm </p>
<p>pt 点数</p>
<p>pc 印刷单位 1pc = 12pt</p>
</li>
</ol>
<h3 id="颜色："><a href="#颜色：" class="headerlink" title="颜色："></a>颜色：</h3><p>HTML中统一使用RGB模式，基本设置 rgb(red, green , blue , 透明度 )</p>
<h3 id="基本设置："><a href="#基本设置：" class="headerlink" title="基本设置："></a>基本设置：</h3><blockquote>
<p>font-family : 设置字体</p>
<p>font-style : 设置斜体</p>
<p>font-weight: 设置加粗，参数有 normal, bold(加粗) , bolder(更粗),lighter(更细), 100- 900 按每100为为一个阶段，数字越大，字体越粗</p>
<p>font-transform： 大小写转换</p>
<p>font-size:字体大小</p>
<p>text-decoration:文字的修饰，主要有underline 下划线，line-through 删除线,overline为文字加顶线，blink 文字闪烁(部分浏览器支持)</p>
<p>texr-indent：首行缩进，后面跟缩进的长度，一般使用2em来实现缩进两个字</p>
<p>letter-spacing： 控制字母间距</p>
<p>word-sacing:控制单词间距</p>
<p>line-height: 行高</p>
<p>border :添加边框，可以设置粗细，颜色和虚实</p>
<p>margin 外边框 后面两个参数分别是设置上下距离和左右距离</p>
<p>text-align : 设置文本的水平位置，left,right,center, justify(两端对齐)</p>
<p>background: 设置背景色</p>
<p>text-shadow: 给图片添加阴影效果，后面四个参数是x轴的偏移尺寸，y轴的便宜尺寸，阴影半径，阴影颜色</p>
</blockquote>
<h3 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h3><ul>
<li>rgba () 第四个参数是透明度</li>
</ul>
<h2 id="CSS设置图片属性"><a href="#CSS设置图片属性" class="headerlink" title="CSS设置图片属性"></a>CSS设置图片属性</h2><blockquote>
<p>border-width 设置边框的粗细</p>
<p>border-color  设置边框的颜色</p>
<p>border-style  线性，可以在一些预先定义好的线型中选择</p>
<p>也可以</p>
<p>border-上下左右-属性   来单独设置上下左右的边框</p>
<p>甚至可以直接border ： 后面写大小类型和颜色</p>
<p>例如： border : plum 2px dotted;</p>
<p>实现文字环绕：</p>
<p>float : 将图片移动到页面左侧或者右侧从而使得文字能够从另一端来环绕</p>
</blockquote>
<h2 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h2><p>DOM ：document object model 文档对象模型 ^eb3dd6</p>
<p>padding -border-margin 模型  (顺序是上右下左) </p>
<ul>
<li><strong>Margin(外边距)</strong>&nbsp;- 清除边框外的区域，外边距是透明的。</li>
<li><strong>Border(边框)</strong>&nbsp;- 围绕在内边距和内容外的边框。</li>
<li><strong>Padding(内边距)</strong>&nbsp;- 清除内容周围的区域，内边距是透明的。</li>
<li><strong>Content(内容)</strong>&nbsp;- 盒子的内容，显示文本和图像。</li>
</ul>
<p>一个盒模型包括：content(内容) 、padding(内边距) 、border(内容的边框), margin (外边距)</p>
<p>标准文档流：normal  document stream  </p>
<blockquote>
<p>div  区块容器标记，里面可以容纳各种HTML元素，可以将div看作一个对象</p>
<p>span 也是区块标记</p>
<p>二者区别： div 内的元素可以自动换行，</p>
<p>span 不会换行，没结构上的意义，仅仅是一个行内元素，当其他行内元素不适合的时候就可以使用span了</p>
<p>span 可以包含在div中，但是div不能包含在span 中，使用display来让行内元素表现的像块级元素</p>
<p>相邻的两个行内元素的margin 是第一个的right-margin 第二个的left-margin 之和</p>
</blockquote>
<h3 id="边距控制"><a href="#边距控制" class="headerlink" title="边距控制"></a>边距控制</h3><ul>
<li>border-bottom</li>
</ul>
<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><blockquote>
<p>background-image : url() 插入图片，</p>
<p>一般情况下，图片会自动向水平和数值两个方向平铺，可以使·用以下属性来进行控制</p>
<p>background-repeat : </p>
<p>repeat 默认，沿水平和竖直方向平铺</p>
<p>no-repeat 不平铺，只显示一次</p>
<p>repeat-x 沿水平平铺</p>
<p>repeat-y 沿竖直方向平铺</p>
<p>background-position 设置背景的位置</p>
<p>也是可以合并为一行的: 直接background + 属性即可</p>
<p>background-radius： 来设置盒模型的四个角是否圆滑 ， 后面的四个参数是从左上角开始，顺时针旋转的</p>
<p>box-shadow 给盒模型设置阴影， 后面四个参数分别是水平偏移量，垂直偏移量，模糊，阴影扩展尺寸，阴影颜色，外部阴影或者是内部阴影</p>
</blockquote>
<h2 id="background-函数"><a href="#background-函数" class="headerlink" title="background 函数"></a>background 函数</h2><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token function">linear-gradient</span><span class="token punctuation">(</span>direction<span class="token punctuation">,</span>指定渐变方向<span class="token punctuation">,</span>color-stop1<span class="token punctuation">,</span>...<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>链接：</p>
<h2 id="想要打开一个新的窗口，需要在a标签中使用target-属性，并将其设置为-bank-对鼠标的操作进行反应的元素-任何html元素都能做到-常规选择器-link-常规状态-visited-点击过之后-hover-悬停状态-active-点击时-使用CSS对超链接进行修饰-text-decoration-包括color-line-style-thickness"><a href="#想要打开一个新的窗口，需要在a标签中使用target-属性，并将其设置为-bank-对鼠标的操作进行反应的元素-任何html元素都能做到-常规选择器-link-常规状态-visited-点击过之后-hover-悬停状态-active-点击时-使用CSS对超链接进行修饰-text-decoration-包括color-line-style-thickness" class="headerlink" title="想要打开一个新的窗口，需要在a标签中使用target 属性，并将其设置为_bank### 对鼠标的操作进行反应的元素(任何html元素都能做到)常规选择器 + : +- link 常规状态- visited 点击过之后- hover 悬停状态- active 点击时### 使用CSS对超链接进行修饰- text-decoration 包括color,line,style,thickness"></a>想要打开一个新的窗口，需要在a标签中使用target 属性，并将其设置为_bank<br>### 对鼠标的操作进行反应的元素(任何html元素都能做到)<br>常规选择器 + : +<br>- link 常规状态<br>- visited 点击过之后<br>- hover 悬停状态<br>- active 点击时<br>### 使用CSS对超链接进行修饰<br>- text-decoration 包括color,line,style,thickness</h2><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">a</span><span class="token punctuation">{</span><span class="token comment">/*通用*/</span>
    <span class="token property">text-decoration</span><span class="token punctuation">:</span> none<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">/*以下是使用了CSS伪类型属性来进行修饰*/</span>
<span class="token comment">/*
设置顺寻时 LoVw HaTe 爱恨
link 
visited
hover
active
*/</span>
<span class="token selector">a:link</span><span class="token punctuation">{</span> <span class="token comment">/*普通浏览*/</span>
    <span class="token property">color</span><span class="token punctuation">:</span> black<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector">a:visited</span><span class="token punctuation">{</span><span class="token comment">/*点击过之后*/</span>
    <span class="token property">color</span><span class="token punctuation">:</span> black<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector">a:hover</span><span class="token punctuation">{</span>  <span class="token comment">/*鼠标指针经过时*/</span>
   <span class="token property">color</span><span class="token punctuation">:</span> plum<span class="token punctuation">;</span>
   <span class="token property">text-decoration</span><span class="token punctuation">:</span> underline<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector">a:active</span><span class="token punctuation">{</span><span class="token comment">/*点击时*/</span>
    <span class="token property">color</span><span class="token punctuation">:</span> blue<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/filter">https://developer.mozilla.org/zh-CN/docs/Web/CSS/filter</a><br>修饰鼠标指针</p>
<blockquote>
<p>cursor :属性即可</p>
</blockquote>
<p>修饰列表</p>
<blockquote>
<p>list-style-type：</p>
<p>属性有：</p>
<p>disc 实心圆、</p>
<p>circle 空心圆</p>
<p>square :正方形</p>
<p>decimal : 十进制数字</p>
<p>upper-alpha 大写字母</p>
<p>lower-alpha 小写字母</p>
<p>upper-roman 大写罗马数字</p>
<p>lower-roman 小写罗马数字</p>
<p>none 不显示任何符号</p>
</blockquote>
<h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><pre class="line-numbers language-none"><code class="language-none">
~~比起c语法更像是Java~~

组成：

ECMAScript,DOM , BOM

1. ECMScript 语言
2. DOM 文档对象模型，使用节点来web
3. BOM 浏览器对象模型

### 语法：

区分大小写，变量无类型，只需要使用let进行声明即可，可初始化为任意类型的值
### 数据类型
```js
number 数字包括，整数小数,NaN Not a Number
string
boolean
null 对象未空
undefined 当声明的变量未初始化时该变量的默认值
使用typeof 来获取数据的类型<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>注释与C相同</p>
<p><strong>HTML中的调取方式：</strong></p>
<p>1.使用 script 标签直接调用</p>
<p>2.通过 script 中src属性进行调用外部文件</p>
<p><strong>var和let的区别</strong></p>
<blockquote>
<p><strong>var 声明是全局作用域或函数作用域，而 let 和 const 是块作用域</strong>。 var 变量可以在其范围内更新和重新声明； let 变量可以被更新但不能重新声明； const 变量既不能更新也不能重新声明。 它们都被提升到其作用域的顶端</p>
</blockquote>
<p><strong><u>判断</u></strong></p>
<p>JavaScript中 == 在比较两侧对象时，如果不同吗，会将其转化为同一个类型再比较，而 === 严格等于不会强制类型转换</p>
<p>!=  不等于    !== 不严格等于</p>
<h3 id="jQuery"><a href="#jQuery" class="headerlink" title="jQuery"></a>jQuery</h3><blockquote>
<p>是JavaScript的一个库，简化 了js的操作</p>
</blockquote>
<p>包含功能:</p>
<ul>
<li>HTML 元素选取</li>
<li>HTML 元素操作</li>
<li>CSS 操作</li>
<li>HTML 事件函数</li>
<li>JavaScript 特效和动画</li>
<li>HTML DOM 遍历和修改</li>
<li>AJAX</li>
<li>Utilities<br>使用方式: 查询使用版本，F12打开控制台之后从console中输入$.fn.jquery 即可查询<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;script src = "本地的jQuery文件或者CDN的url即可"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
<li>基础语法: 通过选取HTML元素对选取的元素执行操作 <pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token function">$</span><span class="token punctuation">(</span>selector<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">action</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 
selector 选择符 查询和查找<span class="token constant">HTML</span>元素
<span class="token function">action</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 执行对元素的操作
<span class="token comment">//示例</span>
<span class="token function">$</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">hide</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 隐藏当前元素
<span class="token function">$</span><span class="token punctuation">(</span><span class="token string">"p"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">hide</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  隐藏所有<span class="token operator">&lt;</span>p<span class="token operator">&gt;</span>元素
<span class="token function">$</span><span class="token punctuation">(</span><span class="token string">"p.test"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">hide</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">class</span> <span class="token operator">=</span> <span class="token string">"test"</span>
<span class="token function">$</span><span class="token punctuation">(</span><span class="token string">"#test"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">hide</span><span class="token punctuation">(</span><span class="token punctuation">)</span> id <span class="token operator">=</span> <span class="token string">"test"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
防止在文档未完全加在就绪之前就运行jQuery代码，可以使用以下两种方式之一来解决<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token function">$</span><span class="token punctuation">(</span>document<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ready</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
<span class="token comment">// 开始写 jQuery 代码... </span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
或者
<span class="token function">$</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> 
<span class="token comment">// 开始写 jQuery 代码... </span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
选择器:</li>
<li><ul>
<li>所有元素</li>
</ul>
</li>
<li>this</li>
<li>.class </li>
<li>“#id”</li>
<li>xxx:first 第几个xxx元素</li>
<li>后代用空格隔开</li>
<li>“[herf]” 选取带有herf 属性的元素</li>
<li>“A[B=’C’]” 或者 “A[B!=’C’]” 选取所有B属性值为C或者不为C的A的元素</li>
<li>:button 选取所有type = button的元素<br>常用的事件方法：</li>
<li>click()点击</li>
<li>dbclick()双击</li>
<li>mouseenter鼠标穿过元素时会发生</li>
<li>mouseleave鼠标离开元素</li>
<li>mousedown 鼠标移动到元素上并进行按下</li>
<li>mouseup 松开鼠标按键</li>
<li>hover悬停</li>
<li>focus 获得焦点</li>
<li>blur 失去焦点<br>效果:</li>
<li>hide，隐藏，show显示</li>
<li>toggle 在hide和show之间进行切换</li>
<li>fadeIn淡入，fadeOut 淡出, fade Toggle()切换淡入淡出</li>
<li>fade To() 允许渐变给不透明度</li>
<li>$(<em>selector</em>).fadeTo(<em>speed,opacity,callback</em>);</li>
<li>滑动 slideDown向下滑， slideUp向上滑, slideToggle()切换</li>
<li>动画操作: $(<em>selector</em>).animate({<em>params</em>}<em>,speed,callback</em>);</li>
<li>params定义动画CSS属性，可使用相对值, +xxx</li>
<li>使用队列:<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token function">$</span><span class="token punctuation">(</span><span class="token string">"button"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">click</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">var</span> div<span class="token operator">=</span><span class="token function">$</span><span class="token punctuation">(</span><span class="token string">"div"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> div<span class="token punctuation">.</span><span class="token function">animate</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token literal-property property">height</span><span class="token operator">:</span><span class="token string">'300px'</span><span class="token punctuation">,</span><span class="token literal-property property">opacity</span><span class="token operator">:</span><span class="token string">'0.4'</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token string">"slow"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> div<span class="token punctuation">.</span><span class="token function">animate</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token literal-property property">width</span><span class="token operator">:</span><span class="token string">'300px'</span><span class="token punctuation">,</span><span class="token literal-property property">opacity</span><span class="token operator">:</span><span class="token string">'0.8'</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token string">"slow"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> div<span class="token punctuation">.</span><span class="token function">animate</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token literal-property property">height</span><span class="token operator">:</span><span class="token string">'100px'</span><span class="token punctuation">,</span><span class="token literal-property property">opacity</span><span class="token operator">:</span><span class="token string">'0.4'</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token string">"slow"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> div<span class="token punctuation">.</span><span class="token function">animate</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token literal-property property">width</span><span class="token operator">:</span><span class="token string">'100px'</span><span class="token punctuation">,</span><span class="token literal-property property">opacity</span><span class="token operator">:</span><span class="token string">'0.8'</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token string">"slow"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
<li>停止动画: stop()</li>
<li>动画链: 连续点即可 $(“#p1”).css(“color”,”red”).slideUp(2000).slideDown(2000);</li>
</ul>
<h4 id="DOM操作"><a href="#DOM操作" class="headerlink" title="DOM操作"></a>DOM操作</h4><ul>
<li>text 设置或返回所选元素的文本内容</li>
<li>html 设置或返回所选元素的内容 包括html标签</li>
<li>val  设置或返回表单字段的值</li>
<li>attr 获得属性值</li>
<li>append 在被选中元素的结尾追加内容</li>
<li>prepend 在被选中元素的开头插入内容‘</li>
<li>after 在被选中元素之后加入内容</li>
<li>before 在被选中元素之前加入内容</li>
<li>remove 删除元素</li>
<li>empty 从被选中元素删除子元素</li>
</ul>
<h4 id="操作CSS类-要提前定义css样式才能添加"><a href="#操作CSS类-要提前定义css样式才能添加" class="headerlink" title="操作CSS类 (要提前定义css样式才能添加)"></a>操作CSS类 (要提前定义css样式才能添加)</h4><ul>
<li>addClass 向被选中元素添加一个或多个类</li>
<li>removeClass 从被选中元素删除一个或多个类</li>
<li>toggleClass 对被选中元素进行添加/删除的切换擦偶哦在</li>
<li>css 设置或返回样式属性 (可直接添加属性值)</li>
<li>$(“p”).css(“background-color”,”yellow”); </li>
<li>$(“p”).css({“background-color”:”yellow”,”font-size”:”200%”})<br>尺寸</li>
<li>width , height , (context大小)</li>
<li>innerWidth , innerHight ,(内边框,padding)</li>
<li>outerWidth , outerHight (margin)<br>遍历DOM树</li>
</ul>
<ol>
<li>向上遍历<ul>
<li>parent</li>
<li>parent 向上到根元素</li>
<li>parentsUntil 返回介于两个给定元素之间的祖先元素</li>
</ul>
</li>
<li>向下遍历<ul>
<li>children 直接子元素</li>
<li>find 查找到最后一个元素</li>
</ul>
</li>
<li>同级遍历<ul>
<li>siblings 所有同级元素</li>
<li>next 下一个同胞元素</li>
<li>nextAll 下一个所有同胞</li>
<li>nextUntil</li>
<li>jQuery prev(), prevAll() &amp; prevUntil()</li>
</ul>
</li>
<li>过滤<ul>
<li>first 被选元素的首个元素</li>
<li>last</li>
<li>eq返回都带有指定索引号的元素(索引从0开始)</li>
<li>filter 过滤条件</li>
<li>not</li>
</ul>
</li>
</ol>
<h3 id="jQuery-AJAX使用"><a href="#jQuery-AJAX使用" class="headerlink" title="jQuery AJAX使用"></a>jQuery AJAX使用</h3><ul>
<li>load 从服务器加在数据并把返回的数据放入备选元素中</li>
<li>$(selector).load(URL,data,callback)</li>
<li>get() post()<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token function">$</span><span class="token punctuation">(</span><span class="token string">"button"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">click</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> $<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"demo_test.php"</span><span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">data<span class="token punctuation">,</span>status</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">"数据: "</span> <span class="token operator">+</span> data <span class="token operator">+</span> <span class="token string">"\n状态: "</span> <span class="token operator">+</span> status<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">///////////////////////////////////////</span>
<span class="token function">$</span><span class="token punctuation">(</span><span class="token string">"button"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">click</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> $<span class="token punctuation">.</span><span class="token function">post</span><span class="token punctuation">(</span><span class="token string">"/try/ajax/demo_test_post.php"</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token literal-property property">name</span><span class="token operator">:</span><span class="token string">"菜鸟教程"</span><span class="token punctuation">,</span> <span class="token literal-property property">url</span><span class="token operator">:</span><span class="token string">"http://www.runoob.com"</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">data<span class="token punctuation">,</span>status</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">"数据: \n"</span> <span class="token operator">+</span> data <span class="token operator">+</span> <span class="token string">"\n状态: "</span> <span class="token operator">+</span> status<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li>
</ul>
<hr>
<p>例如：</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">    <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token string">"1"</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a <span class="token operator">==</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a <span class="token operator">===</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//输出为</span>
<span class="token boolean">true</span> 
<span class="token boolean">false</span>

 	<span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token string">"1"</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a <span class="token operator">!=</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//不进行类型转换</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a <span class="token operator">!==</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 进行类型转换</span>
<span class="token comment">//输出为:</span>
<span class="token boolean">false</span>
<span class="token boolean">true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>for of 语句 (和foreach 一样)</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">for</span> <span class="token punctuation">(</span>a <span class="token keyword">of</span> b<span class="token punctuation">)</span><span class="token punctuation">{</span>
    
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>for in  枚举对象的的属性</p>
<p>函数：两种写法</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">name</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    
<span class="token punctuation">}</span><span class="token punctuation">.</span>

<span class="token comment">//或者</span>
<span class="token function-variable function">name</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>通过使用argumens对象，可以 不用声明形参的名称</p>
<p>arguments[0] 即为第一个形参</p>
<p>arguments.length() 可以获得传入函数中的参量个数，从而用于判断。</p>
<p><strong><u>箭头函数(类似于Lambda表达式)</u></strong></p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> <span class="token function-variable function">name</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">参数</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><strong>类是具有相同属性和功能的“对象” 的抽象</strong></p>
<p><strong>对象是从类中创建的实例</strong></p>
<p>属性是对象中的变量</p>
<p>方法是类中的函数</p>
<p>引用类型：Boolean ， Number 和String 类比Java</p>
<p>对象：</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> person <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">xxx</span> <span class="token operator">:</span> xxx  
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p><strong>赋值</strong></p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> myCar <span class="token operator">=</span> <span class="token punctuation">{</span>
   <span class="token literal-property property">size</span> <span class="token operator">:</span> <span class="token string">"large"</span><span class="token punctuation">,</span>
   <span class="token literal-property property">color</span> <span class="token operator">:</span> <span class="token string">"blue"</span><span class="token punctuation">,</span>
   <span class="token function-variable function">eat</span> <span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"吃吃吃"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> <span class="token punctuation">{</span>size <span class="token punctuation">,</span> color<span class="token punctuation">}</span> <span class="token operator">=</span> myCar<span class="token punctuation">;</span> <span class="token comment">// 同名可用这种方式一键赋值</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>color<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>   数组进行复制:</p>
   <pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span> <span class="token punctuation">,</span> <span class="token number">2</span> <span class="token punctuation">,</span> <span class="token number">3</span> <span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span>
<span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span>a<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">;</span>
<span class="token comment">//补充，对象复制</span>
<span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token literal-property property">name</span> <span class="token operator">:</span> <span class="token string">"Bob"</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> c <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token operator">...</span>obj<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>   JavaScript中数组内容的类型可以不一致</p>
<p>   解构数组：</p>
<p>   array的函数</p>
<ul>
<li><p>push , pop</p>
</li>
<li><p>unshift() 从头部增加 shift() 从头部开始删除第一个元素，并返回</p>
</li>
<li><p>splice(start , deleteCount) 删除指定位置 第二个参数可选，并且代表要删除几个元素</p>
</li>
<li><p>sort</p>
</li>
<li><p>indexOf() 从头开始查找 lastIndexOf () 从尾开始查找，两个参数分别是要查找的内容和开始查找的位置</p>
</li>
<li><p>forEach() 为每一个元素执行一个函数</p>
</li>
<li><p>map() 返回一个由指定函数调用后得到的新数组</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> array <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span> <span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> b <span class="token operator">=</span> array<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
      <span class="token keyword">return</span> e <span class="token operator">*</span><span class="token number">2</span> <span class="token punctuation">;</span>
   <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token comment">//使用map建立一个新数组</span>
   <span class="token keyword">for</span> <span class="token punctuation">(</span>a <span class="token keyword">of</span> b<span class="token punctuation">)</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>

   <span class="token keyword">let</span> c <span class="token operator">=</span> array<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token parameter">x</span> <span class="token operator">=&gt;</span> x <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token comment">//filter用于过滤数组的某些数据</span>
   <span class="token keyword">for</span> <span class="token punctuation">(</span>a <span class="token keyword">of</span> c<span class="token punctuation">)</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
   console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>array<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//打印出了map[a[]] = b[]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


</li>
<li><p>every 每个元素都当作参数，所有都满足才返回true</p>
</li>
<li><p>some 部分满足即可true</p>
</li>
<li><p>slice 截取一部分</p>
</li>
<li><p>joint(‘,’) 将数组转化为字符串并返回</p>
</li>
<li><p>展开运算符  数组[…] 即可展开</p>
</li>
</ul>
<p>   Map</p>
<ul>
<li>set(“key” ,”value”)</li>
<li>for (let [key , value] of map)</li>
<li>for (let key of map)   for (let value of map)</li>
<li>forEach(函数)</li>
<li>合并 自己看文档喽</li>
</ul>
<p>   Set</p>
<ul>
<li>add</li>
<li>并集，交集，差集 自己看</li>
</ul>
<h3 id="BOM对象"><a href="#BOM对象" class="headerlink" title="BOM对象"></a>BOM对象</h3><ol>
<li><p>window对象，用于操作浏览器的窗口</p>
<p>常用的有  第三个参数与新窗口有关，自己去看</p>
<pre><code>- moveBy(x , y) 将窗口向又或者向下移动
- moveTo(x ,y) 移动到指定位置
- resizeBy (dw , dh) 缩放
- resizeTo (w ,h )  缩放到指定窗口大小
- alert() 输出
- prompt() 读入用户输入
- confirm() 显示确认和取消 确定 返回值是true
- setinterval() 按照指定周期来调用函数和表达式 参数未函数 + 毫秒数
- setTimeout() 在指定毫秒数后调用函数计算表达式
</code></pre>
</li>
<li><p>location 对象，用于分析和设置页面的URL，主要是window 和 document 对象的属性<br> 直接使用location . xxx 即可</p>
<p>有以下属性</p>
<pre><code>- hash 如果URL包含书签#，则返回#后边的内容
- host 服务器的名称
- &lt;u&gt;**herf**&lt;/u&gt; 当前载入的完整的URL 
- pathname URL 中主机后面的部分
- port 请求端口
- protocol 协议
- search 执行GET请求的URL中 ? 之后的部分
</code></pre>
<p>补充：URL</p>
<blockquote>
<p><strong>URL</strong> 代表着是统一资源定位符（Uniform Resource Locator）。URL 无非就是一个给定的独特资源在 Web 上的地址。理论上说，每个有效的 URL 都指向一个唯一的资源。这个资源可以是一个 HTML 页面，一个 CSS 文档，一幅图像，等等。而在实际中，也有一些例外，最常见的情况就是一个 URL 指向了不存在的或是被移动过的资源。由于通过 URL 呈现的资源和 URL 本身由 Web 服务器处理，因此 web 服务器的拥有者需要认真地维护资源以及与它关联的 URL。</p>
</blockquote>
</li>
<li><p>navigator 对象， 进行客户端检测</p>
<pre><code>- appCodeName 浏览器代码名的字符串表示
- appName 官方浏览器名的字符串表示
- appVersion 浏览器版本信息表示
- javaEnabled() 是否启用了Java
- platform 运行浏览器的计算机平台字符串表示
- plugins 安装在浏览器中的插件组数
- userAgent 用户代理头字符串的字符串表示 最常用
</code></pre>
</li>
<li><p>screen 对象 也是 window对象的属性</p>
<pre><code>- availHeight 窗口可以使用的屏幕高度
- availWidth
- colorDepth 用户表示颜色位数
- height 屏幕高度
- width 
</code></pre>
</li>
<li><p>history 导航历史记录</p>
<pre><code>- go( ) 前进后退几页，也可以使用字符串，导航到包哦含这个字符串的第一个也米娜
- back()
- forward()
- length 历史记录中有多个条目，可以来判断当前是不是你的第一个页面
</code></pre>
<h3 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h3><p>将标记语言的各个组成部分封装为对应的对象</p>
<blockquote>
<p>Document 整个文档对象<br>Element 元素对象<br>Text   文本对象<br>Comment 注释对象 </p>
</blockquote>
<p>js可以通过DOM对HTML进行操作和做出反应 ^6aefb6</p>
</li>
</ol>
<h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><ol>
<li>[[Web学习#^6aefb6|Core DOM 所有文档类型的标准模型]] </li>
<li>XML DOM XML 文档的标准模型</li>
<li>HTML DOM HTML 文档的标准模型</li>
</ol>
<p>	</p>
<h4 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h4><p>具体的标签对象的属性和函数去MDN里看看 </p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//通过id值查找对象</span>
<span class="token keyword">var</span> h1 <span class="token operator">=</span> doucument<span class="token punctuation">.</span><span class="token function">getElementById1</span><span class="token punctuation">(</span><span class="token string">'h1'</span><span class="token punctuation">)</span>
<span class="token comment">//以下函数无法查找特定的某一个对象，所以返回的一个对象数组</span>
<span class="token comment">//根据标签名查找对象</span>
<span class="token keyword">var</span> divs <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementsByTagName</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">)</span>
<span class="token comment">//根据name来获取</span>
<span class="token function">getElementsByName</span><span class="token punctuation">(</span><span class="token string">'hobby'</span><span class="token punctuation">)</span>
<span class="token comment">//根据class 来获取</span>
<span class="token function">getElementsByClassName</span><span class="token punctuation">(</span><span class="token string">'cls'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>事件绑定</p>
<ol>
<li>通过HTML标签中的属性来绑定<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">"</span>button<span class="token punctuation">"</span></span> <span class="token special-attr"><span class="token attr-name">onclick</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">"</span><span class="token value javascript language-javascript"><span class="token function">on</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span><span class="token punctuation">"</span></span></span> <span class="token attr-name">value1</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">"</span>按钮1<span class="token punctuation">"</span></span> <span class="token punctuation">&gt;</span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
	<span class="token keyword">function</span> <span class="token function">on</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token function">alert</span> <span class="token punctuation">(</span><span class="token string">'我被点击了'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	
	<span class="token punctuation">}</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li>通过DOM元素来绑定<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">"</span>button<span class="token punctuation">"</span></span> <span class="token attr-name">id</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">"</span>btn<span class="token punctuation">"</span></span> <span class="token attr-name">value</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">"</span>按钮2<span class="token punctuation">"</span></span> <span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span>
	document.getElementById('btn').onclick = function(){
		alert('我被点击了');	
	}
	<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ol>
<h2 id="React"><a href="#React" class="headerlink" title="React"></a>React</h2><p>   JavaScript的一个第三方库</p>
<p>   react app 由组件组成，react组件是返回html标签的JavaScript函数</p>
<p>   react 的组件可以用作类似于html的标签，区别是React 组件必须以大写字母开头，HTML标签必须以小写字母开头</p>
<p>   JavaScript的component实际上就是JavaBean</p>
<p>   例如:</p>
   <pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">MyButton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&lt;</span>button<span class="token operator">&gt;</span><span class="token constant">I</span>'m a button<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>   之后MyButton可作为标签使用</p>
   <pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">function</span> <span class="token function">MyApp</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>h1<span class="token operator">&gt;</span>Welcome to my app<span class="token operator">&lt;</span><span class="token operator">/</span>h1<span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>MyButton <span class="token operator">/</span><span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>   <strong>hotloader</strong>是好东西</p>
<p>   <strong>React命名:</strong></p>
<blockquote>
<p>HTML中的类为 class ，而React中的class命名为className</p>
<p><code>&lt;h4 className="Profile-subTitle"&gt;About Me&lt;/h4&gt;</code></p>
<p>类名为：组件名(文件名) 扩折号 文件中的作用名，遵循驼峰</p>
</blockquote>
<p>   使用 import xxx from “xxx” 来在js文件中导入其他的component</p>
<p>   使用 import “xxx.css” 来从导入css文件</p>
<p>   使用 export default xxx 来导出这个组件，从而让其他文件能够调用这个组件</p>
<p>   具体可看示例 catbook-react </p>
<h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><blockquote>
<p>使用js对象标记法书写的文本</p>
</blockquote>
<p>格式：</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//这个变量是一个字符串类型的，不是对象</span>
<span class="token keyword">var</span> 变量 <span class="token operator">=</span> <span class="token string">'{"key1" : value1 , "key2" : value2}'</span><span class="token punctuation">;</span><span class="token comment">//单引号来表名时变量类型</span>
<span class="token comment">//JSON 字符串和js对象转化</span>
<span class="token keyword">var</span> jsObject <span class="token operator">=</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>userStr<span class="token punctuation">)</span>
<span class="token keyword">var</span> jsonStr <span class="token operator">=</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>jsObject<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h2><h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><p>组成：URL + Methods + Request Headers + Request Body</p>
<blockquote>
<p>URL 文件定位，网址 (定位)<br>URI主要用于标识网络资源名称（比如网址）标识唯一的资源 (身份证)</p>
</blockquote>
<h3 id="网络通信三要素"><a href="#网络通信三要素" class="headerlink" title="网络通信三要素"></a>网络通信三要素</h3><ul>
<li>ip:计算机在网络中的唯一标识	</li>
<li>端口: 应用程序在计算机中的唯一表示</li>
<li>传输协议:<ul>
<li>tcp 安全协议，三次握手,四次挥手 <a target="_blank" rel="noopener" href="https://ost.51cto.com/posts/17361">教程</a></li>
<li>udp 不安全协议</li>
</ul>
</li>
</ul>
<h3 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h3><ul>
<li>请求行大写请求方式，URL,请求协议，版本号</li>
<li>请求头存放请求参数和值，键值对的方式， 参数名:参数值</li>
<li>请求空行一行来区分请求头和请求体</li>
<li>get方式没有请求体</li>
</ul>
<h3 id="Methods"><a href="#Methods" class="headerlink" title="Methods"></a>Methods</h3><ul>
<li><code>GET</code> 方法请求一个指定资源的表示形式，使用 <code>GET</code> 的请求应该只被用于获取数据。</li>
<li><code>HEAD</code> 方法请求一个与 <code>GET</code> 请求的响应相同的响应，但没有响应体</li>
<li><code>POST</code> 方法用于将实体提交到指定的资源，通常导致在服务器上的状态变化或副作用。</li>
<li><code>PUT</code> 方法用有效载荷请求替换目标资源的所有当前表示。</li>
<li><code>DELETE</code> 方法删除指定的资源。</li>
<li><code>CONNECT</code> 方法建立一个到由目标资源标识的服务器的隧道。</li>
<li><code>OPTIONS</code> 方法用于描述目标资源的通信选项。</li>
<li><code>TRACE</code> 方法沿着到目标资源的路径执行一个消息环回测试。</li>
<li><code>PATCH</code> 方法用于对资源应用部分修改。</li>
</ul>
<hr>
<p><strong>响应部分</strong></p>
<ul>
<li>响应行 :  协议，版本号，状态码，状态描述信息</li>
<li>响应头 :  参数和值， 参数名 : 参数值 </li>
<li>响应体 : html 格式<br>状态码：</li>
</ul>
<p>1xx：信息</p>
<p>2xx：succeeded</p>
<p>3xx：redirect 重定向</p>
<p>4xx:  你请求出错</p>
<p>5xx：服务器出错</p>
<h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><blockquote>
<p><strong>应用程序接口</strong>（英语：<strong>a</strong>pplication <strong>p</strong>rogramming <strong>i</strong>nterface[<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/zh-hans/%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%8E%A5%E5%8F%A3#cite_note-%E5%88%98%E7%91%9E%E6%96%B02018-1">1]</a>），缩写为<strong>API</strong>[<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/zh-hans/%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%8E%A5%E5%8F%A3#cite_note-UnmehopaVemuri2006-2">2]</a>，是一种<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97">计算</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BB%8B%E9%9D%A2_(%E8%B3%87%E8%A8%8A%E7%A7%91%E6%8A%80)">接口</a>，它定义多个<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%BD%AF%E4%BB%B6">软件</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%B8%AD%E4%BB%8B">中介</a>之间的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=%E4%BA%A4%E4%BA%92&amp;action=edit&amp;redlink=1">交互</a>，以及可以进行的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=%E8%B0%83%E7%94%A8&amp;action=edit&amp;redlink=1">调用</a>（call）或<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=%E8%AF%B7%E6%B1%82&amp;action=edit&amp;redlink=1">请求</a>（request）的种类，如何进行调用或发出请求，应使用的数据格式，应遵循的惯例等。它还可以提供<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=%E6%89%A9%E5%B1%95%E6%9C%BA%E5%88%B6&amp;action=edit&amp;redlink=1">扩展机制</a>，以便用户可以通过各种方式对现有功能进行不同程度的扩展[<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/zh-hans/%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%8E%A5%E5%8F%A3#cite_note-Fisher1-3">3]</a>。一个API可以是完全定制的，针对某个组件的，也可以是基于行业标准设计的以确保互操作性。通过<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1">信息隐藏</a>，API实现了<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%A8%A1%E5%9D%97%E5%8C%96%E7%BC%96%E7%A8%8B">模块化编程</a>，从而允许用户实现独立地使用接口。</p>
</blockquote>
<p>目的：</p>
<p><img src="/2023/06/17/01/1690524156434.png"></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@RestController</span> <span class="token comment">//加上这个之后变为请求处理类  </span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HelloController</span> <span class="token punctuation">{</span>  
<span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/hello"</span><span class="token punctuation">)</span>  
<span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  
<span class="token keyword">return</span> <span class="token string">"hello world!"</span><span class="token punctuation">;</span>  
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>一些参数的实现<br><img src="/2023/06/17/01/%E5%8F%82%E6%95%B0.png"><br><img src="/2023/06/17/01/%E5%90%8C%E4%B8%80%E7%9A%84%E5%93%8D%E5%BA%94%E7%BB%93%E6%9E%9C.png"></p>
<h2 id="形式良好的-XML-文档"><a href="#形式良好的-XML-文档" class="headerlink" title="形式良好的 XML 文档"></a>形式良好的 XML 文档</h2><p>“形式良好”的 XML 文档拥有正确的语法。</p>
<p>在前面的章节描述的语法规则：</p>
<ul>
<li>XML 文档必须有一个根元素</li>
<li>XML元素都必须有一个关闭标签</li>
<li>XML 标签对大小写敏感</li>
<li>XML 元素必须被正确的嵌套</li>
<li>XML 属性值必须加引号<br>在 XML 中，有 5 个预定义的实体引用：</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>&lt;</td>
<td>&lt;</td>
<td>less than</td>
</tr>
<tr>
<td>&gt;</td>
<td>&gt;</td>
<td>greater than</td>
</tr>
<tr>
<td>&amp;</td>
<td>&amp;</td>
<td>ampersand</td>
</tr>
<tr>
<td>&amp;apos;</td>
<td>‘</td>
<td>apostrophe</td>
</tr>
<tr>
<td>"</td>
<td>“</td>
<td>quotation mark</td>
</tr>
</tbody></table>
<h2 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h2><p>是接口，使用时要自己实现</p>
<h4 id="web-xml中配置（可用注解实现了，暴怒需要这么写了）"><a href="#web-xml中配置（可用注解实现了，暴怒需要这么写了）" class="headerlink" title="web.xml中配置（可用注解实现了，暴怒需要这么写了）"></a>web.xml中配置（可用注解实现了，暴怒需要这么写了）</h4><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">	<span class="token comment">&lt;!-- Servlets --&gt;</span>
	<span class="token comment">&lt;!-- 配置类名和路径--&gt;</span>  
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet</span><span class="token punctuation">&gt;</span></span>  
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-name</span><span class="token punctuation">&gt;</span></span>demo1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-name</span><span class="token punctuation">&gt;</span></span>  
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-class</span><span class="token punctuation">&gt;</span></span>com.example.servelet_study.servlet.ServletDemo1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-class</span><span class="token punctuation">&gt;</span></span>  
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet</span><span class="token punctuation">&gt;</span></span>  
<span class="token comment">&lt;!-- 配置请求路径 --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-mapping</span><span class="token punctuation">&gt;</span></span>  
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-name</span><span class="token punctuation">&gt;</span></span>demo1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-name</span><span class="token punctuation">&gt;</span></span>  
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>url-pattern</span><span class="token punctuation">&gt;</span></span>/demo1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>url-pattern</span><span class="token punctuation">&gt;</span></span>  
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-mapping</span><span class="token punctuation">&gt;</span></span>
<span class="token comment">&lt;!-- 配置servlet的init时间 --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>load-on-startup</span><span class="token punctuation">&gt;</span></span> 数字 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>load-on-startup</span><span class="token punctuation">&gt;</span></span> 数字为正数时可以在服务器启动时被创建，为 负数时可以在第一次访问的时候进行加载<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@WebServlet</span><span class="token punctuation">(</span> <span class="token string">"/..."</span><span class="token punctuation">,</span><span class="token string">"/..."</span><span class="token punctuation">,</span><span class="token string">"/..."</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h4 id="接口方法"><a href="#接口方法" class="headerlink" title="接口方法"></a>接口方法</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 在第一次创建<span class="token class-name">Servlet</span>时被调用
<span class="token function">service</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 在被访问时会被调用，会适当的调用doGet等方法
<span class="token function">destroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token function">getSercletConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 获取配置文件
getServletInfo <span class="token punctuation">(</span><span class="token punctuation">)</span> 获取servlet版本信息<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">## 分层解耦
### 三层架构
1. controller : 控制层 ，接受前端发送的请求，对请求进行处理，并响应数据
2. service: 业务逻辑层，处理具体的业务逻辑
3. dao 数据访问层(Data Access Object ) (持久层),负责数据的访问操作，包括增删改查
### IOC &amp; DI
```java
@Component 将当前类交给IOC 容器 //加在需要被new的对象所在的层
@Autowired 运行时IOC 容器会提供该类型的bean并赋值给变量 依赖注入 //加在controller层

加上之后就不需要自己进行new对象了，直接建立对象变量即可
//其他注解
@Component 声明bean的基础注解
//以下在web中常用
@Controller 标注在控制器上
@Service 标注在业务类上
//DI注解
@Autowired 默认是按照类型进行的，如果存在多个相同的类型的bean就会出现报错
@Primary 想要哪个bean被注入就直接加在那个类前面
@Qualifier("value") 在使用的时候加上这个，value为bean的名字
@Resource (name = "") 
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="HttpServletRequest中常用的方法"><a href="#HttpServletRequest中常用的方法" class="headerlink" title="HttpServletRequest中常用的方法"></a>HttpServletRequest中常用的方法</h3><ul>
<li>Map&nbsp;getParameterMap()<br>  获取包含所有请求参数及值的 Map 对象。需要注意，该 Map 的 value 为 String[]，即一个参数所对应的值为一个数组。说明一个参数可以对应多个值。</li>
<li>Enumeration&nbsp;getParameterNames()<br>  获取请求参数 Map 的所有 key,即获取所有请求参数名。</li>
<li>String[] getParameterValues(String name)<br>  根据指定的请求参数名称，获取其对应的所有值。这个方法一般用于获取复选框(checkbox)数据。</li>
<li>String getParameter(String name)<br>  根据指定的请求参数名称，获取其对应的值。若该参数名称对应的是多个值，则该方法获取到的是第一个值。这个方法是最常用的方法。</li>
</ul>
<p>获取客户端信息的方法：</p>
<ul>
<li>getRequestURL方法返回客户端发出请求时的完整URL。</li>
<li>getRequestURI方法返回请求行中的资源名部分。</li>
<li>getQueryString 方法返回请求行中的参数部分。</li>
<li>getRemoteAddr方法返回发出请求的客户机的IP地址</li>
<li>getRemoteHost方法返回发出请求的客户机的完整主机名</li>
<li>getRemotePort方法返回客户机所使用的网络端口号</li>
<li>getLocalAddr方法返回WEB服务器的IP地址。</li>
<li>getLocalName方法返回WEB服务器的主机名</li>
<li>getMethod得到客户机请求方式<pre class="line-numbers language-java" data-language="java"><code class="language-java">request<span class="token punctuation">.</span><span class="token function">setAttribute</span><span class="token punctuation">(</span><span class="token string">"test"</span><span class="token punctuation">,</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 暂存req请求中的信息

equest<span class="token punctuation">.</span><span class="token function">getRequestDispacther</span><span class="token punctuation">(</span><span class="token string">"/test.jsp"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forword</span><span class="token punctuation">(</span>request<span class="token punctuation">,</span>response<span class="token punctuation">)</span><span class="token punctuation">;</span> 转发


response<span class="token punctuation">.</span><span class="token function">sendRedirect</span><span class="token punctuation">(</span><span class="token string">"test.jsp"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 重定向<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
<h3 id="filter-1"><a href="#filter-1" class="headerlink" title="filter"></a>filter</h3><blockquote>
<p>由于表单的post 提交方式，所以要编写好编码的过滤器来支持中文存取</p>
</blockquote>
<h2 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h2><p>免除js中的 DOM操作简化书写</p>
<ol>
<li>新建html页面引入Vue.js文件</li>
<li>创建Vue核心对象，定义数据模型<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
<span class="token keyword">new</span> <span class="token class-name">Vue</span> <span class="token punctuation">(</span><span class="token punctuation">{</span>
	<span class="token literal-property property">el</span> <span class="token operator">:</span> <span class="token string">"#app"</span><span class="token punctuation">,</span> <span class="token comment">//Vue要控制哪个区， #+id 类似css的选择器</span>
	<span class="token literal-property property">data</span> <span class="token operator">:</span> <span class="token punctuation">{</span><span class="token comment">//数据模型</span>
		<span class="token literal-property property">message</span> <span class="token operator">:</span> <span class="token string">"hello Vue"</span>	
	<span class="token punctuation">}</span>
	<span class="token literal-property property">method</span> <span class="token operator">:</span><span class="token punctuation">{</span>
		<span class="token comment">//定义函数</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li>编写视图<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">"</span>app<span class="token punctuation">"</span></span> <span class="token punctuation">&gt;</span></span>
	<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">v-model</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">"</span>message<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span> //绑定数据模型
	{{ message }} //直接获取数据模型中的数据进行展示
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
//
{{}} 插值表达式，中间可以填入 变量，三元运算符，函数调用，算数运算
v-model = "" 模型绑定<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ol>
<h3 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">v<span class="token operator">-</span>bind 为<span class="token constant">HTML</span> 标签绑定属性值，例如设置href <span class="token punctuation">,</span> css 样式
<span class="token literal-property property">或者直接</span> <span class="token operator">:</span> <span class="token operator">+</span> href <span class="token operator">...</span>
v<span class="token operator">-</span>model 在表单元素上实现双向数据绑定
v<span class="token operator">-</span>on 为<span class="token constant">HTML</span>绑定事务 v<span class="token operator">-</span>on<span class="token operator">:</span>click 可简写为@click
<span class="token comment">//</span>

<span class="token comment">//</span>
v<span class="token operator">-</span><span class="token keyword">if</span> 
v<span class="token operator">-</span><span class="token keyword">else</span><span class="token operator">-</span><span class="token keyword">if</span> 条件性的渲染某元素
v<span class="token operator">-</span><span class="token keyword">else</span>
v<span class="token operator">-</span>show 根据条件显示某元素，区别是切换的是display属性的值
v<span class="token operator">-</span><span class="token keyword">for</span> 列表渲染，遍历容器的元素或对象的属性<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="生命周期及其对应的方法"><a href="#生命周期及其对应的方法" class="headerlink" title="生命周期及其对应的方法"></a>生命周期及其对应的方法</h3><h2 id="Ajax-异步的js和xml"><a href="#Ajax-异步的js和xml" class="headerlink" title="Ajax : 异步的js和xml"></a>Ajax : 异步的js和xml</h2><h3 id="Axios"><a href="#Axios" class="headerlink" title="Axios"></a>Axios</h3><p>简化了Axios<br><code> npm install axios</code><br>在入口文件引入</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">import</span> axios <span class="token keyword">from</span> <span class="token string">"axios"</span><span class="token punctuation">;</span>  
<span class="token comment">//把axios全局导出  </span>
app<span class="token punctuation">.</span>config<span class="token punctuation">.</span>globalProperties<span class="token punctuation">.</span>$axios <span class="token operator">=</span> axios<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<ul>
<li>发送多个请求<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//定义两个异步函数</span>
<span class="token keyword">function</span> <span class="token function">getUserAccount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">return</span> axios<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">'/user/12345'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span> 
<span class="token keyword">function</span> <span class="token function">getUserPermissions</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
<span class="token keyword">return</span> axios<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">'/user/12345/permissions'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span>
<span class="token comment">//等待两个都执行完毕再返回结果</span>
Promise<span class="token punctuation">.</span><span class="token function">all</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token function">getUserAccount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">getUserPermissions</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">[</span>acct<span class="token punctuation">,</span> perm<span class="token punctuation">]</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// ... });</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li>使用时只需要在axios中传入config即可</li>
<li>创建一个自定义的实例<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> instance <span class="token operator">=</span> axios<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
	<span class="token literal-property property">baseURL</span><span class="token operator">:</span> <span class="token string">'https://some-domain.com/api/'</span><span class="token punctuation">,</span> 
	<span class="token literal-property property">timeout</span><span class="token operator">:</span> <span class="token number">1000</span><span class="token punctuation">,</span> 
	<span class="token literal-property property">headers</span><span class="token operator">:</span> <span class="token punctuation">{</span><span class="token string-property property">'X-Custom-Header'</span><span class="token operator">:</span> <span class="token string">'foobar'</span><span class="token punctuation">}</span> 
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><a target="_blank" rel="noopener" href="https://axios-http.com/zh/docs/req_config">config配置详解</a></li>
<li>拦截器<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 添加请求拦截器</span>
axios<span class="token punctuation">.</span>interceptors<span class="token punctuation">.</span>request<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">config</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 在发送请求之前做些什么</span>
    <span class="token keyword">return</span> config<span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 对请求错误做些什么</span>
    <span class="token keyword">return</span> Promise<span class="token punctuation">.</span><span class="token function">reject</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 添加响应拦截器</span>
axios<span class="token punctuation">.</span>interceptors<span class="token punctuation">.</span>response<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">response</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 2xx 范围内的状态码都会触发该函数。</span>
    <span class="token comment">// 对响应数据做点什么</span>
    <span class="token keyword">return</span> response<span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 超出 2xx 范围的状态码都会触发该函数。</span>
    <span class="token comment">// 对响应错误做点什么</span>
    <span class="token keyword">return</span> Promise<span class="token punctuation">.</span><span class="token function">reject</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><a target="_blank" rel="noopener" href="https://axios-http.com/zh/docs/handling_errors">错误处理</a></li>
</ul>
<h2 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h2><p><strong>Nginx (engine x)</strong>&nbsp;是一款轻量级的 Web 服务器 、反向代理服务器及电子邮件（IMAP/POP3）代理服务器。<br><strong>什么是反向代理？</strong></p>
<p>反向代理（Reverse Proxy）方式是指以代理服务器来接受 internet 上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给 internet 上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">nginx <span class="token parameter variable">-s</span> stop       快速关闭Nginx，可能不保存相关信息，并迅速终止web服务。
nginx <span class="token parameter variable">-s</span> quit       平稳关闭Nginx，保存相关信息，有安排的结束web服务。
nginx <span class="token parameter variable">-s</span> reload     因改变了Nginx相关配置，需要重新加载配置而重载。
nginx <span class="token parameter variable">-s</span> reopen     重新打开日志文件。
nginx <span class="token parameter variable">-c</span> filename   为 Nginx 指定一个配置文件，来代替缺省的。
nginx <span class="token parameter variable">-t</span>            不运行，仅仅测试配置文件。nginx 将检查配置文件的语法的正确性，并尝试打开配置文件中所引用到的文件。
nginx <span class="token parameter variable">-v</span>            显示 nginx 的版本。
nginx <span class="token parameter variable">-V</span>            显示 nginx 的版本，编译器版本和配置参数。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>启动nginx服务，启动时会一闪而过是正常的</p>
<p>start nginx</p>
<p>查看任务进程是否存在，dos或打开任务管理器都行</p>
<p>tasklist /fi “imagename eq nginx.exe”</p>
<h2 id="Vue-1"><a href="#Vue-1" class="headerlink" title="Vue"></a>Vue</h2><h2 id="Element"><a href="#Element" class="headerlink" title="Element"></a>Element</h2><h2 id="maven"><a href="#maven" class="headerlink" title="maven"></a>maven</h2><p>用于项目管理构建和依赖管理，将依赖写入到maven配置文件中即可自动下载到项目中</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://m.imooc.com/wiki/mavenlesson-maveninstall">https://m.imooc.com/wiki/mavenlesson-maveninstall</a></li>
<li>构建项目<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mvn archetype:generate <span class="token parameter variable">-DgroupId</span><span class="token operator">=</span>com.mic.tech <span class="token parameter variable">-DartifactId</span><span class="token operator">=</span>firstProject <span class="token parameter variable">-DarchetypeArtifactId</span><span class="token operator">=</span>maven-archetype-quickstart <span class="token parameter variable">-DinteractiveMode</span><span class="token operator">=</span>false
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
</ol>
<ul>
<li><strong>-DgourpId</strong>: 组织名，一般为公司网址的反写；</li>
<li><strong>-DartifactId</strong>: 项目名-模块名；</li>
<li><strong>-DarchetypeArtifactId</strong>: 用来指定 ArchetypeId，这里用到的是maven-archetype-quickstart，即创建一个简单 Java 应用；</li>
<li><strong>-DinteractiveMode</strong>: 是否使用交互模式。</li>
</ul>
<ol start="3">
<li>idea已经内置maven</li>
</ol>
<p>添加外部依赖</p>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">将外部文件导入到项目中，配置pom.xml
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">&gt;</span></span>
    <span class="token comment">&lt;!-- 在这里添加你的依赖 --&gt;</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>ldapjdk<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>  <span class="token comment">&lt;!-- 库名称，也可以自定义 --&gt;</span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>ldapjdk<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token comment">&lt;!--库名称，也可以自定义--&gt;</span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>1.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span> <span class="token comment">&lt;!--版本号--&gt;</span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">&gt;</span></span>system<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">&gt;</span></span> <span class="token comment">&lt;!--作用域--&gt;</span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>systemPath</span><span class="token punctuation">&gt;</span></span>${basedir}\src\lib\ldapjdk.jar<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>systemPath</span><span class="token punctuation">&gt;</span></span> <span class="token comment">&lt;!--项目根目录下
        的lib文件夹下--&gt;</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span> 
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="JSP"><a href="#JSP" class="headerlink" title="JSP"></a>JSP</h2><p>cookie存储在客户端，session 存储在服务器端</p>
<h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><pre class="line-numbers language-JSP" data-language="JSP"><code class="language-JSP">&lt;% 代码 %&gt;
&lt;%! int i = 0 ; %&gt; 变量声明
&lt;%= 表达式 %&gt;  表达式声明
&lt;%-- 注释 --%&gt; 注释，注释内容 不会被发送到浏览器
&lt;!-- html注释 --&gt; 可以通过查看源代码来进行查看
if --else 语法
&lt;% if (day == 1 || day == 7) { %&gt;
      &lt;p&gt;今天是周末&lt;/p&gt;
&lt;% } else { %&gt;
      &lt;p&gt;今天不是周末&lt;/p&gt;
&lt;% } %&gt;
switch 
&lt;% 
switch(day) {
case 0:
   out.println("星期天");
   break;
case 1:
   out.println("星期一");
   break;
case 2:
   out.println("星期二");
   break;
case 3:
   out.println("星期三");
   break;
case 4:
   out.println("星期四");
   break;
case 5:
   out.println("星期五");
   break;
default:
   out.println("星期六");
}
%&gt;
for循环
&lt;%for ( fontSize = 1; fontSize &lt;= 3; fontSize++){ %&gt;
   &lt;font color="green" size="&lt;%= fontSize %&gt;"&gt;
    菜鸟教程
   &lt;/font&gt;&lt;br /&gt;
&lt;%}%&gt;
while循环
&lt;%while ( fontSize &lt;= 3){ %&gt;
   &lt;font color="green" size="&lt;%= fontSize %&gt;"&gt;
    菜鸟教程
   &lt;/font&gt;&lt;br /&gt;
&lt;%fontSize++;%&gt;
&lt;%}%&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="JSP行为"><a href="#JSP行为" class="headerlink" title="JSP行为"></a>JSP行为</h3><p>使用xml语法来控制servlet引擎，能够动态插入一个文件重用Javabean组件，切换页面</p>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>jsp</span> <span class="token attr-name">:action_name</span> <span class="token attr-name">attribute</span> <span class="token attr-name">attribute</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">"</span>value<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
action_name :
include 在当前页面包含静态
useBean 寻找和初始化一个java组件
setProperty 设置JavaBean组件的值
getProperty 将JavaBean 组件的值插入到output中
forward 从一个jsp文件向另一个文件传递一个包含用户请求的request 对象
plugin 再生成的html页面中包含Applet和JavaBean对象
element 动态创建一个xml元素
attribute 定义动态创建的xml元素的属性
body 动态创建xml元素主体
text 用于封装数据
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="JSP-指令"><a href="#JSP-指令" class="headerlink" title="JSP 指令"></a>JSP 指令</h3><pre class="line-numbers language-jsp" data-language="jsp"><code class="language-jsp">&lt;%@ 指令 %&gt;  
主要指令有: 
page  定义网页依赖属性 脚本语言,error页面，缓存需求等
	page相关的属性
	buffer 指定out对象使用缓冲区大小
	autoFlush 控制out 对象的缓存区
	conteneType 指定当前JSP 页面发生异常时需要转向的错误处理页面
	error Page 指定当JSP页面发生异常时需要转向的错误处理页面
	isErrorPage 指定当前页面是否可以作为另一个JSP页面的错误处理页面
	extends servlet 从哪个类继承
	import 导入要使用的java 类
	info 定义jsp页面的表述信息
	isThreadSafe 指定对JSP页面的访问是否为线程安全
	language 定义JSP页面所用的脚本语言，默认是Java
	session 指定JSP页面是否使用session
	isELIgnored 指定是否执行EL表达式
	isScriptingEnabled 确定脚本元素能否被使用
	
include 包含其他文件
	&lt;%@ include file = "文件的相对url" %&gt;
taglib  引入标签库的定义，可以自定义标签
	&lt;% tagelib uri = "uri" prefix = "refix0Tag" %&gt;
	uri 标签库的位置   prefix 指定标签库的前缀<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="JSP动作元素"><a href="#JSP动作元素" class="headerlink" title="JSP动作元素"></a>JSP动作元素</h3><p>JSP动作元素在请求阶段处理阶段起作用，且使用的时xml语法</p>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">语法：
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">jsp:</span></span> <span class="token attr-name">action_name</span> <span class="token attr-name">attribute</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">"</span><span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>
include 在页面被请求的时候引入一个文件
	page = "url" flush = "true or false" 定义在包含资源前是否刷新缓存区
useBean 寻找或者实例化一个JavaBean
	<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">jsp:</span>useBean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>name<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>package.class<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>
	class指定Bean的完整包名。
	type 指定将引用该对象变量的类型。
	beanName 通过 java.beans.Beans 的 instantiate() 方法指定Bean的名字。
setProperty 设置JavaBean的属性
	将其放在useBean中只会在找到一个Bean示例才会进行执行
	放在外部则不论是否找到bean都会执行
	属性: name 表示要设置属性的是哪个bean
	property 无论要设置哪个属性都有一个特殊用法
	value 指定bean属性的值
	param 指定用哪个参数作为Bean属性的值
getProperty 输出某个JavaBean的属性
	提取对应的Bean属性的值，转化为字符串然后输出
	name 药检所的bean属性名称
	property 表示要提取属性的值
forward 把请求转到一个新的界面
plugin 根据浏览器类型为Java插件生成obeject 活embed 标记
element 定义动态xml元素
attribute 设置动态定义的xml属性
body 动态定义的xml内容
text 在jsp页面和文档中使用写入文本的模板<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="JSP隐式对象，可以直接使用而不显示声明"><a href="#JSP隐式对象，可以直接使用而不显示声明" class="headerlink" title="JSP隐式对象，可以直接使用而不显示声明"></a>JSP隐式对象，可以直接使用而不显示声明</h3><ol>
<li>request 对象 ^8a3722</li>
<li>response对象</li>
<li>out</li>
<li>session 用来追踪在各个客户端请求间的会话</li>
<li>application 代表这这个JSP页面</li>
<li>config </li>
<li>pageContext 代表整个jsp页面，存储了request和response的引用，application 对象，config , session .  out可以访问这个对象来导出</li>
<li>page == this</li>
<li>exception</li>
</ol>
<h4 id="request-同servlet中的request"><a href="#request-同servlet中的request" class="headerlink" title="request(同servlet中的request)"></a>request(同servlet中的request)</h4><table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td><strong>Cookie[] getCookies()</strong><br><br>返回客户端所有的Cookie的数组</td>
</tr>
<tr>
<td>2</td>
<td><strong>Enumeration getAttributeNames()</strong><br><br>返回request对象的所有属性名称的集合</td>
</tr>
<tr>
<td>3</td>
<td><strong>Enumeration getHeaderNames()</strong><br><br>返回所有HTTP头的名称集合</td>
</tr>
<tr>
<td>4</td>
<td><strong>Enumeration getParameterNames()</strong><br><br>返回请求中所有参数的集合</td>
</tr>
<tr>
<td>5</td>
<td><strong>HttpSession getSession()</strong><br><br>返回request对应的session对象，如果没有，则创建一个</td>
</tr>
<tr>
<td>6</td>
<td><strong>HttpSession getSession(boolean create)</strong><br><br>返回request对应的session对象，如果没有并且参数create为true，则返回一个新的session对象</td>
</tr>
<tr>
<td>7</td>
<td><strong>Locale getLocale()</strong><br><br>返回当前页的Locale对象，可以在response中设置</td>
</tr>
<tr>
<td>8</td>
<td><strong>Object getAttribute(String name)</strong><br><br>返回名称为name的属性值，如果不存在则返回null。</td>
</tr>
<tr>
<td>9</td>
<td><strong>ServletInputStream getInputStream()</strong><br><br>返回请求的输入流</td>
</tr>
<tr>
<td>10</td>
<td><strong>String getAuthType()</strong><br><br>返回认证方案的名称，用来保护servlet，比如 “BASIC” 或者 “SSL” 或 null 如果 JSP没设置保护措施</td>
</tr>
<tr>
<td>11</td>
<td><strong>String getCharacterEncoding()</strong><br><br>返回request的字符编码集名称</td>
</tr>
<tr>
<td>12</td>
<td><strong>String getContentType()</strong><br><br>返回request主体的MIME类型，若未知则返回null</td>
</tr>
<tr>
<td>13</td>
<td><strong>String getContextPath()</strong><br><br>返回request URI中指明的上下文路径</td>
</tr>
<tr>
<td>14</td>
<td><strong>String getHeader(String name)</strong><br><br>返回name指定的信息头</td>
</tr>
<tr>
<td>15</td>
<td><strong>String getMethod()</strong><br><br>返回此request中的HTTP方法，比如 GET,，POST，或PUT</td>
</tr>
<tr>
<td>16</td>
<td><strong>String getParameter(String name)</strong><br><br>返回此request中name指定的参数，若不存在则返回null</td>
</tr>
<tr>
<td>17</td>
<td><strong>String getPathInfo()</strong><br><br>返回任何额外的与此request URL相关的路径</td>
</tr>
<tr>
<td>18</td>
<td><strong>String getProtocol()</strong><br><br>返回此request所使用的协议名和版本</td>
</tr>
<tr>
<td>19</td>
<td><strong>String getQueryString()</strong><br><br>返回此 request URL包含的查询字符串</td>
</tr>
<tr>
<td>20</td>
<td><strong>String getRemoteAddr()</strong><br><br>返回客户端的IP地址</td>
</tr>
<tr>
<td>21</td>
<td><strong>String getRemoteHost()</strong><br><br>返回客户端的完整名称</td>
</tr>
<tr>
<td>22</td>
<td><strong>String getRemoteUser()</strong><br><br>返回客户端通过登录认证的用户，若用户未认证则返回null</td>
</tr>
<tr>
<td>23</td>
<td><strong>String getRequestURI()</strong><br><br>返回request的URI</td>
</tr>
<tr>
<td>24</td>
<td><strong>String getRequestedSessionId()</strong><br><br>返回request指定的session ID</td>
</tr>
<tr>
<td>25</td>
<td><strong>String getServletPath()</strong><br><br>返回所请求的servlet路径</td>
</tr>
<tr>
<td>26</td>
<td><strong>String[] getParameterValues(String name)</strong><br><br>返回指定名称的参数的所有值，若不存在则返回null</td>
</tr>
<tr>
<td>27</td>
<td><strong>boolean isSecure()</strong><br><br>返回request是否使用了加密通道，比如HTTPS</td>
</tr>
<tr>
<td>28</td>
<td><strong>int getContentLength()</strong><br><br>返回request主体所包含的字节数，若未知的返回-1</td>
</tr>
<tr>
<td>29</td>
<td><strong>int getIntHeader(String name)</strong><br><br>返回指定名称的request信息头的值</td>
</tr>
<tr>
<td>30</td>
<td><strong>int getServerPort()</strong><br><br>返回服务器端口号</td>
</tr>
</tbody></table>
<h3 id="Token是一种令牌，用来识别访问人员的"><a href="#Token是一种令牌，用来识别访问人员的" class="headerlink" title="Token是一种令牌，用来识别访问人员的"></a>Token是一种令牌，用来识别访问人员的</h3>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/5/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">QingQiu</p>
  <div class="site-description" itemprop="description">个人网站，学习记录，面试记录和经验总结、互联网中一块属于自己的小窝</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">57</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">26</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Zuofw/zuofw-rpc" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Zuofw&#x2F;zuofw-rpc" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2022 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">QingQiu</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="站点总字数">470k</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  















  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
