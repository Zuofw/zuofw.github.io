<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"zuofw.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="个人网站，学习记录，面试记录和经验总结、互联网中一块属于自己的小窝">
<meta property="og:type" content="website">
<meta property="og:title" content="QingQiu&#39;Blog">
<meta property="og:url" content="https://zuofw.github.io/page/2/index.html">
<meta property="og:site_name" content="QingQiu&#39;Blog">
<meta property="og:description" content="个人网站，学习记录，面试记录和经验总结、互联网中一块属于自己的小窝">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="QingQiu">
<meta property="article:tag" content="博客，学习，成长">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://zuofw.github.io/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>QingQiu'Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>


<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">QingQiu'Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">清秋的博客</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-fa fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-fa fa-archive"></i>归档</a>

  </li>
        <li class="menu-item menu-item-github">

    <a href="https://github.com/Zuofw" rel="noopener" target="_blank"><i class="fa fa-fw fa-fab fa-github"></i>Github</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zuofw.github.io/2024/09/03/19/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="QingQiu">
      <meta itemprop="description" content="个人网站，学习记录，面试记录和经验总结、互联网中一块属于自己的小窝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="QingQiu'Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/09/03/19/" class="post-title-link" itemprop="url">深入浅出Kafka</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-09-03 14:58:19" itemprop="dateCreated datePublished" datetime="2024-09-03T14:58:19+08:00">2024-09-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-09-08 17:43:22" itemprop="dateModified" datetime="2024-09-08T17:43:22+08:00">2024-09-08</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.6k</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h1><h2 id="常见问题-Java-API-一个独立的Kafka服务器被称作broker-broker是集群的组成部分，每个集群都有一个broker同时充当了集群控制器的角色-kafka的主题被分为多个分区，分区存储在磁盘中-kafka的消息特点：消息会保留一段时间，即使应用程序下线，消息仍然会保存在kafka里，是基于磁盘的数据存储。-API使用：-producer-record的参数，topic-key-value-key可以省略，当省略时就是一个没有key的value，key一般用于把相同key的数据写入同一个分区里-send默认是发送并忘记，send会返回一个Future对象使用-get方法得到RecordMetadata对象，可以获取消息的偏移量-异步发送-send-record-回调函数类-，回调函数需要实现Callback类，并且重写其中的方法-配置设置：-1-acks-x3D-0-生产者无需等待服务器的响应，但消息丢失时不会知晓，-x3D-1，只要集群的首领节点收到即可，-x3D-all需要所有参与复制的节点都受到消息才会受到服务器的响应，不建议-2-buffer-memory设置producer内存缓冲区大小，-3-compression-type设置消息的压缩格式，默认不会压缩-4-retries重试次数-5-batch-size-当多个消息被发送到同一个分区时，producer会把他们放在一起，当作一个批次，这个参数指定一个批次可以使用的最大内存-6-max-in-flight-requests-per-connection-生产者在接收到服务器响应之前可以发送多少个消息，设置为-1-时可以保证消息是按照顺序写入的，适合在银行等严格要求顺序的时候使用-自定义分区：-consumer-API-1-consumer类的创建方式和producer一致，但是推荐指定-group-id来指定属于哪个群组，-2-consumer-subscirbe-订阅相关的topic，同时支持正则表达式-consumer-subscribe-Arrays-asList-quot-topic1-quot-quot-topic2-quot-3-consumer-poll-xxx-参数是轮询的阻塞时间，会等待broker返回数据-4-记得-close-5-建议一个线程中只有一个消费者-配置：-大部分和producer类似-fetch-min-bytes消费者从服务器获取记录的最小字节数，当数据量大于等于这个值才会被返回给消费者-提交和偏移量：消费者往-consumer-offset特殊主题发送消息，消息包含每个分区的偏移量，当触发再均衡时，消费者会读取每个分区组后一次提交的偏移量，然后从偏移量指定的地方开始处理-提交方式：-1-自动提交-每隔一段时间自动提交一次-2-提交当前偏移量-设置auto-commit-offset为false-然后使用commitSync-提交偏移量，会提交最新的一次由poll获得的偏移量-3-异步提交：commitAsync-，也可使用回调函数来处理-4-可以提交特定偏移量，而不是最后一次poll得到的偏移量-通过实现-ConsumerRebalanceListener接口来定义在consumer失去对分区的所有权时需要处理的事件，可在这里使用-seek-方法加上自定义的函数来实现从数据库中获得偏移量-Kafka本体-优势高吞吐，高性能，持久化-将消息持久化到磁盘，通过将数据持久化硬盘，以及follower节点来防止数据丢失-缺点是异步的不适合电商场景-架构设计-Producer-Consumer-Topic-主题，由用户定义并配置在Kafka服务器，建立Producer和Consumer之间的订阅关系，身缠这发送消息到特定的Topic下，消费者从这个Topic下消费消息。逻辑概念，相当于数据库中的表-Partition-消息分区，一个Topic可以分为多个partition，partition是一个有序的队列，partition的每条消息都会被分配一个有序的id-offset-物理实际概念，每一个partition对应一个log，producer生产的数据会不断地追加到该log文件末端，且每条数据都有自己的offset。系哦啊飞着组中的每个消费者都会实时记录自己消费到哪个offset-Broker-一台Kafka就是一个broker，一个集群由多个broker组成，一个broker可以容纳多个topic-ConsumerGroup-消费者组，用于归组同类消费者。每个consumer属于一个特定的consumer-group，多个消费者可以共同消费一个Topic下的消息，每个消费者获取部分消息。-一个Partition对应一个唯一的文件夹，文件夹下使用的是Segment-File的存储方式进行存储。将大文件拆成小文件，分为索引未见和数据文件-基本流程-producer先从zookeeper的broker-x2F-x2F-state节点找到该partiton的leader-producer将消息发送给该leader-leader将消息写出本地log-follower从leader-pull-消息-写入本地log，后向leader发送ACK-leader收到所有ISR中的replication的ACK，增加HT-high-watermark-，最后commit-的offset-并向producer发送ACK-生产过程1-Producer创建时，先创建一个Sender线程并且设置守护线程2-生产的消息经过拦截器-gt-序列化器-gt-分区器，将消息存在缓冲区3-批量发送的条件：缓冲区数据大小达到batch-size或者linger-ms达到上限4-发往指定分区，最后到达broker-acks-x3D-0，消息放到缓冲区就认为发送完成-acks-x3D-1消息写到主分区即可完成，如果主分区收到消息之后宕机，副本分区来不及同步消息，消息就会丢失-acks-x3D-all-等待所有的ISR副本的缺人记录5-如果设置了重试次数并且大于0，就会进行重试6-成功，返回元数据给生产者ISR（In-Sync-Replicas）是指与领导者副本保持同步的副本集合-生产者Offset消息写入的时候，每一个分区都有一个offset，即每个分区的最新最大的offset。-消费者Offset不同消费组中的消费者可以针对一个分区存储不同的Offset，互不影响。-LogSegment日志文件的组成部分-Leader选举-Kafka会在Zookeeper上针对每个Topic维护一个成为ISR的集合-当集合中副本都跟Leader同的副本同步之后，kafka才会认为消息已提交-只有这些跟Leader保持同步的Follower才应该被选作新的Leader"><a href="#常见问题-Java-API-一个独立的Kafka服务器被称作broker-broker是集群的组成部分，每个集群都有一个broker同时充当了集群控制器的角色-kafka的主题被分为多个分区，分区存储在磁盘中-kafka的消息特点：消息会保留一段时间，即使应用程序下线，消息仍然会保存在kafka里，是基于磁盘的数据存储。-API使用：-producer-record的参数，topic-key-value-key可以省略，当省略时就是一个没有key的value，key一般用于把相同key的数据写入同一个分区里-send默认是发送并忘记，send会返回一个Future对象使用-get方法得到RecordMetadata对象，可以获取消息的偏移量-异步发送-send-record-回调函数类-，回调函数需要实现Callback类，并且重写其中的方法-配置设置：-1-acks-x3D-0-生产者无需等待服务器的响应，但消息丢失时不会知晓，-x3D-1，只要集群的首领节点收到即可，-x3D-all需要所有参与复制的节点都受到消息才会受到服务器的响应，不建议-2-buffer-memory设置producer内存缓冲区大小，-3-compression-type设置消息的压缩格式，默认不会压缩-4-retries重试次数-5-batch-size-当多个消息被发送到同一个分区时，producer会把他们放在一起，当作一个批次，这个参数指定一个批次可以使用的最大内存-6-max-in-flight-requests-per-connection-生产者在接收到服务器响应之前可以发送多少个消息，设置为-1-时可以保证消息是按照顺序写入的，适合在银行等严格要求顺序的时候使用-自定义分区：-consumer-API-1-consumer类的创建方式和producer一致，但是推荐指定-group-id来指定属于哪个群组，-2-consumer-subscirbe-订阅相关的topic，同时支持正则表达式-consumer-subscribe-Arrays-asList-quot-topic1-quot-quot-topic2-quot-3-consumer-poll-xxx-参数是轮询的阻塞时间，会等待broker返回数据-4-记得-close-5-建议一个线程中只有一个消费者-配置：-大部分和producer类似-fetch-min-bytes消费者从服务器获取记录的最小字节数，当数据量大于等于这个值才会被返回给消费者-提交和偏移量：消费者往-consumer-offset特殊主题发送消息，消息包含每个分区的偏移量，当触发再均衡时，消费者会读取每个分区组后一次提交的偏移量，然后从偏移量指定的地方开始处理-提交方式：-1-自动提交-每隔一段时间自动提交一次-2-提交当前偏移量-设置auto-commit-offset为false-然后使用commitSync-提交偏移量，会提交最新的一次由poll获得的偏移量-3-异步提交：commitAsync-，也可使用回调函数来处理-4-可以提交特定偏移量，而不是最后一次poll得到的偏移量-通过实现-ConsumerRebalanceListener接口来定义在consumer失去对分区的所有权时需要处理的事件，可在这里使用-seek-方法加上自定义的函数来实现从数据库中获得偏移量-Kafka本体-优势高吞吐，高性能，持久化-将消息持久化到磁盘，通过将数据持久化硬盘，以及follower节点来防止数据丢失-缺点是异步的不适合电商场景-架构设计-Producer-Consumer-Topic-主题，由用户定义并配置在Kafka服务器，建立Producer和Consumer之间的订阅关系，身缠这发送消息到特定的Topic下，消费者从这个Topic下消费消息。逻辑概念，相当于数据库中的表-Partition-消息分区，一个Topic可以分为多个partition，partition是一个有序的队列，partition的每条消息都会被分配一个有序的id-offset-物理实际概念，每一个partition对应一个log，producer生产的数据会不断地追加到该log文件末端，且每条数据都有自己的offset。系哦啊飞着组中的每个消费者都会实时记录自己消费到哪个offset-Broker-一台Kafka就是一个broker，一个集群由多个broker组成，一个broker可以容纳多个topic-ConsumerGroup-消费者组，用于归组同类消费者。每个consumer属于一个特定的consumer-group，多个消费者可以共同消费一个Topic下的消息，每个消费者获取部分消息。-一个Partition对应一个唯一的文件夹，文件夹下使用的是Segment-File的存储方式进行存储。将大文件拆成小文件，分为索引未见和数据文件-基本流程-producer先从zookeeper的broker-x2F-x2F-state节点找到该partiton的leader-producer将消息发送给该leader-leader将消息写出本地log-follower从leader-pull-消息-写入本地log，后向leader发送ACK-leader收到所有ISR中的replication的ACK，增加HT-high-watermark-，最后commit-的offset-并向producer发送ACK-生产过程1-Producer创建时，先创建一个Sender线程并且设置守护线程2-生产的消息经过拦截器-gt-序列化器-gt-分区器，将消息存在缓冲区3-批量发送的条件：缓冲区数据大小达到batch-size或者linger-ms达到上限4-发往指定分区，最后到达broker-acks-x3D-0，消息放到缓冲区就认为发送完成-acks-x3D-1消息写到主分区即可完成，如果主分区收到消息之后宕机，副本分区来不及同步消息，消息就会丢失-acks-x3D-all-等待所有的ISR副本的缺人记录5-如果设置了重试次数并且大于0，就会进行重试6-成功，返回元数据给生产者ISR（In-Sync-Replicas）是指与领导者副本保持同步的副本集合-生产者Offset消息写入的时候，每一个分区都有一个offset，即每个分区的最新最大的offset。-消费者Offset不同消费组中的消费者可以针对一个分区存储不同的Offset，互不影响。-LogSegment日志文件的组成部分-Leader选举-Kafka会在Zookeeper上针对每个Topic维护一个成为ISR的集合-当集合中副本都跟Leader同的副本同步之后，kafka才会认为消息已提交-只有这些跟Leader保持同步的Follower才应该被选作新的Leader" class="headerlink" title="常见问题## Java API- 一个独立的Kafka服务器被称作broker,broker是集群的组成部分，每个集群都有一个broker同时充当了集群控制器的角色- kafka的主题被分为多个分区，分区存储在磁盘中- kafka的消息特点：消息会保留一段时间，即使应用程序下线，消息仍然会保存在kafka里，是基于磁盘的数据存储。- API使用：    - producer        - record的参数，topic , key ,value key可以省略，当省略时就是一个没有key的value，key一般用于把相同key的数据写入同一个分区里        - send默认是发送并忘记，send会返回一个Future对象使用.get方法得到RecordMetadata对象，可以获取消息的偏移量        - 异步发送.send(record,回调函数类)，回调函数需要实现Callback类，并且重写其中的方法        - 配置设置：            1. acks = 0 生产者无需等待服务器的响应，但消息丢失时不会知晓， = 1，只要集群的首领节点收到即可，= all需要所有参与复制的节点都受到消息才会受到服务器的响应，不建议            2. buffer.memory设置producer内存缓冲区大小，            3. compression.type设置消息的压缩格式，默认不会压缩            4. retries重试次数            5. batch.size 当多个消息被发送到同一个分区时，producer会把他们放在一起，当作一个批次，这个参数指定一个批次可以使用的最大内存            6. max.in.flight.requests.per.connection 生产者在接收到服务器响应之前可以发送多少个消息，设置为 1 时可以保证消息是按照顺序写入的，适合在银行等严格要求顺序的时候使用        - 自定义分区：        -  consumer:        - API:            1. consumer类的创建方式和producer一致，但是推荐指定 group.id来指定属于哪个群组，            2. consumer.subscirbe()订阅相关的topic，同时支持正则表达式 consumer.subscribe(Arrays.asList(&quot;topic1&quot;, &quot;topic2&quot;));            3. consumer.poll(xxx) 参数是轮询的阻塞时间，会等待broker返回数据            4. 记得.close()            5. 建议一个线程中只有一个消费者        - 配置：            - 大部分和producer类似            - fetch.min.bytes消费者从服务器获取记录的最小字节数，当数据量大于等于这个值才会被返回给消费者        - 提交和偏移量：消费者往_consumer_offset特殊主题发送消息，消息包含每个分区的偏移量，当触发再均衡时，消费者会读取每个分区组后一次提交的偏移量，然后从偏移量指定的地方开始处理            - 提交方式：                1. 自动提交:每隔一段时间自动提交一次                2. 提交当前偏移量:设置auto.commit.offset为false.然后使用commitSync()提交偏移量，会提交最新的一次由poll获得的偏移量                3. 异步提交：commitAsync()，也可使用回调函数来处理                4. 可以提交特定偏移量，而不是最后一次poll得到的偏移量        - 通过实现 ConsumerRebalanceListener接口来定义在consumer失去对分区的所有权时需要处理的事件，可在这里使用.seek()方法加上自定义的函数来实现从数据库中获得偏移量## Kafka本体### 优势高吞吐，高性能，持久化(将消息持久化到磁盘，通过将数据持久化硬盘，以及follower节点来防止数据丢失)缺点是异步的不适合电商场景### 架构设计- Producer- Consumer- Topic 主题，由用户定义并配置在Kafka服务器，建立Producer和Consumer之间的订阅关系，身缠这发送消息到特定的Topic下，消费者从这个Topic下消费消息。逻辑概念，相当于数据库中的表- Partition 消息分区，一个Topic可以分为多个partition，partition是一个有序的队列，partition的每条消息都会被分配一个有序的id(offset) 物理实际概念，每一个partition对应一个log，producer生产的数据会不断地追加到该log文件末端，且每条数据都有自己的offset。系哦啊飞着组中的每个消费者都会实时记录自己消费到哪个offset- Broker 一台Kafka就是一个broker，一个集群由多个broker组成，一个broker可以容纳多个topic- ConsumerGroup 消费者组，用于归组同类消费者。每个consumer属于一个特定的consumer group，多个消费者可以共同消费一个Topic下的消息，每个消费者获取部分消息。- 一个Partition对应一个唯一的文件夹，文件夹下使用的是Segment File的存储方式进行存储。将大文件拆成小文件，分为索引未见和数据文件### 基本流程- producer先从zookeeper的broker/**/state节点找到该partiton的leader- producer将消息发送给该leader- leader将消息写出本地log- follower从leader pull 消息- 写入本地log，后向leader发送ACK- leader收到所有ISR中的replication的ACK，增加HT(high watermark ，最后commit 的offset)并向producer发送ACK#### 生产过程1. Producer创建时，先创建一个Sender线程并且设置守护线程2. 生产的消息经过拦截器->序列化器->分区器，将消息存在缓冲区3. 批量发送的条件：缓冲区数据大小达到batch.size或者linger.ms达到上限4. 发往指定分区，最后到达broker    - acks = 0，消息放到缓冲区就认为发送完成    - acks = 1消息写到主分区即可完成，如果主分区收到消息之后宕机，副本分区来不及同步消息，消息就会丢失    - acks = all 等待所有的ISR副本的缺人记录5. 如果设置了重试次数并且大于0，就会进行重试6. 成功，返回元数据给生产者ISR（In-Sync Replicas）是指与领导者副本保持同步的副本集合#### 生产者Offset消息写入的时候，每一个分区都有一个offset，即每个分区的最新最大的offset。#### 消费者Offset不同消费组中的消费者可以针对一个分区存储不同的Offset，互不影响。#### LogSegment日志文件的组成部分#### Leader选举- Kafka会在Zookeeper上针对每个Topic维护一个成为ISR的集合- 当集合中副本都跟Leader同的副本同步之后，kafka才会认为消息已提交- 只有这些跟Leader保持同步的Follower才应该被选作新的Leader"></a><a target="_blank" rel="noopener" href="https://javaguide.cn/high-performance/message-queue/kafka-questions-01.html">常见问题</a><br>## Java API<br>- 一个独立的Kafka服务器被称作broker,broker是集群的组成部分，每个集群都有一个broker同时充当了集群控制器的角色<br>- kafka的主题被分为多个分区，分区存储在磁盘中<br>- kafka的消息特点：消息会保留一段时间，即使应用程序下线，消息仍然会保存在kafka里，是基于磁盘的数据存储。<br>- API使用：<br>    - producer<br>        - record的参数，topic , key ,value key可以省略，当省略时就是一个没有key的value，key一般用于把相同key的数据写入同一个分区里<br>        - send默认是发送并忘记，send会返回一个Future对象使用.get方法得到RecordMetadata对象，可以获取消息的偏移量<br>        - 异步发送.send(record,回调函数类)，回调函数需要实现Callback类，并且重写其中的方法<br>        - 配置设置：<br>            1. acks = 0 生产者无需等待服务器的响应，但消息丢失时不会知晓， = 1，只要集群的首领节点收到即可，= all需要所有参与复制的节点都受到消息才会受到服务器的响应，不建议<br>            2. buffer.memory设置producer内存缓冲区大小，<br>            3. compression.type设置消息的压缩格式，默认不会压缩<br>            4. retries重试次数<br>            5. batch.size 当多个消息被发送到同一个分区时，producer会把他们放在一起，当作一个批次，这个参数指定一个批次可以使用的最大内存<br>            6. max.in.flight.requests.per.connection 生产者在接收到服务器响应之前可以发送多少个消息，设置为 1 时可以保证消息是按照顺序写入的，适合在银行等严格要求顺序的时候使用<br>        - 自定义分区：<br>    <pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DemoPartitionser</span> <span class="token keyword">implements</span> <span class="token class-name">Partitioner</span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> <span class="token class-name">String</span> myKey<span class="token punctuation">;</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">partition</span><span class="token punctuation">(</span><span class="token class-name">String</span> topic<span class="token punctuation">,</span> <span class="token class-name">Object</span> key<span class="token punctuation">,</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> keyBytes<span class="token punctuation">,</span> <span class="token class-name">Object</span> value<span class="token punctuation">,</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> valueBytes<span class="token punctuation">,</span> <span class="token class-name">Cluster</span> cluster<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 获取分区列表</span>
        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">PartitionInfo</span><span class="token punctuation">&gt;</span></span> partitionInfos <span class="token operator">=</span> cluster<span class="token punctuation">.</span><span class="token function">partitionsForTopic</span><span class="token punctuation">(</span>topic<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 获取分区数</span>
        <span class="token keyword">int</span> partitionNum <span class="token operator">=</span> partitionInfos<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>keyBytes <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>key <span class="token keyword">instanceof</span> <span class="token class-name">String</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"key is null or not a string"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 如果key为key，则分配到最后一个分区</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token string">"key"</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">return</span> partitionNum<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">//其余的消息都分配到最后一个分区</span>
        <span class="token keyword">return</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">abs</span><span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token punctuation">(</span>partitionNum <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token punctuation">}</span>

    <span class="token comment">/*
     * @description:
     * @author bronya
     * @date: 2024/4/20 14:50
     * @param map
     */</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">configure</span><span class="token punctuation">(</span><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token operator">?</span><span class="token punctuation">&gt;</span></span> map<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        myKey <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">)</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"key"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>    -  consumer:<br>        - API:<br>            1. consumer类的创建方式和producer一致，但是推荐指定 group.id来指定属于哪个群组，<br>            2. consumer.subscirbe()订阅相关的topic，同时支持正则表达式 <code>consumer.subscribe(Arrays.asList("topic1", "topic2"));</code><br>            3. consumer.poll(xxx) 参数是轮询的阻塞时间，会等待broker返回数据<br>            4. 记得.close()<br>            5. 建议一个线程中只有一个消费者<br>        - 配置：<br>            - 大部分和producer类似<br>            - fetch.min.bytes消费者从服务器获取记录的最小字节数，当数据量大于等于这个值才会被返回给消费者<br>        - 提交和偏移量：消费者往_consumer_offset特殊主题发送消息，消息包含每个分区的偏移量，当触发再均衡时，消费者会读取每个分区组后一次提交的偏移量，然后从偏移量指定的地方开始处理<br>            - 提交方式：<br>                1. 自动提交:每隔一段时间自动提交一次<br>                2. 提交当前偏移量:设置auto.commit.offset为false.然后使用commitSync()提交偏移量，会提交最新的一次由poll获得的偏移量<br>                3. 异步提交：commitAsync()，也可使用回调函数来处理<br>                4. 可以提交特定偏移量，而不是最后一次poll得到的偏移量<br>        - 通过实现 ConsumerRebalanceListener接口来定义在consumer失去对分区的所有权时需要处理的事件，可在这里使用.seek()方法加上自定义的函数来实现从数据库中获得偏移量<br>## Kafka本体<br>### 优势<br>高吞吐，高性能，持久化(将消息持久化到磁盘，通过将数据持久化硬盘，以及follower节点来防止数据丢失)<br>缺点是异步的不适合电商场景<br>### 架构设计<br>- Producer<br>- Consumer<br>- Topic 主题，由用户定义并配置在Kafka服务器，建立Producer和Consumer之间的订阅关系，身缠这发送消息到特定的Topic下，消费者从这个Topic下消费消息。逻辑概念，相当于数据库中的表<br>- Partition 消息分区，一个Topic可以分为多个partition，partition是一个有序的队列，partition的每条消息都会被分配一个有序的id(offset) 物理实际概念，每一个partition对应一个log，producer生产的数据会不断地追加到该log文件末端，且每条数据都有自己的offset。系哦啊飞着组中的每个消费者都会实时记录自己消费到哪个offset<br>- Broker 一台Kafka就是一个broker，一个集群由多个broker组成，一个broker可以容纳多个topic<br>- ConsumerGroup 消费者组，用于归组同类消费者。每个consumer属于一个特定的consumer group，多个消费者可以共同消费一个Topic下的消息，每个消费者获取部分消息。<br>- 一个Partition对应一个唯一的文件夹，文件夹下使用的是Segment File的存储方式进行存储。将大文件拆成小文件，分为索引未见和数据文件<br>### 基本流程<br>- producer先从zookeeper的broker/**/state节点找到该partiton的leader<br>- producer将消息发送给该leader<br>- leader将消息写出本地log<br>- follower从leader pull 消息<br>- 写入本地log，后向leader发送ACK<br>- leader收到所有ISR中的replication的ACK，增加HT(high watermark ，最后commit 的offset)并向producer发送ACK<br>#### 生产过程<br>1. Producer创建时，先创建一个Sender线程并且设置守护线程<br>2. 生产的消息经过拦截器-&gt;序列化器-&gt;分区器，将消息存在缓冲区<br>3. 批量发送的条件：缓冲区数据大小达到batch.size或者linger.ms达到上限<br>4. 发往指定分区，最后到达broker<br>    - acks = 0，消息放到缓冲区就认为发送完成<br>    - acks = 1消息写到主分区即可完成，如果主分区收到消息之后宕机，副本分区来不及同步消息，消息就会丢失<br>    - acks = all 等待所有的ISR副本的缺人记录<br>5. 如果设置了重试次数并且大于0，就会进行重试<br>6. 成功，返回元数据给生产者<br>ISR（In-Sync Replicas）是指与领导者副本保持同步的副本集合<br>#### 生产者Offset<br>消息写入的时候，每一个分区都有一个offset，即每个分区的最新最大的offset。<br>#### 消费者Offset<br>不同消费组中的消费者可以针对一个分区存储不同的Offset，互不影响。<br>#### LogSegment<br>日志文件的组成部分<br>#### Leader选举<br>- Kafka会在Zookeeper上针对每个Topic维护一个成为ISR的集合<br>- 当集合中副本都跟Leader同的副本同步之后，kafka才会认为消息已提交<br>- 只有这些跟Leader保持同步的Follower才应该被选作新的Leader</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zuofw.github.io/2024/08/01/12/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="QingQiu">
      <meta itemprop="description" content="个人网站，学习记录，面试记录和经验总结、互联网中一块属于自己的小窝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="QingQiu'Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/08/01/12/" class="post-title-link" itemprop="url">脚本语言学习</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-08-01 14:30:12 / 修改时间：14:32:03" itemprop="dateCreated datePublished" datetime="2024-08-01T14:30:12+08:00">2024-08-01</time>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>9</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h1><p>基本语法</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zuofw.github.io/2024/07/22/14/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="QingQiu">
      <meta itemprop="description" content="个人网站，学习记录，面试记录和经验总结、互联网中一块属于自己的小窝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="QingQiu'Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/07/22/14/" class="post-title-link" itemprop="url">git快速使用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-07-22 10:27:14 / 修改时间：17:17:57" itemprop="dateCreated datePublished" datetime="2024-07-22T10:27:14+08:00">2024-07-22</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/tools/" itemprop="url" rel="index"><span itemprop="name">tools</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.1k</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>本文不是git入门，但后续会补一些入门知识，主要是写给工作室的学弟学妹快速排障使用。<del>主要是被某些同学整无语了才想着记录一下</del><br>观看前提：会上github</p>
<h1 id="git后悔药"><a href="#git后悔药" class="headerlink" title="git后悔药"></a>git后悔药</h1><blockquote>
<p>世上没有后悔药</p>
</blockquote>
<p>但是git有(￣︶￣*))<br>还在担心上班时脑子一热写下臭骂老板的话导致绩效奖没有吗，还在担心提交记录写的丑吗，还在担心远程push的时候不会搞吗，这篇文章用来记录如何解决这些问题。</p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>先介绍一些概念：</p>
<ol>
<li>工作区：工作区就是我们修改的文件但是还没有进行git add</li>
<li>暂存区：我们使用git add 之后但是还么有进行git commit</li>
<li>已提交：进行git commit 之后</li>
<li>已经推送到远程仓库：git push之后</li>
<li>HEAD：Git中的一个特殊的指针，指向了当前<strong>所在分支的最新提交</strong>。可以使用 ^ 来当作指针修饰符，HEAD^代表前一个提交， HEAD^^或者HEAD<del>2代表上两层提交，同理HEAD</del>n 当前提交的第n级父提交</li>
</ol>
<h2 id="工作区"><a href="#工作区" class="headerlink" title="工作区"></a>工作区</h2><p>在工作区进行修改之后，发现不想要了可以使用<br><code>git checkout -- &lt;文件名&gt;</code>来撤回修改<br>不过现在git新版本推荐使用<br><code>git restore &lt;文件名&gt;</code> 来撤回修改</p>
<h2 id="暂存区"><a href="#暂存区" class="headerlink" title="暂存区"></a>暂存区</h2><p><code>git reset HEAD &lt;文件名&gt;</code> 使用这个命令可以将这个文件放回工作区，之后如果不想要了可以结合工作区的命令来撤回修改</p>
<h2 id="已提交"><a href="#已提交" class="headerlink" title="已提交"></a>已提交</h2><ol>
<li>撤回提交但是保留修改：也就是回到工作区 : <code>git reset --soft HEAD^</code></li>
<li>撤回提交并且撤回修改：也就是回到暂存区，<code>git rest --mixed HEAD^</code>可以简写为 <code>git rest HEAD^</code></li>
<li>撤回修改并且丢失所有的修改：也就是将工作区和暂存区的修改都给撤回：<code>git reset --hard HEAD^</code></li>
</ol>
<h2 id="已经推送到远程仓库"><a href="#已经推送到远程仓库" class="headerlink" title="已经推送到远程仓库"></a>已经推送到远程仓库</h2><p>当你到达这一步的时候，你肯定已经慌了，绩效奖多半是没了（；´д｀）ゞ<br><code>git revert HEAD</code><br>使用这个可以将你修改的东西撤回，然后你将这个新的提交上去就能够覆盖掉你原来的提交了，但是你原来的那个提交还是在记录中的，仍然可以访问的。</p>
<h1 id="git开发注意"><a href="#git开发注意" class="headerlink" title="git开发注意"></a>git开发注意</h1><h2 id="如何进去github"><a href="#如何进去github" class="headerlink" title="如何进去github"></a>如何进去github</h2><p>由于不可抗力，github需要一些魔法才能进去。不过工作室目前使用的是工作室服务器上搭建的gitea进行代码的管理，操作和github上基本一致。但是仓库目前由于学校锁ip，必须使用校园网才能进去，所以当成员不在校时，可以使用github来进行开发。</p>
<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="如何提交代码"><a href="#如何提交代码" class="headerlink" title="如何提交代码"></a>如何提交代码</h3><ol>
<li>在仓库上中建立一个你英文名字的分支或者forked一个到自己仓库中(工作室一般采用第一种)</li>
<li>本地打开terminal，输入<code>git push origin 你要提交的本地分支:你要提交到的远程分支名字</code>，示例：<code>git push origin main:huangzhenwei</code> </li>
<li>点开仓库，找到Pull Request (pr)</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zuofw.github.io/2024/06/24/02/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="QingQiu">
      <meta itemprop="description" content="个人网站，学习记录，面试记录和经验总结、互联网中一块属于自己的小窝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="QingQiu'Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/06/24/02/" class="post-title-link" itemprop="url">JVM学习</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-06-24 21:41:02" itemprop="dateCreated datePublished" datetime="2024-06-24T21:41:02+08:00">2024-06-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-09-30 14:49:44" itemprop="dateModified" datetime="2024-09-30T14:49:44+08:00">2024-09-30</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>16k</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="面试常问"><a href="#面试常问" class="headerlink" title="面试常问"></a>面试常问</h1><p>[黑马JVM面试](<a target="_blank" rel="noopener" href="https://lisxpq12rl7.feishu.cn/wiki/QkOzwr3gIiv8eTkKngTc6Lv6nlf">‌⁠​​‍​‍﻿​﻿‌​​​​​⁠​‌﻿​‌‌​‍​​​﻿​​⁠​‬‍​﻿​﻿​​‍​‍​​‌‌​‬面试篇 - 飞书云文档 (feishu.cn)</a>)<br><a target="_blank" rel="noopener" href="https://www.yuque.com/tulingzhouyu/db22bv/td5a84ty4vel22ge#f8eDZ">👍Java虚拟机8-11双版本 -JVM高频面试题👍 (yuque.com)</a></p>
<h2 id="new的过程-x2F-创建对象的步骤"><a href="#new的过程-x2F-创建对象的步骤" class="headerlink" title="new的过程/创建对象的步骤"></a>new的过程/创建对象的步骤</h2><ol>
<li>类加载检查，先去检查是否能在常量池中定位到这个类的符号引用来判断是否已经创建了</li>
<li>分配内存(指针碰撞，空闲列表)</li>
<li>初始化零值</li>
<li>设置对象头：</li>
<li>执行init方法</li>
</ol>
<h2 id="静态变量存储在哪里呢？"><a href="#静态变量存储在哪里呢？" class="headerlink" title="静态变量存储在哪里呢？"></a>静态变量存储在哪里呢？</h2><ul>
<li>JDK6及之前的版本中，静态变量是存放在方法区中的，也就是永久代。</li>
<li>JDK7及之后的版本中，静态变量是存放在堆中的Class对象中，脱离了永久代。</li>
</ul>
<h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><p><img src="/2024/06/24/02/JVM%E7%BB%84%E6%88%90.png" alt="|525"></p>
<ul>
<li><del>编译器</del>：不属于Java虚拟机的一部分，负责将源代码文件编译成字节码文件。</li>
<li>类加载子系统，负责将字节码文件读取、解析并保存到内存中。其核心就是类加载器。</li>
<li>运行时数据区，管理JVM使用到的内存。</li>
<li>执行引用，分为解释器 解释执行字节码指令；即时编译器 优化代码执行性能； 垃圾回收器 将不再使用的对象进行回收。</li>
<li>本地接口，保存了本地已经编译好的方法，使用C/C++语言实现。</li>
</ul>
<h2 id="运行时数据区的组成"><a href="#运行时数据区的组成" class="headerlink" title="运行时数据区的组成"></a>运行时数据区的组成</h2><p><img src="/2024/06/24/02/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E7%9A%84%E7%BB%84%E6%88%90.png" alt="|900"></p>
<ul>
<li>堆，可分为新生代和老年代，新生代可分为Eden，Surviver1，Surviver2</li>
<li>方法区：永久区，存储已经被Java虚拟机架子啊的类信息等，jdk1.8之后称为元空间。</li>
<li>虚拟机栈：线程私有，内有多个栈帧，方法在执行时会创建栈帧，包含(局部变量表，操作数栈，动态链接，返回地址等)<ul>
<li>局部变量表：存放方法参数，局部变量</li>
<li>操作数栈：记录一个方法在执行过程中，字节码指令向操作数栈进行入栈和出栈的过程。</li>
<li>动态链接：字节码中的符号链接，一部分在类加载过程中转化为直接引用(静态解析)，还有一部分在运行时转化为直接引用，也就是动态链接。</li>
<li>返回地址：当前方法执行过程中，当前方法需要返回的位置。</li>
</ul>
</li>
<li>本地方法栈：服务的是Native方法</li>
<li>PC程序计数器：线程私有</li>
</ul>
<h2 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h2><p>每一个方法的调用使用一个栈帧来保存，每一个线程都有一个自己的虚拟机栈，生命周期和线程相同<br>主要包括</p>
<ol>
<li>局部变量表：方法执行过程中存放所有的局部变量</li>
<li>操作数栈：虚拟机在执行指令过程中用来存放临时数据的一块区域</li>
<li>帧数据：主要包括动态链接、方法出口、异常表等内容。</li>
</ol>
<h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>存储的是native本地方法的栈<br>本地方法（Native Method）是使用非 Java 语言（通常是 C 或 C++）编写的方法。这些方法通过 Java 本地接口（Java Native Interface，JNI）与 Java 代码进行交互。使用本地方法的主要目的是为了实现以下几个功能：</p>
<ol>
<li><strong>与操作系统交互</strong>：直接调用操作系统的底层功能。</li>
<li><strong>提高性能</strong>：在性能关键的部分使用更高效的本地代码。</li>
<li><strong>访问硬件</strong>：与特定硬件设备进行交互。</li>
<li><strong>复用现有库</strong>：调用已有的用其他语言编写的库。</li>
</ol>
<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>用来存放创建出来的对象，栈上的局部变量表中，可以存放对上的引用，静态变量也可以存放堆对象的引用，实现对象在线程之间的共享<br>堆是垃圾回收的最主要部分</p>
<h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><p>ClassLoader是Java虚拟机提供给应用程序去实现获取类和接口字节码数据的技术。去获得二进制字节码信息。然后通过JVM调用JNI也就是本地接口方法区创建对象<br><img src="/2024/06/24/02/%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%AC%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8.png"></p>
<h4 id="类加载器的分类"><a href="#类加载器的分类" class="headerlink" title="类加载器的分类"></a>类加载器的分类</h4><h5 id="jdk8以及之前"><a href="#jdk8以及之前" class="headerlink" title="jdk8以及之前"></a>jdk8以及之前</h5><ol>
<li>Java代码实现的(扩展类加载器，应用程序类加载器)</li>
<li>Java虚拟机底层代码实现的(启动类加载器)<br>使用启动加载类器加载器去加载用户的jar包，可以在虚拟机参数那里添加：<br><code>-Xbootclasspath /a: jar包名</code><br>Java中的加载器： 是一个静态内部类，继承自URLClassLoader，通过目录或者指定jar包将字节码文件加载到内存中<br><img src="/2024/06/24/02/Java%E4%B8%AD%E7%9A%84%E9%BB%98%E8%AE%A4%E5%8A%A0%E8%BD%BD%E5%99%A8.png"></li>
</ol>
<h5 id="双亲委派机制-jdk8以及之前重点"><a href="#双亲委派机制-jdk8以及之前重点" class="headerlink" title="双亲委派机制(jdk8以及之前重点)"></a>双亲委派机制(jdk8以及之前重点)</h5><p>可以解决的问题:<br>重复的类：启动类，根据双亲委派机制，如果同一个类出现在三个类加载器中，会由启动类加载器来加载。<br>String类能覆盖吗？ 不能，会由启动类加载器加载在rt.jar包中的String类<br>类加载器的关系：应用类加载器的父类加载器识扩展类加载器，扩展类加载器没有父类加载器，但是会委派给启动类加载器。<br>双亲委派机制的作用：<br>保证类加载器的安全性，避免重复加载。</p>
<ol>
<li>每一个类加载器都有一个父类加载器，在类加载的过程中，每个加载器会先检查是否已经加载了该类，如果已经加载则直接返回否则奖将载请求委派给父类加载器</li>
<li>如果所有的父类加载器都无法加载，就由当前加载器尝试加载，也就是说，如果父类加载器的加载路径中没有这个类，就会由他自己加载 <img src="/2024/06/24/02/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE.png"><img src="/2024/06/24/02/%E4%B8%8A%E4%B8%8B%E5%A7%94%E6%B4%BE.png"></li>
</ol>
<h5 id="如何打破双亲委派机制"><a href="#如何打破双亲委派机制" class="headerlink" title="如何打破双亲委派机制"></a>如何打破双亲委派机制</h5><ol>
<li>自定义类加载器并且重写loadClass方法就可以将双亲委派机制的代码去除。Tomcat通过这种方式实现应用之间类隔离，每一个应用会有一个独立的类加载器加载对应的类</li>
<li>线程上下文加载器加载类，比如JDBC和JNDI等,JDBC使用DriverManager来管理项目中引入的不同的数据库驱动，DriverManager类位于rt.jar包中，由启动类加载器加载。依赖中的mysql驱动对应的类，由应用程序类加载器来加载，DriverManager属于rt.jar是启动类加载器加载的。而用户jar包中的驱动需要由应用类加载器加载，这就违反了双亲委派机制。<img src="/2024/06/24/02/JDBC.png">定义服务接口：JDBC定义了java.sql.Driver接口。<br>服务提供者：各个数据库厂商实现java.sql.Driver接口，并在META-INF/services目录下创建文件java.sql.Driver，文件内容为实现类的全限定名。<br>加载驱动：DriverManager类在静态代码块中通过ServiceLoader加载所有实现java.sql.Driver接口的类，并调用Class.forName方法加载驱动类。<blockquote>
<p>定义服务接口：JDBC定义了java.sql.Driver接口。<br>服务提供者：各个数据库厂商实现java.sql.Driver接口，并在META-INF/services目录下创建文件java.sql.Driver，文件内容为实现类的全限定名。<br>加载驱动：DriverManager类在静态代码块中通过ServiceLoader加载所有实现java.sql.Driver接口的类，并调用Class.forName方法加载驱动类</p>
</blockquote>
</li>
<li>Osgi框架的类加载器，允许同级之间委托进行类的加载<br>自定义类加载器父类怎么是AppClassLoader呢？<br><img src="/2024/06/24/02/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E7%88%B6%E7%B1%BB.png"></li>
</ol>
<h5 id="JDK9之后的类加载器"><a href="#JDK9之后的类加载器" class="headerlink" title="JDK9之后的类加载器"></a>JDK9之后的类加载器</h5><p><strong>为什么抛弃了拓展类加载器</strong> ？<br>因为扩展类加载器主要是和加载jre环境下lib下的jar包，需要拓展Java的功能时，需要把jar包能够在ext文件夹下，不安全<br>JDK9引入的模块化开发取代了他</p>
<ol>
<li>启动类加载器使用Java编写，位于jdk.internal.loader.ClassLoaders类中。Java中的BootClassLoader继承自BuiltinClassLoader实现从模块中找到要加载的字节码资源文件。但是还是无法获取到</li>
<li>扩展类加载器被替换成了平台类加载器，所以继承关系从URLClassLoader变成了BuiltinClassLoader，BuiltinClassLoader实现了从模块中加载字节码文件。平台类加载器的存在更多的是为了与老版本的设计方案兼容，自身没有特殊的逻辑</li>
</ol>
<h5 id="双亲委派机制总结"><a href="#双亲委派机制总结" class="headerlink" title="双亲委派机制总结"></a>双亲委派机制总结</h5><p><img src="/2024/06/24/02/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6%E6%80%BB%E7%BB%93.png" alt="|500"></p>
<h4 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h4><p>加载、连接、初始化、使用、卸载</p>
<h5 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h5><p>简单概括：找到需要加载的类，并把类的信息加载到JVM中，然后在堆中实例化一个java.lang.Class对象，作为方法区中的这个类的信息的入口</p>
<ol>
<li>加载过程中是类加载器根据类的全限定名通过不同的渠道以二进制流的形式获取字节码信息</li>
<li>加载器加载完类之后，Java虚拟机将字节码中的信息保存到方法区中，生成一个InstanceKlass对象，保存类的所有信息，里面还包含实现特定功能比如多态的信息</li>
<li>Java虚拟机在堆中生成一份与方法去中数据类似的java.lang.Class对象，作用是在Java代码中获取类的信息和存储静态字段的数据，jkd8以后将静态字段放在堆区中。 优点是：对于开发者来说只需要访问堆中的Class对象而不需要访问方法区中的所有信息，能够很好的控制开发者访问数据的范围</li>
</ol>
<h5 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h5><ol>
<li>验证，校验Java字节码文件是都遵循了约束，一般不需要程序员参与</li>
<li>为静态变量分配内存并设置初始值，如果使用了final来修饰，就会直接将代码中的值赋给静态变量</li>
<li>解析，将符号引用替换为直接引用，符号引用是在字节码中使用序号来进行引用，而直接引用就是使用内存中的地址直接进行访问</li>
</ol>
<h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><p>当类被直接引用的时候才会出发类的初始化。类被直接引用的情况有-&gt;<br>new,读取或设置类的静态变量，调用类的静态方法，通过反射来执行前三种，初始化子类时会触发父类的初始化，接口实现类初始化时，会出发直接或间接实现的所有接口的初始化<br>类的初始化只会运行静态部分，而且优先父类</p>
<ol>
<li>执行静态代码块中的代码，为静态变量赋值</li>
<li>初始化阶段会执行字节码中clinit部分的字节码指令</li>
</ol>
<h5 id="程序中可以直接导致初始化的操作："><a href="#程序中可以直接导致初始化的操作：" class="headerlink" title="程序中可以直接导致初始化的操作："></a>程序中可以直接导致初始化的操作：</h5><ol>
<li>访问一个类的静态变量或者静态方法，final修饰的并且等号在右侧是常量的话不会触发初始化，因为在连接阶段就已经进行赋值了</li>
<li>调用Class.forName(String className)时会进行初始化</li>
<li>new </li>
<li>执行Main方法的当前类<br><code>&lt;clinit&gt;</code>是Java中的一个特殊方法，代表初始化器（class initializer）。这个方法不是由程序员显式编写的，而是由Java虚拟机（JVM）自动生成的。当类被首次加载到JVM时，<code>&lt;clinit&gt;</code>方法负责执行类变量的静态初始化和静态初始化块的代码<br><code>clinit</code> 在以下情况不会出现：</li>
<li>无静态代码块</li>
<li>有静态变量声明但是没有赋值语句</li>
<li>静态变量的定义使用final字段，会在准备阶段直接进行初始化。<br>访问父类静态变量，只会初始化父类<br>new 子类时会先执行父类的clinit方法<br>数组的创建不会导致数组中元素的类的初始化。<br>final修饰的变量如果不是常量需要执行指令才能得出结果会执行clinit方法进行初始化</li>
</ol>
<h5 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h5><h5 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h5><h4 id="字节码文件"><a href="#字节码文件" class="headerlink" title="字节码文件"></a>字节码文件</h4><ol>
<li>常量池：避免保存重复的内容，节省空间</li>
<li>具体的字节码文件分析 <img src="/2024/06/24/02/%E5%AD%97%E8%8A%82%E7%A0%81.png"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//源码</span>
<span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  
i <span class="token operator">=</span> i <span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token comment">//字节码</span>
<span class="token number">0</span> iconst_0  将<span class="token number">0</span>放在操作数栈中
<span class="token number">1</span> istore_1 弹出操作数栈最顶层数据到局部变量<span class="token number">1</span>号位
<span class="token number">2</span> iload_1  复制到操作数栈顶
<span class="token number">3</span> iinc <span class="token number">1</span> by <span class="token number">1</span> 将局部变量<span class="token number">1</span>号位的数据 <span class="token operator">+</span> <span class="token number">1</span>
<span class="token number">6</span> istore_1 弹出，保存在一号位，所以被覆盖了
<span class="token number">7</span> <span class="token keyword">return</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ol>
<h5 id="组成-1"><a href="#组成-1" class="headerlink" title="组成"></a>组成</h5><p>基础信息，常量池(保存字符串常量、类或者接口名，主要在字节码指令中使用)，字段，方法，属性</p>
<h3 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h3><h4 id="按照线程共享不共享区分："><a href="#按照线程共享不共享区分：" class="headerlink" title="按照线程共享不共享区分："></a>按照线程共享不共享区分：</h4><ul>
<li>线程不共享<ol>
<li>程序计数器</li>
<li>Java虚拟机栈</li>
<li>本地方法栈</li>
</ol>
</li>
<li>线程共享<ol>
<li>方法区</li>
<li>堆</li>
</ol>
</li>
</ul>
<h5 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h5><p>内存溢出：程序在使用某一块内存区域时，存放的数据需要占用的内存大小超过了虚拟机能提供的内存上限<br>每个线程只需要存储一个固定长度的内存地址，所以程序计数器是不会发生内存溢出的<br>程序员无需对程序计数器进行任何处理</p>
<h5 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h5><p>Java虚拟机使用栈来管理方法调用中的基本数据。每一个方法的调用使用一个栈帧来保存，每个线程都包含一个自己的虚拟机栈<br><img src="/2024/06/24/02/%E6%A0%88%E5%86%85%E5%AD%98.png"></p>
<h6 id="栈帧的组成"><a href="#栈帧的组成" class="headerlink" title="栈帧的组成"></a>栈帧的组成</h6><ul>
<li>局部变量表：存放运行中的所有局部变量，包括局部变量表保存的内容有：实例方法的this对象，方法的参数，方法体中声明的局部变量。<img src="/2024/06/24/02/%E5%8F%98%E9%87%8F%E8%A1%A8.png"></li>
<li>操作数栈：存放临时数据<ul>
<li>栈帧中的局部变量表是一个数组，数组中每一个位置称之为槽(slot) ，long和double类型占用两个槽，其他类型占用一个槽。</li>
<li>实例方法中的序号为0的位置存放的是this，指的是当前调用方法的对象，运行时会在内存中存放实例对象的地址。</li>
<li>为了节省空间，局部变量表中的槽是可以复用的，一旦某个局部变量不再生效，当前槽就可以再次被使用。</li>
</ul>
</li>
<li>帧数据：包含动态链接、方法出口、异常表的引用<img src="/2024/06/24/02/%E6%96%B9%E6%B3%95%E5%87%BA%E5%8F%A3.png"></li>
</ul>
<h5 id="本地方法栈："><a href="#本地方法栈：" class="headerlink" title="本地方法栈："></a>本地方法栈：</h5><p>存储natice本地方法的栈帧，在Hotspot虚拟机中，Java虚拟机栈和本地方法栈实现上使用了同一个栈空间。</p>
<h5 id="堆内存"><a href="#堆内存" class="headerlink" title="堆内存"></a>堆内存</h5><p><img src="/2024/06/24/02/%E6%A0%B9%E6%8D%AE%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%90%86%E8%AE%BA%E5%88%92%E5%88%86%E7%9A%84%E5%A0%86.png"><br>一般Java程序中堆内存是空间最大的一块内存区域。创建出来的对象都存在于堆上。栈上的局部变量表中，可以存放堆上对象的引用。静态变量也可以存放堆对象的引用，通过静态变量就可以实现对象在线程之间共享。<br>堆空间有三个需要关注的值，used、total、max。used指的是当前已使用的堆内存，total是java虚拟机已经分配的可用堆内存，max是java虚拟机可以分配的最大堆内存。<br><strong>不是当used = max = total的时候，堆内存就溢出</strong></p>
<hr>
<h5 id="方法区："><a href="#方法区：" class="headerlink" title="方法区："></a>方法区：</h5><p>方法区存放基础信息的位置，线程共享的，主要包含三部分：</p>
<ul>
<li>类的元信息，保存所有类的基本信息</li>
<li>运行时常量池，保存了字节码文件中常量池内容</li>
<li>字符串常量池，保存了字符串常量</li>
</ul>
<h6 id="元信息"><a href="#元信息" class="headerlink" title="元信息"></a>元信息</h6><p>一般称之为InstanceKlass对象。在类的加载阶段完成。其中就包含了类的字段、方法等字节码文件中的内容，同时还保存了运行过程中需要使用的虚方法表（实现多态的基础）等信息。</p>
<h6 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h6><p>字节码文件中通过编号查表的方式找到常量，这种常量池称为静态常量池。当常量池加载到内存中之后，可以通过内存地址快速的定位到常量池中的内容，这种常量池称为运行时常量池。<img src="/2024/06/24/02/%E6%96%B9%E6%B3%95%E5%8C%BA%E7%9A%84%E5%AE%9E%E7%8E%B0.png"></p>
<h6 id="字符串常量池"><a href="#字符串常量池" class="headerlink" title="字符串常量池"></a>字符串常量池</h6><p>字符串的拼接操作会创建一个新的字符串对象，而不是使用字符串常量池中的现有对象。<br>而直接用两个字符串拼接是放在常量池的，不是新建了一个对象</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">String</span> s1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"abc"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">String</span> s2 <span class="token operator">=</span> <span class="token string">"abc"</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s1 <span class="token operator">==</span> s2<span class="token punctuation">)</span><span class="token punctuation">;</span>
答案是<span class="token boolean">false</span><span class="token punctuation">,</span>因为<span class="token string">"abc"</span>是直接放入字符串常量池的，而<span class="token keyword">new</span> 出来的是放在堆内存中，两者所在的位置不同。
<span class="token number">1.</span>

<span class="token comment">/**
 * 字符串常量池案例
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Demo3</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">String</span> a <span class="token operator">=</span> <span class="token string">"1"</span><span class="token punctuation">;</span>
        <span class="token class-name">String</span> b <span class="token operator">=</span> <span class="token string">"2"</span><span class="token punctuation">;</span>
        <span class="token class-name">String</span> c <span class="token operator">=</span> <span class="token string">"12"</span><span class="token punctuation">;</span>
        <span class="token class-name">String</span> d <span class="token operator">=</span> <span class="token string">"1"</span> <span class="token operator">+</span> <span class="token string">"2"</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>c <span class="token operator">==</span> d<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
答案是<span class="token boolean">true</span><span class="token punctuation">,</span>在编译阶段就把 <span class="token string">"1"</span> <span class="token operator">+</span> <span class="token string">"2"</span>连接在一起了
<span class="token number">2.</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Demo2</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">String</span> a <span class="token operator">=</span> <span class="token string">"1"</span><span class="token punctuation">;</span>
        <span class="token class-name">String</span> b <span class="token operator">=</span> <span class="token string">"2"</span><span class="token punctuation">;</span>
        <span class="token class-name">String</span> c <span class="token operator">=</span> <span class="token string">"12"</span><span class="token punctuation">;</span>
        <span class="token class-name">String</span> d <span class="token operator">=</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>c <span class="token operator">==</span> d<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
答案是<span class="token boolean">false</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>jdk8之后运行时常量池放在元空间，而字符串常量池还在堆中。<br><strong>String.intern()方法是可以手动将字符串放入字符串常量池中</strong></p>
<h5 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h5><p>直接内存不属于Java运行时的内存区域，NIO机制中使用直接内存来解决</p>
<ol>
<li>Java堆中的对象如果不再使用要回收，回收时会影响对象的创建和使用。</li>
<li>IO操作比如读文件，需要先把文件读入直接内存（缓冲区）再把数据复制到Java堆中。<br>现在直接放入直接内存即可，同时Java堆上维护直接内存的引用，减少了数据复制的开销。写文件也是类似的思路。<img src="/2024/06/24/02/%E6%96%87%E4%BB%B6%E5%A4%8D%E5%88%B6.png"></li>
</ol>
<h3 id="执行引擎"><a href="#执行引擎" class="headerlink" title="执行引擎"></a>执行引擎</h3><h3 id="本地接口"><a href="#本地接口" class="headerlink" title="本地接口"></a>本地接口</h3><h3 id="垃圾收集器GC"><a href="#垃圾收集器GC" class="headerlink" title="垃圾收集器GC"></a>垃圾收集器GC</h3><p>GC (Garbage Collection)，堆是垃圾回收最主要的区域，所以也被乘坐GC堆。<br>如何手动触发垃圾回收：使用<code>System.gc()</code>，但是这个方法不会立即进行回收，只是向虚拟机发送一个垃圾回收的请求。</p>
<h4 id="不由GC进行回收的部分"><a href="#不由GC进行回收的部分" class="headerlink" title="不由GC进行回收的部分"></a>不由GC进行回收的部分</h4><p>线程不共享的部分不需要GC进行回收，因为随着线程的销毁，对应的方法的栈帧就会自动弹出栈并且释放掉对应的内存。</p>
<h4 id="进行回收的部分"><a href="#进行回收的部分" class="headerlink" title="进行回收的部分"></a>进行回收的部分</h4><h5 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h5><p>主要回收不再使用的类，需要满足以下条件</p>
<ol>
<li>这个类所有的实例对象都被回收，在队中不存在该类的实例对象以及子类对象</li>
<li>加载该类的类加载器已经被回收，类加载器的任务完成之后引用被去除后就会被回收</li>
<li>java.lang.Class对象没有在任何地方被引用<img src="/2024/06/24/02/Class.png"></li>
</ol>
<h5 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h5><p>Java中的对象能否被回收是根据对象是否被引用来决定的。如果对象被引用就不允许被回收<br>主要的算法：</p>
<h6 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h6><p>为每个对象维护一个指针，对象被引用时+1，取消引用时-d。<br>缺点是：</p>
<ol>
<li>每次引用都要维护计数器，会影响系统的性能</li>
<li>存在循环引用问题，A引用B，B引用A就无法回收了</li>
</ol>
<h6 id="可达性分析法"><a href="#可达性分析法" class="headerlink" title="可达性分析法"></a>可达性分析法</h6><p>可达性分析法将对象分为：垃圾回收的根对象 (GC Root)和普通对象，对象之间存在引用关系。<br>可达性分析就是如果某个对象到GC Root是可达的，就不能被回收。<br>哪些对象被称之为GC Root对象呢？</p>
<ul>
<li>线程Thread对象，引用线程栈帧中的方法参数、局部变量等。</li>
<li>系统类加载器加载的java.lang.Class对象，引用类中的静态变量。<img src="/2024/06/24/02/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%AF%B9%E8%B1%A1.png"></li>
<li>监视器对象，用来保存同步锁synchronized关键字持有的对象。<img src="/2024/06/24/02/%E7%9B%91%E8%A7%86%E5%99%A8%E5%AF%B9%E8%B1%A1.png"></li>
<li>本地方法调用时使用的全局对象。</li>
</ul>
<h4 id="常见的引用对象"><a href="#常见的引用对象" class="headerlink" title="常见的引用对象"></a>常见的引用对象</h4><p>可达性算法中描述的对象引用，一般指的是强引用，Java中还设计了几种其他引用方式：</p>
<ul>
<li>软引用</li>
<li>弱引用</li>
<li>虚引用</li>
<li>终结器引用</li>
</ul>
<h5 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h5><p>如果一个对象只有软引用关联到他时，程序内存不足时回将其中的数据及逆行回收，软引用常用于缓存中<br>好处就是用作缓存快速从内存中读取，即使被释放了也可以重新获取，减少内存溢出的可能性<br>软引用对象本身，也需要被强引用，否则软引用对象也会被回收掉。<br>使用案例：</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">/**
 * 软引用案例2 - 基本使用
 */
public class SoftReferenceDemo2 {
    public static void main(String[] args) throws IOException {

        byte[] bytes = new byte[1024 * 1024 * 100];
        SoftReference&lt;byte[]&gt; softReference = new SoftReference&lt;byte[]&gt;(bytes);
        bytes = null;
        System.out.println(softReference.get());

        byte[] bytes2 = new byte[1024 * 1024 * 100];
        System.out.println(softReference.get());
//
//        byte[] bytes3 = new byte[1024 * 1024 * 100];
//        softReference = null;
//        System.gc();
//
//        System.in.read();
    }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果软引用对象中的数据已经被回收了，那么这个对象本身也可以被回收了<br>SoftReference提供了一套队列机制：</p>
<ol>
<li>软引用创建时，通过构造器传入引用队列</li>
<li>在软引用中包含的对象被回收时，该软引用对象会被放入引用队列</li>
<li>通过代码遍历引用队列，将SoftReference的强引用删除<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">/**
 * 软引用案例3 - 引用队列使用
 */
public class SoftReferenceDemo3 {

    public static void main(String[] args) throws IOException {

        ArrayList&lt;SoftReference&gt; softReferences = new ArrayList&lt;&gt;();
        ReferenceQueue&lt;byte[]&gt; queues = new ReferenceQueue&lt;byte[]&gt;();
        for (int i = 0; i &lt; 10; i++) {
            byte[] bytes = new byte[1024 * 1024 * 100];
            SoftReference studentRef = new SoftReference&lt;byte[]&gt;(bytes,queues);
            softReferences.add(studentRef);
        }

        SoftReference&lt;byte[]&gt; ref = null;
        int count = 0;
        while ((ref = (SoftReference&lt;byte[]&gt;) queues.poll()) != null) {
            count++;
        }
        System.out.println(count);

    }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ol>
<h5 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h5><p>弱引用整体与软引用基本一致，但是弱引用不管内存够不够都会直接被回收</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">package chapter04.weak;

import java.io.IOException;
import java.lang.ref.WeakReference;

/**
 * 弱引用案例 - 基本使用
 */
public class WeakReferenceDemo2 {
    public static void main(String[] args) throws IOException {

        byte[] bytes = new byte[1024 * 1024 * 100];
        WeakReference&lt;byte[]&gt; weakReference = new WeakReference&lt;byte[]&gt;(bytes);
        bytes = null;
        System.out.println(weakReference.get());

        System.gc();

        System.out.println(weakReference.get());
    }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h5 id="虚引用和终结器引用"><a href="#虚引用和终结器引用" class="headerlink" title="虚引用和终结器引用"></a>虚引用和终结器引用</h5><p>这两种引用在常规开发中是不会使用的。</p>
<ul>
<li>虚引用也叫幽灵引用/幻影引用，不能通过虚引用对象获取到包含的对象。虚引用唯一的用途是当对象被垃圾回收器回收时可以接收到对应的通知。Java中使用PhantomReference实现了虚引用，直接内存中为了及时知道直接内存对象不再使用，从而回收内存，使用了虚引用来实现。</li>
<li>终结器引用指的是在对象需要被回收时，终结器引用会关联对象并放置在Finalizer类中的引用队列中，在稍后由一条由FinalizerThread线程从队列中获取对象，然后执行对象的finalize方法，在对象第二次被回收时，该对象才真正的被回收。在这个过程中可以在finalize方法中再将自身对象使用强引用关联上，但是不建议这样做。<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">package chapter04.finalreference;

/**
 * 终结器引用案例
 */
public class FinalizeReferenceDemo {
    public static FinalizeReferenceDemo reference = null;

    public void alive() {
        System.out.println("当前对象还存活");
    }

    @Override
    protected void finalize() throws Throwable {
        try{
            System.out.println("finalize()执行了...");
            //设置强引用自救
            reference = this;
        }finally {
            super.finalize();
        }
    }

    public static void main(String[] args) throws Throwable {
        reference = new FinalizeReferenceDemo();
       test();
       test();
    }

    private static void test() throws InterruptedException {
        reference = null;
        //回收对象
        System.gc();
        //执行finalize方法的优先级比较低，休眠500ms等待一下
        Thread.sleep(500);
        if (reference != null) {
            reference.alive();
        } else {
            System.out.println("对象已被回收");
        }
    }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
<h4 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h4><ol>
<li>找到内存中存活的对象</li>
<li>释放不再存活对象的内存，使得程序能再次利用这部分空间</li>
</ol>
<h4 id="垃圾回收算法的历史和分类"><a href="#垃圾回收算法的历史和分类" class="headerlink" title="垃圾回收算法的历史和分类"></a>垃圾回收算法的历史和分类</h4><p>1960年John McCarthy发布了第一个GC算法：标记-清除算法。<br>1963年Marvin L. Minsky 发布了复制算法。</p>
<p>本质上后续所有的垃圾回收算法，都是在上述两种算法的基础上优化而来。</p>
<h5 id="标记清除算法"><a href="#标记清除算法" class="headerlink" title="标记清除算法"></a>标记清除算法</h5><p>GCRoot包含的对象：</p>
<blockquote>
<p>• 虚拟机栈(栈帧中的局部变量表)中引⽤的对象<br>• 本地⽅法栈(Native ⽅法)中引⽤的对象<br>• ⽅法区中类静态属性引⽤的对象<br>• ⽅法区中常量引⽤的对象<br>• 所有被同步锁持有的对象<br>• JNI（Java Native Interface）引⽤的对象</p>
</blockquote>
<p>标记清除算法的核心思想分为两个阶段：</p>
<ol>
<li>标记阶段，将所有存活的对象进行标记。Java中使用可达性分析算法，从GC Root开始通过引用链遍历出所有存活对象。从GC Root对象开始扫描，将对象A、B、C在引用链上的对象标记出来</li>
<li>清除阶段，从内存中删除没有被标记也就是非存活对象。将没有标记的对象清理掉，所以对象D就被清理掉了。<br>缺点：</li>
<li>碎片化问题由于内存是连续的，所以在对象被删除之后，内存中会出现很多细小的可用内存单元。如果我们需要的是一个比较大的空间，很有可能这些内存单元的大小过小无法进行分配</li>
<li>分配速度慢。由于内存碎片的存在，需要维护一个空闲链表，极有可能发生每次需要遍历到链表的最后才能获得合适的内存空间。 我们需要用一个链表来维护，哪些空间可以分配对象，很有可能需要遍历这个链表到最后，才能发现这块空间足够我们去创建一个对象。如下图，遍历到最后才发现有足够的空间分配3个字节的对象了。如果链表很长，遍历也会花费较长的时间。</li>
</ol>
<h5 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h5><ol>
<li>准备两块空间From空间和To空间，每次在对象分配阶段，只能使用其中一块空间（From空间）。</li>
<li>在垃圾回收GC阶段，将From中存活对象复制到To空间。</li>
<li>将两块空间的From和To名字互换。下次依然在From空间上创建对象。<br>优点：</li>
</ol>
<ul>
<li>吞吐量高，复制算法只需要遍历一次存活对象复制到To空间即可，比标记-整理算法少了一次遍历的过程，因而性能较好，但是不如标记-清除算法，因为标记清除算法不需要进行对象的移动</li>
<li>不会发生碎片化，复制算法在复制之后就会将对象按顺序放入To空间中，所以对象以外的区域都是可用空间，不存在碎片化内存空间。<br>缺点：<br>内存使用效率低，每次只能让一半的内存空间来为创建对象使用。</li>
</ul>
<h5 id="标记整理算法"><a href="#标记整理算法" class="headerlink" title="标记整理算法"></a>标记整理算法</h5><p>标记整理算法也叫标记压缩算法，是对标记清理算法中容易产生内存碎片问题的一种解决方案。</p>
<p>核心思想分为两个阶段：</p>
<ol>
<li>标记阶段，将所有存活的对象进行标记。Java中使用可达性分析算法，从GC Root开始通过引用链遍历出所有存活对象。</li>
<li>整理阶段，将存活对象移动到堆的一端。清理掉存活对象的内存空间。<br>优点：</li>
</ol>
<ul>
<li>内存使用效率高，整个堆内存都可以使用，不会像复制算法只能使用半个堆内存</li>
<li>不会发生碎片化，在整理阶段可以将对象往内存的一侧进行移动，剩下的空间都是可以分配对象的有效空间<br>缺点：<br>整理阶段的效率不高，整理算法有很多种，比如Lisp2整理算法需要对整个堆中的对象搜索3次，整体性能不佳。可以通过Two-Finger、表格算法、ImmixGC等高效的整理算法优化此阶段的性能</li>
</ul>
<h5 id="分代垃圾回收算法"><a href="#分代垃圾回收算法" class="headerlink" title="分代垃圾回收算法"></a>分代垃圾回收算法</h5><p>现代优秀的垃圾回收算法，会将上述描述的垃圾回收算法组合进行使用，其中应用最广的就是分代垃圾回收算法(Generational GC)。<br>分代垃圾回收将整个内存区域划分为年轻代和老年代：<img src="/2024/06/24/02/%E5%88%92%E5%88%86.png"></p>
<ol>
<li>分代回收时，创建出来的对象，首先会被放入Eden伊甸园区。<img src="/2024/06/24/02/Eden.png"></li>
<li>随着对象在Eden区越来越多，如果Eden区满，新创建的对象已经无法放入，就会触发年轻代的GC，称为Minor GC或者Young GC。Minor GC会把需要eden中和From需要回收的对象回收，把没有回收的对象放入To区。<img src="/2024/06/24/02/MinorGC.png"></li>
<li>接下来，S0会变成To区，S1变成From区。当eden区满时再往里放入对象，依然会发生Minor GC。<img src="/2024/06/24/02/%E5%8F%98%E6%8D%A2.png"></li>
<li>如果Minor GC后对象的年龄达到阈值（最大15，默认值和垃圾回收器有关），对象就会被晋升至老年代。<img src="/2024/06/24/02/%E8%BF%AD%E4%BB%A3.png"></li>
<li>当老年代中空间不足，无法放入新的对象时，先尝试minor gc如果还是不足，就会触发Full GC，Full GC会对整个堆进行垃圾回收。如果Full GC依然无法回收掉老年代的对象，那么当对象继续放入老年代时，就会抛出Out Of Memory异常。</li>
</ol>
<p>为什么分代GC算法要把堆分成年轻代和老年代？首先我们要知道堆内存中对象的特性：</p>
<ul>
<li>系统中的大部分对象，都是创建出来之后很快就不再使用可以被回收，比如用户获取订单数据，订单数据返回给用户之后就可以释放了。</li>
<li>老年代中会存放长期存活的对象，比如Spring的大部分bean对象，在程序启动之后就不会被回收了。</li>
<li>在虚拟机的默认设置中，新生代大小要远小于老年代的大小。</li>
</ul>
<p>分代GC算法将堆分成年轻代和老年代主要原因有：</p>
<ol>
<li>可以通过调整年轻代和老年代的比例来适应不同类型的应用程序，提高内存的利用率和性能。</li>
<li>新生代和老年代使用不同的垃圾回收算法，新生代一般选择复制算法，老年代可以选择标记-清除和标记-整理算法，由程序员来选择灵活度较高。</li>
<li>分代的设计中允许只回收新生代（minor gc），如果能满足对象分配的要求就不需要对整个堆进行回收(full gc),STW时间就会减少。</li>
</ol>
<h4 id="垃圾回收器-重点"><a href="#垃圾回收器-重点" class="headerlink" title="垃圾回收器 重点"></a>垃圾回收器 重点</h4><h2 id="一些好用JVM分析工具"><a href="#一些好用JVM分析工具" class="headerlink" title="一些好用JVM分析工具"></a>一些好用JVM分析工具</h2><h3 id="Arthas-Arthas-Install-arthas-aliyun-com"><a href="#Arthas-Arthas-Install-arthas-aliyun-com" class="headerlink" title="[Arthas](Arthas Install | arthas (aliyun.com))"></a>[Arthas](<a target="_blank" rel="noopener" href="https://arthas.aliyun.com/doc/install-detail.html">Arthas Install | arthas (aliyun.com)</a>)</h3><p><img src="/2024/06/24/02/Arthas.png"><br>阿里开发的工具</p>
<h1 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h1><p><img src="/2024/06/24/02/%E5%A0%86%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.png"></p>
<ol>
<li>优先分配在Eden区，如果Eden区没有足够的空间进行分配时，虚拟机会进行一次MinorGC，而那些无需回收的存货对象会进入Survivor的From区，再不满足就进入Old区</li>
<li>大对象直接进入老年代，避免在Eden区和两个Survivor区之间发生大量的内存拷贝</li>
<li>长期存货的对象进入老年代，虚拟机为每一个对象定义一个年龄计数器，经过一次MinorCG就会进入Survivor区，此后每经历一次都会年龄+1，到达阈值，对象进入老年区。</li>
<li></li>
</ol>
<h2 id="Full-GC和Minor-GC和内存回收算法"><a href="#Full-GC和Minor-GC和内存回收算法" class="headerlink" title="Full GC和Minor GC和内存回收算法"></a>Full GC和Minor GC和内存回收算法</h2><blockquote>
<p>大多数情况下，对象在新生代中Eden区分配，当Eden区没有足够的内存进行分配时，回发起一次Minor GC。经过第一次Minor GC仍能够存货，并且能够被Survior容器容纳的话，会被移动到Survivor空间。并且将对象年龄设置为1，之后对象每熬过一次MinorGC，年龄就增加1岁，当它的年龄达到一定程度时，就会被晋级到老年代中。部分垃圾回收器会将大对象直接放入就老代。</p>
</blockquote>
<h3 id="Minor-GC-x2F-Young-GC"><a href="#Minor-GC-x2F-Young-GC" class="headerlink" title="Minor GC/ Young GC"></a>Minor GC/ Young GC</h3><p>只对新生代进行垃圾收集</p>
<h3 id="Major-GC-x2F-Old-GC"><a href="#Major-GC-x2F-Old-GC" class="headerlink" title="Major GC / Old GC"></a>Major GC / Old GC</h3><p>只对老年代进行GC，有时候也可以代指Full GC</p>
<h3 id="Full-GC"><a href="#Full-GC" class="headerlink" title="Full GC"></a>Full GC</h3><p>回收整个Java堆和方法区</p>
<h2 id="内存调优"><a href="#内存调优" class="headerlink" title="内存调优"></a>内存调优</h2><p>内存泄漏(memory leak)：Java中的如果不再使用一个对象，但是该对象依然在CG ROOT的引用链上，这个对象就不会被回收。<br>绝大数情况都是由堆内存泄露引起的<br>常见由：</p>
<ol>
<li>没有及时删除缓存数据</li>
<li>分布式任务调度系统等进行任务调度任务结束中出现了内存泄漏。</li>
</ol>
<h3 id="代码中的内存泄漏"><a href="#代码中的内存泄漏" class="headerlink" title="代码中的内存泄漏"></a>代码中的内存泄漏</h3><h4 id="equals和hashCode，不正确使用会导致泄漏"><a href="#equals和hashCode，不正确使用会导致泄漏" class="headerlink" title="equals和hashCode，不正确使用会导致泄漏"></a>equals和hashCode，不正确使用会导致泄漏</h4><ol>
<li><strong>不一致的&nbsp;<code>equals()</code>&nbsp;和&nbsp;<code>hashCode()</code>&nbsp;实现</strong>：<ul>
<li>如果两个对象根据&nbsp;<code>equals()</code>&nbsp;方法被认为是相等的，那么它们的&nbsp;<code>hashCode()</code>&nbsp;值也必须相等。如果这个规则被违反，可能会导致哈希表中的对象无法正确地被访问和删除，从而导致内存泄漏。</li>
</ul>
</li>
<li><strong>对象无法被正确移除</strong>：<ul>
<li>在使用哈希表时，如果对象的&nbsp;<code>hashCode()</code>&nbsp;值在插入后发生变化，可能会导致对象无法被正确移除，因为哈希表依赖于&nbsp;<code>hashCode()</code>&nbsp;值来定位对象。<br>在定义新类时没有重写正确的equals()和hashCode()方法。在使用HashMap的场景下，如果使用这个类对象作为key，HashMap在判断key是否已经存在时会使用这些方法，如果重写方式不正确，会导致相同的数据被保存多份。<br>正常情况：</li>
</ul>
</li>
<li>以JDK8为例，首先调用hash方法计算key的哈希值，hash方法中会使用到key的hashcode方法。根据hash方法的结果决定存放的数组中位置。</li>
<li>如果没有元素，直接放入。如果有元素，先判断key是否相等，会用到equals方法，如果key相等，直接替换value；key不相等，走链表或者红黑树查找逻辑，其中也会使用equals比对是否相同。<br>异常情况：</li>
<li>hashCode方法不对，导致相同id的学生对象计算出来的hash值不同被放在不同的槽中</li>
<li>equals方法不对，导致即使id相同，也会被认为是不同的对象<br>下列代码会重复添加这个对象，导致内存溢出，因为不是相同的对象实例</li>
</ol>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">  <span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token punctuation">{</span>
        <span class="token class-name">Integer</span> id<span class="token punctuation">;</span>
        <span class="token class-name">String</span> name<span class="token punctuation">;</span>
        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setId</span><span class="token punctuation">(</span><span class="token class-name">Integer</span> id<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>id <span class="token operator">=</span> id<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setName</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">public</span> <span class="token class-name">Integer</span> <span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> id<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> name<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>
	    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">long</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Student</span><span class="token punctuation">,</span><span class="token class-name">Long</span><span class="token punctuation">&gt;</span></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>
	        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	            <span class="token class-name">Student</span> student <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	            student<span class="token punctuation">.</span><span class="token function">setId</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	            student<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"张三"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	            map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>student<span class="token punctuation">,</span><span class="token number">1L</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	        <span class="token punctuation">}</span>
	    <span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>解决方案：</p>
<ol>
<li>在定义新实体时，始终重写equals()和hashCode()方法。</li>
<li>重写时一定要确定使用了唯一标识去区分不同的对象，比如用户的id等。</li>
<li>hashmap使用时尽量使用编号id等数据作为key，不要将整个实体类对象作为key存放。</li>
</ol>
<h4 id="ThreadLocal的使用"><a href="#ThreadLocal的使用" class="headerlink" title="ThreadLocal的使用"></a>ThreadLocal的使用</h4><p>线程池中的线程不被回收导致的ThreadLocal内存泄漏<br>如果仅仅使用手动创建的线程，就算没有调用ThreadLocal的remove方法清理数据，也不会产生内存泄漏。因为当线程被回收时，ThreadLocal也同样被回收。但是如果使用线程池就不一定了。<br>解决方案：<br>线程方法执行完，一定要调用ThreadLocal中的remove方法清理对象。</p>
<h4 id="内部类引用外部类"><a href="#内部类引用外部类" class="headerlink" title="内部类引用外部类"></a>内部类引用外部类</h4><p>非静态的内部类和匿名内部类的错误使用导致内存泄漏</p>
<ol>
<li><strong>非静态的内部类默认会持有外部类</strong> ，尽管代码上不再使用外部类，所以如果有地方引用了这个非静态内部类，会导致外部类也被引用，垃圾回收时无法回收这个外部类。</li>
<li>匿名内部类对象如果在非静态方法中被创建，会持有调用者对象，垃圾回收时无法回收调用者。</li>
</ol>
<p>解决方案：</p>
<ol>
<li>使用静态内部类从而不持有外部对象</li>
<li>使用静态方法，避免匿名内部类持有调用者对象</li>
</ol>
<h4 id="String的intern方法"><a href="#String的intern方法" class="headerlink" title="String的intern方法"></a>String的intern方法</h4><p>由于JDK6中的字符串常量池位于永久代，intern被大量调用并保存产生的内存泄漏</p>
<h4 id="通过静态字段保存对象"><a href="#通过静态字段保存对象" class="headerlink" title="通过静态字段保存对象"></a>通过静态字段保存对象</h4><p>大量的数据在静态变量中被引用，但是不再使用，成为了内存泄漏<br>问题：<br>如果大量的数据在静态变量中被长期引用，数据就不会被释放，如果这些数据不再使用，就成为了内存泄漏。</p>
<p>解决方案：<br>1、尽量减少将对象长时间的保存在静态变量中，如果不再使用，必须将对象删除（比如在集合中）或者将静态变量设置为null。<br>2、使用单例模式时，尽量使用懒加载，而不是立即加载。</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">package com.itheima.jvmoptimize.leakdemo.demo7;

import org.springframework.context.annotation.Lazy;
import org.springframework.stereotype.Component;

@Lazy //懒加载
@Component
public class TestLazy {
    private byte[] bytes = new byte[1024 * 1024 * 1024];
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="资源没有正常关闭"><a href="#资源没有正常关闭" class="headerlink" title="资源没有正常关闭"></a>资源没有正常关闭</h4><p>由于资源没有调用close方法正常关闭，导致的内存溢出<br>连接和流这些资源会占用内存，如果使用完之后没有关闭，这部分内存不一定会出现内存泄漏，但是会导致close方法不被执行。<br>解决方案：</p>
<ol>
<li>为了防止出现这类的资源对象泄漏问题，必须在finally块中关闭不再使用的资源。</li>
<li>从 Java 7 开始，使用try-with-resources语法可以用于自动关闭资源。<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">try</span> <span class="token punctuation">(</span>
    <span class="token class-name">BufferedReader</span> br <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileReader</span><span class="token punctuation">(</span><span class="token string">"file1.txt"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">BufferedReader</span> br2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileReader</span><span class="token punctuation">(</span><span class="token string">"file2.txt"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 使用资源</span>
<span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ol>
<h4 id="并发请求问题"><a href="#并发请求问题" class="headerlink" title="并发请求问题"></a>并发请求问题</h4><h2 id="GC调优"><a href="#GC调优" class="headerlink" title="GC调优"></a>GC调优</h2><p>GC调优是对垃圾回收进行调优，GC调优的主要目标是避免由垃圾回收引起程序性能下降<br>可以进行调优的内容：</p>
<ol>
<li>通用JVM参数的设置</li>
<li>特定垃圾回收器的JVM参数的设置</li>
<li>解决由频繁FULLGC引起的程序性能问题</li>
</ol>
<h3 id="调优指标："><a href="#调优指标：" class="headerlink" title="调优指标："></a>调优指标：</h3><h4 id="垃圾回收的吞吐量"><a href="#垃圾回收的吞吐量" class="headerlink" title="垃圾回收的吞吐量"></a>垃圾回收的吞吐量</h4><ul>
<li>吞吐量，一段时间内程序需要完成的业务数量。<br>保证高吞吐量的常规手段有两条：<br>1、优化业务执行性能，减少单次业务的执行时间<br>2、优化垃圾回收吞吐量</li>
</ul>
<p>垃圾回收吞吐量指的是 CPU 用于执行用户代码的时间与 CPU 总执行时间的比值，即吞吐量 = 执行用户代码时间 /（执行用户代码时间 + GC时间）。吞吐量数值越高，垃圾回收的效率就越高，允许更多的CPU时间去处理用户的业务，相应的业务吞吐量也就越高。</p>
<h4 id="延迟"><a href="#延迟" class="headerlink" title="延迟"></a>延迟</h4><p>1延迟指的是从用户发起一个请求到收到响应这其中经历的时间。比如企业中对于延迟的要求可能会是这样的：<br>所有的请求必须在5秒内返回给用户结果</p>
<p>延迟 = GC延迟 + 业务执行时间，所以如果GC时间过长，会影响到用户的使用。</p>
<h4 id="内存使用量"><a href="#内存使用量" class="headerlink" title="内存使用量"></a>内存使用量</h4><p>内存使用量指的是Java应用占用系统内存的最大值，一般通过Jvm参数调整，在满足上述两个指标的前提下，这个值越小越好。</p>
<h3 id="调优工具"><a href="#调优工具" class="headerlink" title="调优工具"></a>调优工具</h3><h4 id="jstat工具"><a href="#jstat工具" class="headerlink" title="jstat工具"></a>jstat工具</h4><p>Jstat工具是JDK自带的一款监控工具，可以提供各种垃圾回收、类加载、编译信息<br>等不同的数据。使用方法为：<code>jstat -gc 进程ID 每次统计的间隔（毫秒） 统计次数</code></p>
<p>C代表Capacity容量，U代表Used使用量<br>S – 幸存者区，E – 伊甸园区，O – 老年代，M – 元空间<br>YGC、YGT：年轻代GC次数和GC耗时（单位：秒）<br>FGC、FGCT：Full GC次数和Full GC耗时<br>GCT：GC总耗时</p>
<h4 id="Visualvm插件"><a href="#Visualvm插件" class="headerlink" title="Visualvm插件"></a>Visualvm插件</h4><h4 id="Prometheus-Grafana"><a href="#Prometheus-Grafana" class="headerlink" title="Prometheus + Grafana"></a>Prometheus + Grafana</h4><h4 id="GC日志"><a href="#GC日志" class="headerlink" title="GC日志"></a>GC日志</h4><h5 id="分析GC日志-GCViewer"><a href="#分析GC日志-GCViewer" class="headerlink" title="分析GC日志 - GCViewer"></a>分析GC日志 - GCViewer</h5><hr>
<h2 id="GraalVM"><a href="#GraalVM" class="headerlink" title="GraalVM"></a>GraalVM</h2><p>GraalVM是Oracle官方推出的一款高性能JDK，使用它享受比OpenJDK或者OracleJDK更好的性能。<br>两种模式：</p>
<ul>
<li>JIT（ Just-In-Time ）模式 ，即时编译模式，在运行时将热点代码编译为本地机器码，以提高执行效率。</li>
<li>AOT（Ahead-Of-Time）模式 ，提前编译模式</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zuofw.github.io/2024/06/17/08/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="QingQiu">
      <meta itemprop="description" content="个人网站，学习记录，面试记录和经验总结、互联网中一块属于自己的小窝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="QingQiu'Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/06/17/08/" class="post-title-link" itemprop="url">深入浅出Zookeeper</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-06-17 15:12:08" itemprop="dateCreated datePublished" datetime="2024-06-17T15:12:08+08:00">2024-06-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-09-12 20:29:55" itemprop="dateModified" datetime="2024-09-12T20:29:55+08:00">2024-09-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">分布式</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.2k</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a target="_blank" rel="noopener" href="https://javaguide.cn/distributed-system/distributed-process-coordination/zookeeper/zookeeper-plus.html">https://javaguide.cn/distributed-system/distributed-process-coordination/zookeeper/zookeeper-plus.html</a></p>
<h2 id="ZooKeeper是什么"><a href="#ZooKeeper是什么" class="headerlink" title="ZooKeeper是什么"></a>ZooKeeper是什么</h2><p>ZooKeeper是一个开源的<strong>分布式协调服务</strong>，设计目标是将哪些复杂且容易出错的分布式一致性服务封装起来，构成一个高效的原语(原语的执行必须连续且不可分割)集，并以一系列简单易用的接口提供给用户时使用</p>
<h2 id="常用场景"><a href="#常用场景" class="headerlink" title="常用场景"></a>常用场景</h2><ol>
<li>命名服务：通过ZooKeepe的顺序节点生成全局唯一ID</li>
<li>数据发布/订阅：通过Watcher机制可以很方便的实现数据发布/订阅。其他机器可以通过监听ZooKeeper上的节点变化来实现配置的动态更新</li>
<li>分布式锁：通过创建唯一节点获得分布式锁，当获得锁的乙方执行完相关的代码或者挂掉后就释放，也需要使用Watcher机制</li>
</ol>
<h2 id="一些可以使用的场景"><a href="#一些可以使用的场景" class="headerlink" title="一些可以使用的场景"></a>一些可以使用的场景</h2><h3 id="手写rpc-注册中心-使用ZooKeeper作为注册中心手写RPC"><a href="#手写rpc-注册中心-使用ZooKeeper作为注册中心手写RPC" class="headerlink" title="[[手写rpc#注册中心|使用ZooKeeper作为注册中心手写RPC]]"></a>[[手写rpc#注册中心|使用ZooKeeper作为注册中心手写RPC]]</h3><h3 id="使用ZooKeeper作为分布式锁"><a href="#使用ZooKeeper作为分布式锁" class="headerlink" title="使用ZooKeeper作为分布式锁"></a>使用ZooKeeper作为分布式锁</h3><h2 id="重要概念"><a href="#重要概念" class="headerlink" title="重要概念"></a>重要概念</h2><h3 id="Data-model"><a href="#Data-model" class="headerlink" title="Data model"></a>Data model</h3><p>ZooKeeper数据模型使用层次化的多叉树形结构，每个节点上都可以存储数据，而且数据可以是数字、字符串、二进制序列。每个节点可以有N个子节点。每个数据节点叫做znode，是数据的最小单元，每个znode都有唯一的路径标识<br><strong>znode存储的数据大小上线为1M</strong>，避免将大数据保存在ZooKeeper中</p>
<h3 id="znode"><a href="#znode" class="headerlink" title="znode"></a>znode</h3><h3 id="分类："><a href="#分类：" class="headerlink" title="分类："></a>分类：</h3><ul>
<li>持久(PERSISTENT)节点：一旦创建就存在即使ZooKeeper集群宕机，知道将其删除</li>
<li>临时(<strong>EPHEMERAL</strong>)节点：临时节点的声明周期与客户端会话绑定。会话节点小时则节点消失，临时节点只能作为叶子节点，不可创建属于自己的子节点。</li>
<li>持久顺序节点：除了具有持久节点外，子节点的名称还有顺序性。</li>
</ul>
<h3 id="znode的组成："><a href="#znode的组成：" class="headerlink" title="znode的组成："></a>znode的组成：</h3><ul>
<li>stat：状态信息<img src="/2024/06/17/08/znode%E7%8A%B6%E6%80%81%E4%BF%A1%E6%81%AF.png"></li>
<li>data：节点存放数据的具体内容</li>
</ul>
<h3 id="版本："><a href="#版本：" class="headerlink" title="版本："></a>版本：</h3><p>ZooKeeper会为每一个znode维护一个叫做Stat的数据结构<br>Stat中记录了三个znode相关的版本：</p>
<ul>
<li>dataVersion：当前znode节点的版本号</li>
<li>cversion：当前znode子节点的版本</li>
<li>aclVersion：当前znode的ACL的版本</li>
</ul>
<h3 id="ACL：权限控制"><a href="#ACL：权限控制" class="headerlink" title="ACL：权限控制"></a>ACL：权限控制</h3><ul>
<li>CREATE：创建子节点</li>
<li>READ：获取节点数据和列出其子节点</li>
<li>WRITE：设置/更新节点数据</li>
<li>DELETE：删除子节点</li>
<li>ADMIN：设置节点ACL的权限<br>身份认证有四种方式：</li>
<li>world：默认，任何用户都可以无条件访问</li>
<li>auth ： 不适用任何id，代表任何已经认证的用户</li>
<li>digest：用户名:密码的方式</li>
<li>ip：对指定ip进行限制</li>
</ul>
<h2 id="Watcher-事件监听器"><a href="#Watcher-事件监听器" class="headerlink" title="Watcher(事件监听器)"></a>Watcher(事件监听器)</h2><p>ZooKeeper允许用户在指定节点上注册一些Watcher，并且在一些特定事件触发时，ZooKeeper服务器会将事件通知到感兴趣的客户端上。<img src="/2024/06/17/08/watcher%E7%9A%84%E4%BD%9C%E7%94%A8.png"></p>
<h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><p>ZooKeeper服务端与客户端之间的一个TCP长连接。客户端可以通过它进行心跳检测与服务器保持有效的会话，也能够向ZooKeeper服务器发送请求并接受响应。同时也能接收来在服务器的Watcher事件通知</p>
<h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><h3 id="ZooKeeper将集群中节点的角色分为三类："><a href="#ZooKeeper将集群中节点的角色分为三类：" class="headerlink" title="ZooKeeper将集群中节点的角色分为三类："></a>ZooKeeper将集群中节点的角色分为三类：</h3><ul>
<li>Leader 为客户端提供读写服务，负责投票的发起和决议，更新系统状态</li>
<li>Follower：<strong>只读</strong>，将写服务转发给Leader，参与选举过程的头票</li>
<li>Observer：<strong>只读</strong>，写服务转发给Leader，不参与选举中的投票，也不参与”过半写成功”策略。 在不影响写性能的情况下提升集群的读性能。</li>
</ul>
<h3 id="Leader的选举过程"><a href="#Leader的选举过程" class="headerlink" title="Leader的选举过程"></a>Leader的选举过程</h3><p>条件：<br>当Leader服务器出现网络中断、崩溃退出与重启等异常情况是，会进去Leader选举过程。<br>流程：</p>
<ol>
<li>Leader election 选举阶段：开始投票，只要有一个节点获得过半节点的票数即可作为准Leader</li>
<li>Discovery发现阶段：followers跟准节点leader进行通信，同步followers最近接收的事务提议</li>
<li>Synchronization 同步阶段：利用leader前一阶段获得的最新提议历史，同步集群中所有的副本，同步之后，准leader成为正式节点</li>
<li>Broadcast 广播阶段：Zookeeper集群正式对外提供事务服务，leader及逆行消息广播，如果有新的节点加入，还需要进行同步<br>节点的状态：</li>
</ol>
<ul>
<li>LOOKING：寻找Leader</li>
<li>LEADING：Leader状态，对应的节点成为Leader</li>
<li>FOLLOWING：对应的节点成为Follower</li>
<li>OBSERVING：对应的节点成为OBSERVING<br>脑裂问题通过过半机制解决</li>
</ul>
<h2 id="ZAB协议"><a href="#ZAB协议" class="headerlink" title="ZAB协议"></a>ZAB协议</h2><p>ZooKeeper Atomic Broadcast，原子广播<br>###3 模式</p>
<ul>
<li>崩溃恢复：启动或者出现异常状况时，进行崩溃恢复状态，当选举出新的Leader节点，并且已经进行状态同步之后，退出恢复状态。</li>
<li>消息广播：当集群中已经完成状态通过，整个服务架构进入消息广播模式。新加入的节点会自觉进入数据恢复状态。</li>
</ul>
<h2 id="常见的Java-API"><a href="#常见的Java-API" class="headerlink" title="常见的Java API"></a>常见的Java API</h2><blockquote>
<p>curator-x-discovery是 Apache Curator 库中的一个模块，用于简化与 Apache ZooKeeper 交互时的服务发现和注册功能</p>
</blockquote>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">ServiceDiscovery</span> 用于管理服务的注册和发现
<span class="token class-name">ServiceInstance</span> 描述一个服务的信息
<span class="token class-name">CuratorFramework</span> zk连接客户端<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zuofw.github.io/2024/06/17/36/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="QingQiu">
      <meta itemprop="description" content="个人网站，学习记录，面试记录和经验总结、互联网中一块属于自己的小窝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="QingQiu'Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/06/17/36/" class="post-title-link" itemprop="url">RPC</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-06-17 10:48:36 / 修改时间：15:04:09" itemprop="dateCreated datePublished" datetime="2024-06-17T10:48:36+08:00">2024-06-17</time>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>648</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="RPC（Remote-Procedure-Call）-远程调用"><a href="#RPC（Remote-Procedure-Call）-远程调用" class="headerlink" title="RPC（Remote Procedure Call） 远程调用"></a><strong>RPC（Remote Procedure Call）</strong> 远程调用</h1><h2 id="RPC原理"><a href="#RPC原理" class="headerlink" title="RPC原理"></a>RPC原理</h2><p>可以分为五个部分实现</p>
<ol>
<li>客户端(服务消费端)： 调用方法的一端</li>
<li>客户端Stub(桩):代理类，将调用的方法、类、方法参数作为信息传递到服务端</li>
<li>网络传输: 将信息传输到服务端，并且将返回结果发挥给调用端，推荐使用Netty</li>
<li>服务端Stub: 接收信息，去执行对应的方法，将结果返回</li>
<li>服务端(服务提供端): 提供服务的一端<br>过程：</li>
<li>服务消费端client以本地调用的方式去调用远程服务</li>
<li>客户端Stub (client stud) 接收调用后将方法、参数等组装进能够进行网络传输的消息体(序列化之后) : RpcRequest</li>
<li>客户端Stub 找到远程服务的地址，将消息发送到服务提供端</li>
<li>服务端Stub 收到消息后，反序列化为RpcRequest 对象</li>
<li>服务端Stub 根据RpcRequest中的类，方法，方法参数等信息调用本地方法1</li>
<li>服务端Stub 将得到的结果封装为 RpcResponse序列化后发送给消费方</li>
<li>客户端Stub接收消息并将其反序列化为RpcReponse</li>
</ol>
<h2 id="Invoker是什么"><a href="#Invoker是什么" class="headerlink" title="Invoker是什么"></a>Invoker是什么</h2><p>Inboker 是Dubbo对远程调用的抽象<img src="/2024/06/17/36/invoker.png"></p>
<h2 id="Dubbo-的SPI机制"><a href="#Dubbo-的SPI机制" class="headerlink" title="Dubbo 的SPI机制"></a>Dubbo 的SPI机制</h2><p>SPI (Service Provider Interface)：将接口的实现放在配置文件中，在程序的执行过程中读取配置文件，通过反射加载实现类。也就是提供接口，允许第三方实现这个接口</p>
<h2 id="Dubbo-的微内核架构"><a href="#Dubbo-的微内核架构" class="headerlink" title="Dubbo 的微内核架构"></a>Dubbo 的微内核架构</h2><blockquote>
<p>微内核架构模式又名插件架构模式，是基于产品应用程序的一种自然模式。允许用户添加额外的应用到核心应用。例如IDE</p>
</blockquote>
<h2 id="Dubbo的负载均衡策略"><a href="#Dubbo的负载均衡策略" class="headerlink" title="Dubbo的负载均衡策略"></a>Dubbo的负载均衡策略</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zuofw.github.io/2024/06/16/16/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="QingQiu">
      <meta itemprop="description" content="个人网站，学习记录，面试记录和经验总结、互联网中一块属于自己的小窝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="QingQiu'Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/06/16/16/" class="post-title-link" itemprop="url">设计模式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-06-16 10:10:16" itemprop="dateCreated datePublished" datetime="2024-06-16T10:10:16+08:00">2024-06-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-08-04 22:52:17" itemprop="dateModified" datetime="2024-08-04T22:52:17+08:00">2024-08-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">设计模式</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.7k</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><p>设计模式是⼀套被反复使⽤的、多数⼈知晓的、经过分类编⽬的、代码设计经验的总结。</p>
<h2 id="设计模式的原则"><a href="#设计模式的原则" class="headerlink" title="设计模式的原则"></a>设计模式的原则</h2><ol>
<li>开闭原则：对扩展开放，对修改关闭</li>
<li>单一职责原：一个类只负责一个功能领域中的相应职责</li>
<li>里氏替换原则：所有引用基类的地方必须能透明地使用其子类对象</li>
<li>依赖倒置原则：以来月抽象，不能依赖于具体实现</li>
<li>接口隔离原则：类之间的依赖关系应该简历在最小接口上</li>
<li>合成/聚合复用原则：尽量使用合成/聚合，而不是通过继承达到复用的目的。</li>
<li>迪米特法则：一个软件实体应该尽量少的与其他实体发生相互作用</li>
</ol>
<h2 id="设计模式的分类"><a href="#设计模式的分类" class="headerlink" title="设计模式的分类"></a>设计模式的分类</h2><ul>
<li>创建型：在创建对象的同时隐藏创建逻辑，不适用new 直接实例化对象。 主要有 工厂/抽象工厂/单例/创造者/原型模式</li>
<li>结构型：通过类和接口间的继承和引用实现创建负责结构的对象。包括适配器/桥接模式/过滤器/组合/装饰器/外观/享元/代理模式</li>
<li>行为型：通过类之间不同通信方式实现不同行为，包括责任链/命名/解释器/迭代器/终结者/备忘录/观察者/状态/策略/模板/访问者模式<br><img src="/2024/06/16/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%88%86%E7%B1%BB.png"></li>
</ul>
<h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><h4 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a>简单工厂</h4><p>由一个工厂对象来创建实例，客户但不需要关注创建逻辑，只需要传递工厂参数。</p>
<h4 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h4><p>工厂方法模式将具体产品的任务分发给具体的产品工厂，也就是一个抽象工厂，定义生产接口但是不负责具体的产品。</p>
<h4 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h4><p>简单和方法只是针对一类产品。<br>抽象工厂通过在AbstactFactory中增减创建产品的接口，然后由子类工厂去实现新增产品的创建。</p>
<h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>单例模式是创建型模式，任何情况下只存在一个实例，构造方法必须是私有，由自己创建一个静态变量存储实例，对外提供一个静态公有方法获取实例。<br>优点是只能有一个实例，减少了开销。</p>
<h4 id="常见的写法"><a href="#常见的写法" class="headerlink" title="常见的写法"></a>常见的写法</h4><h5 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h5><p>类⼀加载就创建对象</p>
<p>优点：线程安全，没有加锁，执⾏效率较⾼<br>缺点：不是懒加载，类加载时就初始化，浪费内存空间</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>
 <span class="token comment">// 1、私有化构造⽅法</span>
 <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
 <span class="token comment">// 2、定义⼀个静态变量指向⾃⼰类型</span>
 <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> instance <span class="token operator">=</span> <span class="token keyword">new</span>
<span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token comment">// 3、对外提供⼀个公共的⽅法获取实例</span>
 <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	 <span class="token keyword">return</span> instance<span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h5 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h5><p>单线程模式下没问题，多线程无法保证单例<br>优点是：懒加载<br>缺点是：线程安全</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>
	 <span class="token comment">// 1、私有化构造⽅法</span>
	 <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token punctuation">}</span>
	 <span class="token comment">// 2、定义⼀个静态变量指向⾃⼰类型</span>
	 <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> instance<span class="token punctuation">;</span>
	 <span class="token comment">// 3、对外提供⼀个公共的⽅法获取实例</span>
	 <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		 <span class="token comment">// 判断为 null 的时候再创建对象</span>
		 <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			 instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		 <span class="token punctuation">}</span>
		 <span class="token keyword">return</span> instance<span class="token punctuation">;</span>
	 <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="线程安全的懒汉式"><a href="#线程安全的懒汉式" class="headerlink" title="线程安全的懒汉式"></a>线程安全的懒汉式</h4><p>使用synchronized关键字枷锁保证线程安全。可以加在方法上面，也可以添加在代码块上面。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>
	 <span class="token comment">// 1、私有化构造⽅法</span>
	 <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token punctuation">}</span>
	 <span class="token comment">// 2、定义⼀个静态变量指向⾃⼰类型</span>
	 <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> instance<span class="token punctuation">;</span>
	 <span class="token comment">// 3、对外提供⼀个公共的⽅法获取实例</span>
	 <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		 <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		 instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		 <span class="token punctuation">}</span>
		 <span class="token keyword">return</span> instance<span class="token punctuation">;</span>
	 <span class="token punctuation">}</span>
 <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><p>适配器模式将一个类的接口转化为用户期望的另一个接口，让原本两个不兼容的接口能够无缝完成对接。</p>
<p>优点：</p>
<ol>
<li>提⾼了类的复⽤；</li>
<li>组合若⼲关联对象形成对外提供统⼀服务的接⼝；</li>
<li>扩展性、灵活性好。<br>缺点：</li>
<li>过多使⽤适配模式容易造成代码功能和逻辑意义的混淆。</li>
<li>部分语⾔对继承的限制，可能⾄多只能适配⼀个适配者类，⽽且⽬标类必须是抽象类</li>
</ol>
<h4 id="类适配器"><a href="#类适配器" class="headerlink" title="类适配器"></a>类适配器</h4><p>通过类继承，继承Target接口，继承Adaptee的实现</p>
<h4 id="对象适配器"><a href="#对象适配器" class="headerlink" title="对象适配器"></a>对象适配器</h4><p>通过类对象组合实现适配</p>
<h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p>本质是一个中间件，主要目的是解耦服务的提供者和使用者，使用者通过代理间接的访问服务提供者。<br>是一种结构性模式</p>
<h4 id="动态代理和静态代理的区别"><a href="#动态代理和静态代理的区别" class="headerlink" title="动态代理和静态代理的区别"></a>动态代理和静态代理的区别</h4><p>动态代理<br>动态代理是在运行时创建代理对象的机制。代理对象可以在不修改原始对象代码的情况下，拦截对目标对象的方法调用，并在调用前后添加额外的逻辑。Java 中的动态代理主要有两种实现方式：<br>静态代理<br>静态代理是在编译时创建代理类的机制。代理类在编译时就已经存在，并且实现了与目标对象相同的接口。静态代理通过在代理类中调用目标对象的方法来实现对目标对象的代理。</p>
<ol>
<li>动态代理不需要实现接口可以直接代理实现类，并且可以不许哟啊针对每个目标类都创建一个代理类。静态代理中接口一旦要新增方法，目标对象和代理对象都需要进行修改。</li>
<li>JVM层面：静态代理在编译时就将、接口、实现类、代理类这些都变成一个个实际的class文件。 动态代理是在运行时动态生成类字节码，并且加载到JVM中。</li>
</ol>
<h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p>观察者模式是一种对象行为模式，住哟啊处理对象之间的一对多关系。当一个对象状态发生变化时，所有该对象的关注着都能收到状态变化通知进行响应的处理</p>
<p>优点：</p>
<ol>
<li>被观察者和观察者之间是抽象耦合的；</li>
<li>耦合度较低，两者之间的关联仅仅在于消息的通知</li>
<li>被观察者⽆需关⼼他的观察者；</li>
<li>⽀持⼴播通信；</li>
</ol>
<p>缺点：</p>
<ol>
<li>观察者只知道被观察对象发⽣了变化，但不知变化的过程和缘由；</li>
<li>观察者同时也可能是被观察者，消息传递的链路可能会过⻓，完成所有通知花费时间较多；</li>
<li>如果观察者和被观察者之间产⽣循环依赖，或者消息传递链路形成闭环，会导致⽆限循环；</li>
</ol>
<h4 id="你的项⽬是怎么⽤的观察者模式？"><a href="#你的项⽬是怎么⽤的观察者模式？" class="headerlink" title="你的项⽬是怎么⽤的观察者模式？"></a>你的项⽬是怎么⽤的观察者模式？</h4><blockquote>
<p>在⽀付场景下，⽤户购买⼀件商品，当⽀付成功之后三⽅会回调⾃身，在这个时候系统可能会有很多需要执⾏的逻辑（如：更新订单状态，发送邮<br>件通知，赠送礼品…），这些逻辑之间并没有强耦合，因此天然适合使⽤观察者模式去实现这些功能，当有更多的操作时，只需要添加新的观察者就能实现，完美实现了对修改关闭，对扩展开放的开闭原则。</p>
</blockquote>
<h3 id="修饰器模式"><a href="#修饰器模式" class="headerlink" title="修饰器模式"></a>修饰器模式</h3><p>修饰器模式住主要是对现有的类对象进行包裹和封装，以期在不改变类对象及其类定义的情况下为对象添加额外功能。是一种对象接口模式。</p>
<h4 id="讲讲装饰器模式的应⽤场景"><a href="#讲讲装饰器模式的应⽤场景" class="headerlink" title="讲讲装饰器模式的应⽤场景"></a>讲讲装饰器模式的应⽤场景</h4><p>如果你希望在⽆需修改代码的情况下即可使⽤对象， 且希望在运⾏时为对象新增额外的⾏为， 可以使⽤装饰模式。</p>
<p>装饰能将业务逻辑组织为层次结构， 你可为各层创建⼀个装饰， 在运⾏时<br>将各种不同逻辑组合成对象。 由于这些对象都遵循通⽤接⼝， 客户端代码能以相同的⽅式使⽤这些对象。</p>
<p>如果⽤继承来扩展对象⾏为的⽅案难以实现或者根本不可⾏， 你可以使⽤该模式。</p>
<p>许多编程语⾔使⽤ final 最终关键字来限制对某个类的进⼀步扩展。 复⽤最终类已有⾏为的唯⼀⽅法是使⽤装饰模式： ⽤封装器对其进⾏封装。</p>
<h3 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h3><p>一个请求沿着责任链进行传递，直到链上有某个处理者处理它位为止。</p>
<h4 id="讲讲责任链模式的应⽤场景"><a href="#讲讲责任链模式的应⽤场景" class="headerlink" title="讲讲责任链模式的应⽤场景"></a>讲讲责任链模式的应⽤场景</h4><p>当程序需要使⽤不同⽅式处理不同种类请求， ⽽且请求类型和顺序预</p>
<p>先未知时， 可以使⽤责任链模式。该模式能将多个处理者连接成⼀条</p>
<p>链。 接收到请求后， 它会 “询问” 每个处理者是否能够对其进⾏处理。</p>
<p>这样所有处理者都有机会来处理请求。</p>
<p>当必须按顺序执⾏多个处理者时， 可以使⽤该模式。 ⽆论你以何种顺</p>
<p>序将处理者连接成⼀条链， 所有请求都会严格按照顺序通过链上的处</p>
<p>理者</p>
<h4 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h4><p>对象行为模式，针对一组算法将每一个算法封装到具有共同解耦的独立的类中，从而是他们能够相互替换。</p>
<h2 id="Spring-使⽤了哪些设计模式？"><a href="#Spring-使⽤了哪些设计模式？" class="headerlink" title="Spring 使⽤了哪些设计模式？"></a>Spring 使⽤了哪些设计模式？</h2><p>Spring 框架中⽤到了哪些设计模式？</p>
<ul>
<li>⼯⼚设计模式 : Spring 使⽤⼯⼚模式通过BeanFactory 、 ApplicationContext 创建 bean 对象。</li>
<li>代理设计模式 : Spring AOP 功能的实现。</li>
<li>单例设计模式 : Spring 中的 Bean 默认都是单例的。</li>
<li>模板⽅法模式 : Spring 中 jdbcTemplate 、 hibernateTemplate 等以Template 结尾的对数据库操作的类，它们就使⽤到了模板模式。</li>
<li>包装器设计模式 : 我们的项⽬需要连接多个数据库，⽽且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。</li>
<li>观察者模式: Spring 事件驱动模型就是观察者模式很经典的⼀个应⽤。</li>
<li>适配器模式 :Spring AOP 的增强或通知(Advice)使⽤到了适配器模式、spring MVC 中也是⽤到了适配器模式适配 Controller 。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zuofw.github.io/2024/06/13/21/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="QingQiu">
      <meta itemprop="description" content="个人网站，学习记录，面试记录和经验总结、互联网中一块属于自己的小窝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="QingQiu'Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/06/13/21/" class="post-title-link" itemprop="url">软件工程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-06-13 21:56:21 / 修改时间：22:09:19" itemprop="dateCreated datePublished" datetime="2024-06-13T21:56:21+08:00">2024-06-13</time>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>662</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="软件工程相关"><a href="#软件工程相关" class="headerlink" title="软件工程相关"></a>软件工程相关</h2><h3 id="软件开发模型"><a href="#软件开发模型" class="headerlink" title="软件开发模型"></a>软件开发模型</h3><p>瀑布模型（Waterfall Model）、快速原型模型（Rapid Prototype Model）、V 模型（V-model）、W 模型（W-model）、敏捷开发模型等</p>
<h4 id="敏捷开发"><a href="#敏捷开发" class="headerlink" title="敏捷开发"></a>敏捷开发</h4><p><strong>敏捷开发</strong> 是一种以人为核心、迭代、循序渐进的开发方法。在敏捷开发中，软件项目的构建被切分成多个子项目，各个子项目的成果都经过测试，具备集成和可运行的特征。换言之，就是把一个大项目分为多个相互联系，但也可独立运行的小项目，并分别完成，在此过程中软件一直处于可使用状态。</p>
<h3 id="软件开发的基本策略"><a href="#软件开发的基本策略" class="headerlink" title="软件开发的基本策略"></a>软件开发的基本策略</h3><h4 id="软件复用"><a href="#软件复用" class="headerlink" title="软件复用"></a>软件复用</h4><p>构建新软件不需要从头开始，可以复用已有的轮子</p>
<h4 id="分而治之"><a href="#分而治之" class="headerlink" title="分而治之"></a>分而治之</h4><h4 id="逐步演进"><a href="#逐步演进" class="headerlink" title="逐步演进"></a>逐步演进</h4><p>不断进行迭代式增量开发<br>MVP(<strong>Minimum Viable Product</strong> 最小可行产品)</p>
<h4 id="优化折中"><a href="#优化折中" class="headerlink" title="优化折中"></a>优化折中</h4><p>不需要完全优化，用有效的投入内以最有效的方式提高现有软件的质量</p>
<h2 id="代码规范"><a href="#代码规范" class="headerlink" title="代码规范"></a>代码规范</h2><h3 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h3><ul>
<li><strong>类名需要使用大驼峰命名法</strong></li>
<li><strong>方法名、参数名、成员变量、局部变量需要使用小驼峰命名法（lowerCamelCase</strong></li>
<li><strong>测试方法名、常量、枚举名称需要使用蛇形命名法（snake_case）</strong> (各个单词之间通过下划线“_”连接，比如<code>should_get_200_status_code_when_request_is_valid</code>、<code>CLIENT_CONNECT_SERVER_FAILURE</code>)</li>
<li>项目文件夹名称使用串式命名法，在串式命名法中，各个单词之间通过连接符“-”连接，比如<code>dubbo-registry</code>。</li>
<li><strong>抽象类命名使用 Abstract</strong></li>
<li><strong>异常类命名使用 Exception 结尾。</strong></li>
<li><strong>测试类命名以它要测试的类的名称开始，以 Test 结尾。</strong></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zuofw.github.io/2024/06/07/17/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="QingQiu">
      <meta itemprop="description" content="个人网站，学习记录，面试记录和经验总结、互联网中一块属于自己的小窝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="QingQiu'Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/06/07/17/" class="post-title-link" itemprop="url">面试记录</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-06-07 16:52:17" itemprop="dateCreated datePublished" datetime="2024-06-07T16:52:17+08:00">2024-06-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-09-29 15:53:02" itemprop="dateModified" datetime="2024-09-29T15:53:02+08:00">2024-09-29</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>14k</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>DevOps</p>
<h2 id="2024-05-11-同余信科一面（二面已过，但是不要26届的）"><a href="#2024-05-11-同余信科一面（二面已过，但是不要26届的）" class="headerlink" title="2024-05-11 同余信科一面（二面已过，但是不要26届的）"></a>2024-05-11 同余信科一面（二面已过，但是不要26届的）</h2><h3 id="项目中承担的开发工作"><a href="#项目中承担的开发工作" class="headerlink" title="项目中承担的开发工作"></a>项目中承担的开发工作</h3><h3 id="写过哪些模块"><a href="#写过哪些模块" class="headerlink" title="写过哪些模块"></a>写过哪些模块</h3><h3 id="Redis集群"><a href="#Redis集群" class="headerlink" title="Redis集群"></a>Redis集群</h3><h3 id="Java的常用集合用过哪些"><a href="#Java的常用集合用过哪些" class="headerlink" title="Java的常用集合用过哪些"></a>Java的常用集合用过哪些</h3><ol>
<li><strong>ArrayList</strong>f</li>
<li>LinkedList</li>
<li>HashSet</li>
<li>TreeSet</li>
<li>HashMap</li>
</ol>
<h3 id="Stream流"><a href="#Stream流" class="headerlink" title="Stream流"></a>Stream流</h3><h3 id="HashMap的扩容机制"><a href="#HashMap的扩容机制" class="headerlink" title="HashMap的扩容机制"></a>HashMap的扩容机制</h3><ol>
<li>当超过最大长度的0.75的时候开始扩容</li>
<li>创建新的哈希表，容量为原来的两倍</li>
<li>重新哈希：遍历旧的哈希表，将每个元素重新哈希到新的哈希表中。</li>
<li>替换旧的哈希表。</li>
</ol>
<h3 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h3><ol>
<li>类加载器找到字节码文件，从这个文件中读取数据，创建一个在内存中表示的java.lang.Class对象</li>
<li>链接：<ul>
<li>验证：确保被加载的类是否满足Java虚拟机的限制，例如：字节码是否有正确的格式，符号引用是否可以正确解析等</li>
<li>准备：在住呢比阶段，Java虚拟机为类的静态变量分配内存，并且初始化默认值</li>
<li>解析：Java虚拟机将类的符号引用转化为直接引用</li>
</ul>
</li>
<li>初始化：执行类的初始化方法和静态初始化块和静态字段的初始化。</li>
</ol>
<h3 id="MySQL的存储引擎"><a href="#MySQL的存储引擎" class="headerlink" title="MySQL的存储引擎"></a>MySQL的存储引擎</h3><h4 id="InnoDB的底层数据结构，B-树和B树的区别"><a href="#InnoDB的底层数据结构，B-树和B树的区别" class="headerlink" title="InnoDB的底层数据结构，B+树和B树的区别"></a>InnoDB的底层数据结构，B+树和B树的区别</h4><p>B+树<br>区别：</p>
<ol>
<li>B+树中，所有的数据存储在叶子节点中，非叶子节点只存储关键字信息。而在B树中，关键字和数据可以存储在任何节点</li>
<li>叶子节点链接：在B+树中，所有的叶子节点都通过指针连接在一次，形成一个链表结构。B树中叶子节点之间没有链接</li>
<li>关键字重复：B+树种，非叶子节点的关键字会重复出现叶子节点，而在B树种，关键字只出现一次。<br>优点：</li>
<li>B+树的叶子节点不存数据，仅存键值，相同的页表大小的情况下，B+树可以存更多的键值，从而使得树的高度更矮，查找数据进行磁盘IO次数就会减少。数据查询效率也会更快</li>
<li>B+树索引的数据都在叶子节点，而且是按照顺序排列的，查找的时候更容易查找，效率更高</li>
</ol>
<h4 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h4><p>不可以解决幻读问题</p>
<h3 id="数据库的并发一致性问题"><a href="#数据库的并发一致性问题" class="headerlink" title="数据库的并发一致性问题"></a>数据库的并发一致性问题</h3><ol>
<li><p><strong>脏读（Dirty Read）</strong>：一个事务读取了另一个未提交事务的修改。如果那个事务回滚，那么这个读取操作就会读到错误的数据。</p>
</li>
<li><p><strong>不可重复读（Non-repeatable Read）</strong>：在同一个事务中，一个查询操作对同一行数据进行了多次读取，但由于其他事务的修改，导致多次读取的结果不一致。</p>
</li>
<li><p><strong>幻读（Phantom Read）</strong>：在同一个事务中，一个查询操作在前后两次查询中，由于其他事务的插入或删除操作，导致读取到了额外的行或者少了一些行。</p>
</li>
<li><p><strong>丢失更新（Lost Update）</strong>：两个事务同时修改同一行数据，后提交的事务会覆盖前一个事务的修改，导致前一个事务的修改丢失。</p>
</li>
</ol>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h3 id="索引在项目中的实际应用"><a href="#索引在项目中的实际应用" class="headerlink" title="索引在项目中的实际应用"></a>索引在项目中的实际应用</h3><h3 id="AOP相关"><a href="#AOP相关" class="headerlink" title="AOP相关"></a>AOP相关</h3><p>业务逻辑成功，AOP数据库插入操作失败，如何解决<br>怎么把日志写到文件里</p>
<h3 id="对于大量的数据同步，如何处理"><a href="#对于大量的数据同步，如何处理" class="headerlink" title="对于大量的数据同步，如何处理"></a>对于大量的数据同步，如何处理</h3><h4 id="怎么从Nginx的转发中获取实际的IP"><a href="#怎么从Nginx的转发中获取实际的IP" class="headerlink" title="怎么从Nginx的转发中获取实际的IP"></a>怎么从Nginx的转发中获取实际的IP</h4><p>使用proxy_set_header指令将客户端实际IP地址添加到HTTP请求中即可</p>
<pre class="line-numbers language-nginx" data-language="nginx"><code class="language-nginx"><span class="token directive"><span class="token keyword">location</span> /</span> <span class="token punctuation">{</span>
    <span class="token directive"><span class="token keyword">proxy_set_header</span> Host <span class="token variable">$host</span></span><span class="token punctuation">;</span>
    <span class="token directive"><span class="token keyword">proxy_set_header</span> X-Real-IP <span class="token variable">$remote_addr</span></span><span class="token punctuation">;</span>
    <span class="token directive"><span class="token keyword">proxy_set_header</span> X-Forwarded-For <span class="token variable">$proxy_add_x_forwarded_for</span></span><span class="token punctuation">;</span>
    <span class="token directive"><span class="token keyword">proxy_pass</span> http://backend</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
//Java
<span class="token directive"><span class="token keyword">import</span> javax.servlet.http.HttpServletRequest</span><span class="token punctuation">;</span>

@RestController
<span class="token directive"><span class="token keyword">public</span> class MyController</span> <span class="token punctuation">{</span>

    @RequestMapping("/")
    <span class="token directive"><span class="token keyword">public</span> String index(HttpServletRequest request)</span> <span class="token punctuation">{</span>
        <span class="token directive"><span class="token keyword">String</span> ipAddress = request.getHeader(<span class="token string">"X-Forwarded-For"</span>)</span><span class="token punctuation">;</span>
        <span class="token directive"><span class="token keyword">if</span> (ipAddress == null)</span> <span class="token punctuation">{</span>
            <span class="token directive"><span class="token keyword">ipAddress</span> = request.getHeader(<span class="token string">"X-Real-IP"</span>)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token directive"><span class="token keyword">return</span> <span class="token string">"Client IP: "</span> + ipAddress</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="Canal如何使用，有何好处，项目中如何使用"><a href="#Canal如何使用，有何好处，项目中如何使用" class="headerlink" title="Canal如何使用，有何好处，项目中如何使用"></a>Canal如何使用，有何好处，项目中如何使用</h3><h3 id="多线程对逻辑优化"><a href="#多线程对逻辑优化" class="headerlink" title="多线程对逻辑优化"></a>多线程对逻辑优化</h3><h4 id="使用并行Stream流来处理常用数据"><a href="#使用并行Stream流来处理常用数据" class="headerlink" title="使用并行Stream流来处理常用数据"></a>使用并行Stream流来处理常用数据</h4><h4 id="并行流的各种问题"><a href="#并行流的各种问题" class="headerlink" title="并行流的各种问题"></a>并行流的各种问题</h4><ol>
<li><p><strong>线程安全问题</strong>：并行处理数据时，需要注意线程安全问题。如果并行流修改了共享资源，可能会导致数据不一致。</p>
</li>
<li><p><strong>顺序问题</strong>：并行流在处理数据时，不能保证数据的处理顺序。</p>
</li>
<li><p><strong>开销问题</strong>：并行流虽然可以提高处理速度，但是它也会增加额外的开销，如线程切换的开销。对于小数据集，这种开销可能会使并行流的性能低于串行流。</p>
</li>
<li><p><strong>阻塞问题</strong>：如果并行流的任务中有阻塞操作，如 I/O 操作，那么并行流的性能可能会大大降低。</p>
</li>
</ol>
<h3 id="可以对自己的代码进行优化，考虑性能优化"><a href="#可以对自己的代码进行优化，考虑性能优化" class="headerlink" title="可以对自己的代码进行优化，考虑性能优化"></a>可以对自己的代码进行优化，考虑性能优化</h3><h3 id="SpringSecurity相关"><a href="#SpringSecurity相关" class="headerlink" title="SpringSecurity相关"></a>SpringSecurity相关</h3><p>SecurityContext是Spring Security中的一个重要组件，它用于存储与当前执行线程相关的安全性和身份验证信息。在任何地方，你都可以通过SecurityContextHolder来访问当前的SecurityContext。</p>
<h2 id="2024-05-18-青鹤信息一面（笔试挂"><a href="#2024-05-18-青鹤信息一面（笔试挂" class="headerlink" title="2024-05-18 青鹤信息一面（笔试挂)"></a>2024-05-18 青鹤信息一面（笔试挂)</h2><h3 id="MyBatis的延迟加载优化查询效率"><a href="#MyBatis的延迟加载优化查询效率" class="headerlink" title="MyBatis的延迟加载优化查询效率"></a>MyBatis的延迟加载优化查询效率</h3><p>当使用一对多或者多对多的关联查询时，使用延迟加载可以在不需要获取关联数据时，可以避免执行关联查询，从而提高查询效率。</p>
<h3 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h3><h3 id="MySQL的主从同步过程"><a href="#MySQL的主从同步过程" class="headerlink" title="MySQL的主从同步过程"></a>MySQL的主从同步过程</h3><p>使用binlog</p>
<ul>
<li>主从复制：<ul>
<li>master节点会不断将sql命令写入Binary Log，子节点使用I/O线程读入master节点中的Bin Log</li>
<li>字节点使用SQL线程执行Bin Log的语句</li>
</ul>
</li>
</ul>
<h3 id="主主同步如何实现，如何解决并发问题"><a href="#主主同步如何实现，如何解决并发问题" class="headerlink" title="主主同步如何实现，如何解决并发问题"></a>主主同步如何实现，如何解决并发问题</h3><h3 id="如何解决IO的负载均衡分布"><a href="#如何解决IO的负载均衡分布" class="headerlink" title="如何解决IO的负载均衡分布"></a>如何解决IO的负载均衡分布</h3><h3 id="AOP的优势"><a href="#AOP的优势" class="headerlink" title="AOP的优势"></a>AOP的优势</h3><h3 id="JDK17和JDK8的区别"><a href="#JDK17和JDK8的区别" class="headerlink" title="JDK17和JDK8的区别"></a>JDK17和JDK8的区别</h3><h2 id="2024-06-19-中和农信一面（一面挂）"><a href="#2024-06-19-中和农信一面（一面挂）" class="headerlink" title="2024-06-19 中和农信一面（一面挂）"></a>2024-06-19 中和农信一面（一面挂）</h2><h3 id="MySQL索引"><a href="#MySQL索引" class="headerlink" title="MySQL索引"></a>MySQL索引</h3><h4 id="索引失效的场景（重点）"><a href="#索引失效的场景（重点）" class="headerlink" title="索引失效的场景（重点）"></a>索引失效的场景（重点）</h4><ol>
<li>LiIKE操作符以通配符开头例如 “%xx”或 “%xx%” ，但是 “xx%” 可以使用索引。</li>
<li>对索引使用函数或者表达式操作 <code>select * from t_user where length(name)=6 </code></li>
<li>对索引隐式转换，如果查询条件中的类型和列的类型不匹配，MySQL可能会进行类型转换，索引就会失效</li>
<li>联合索引非最左匹配，多个普通字段组合在一起创建的索引叫做联合索引，不遵循最左优先的方式就会失效。</li>
<li>where子句中使用了OR，如果OR后的条件不是索引列就会失效</li>
<li>出现NULL值：如果列中包含NULL值，那么使用IS NULL或IS NOT NULL 查询时索引可能会失效。</li>
</ol>
<h4 id="Text对于字段类型索引会失效吗"><a href="#Text对于字段类型索引会失效吗" class="headerlink" title="Text对于字段类型索引会失效吗"></a>Text对于字段类型索引会失效吗</h4><p><code>TEXT</code>类型的字段是可以被索引的，但是由于<code>TEXT</code>类型的长度可能非常大，所以必须指定前缀长度。这是因为MySQL的B-Tree索引只能存储固定长度的值。如果不指定前缀长度，MySQL会报错。</p>
<h4 id="MySQL如何使用索引的"><a href="#MySQL如何使用索引的" class="headerlink" title="MySQL如何使用索引的"></a>MySQL如何使用索引的</h4><h3 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h3><h4 id="Java中的类什么时候会加载到内存中"><a href="#Java中的类什么时候会加载到内存中" class="headerlink" title="Java中的类什么时候会加载到内存中"></a>Java中的类什么时候会加载到内存中</h4><ol>
<li>实例化的时候：new </li>
<li>访问静态对象时，</li>
<li>子类加载时会把父类也加载进内存</li>
<li>通过反射API时，使用反射时会把对应的类加载到内存中。</li>
</ol>
<h4 id="Hash冲突-amp-HashMap如何解决Hash冲突的，HashMap插入数据的过程"><a href="#Hash冲突-amp-HashMap如何解决Hash冲突的，HashMap插入数据的过程" class="headerlink" title="Hash冲突 &amp; HashMap如何解决Hash冲突的，HashMap插入数据的过程"></a>Hash冲突 &amp; HashMap如何解决Hash冲突的，HashMap插入数据的过程</h4><p>HashMap使用链地址法解决哈希冲突的。HashMap使用数组加链表的方式，数组中的位置可以看作一个桶，每个桶实际就是一个链表或者红黑树。<br>当桶中的数据超过一定的阈值时，默认为8，会转为红黑树。<br>插入过程：</p>
<ol>
<li>计算哈希值，使用键的hashCode()</li>
<li>确定桶的位置，使用哈希值的一部分来确认键值对应该存储在哪个桶中。一般用哈希值的地位来选择桶</li>
<li>检查冲突：<ul>
<li>没有冲突就直接建一个新的节点</li>
<li>有冲突就判断键值是否相同，使用的是equals方法，相等就覆盖，不相等就添加一个新的节点存储键值对</li>
</ul>
</li>
<li>如果HashMap的大小超过了数组长度的0.75就会进行扩容，扩容之后是原来的两倍</li>
</ol>
<h4 id="ThreadLocal的实现原理"><a href="#ThreadLocal的实现原理" class="headerlink" title="ThreadLocal的实现原理"></a>ThreadLocal的实现原理</h4><ol>
<li>每个Thread对象内部有一个ThreadLocalMap对象，然后它的键是ThreadLocal，值是我们像存储的值</li>
<li>ThreadLocal的get实际上使用了ThreadLocalMap来获取值的</li>
</ol>
<h3 id="并发问题"><a href="#并发问题" class="headerlink" title="并发问题"></a>并发问题</h3><h4 id="栅栏-Barrier"><a href="#栅栏-Barrier" class="headerlink" title="栅栏 Barrier"></a>栅栏 Barrier</h4><p>Barrier是一种同步机制，它可以让一组线程在所有线程到达某个点之后再一起继续执行。CountDownLatch就是栅栏的实现。</p>
<h2 id="2024-06-25-江苏运联笔试（已过"><a href="#2024-06-25-江苏运联笔试（已过" class="headerlink" title="2024-06-25 江苏运联笔试（已过)"></a>2024-06-25 江苏运联笔试（已过)</h2><h3 id="如何捕捉一个IO异常，简单说明NULLPoniterException的理解"><a href="#如何捕捉一个IO异常，简单说明NULLPoniterException的理解" class="headerlink" title="如何捕捉一个IO异常，简单说明NULLPoniterException的理解"></a>如何捕捉一个IO异常，简单说明NULLPoniterException的理解</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">try</span> <span class="token punctuation">{</span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span> <span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>

<span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>NullPointerException是程序尝试使用一个需要对象引用的擦欧总，但是这个对象引用却是null，就会抛出这个异常。</p>
<h3 id="代码运行题目"><a href="#代码运行题目" class="headerlink" title="代码运行题目"></a>代码运行题目</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RunningMan</span><span class="token punctuation">{</span>
	<span class="token keyword">public</span> <span class="token class-name">RunningMan</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>“<span class="token class-name">Hi</span><span class="token punctuation">,</span>man<span class="token operator">!</span> <span class="token class-name">Just</span> run<span class="token operator">!</span>”<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">9</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span> <span class="token punctuation">(</span>i<span class="token operator">--</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token punctuation">)</span><span class="token operator">&gt;</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="SQL题目"><a href="#SQL题目" class="headerlink" title="SQL题目"></a>SQL题目</h3><p>建表，多表联合，更新数据，排序，分组</p>
<h3 id="算法题"><a href="#算法题" class="headerlink" title="算法题"></a>算法题</h3><h3 id="MyBatis的主要组成部分，以及需要配置的东西"><a href="#MyBatis的主要组成部分，以及需要配置的东西" class="headerlink" title="MyBatis的主要组成部分，以及需要配置的东西"></a>MyBatis的主要组成部分，以及需要配置的东西</h3><h2 id="2024-06-28-江苏运联一面-已过"><a href="#2024-06-28-江苏运联一面-已过" class="headerlink" title="2024-06-28 江苏运联一面(已过)"></a>2024-06-28 江苏运联一面(已过)</h2><h3 id="项目提问："><a href="#项目提问：" class="headerlink" title="项目提问："></a>项目提问：</h3><p>哪个项目对你提升最大</p>
<h3 id="jdk17新特性-（不会"><a href="#jdk17新特性-（不会" class="headerlink" title="jdk17新特性 （不会)"></a>jdk17新特性 （不会)</h3><p>模式匹配for instanceof、记录</p>
<h4 id="模式匹配的增强"><a href="#模式匹配的增强" class="headerlink" title="模式匹配的增强"></a>模式匹配的增强</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token number">17</span>之前
<span class="token keyword">if</span> <span class="token punctuation">(</span>obj <span class="token keyword">instanceof</span> <span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">String</span> s <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">)</span> obj<span class="token punctuation">;</span>
    <span class="token comment">// 使用s</span>
<span class="token punctuation">}</span>
<span class="token number">17</span>中
<span class="token keyword">if</span> <span class="token punctuation">(</span>obj <span class="token keyword">instanceof</span> <span class="token class-name">String</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 直接使用s</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="密封类"><a href="#密封类" class="headerlink" title="密封类"></a>密封类</h4><p>可以指定哪些类或者接口可以继承或实现它</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">Shape</span> <span class="token keyword">permits</span> <span class="token class-name">Circle</span><span class="token punctuation">,</span> <span class="token class-name">Rectangle</span> <span class="token punctuation">{</span>
    <span class="token comment">// 类定义</span>
<span class="token punctuation">}</span>

<span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Circle</span> <span class="token keyword">extends</span> <span class="token class-name">Shape</span> <span class="token punctuation">{</span>
    <span class="token comment">// 类定义</span>
<span class="token punctuation">}</span>

<span class="token keyword">non-sealed</span> <span class="token keyword">class</span> <span class="token class-name">Rectangle</span> <span class="token keyword">extends</span> <span class="token class-name">Shape</span> <span class="token punctuation">{</span>
    <span class="token comment">// 类定义</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="强化的空指针异常信息"><a href="#强化的空指针异常信息" class="headerlink" title="强化的空指针异常信息"></a>强化的空指针异常信息</h4><p>从JDK 17开始，异常信息会明确指出是哪个变量或哪个表达式的结果为<code>null</code>，大大减少了调试时间。</p>
<h3 id="jdk8-新特性"><a href="#jdk8-新特性" class="headerlink" title="jdk8 新特性"></a>jdk8 新特性</h3><p>Lambda，Stream，新的日期API、Optional类</p>
<h4 id="Stream流相关"><a href="#Stream流相关" class="headerlink" title="Stream流相关"></a>Stream流相关</h4><p>Lambda表达式是Java 8引入的一个重要特性，它提供了一种简洁的方式来表示匿名方法。这种表达式基于数学中的λ演算（一种用于描述函数的系统），在Java中主要用于实现函数式编程的概念。<br>分组：collect里面使用Collectors.groupingBy方法进行分组</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Person</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> peopleByAge <span class="token operator">=</span> people<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token class-name">Collectors</span><span class="token punctuation">.</span><span class="token function">groupingBy</span><span class="token punctuation">(</span><span class="token class-name">Person</span><span class="token operator">::</span><span class="token function">getAge</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>过滤：filter和 limit和distinct和skip</p>
<h4 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h4><p>有什么好处，使用lambda表达式<br>::new 是方法引用的一种，用于引用构造函数<br>可以搭配函数式接口来更加简洁的创建一个类</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Supplier</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Person</span><span class="token punctuation">&gt;</span></span> personSupplier <span class="token operator">=</span> <span class="token class-name">Person</span><span class="token operator">::</span><span class="token keyword">new</span><span class="token punctuation">;</span>
<span class="token class-name">Person</span> person <span class="token operator">=</span> personSupplier<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 调用Person的无参数构造函数</span>
<span class="token class-name">Function</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Person</span><span class="token punctuation">&gt;</span></span> personFunction <span class="token operator">=</span> <span class="token class-name">Person</span><span class="token operator">::</span><span class="token keyword">new</span><span class="token punctuation">;</span>
<span class="token class-name">Person</span> person <span class="token operator">=</span> personFunction<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token string">"Alice"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 调用Person的带有一个String参数的构造函数</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="有什么用"><a href="#有什么用" class="headerlink" title="::有什么用"></a>::有什么用</h4><ol>
<li>引用静态方法，例如Integer::parseInt</li>
<li>引用实例方法：<code>String s = "hello";</code>，则<code>s::toUpperCase</code></li>
<li>引用特定类型的任意对象的实例方法：String::toLowerCase</li>
<li>引用构造函数：ArrayList::new</li>
</ol>
<h3 id="SpringCloud-Alibaba"><a href="#SpringCloud-Alibaba" class="headerlink" title="SpringCloud Alibaba"></a>SpringCloud Alibaba</h3><h4 id="哪些组件"><a href="#哪些组件" class="headerlink" title="哪些组件"></a>哪些组件</h4><p>Nacos、Sentinel、Dubbo、RocketMQ、Seata、Gateway</p>
<h3 id="Nacos的作用"><a href="#Nacos的作用" class="headerlink" title="Nacos的作用"></a>Nacos的作用</h3><h4 id="Nacos如何区分不同的配置"><a href="#Nacos如何区分不同的配置" class="headerlink" title="Nacos如何区分不同的配置"></a>Nacos如何区分不同的配置</h4><ol>
<li><strong>Data ID</strong>：配置ID，通常用于唯一标识一个配置内容。</li>
<li><strong>Group</strong>：分组，Nacos允许用户通过分组来对配置进行分类，一个Group中可以有多个Data ID。</li>
<li><strong>Namespace</strong>：命名空间，用于进一步隔离配置。一个命名空间下可以有多个Group，一个Group下可以有多个Data ID。命名空间通常用于区分不同的开发环境，如开发环境、测试环境和生产环境。</li>
</ol>
<h4 id="命名空间重复了会怎么用"><a href="#命名空间重复了会怎么用" class="headerlink" title="命名空间重复了会怎么用"></a>命名空间重复了会怎么用</h4><p>命名空间是通过唯一的Namespace ID来标识的，而不是仅仅通过名称。即使两个命名空间的名称相同，它们的Namespace ID也是不同的，因此Nacos仍然能够区分它们。<br>如果服务分发后服务断开了会怎么办</p>
<h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><h4 id="Redisson"><a href="#Redisson" class="headerlink" title="Redisson"></a>Redisson</h4><p>Redisson会无限延长一个键的过期时间吗，可以设置超时时间</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">lock<span class="token punctuation">.</span><span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">60</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">SECONDS</span><span class="token punctuation">)</span> 尝试<span class="token number">10</span>s内获得锁，锁的最大生存时间是<span class="token number">60</span>s
lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>进行看门狗
这两步操作实际上是获得了两个锁，不能做到对同一个锁进行看门狗和到达一定时间就放弃这个锁
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h3 id="Java基础-JUC"><a href="#Java基础-JUC" class="headerlink" title="Java基础 JUC***"></a>Java基础 JUC***</h3><p><strong>AtomicInteger</strong>：并发场景下使用，它提供了一种在多线程环境中安全地操作单个整数的方式，而无需使用<code>synchronized</code>关键字。这是通过使用底层的非阻塞算法实现的，通常是利用CPU的原子指令。<code>AtomicInteger</code>支持原子操作，这意味着每个操作都是不可分割的，保证了在并发环境中的线程安全。</p>
<h4 id="八大数据类型和延展性"><a href="#八大数据类型和延展性" class="headerlink" title="八大数据类型和延展性"></a>八大数据类型和延展性</h4><h3 id="MyBatis如何在查询的时候就进行组装"><a href="#MyBatis如何在查询的时候就进行组装" class="headerlink" title="MyBatis如何在查询的时候就进行组装"></a>MyBatis如何在查询的时候就进行组装</h3><ol>
<li>使用resultMap进行结果映射<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>resultMap</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>genderResultMap<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>YourModelClass<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>gender<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>gender_column<span class="token punctuation">"</span></span> <span class="token attr-name">javaType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>java.lang.String<span class="token punctuation">"</span></span> <span class="token attr-name">jdbcType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>INTEGER<span class="token punctuation">"</span></span> <span class="token attr-name">typeHandler</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>GenderTypeHandler<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
    <span class="token comment">&lt;!-- 其他字段映射 --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>resultMap</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>ibatis<span class="token punctuation">.</span>type<span class="token punctuation">.</span></span><span class="token class-name">JdbcType</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>ibatis<span class="token punctuation">.</span>type<span class="token punctuation">.</span></span><span class="token class-name">TypeHandler</span></span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GenderTypeHandler</span> <span class="token keyword">implements</span> <span class="token class-name">TypeHandler</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setParameter</span><span class="token punctuation">(</span><span class="token class-name">PreparedStatement</span> ps<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token class-name">String</span> parameter<span class="token punctuation">,</span> <span class="token class-name">JdbcType</span> jdbcType<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">SQLException</span> <span class="token punctuation">{</span>
        <span class="token comment">// 设置参数时的逻辑（如果需要）</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getResult</span><span class="token punctuation">(</span><span class="token class-name">ResultSet</span> rs<span class="token punctuation">,</span> <span class="token class-name">String</span> columnName<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">SQLException</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> gender <span class="token operator">=</span> rs<span class="token punctuation">.</span><span class="token function">getInt</span><span class="token punctuation">(</span>columnName<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> gender <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">?</span> <span class="token string">"男"</span> <span class="token operator">:</span> <span class="token string">"女"</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getResult</span><span class="token punctuation">(</span><span class="token class-name">ResultSet</span> rs<span class="token punctuation">,</span> <span class="token keyword">int</span> columnIndex<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">SQLException</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> gender <span class="token operator">=</span> rs<span class="token punctuation">.</span><span class="token function">getInt</span><span class="token punctuation">(</span>columnIndex<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> gender <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">?</span> <span class="token string">"男"</span> <span class="token operator">:</span> <span class="token string">"女"</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getResult</span><span class="token punctuation">(</span><span class="token class-name">CallableStatement</span> cs<span class="token punctuation">,</span> <span class="token keyword">int</span> columnIndex<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">SQLException</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> gender <span class="token operator">=</span> cs<span class="token punctuation">.</span><span class="token function">getInt</span><span class="token punctuation">(</span>columnIndex<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> gender <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">?</span> <span class="token string">"男"</span> <span class="token operator">:</span> <span class="token string">"女"</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
最后在配置文件中进行注册<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>typeHandlers</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>typeHandler</span> <span class="token attr-name">handler</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.yourpackage.GenderTypeHandler<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>typeHandlers</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li>
</ol>
<h2 id="2024-06-28-深圳同行者科技一面（一面挂）"><a href="#2024-06-28-深圳同行者科技一面（一面挂）" class="headerlink" title="2024-06-28 深圳同行者科技一面（一面挂）"></a>2024-06-28 深圳同行者科技一面（一面挂）</h2><h3 id="拷打笔试题-x2F-算法题"><a href="#拷打笔试题-x2F-算法题" class="headerlink" title="拷打笔试题/算法题"></a>拷打笔试题/算法题</h3><h4 id="1000w个数据中只有两个相同的数据，如何找出来"><a href="#1000w个数据中只有两个相同的数据，如何找出来" class="headerlink" title="1000w个数据中只有两个相同的数据，如何找出来"></a>1000w个数据中只有两个相同的数据，如何找出来</h4><p>使用HashSet</p>
<h3 id="解释一下签到模块中的接口幂等性"><a href="#解释一下签到模块中的接口幂等性" class="headerlink" title="解释一下签到模块中的接口幂等性"></a>解释一下签到模块中的接口幂等性</h3><h3 id="解释一下如何保证的Redis的高可用性"><a href="#解释一下如何保证的Redis的高可用性" class="headerlink" title="解释一下如何保证的Redis的高可用性"></a>解释一下如何保证的Redis的高可用性</h3><h3 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h3><h4 id="分布式架构要注意哪些问题"><a href="#分布式架构要注意哪些问题" class="headerlink" title="分布式架构要注意哪些问题"></a>分布式架构要注意哪些问题</h4><ol>
<li>数据一致性：要保证集群中的数据是一致的</li>
<li>网络分区容忍性：出现了网络分区，根据CAP定理，出现网络分区时需要在业务需求的一致性和可用性之间做出均衡</li>
<li>服务发现：当服务出现增加减少或者移动，客户端需要找到这些服务，可以使用Nacos解决</li>
<li>负载均衡：合理分配请求或任务到多个服务节点，来优化资源利用率和响应时间</li>
<li>容错和故障转移：单点故障会导致整个系统不可用</li>
<li>事务管理：分布式系统中管理跨多个服务的事务，保证操作的原子性和一致性</li>
<li>安全性：分布式系统中勉励多种安全威胁，数据泄露，服务拒绝攻击</li>
<li>性能监控和调优：<br>CAP原理<br><strong>一致性（Consistency）</strong><br><strong>可用性（Availability</strong>）<br><strong>分区容忍性（Partition tolerance</strong>）<br>当出现网络分区P时，CA只能保证一个</li>
</ol>
<h3 id="项目中遇见的比较棘手的问题，如何解决的"><a href="#项目中遇见的比较棘手的问题，如何解决的" class="headerlink" title="项目中遇见的比较棘手的问题，如何解决的"></a>项目中遇见的比较棘手的问题，如何解决的</h3><h3 id="数据库中的脏数据如何处理"><a href="#数据库中的脏数据如何处理" class="headerlink" title="数据库中的脏数据如何处理"></a>数据库中的脏数据如何处理</h3><h2 id="2024-07-02-江苏运联二面-等结果，自我感觉还可以"><a href="#2024-07-02-江苏运联二面-等结果，自我感觉还可以" class="headerlink" title="2024-07-02 江苏运联二面(等结果，自我感觉还可以)"></a>2024-07-02 江苏运联二面(等结果，自我感觉还可以)</h2><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>主动把自己的亮点项目介绍出来，在自我介绍环节就努力介绍。把自己的优点（英语、六级、博客、项目开发、github、想给开源项目做贡献）</p>
<h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><ol>
<li>自我介绍</li>
<li>承担的责任、前后端都参与开发，主要框架搭建，周期</li>
<li>介绍项目（要主动介绍自己的特点和亮点）</li>
<li>框架搭建使用了哪些技术栈</li>
<li>签到相关</li>
<li>需求怎么来的</li>
<li>有课否？学分能修满否？大三下学期有可否？大四要干嘛？</li>
<li>英语如何</li>
<li>怎么提升阅读</li>
<li>期望薪资</li>
<li>最快到岗</li>
<li></li>
</ol>
<h3 id="HashMap和HashTable什么区别"><a href="#HashMap和HashTable什么区别" class="headerlink" title="HashMap和HashTable什么区别"></a>HashMap和HashTable什么区别</h3><ol>
<li>线程安全：<ul>
<li><strong>HashTable</strong> 线程更安全,他的每个方法都是同步的，可以用在多线程中，不建议使用，建议使用ConcurrentHashMap</li>
</ul>
</li>
<li>性能：HashMap性能更好，因为不需要进行同步</li>
<li>空值：HashTable不允许key/value为null，而HashMap允许一条记录的key为null，允许多个记录的value为null</li>
<li>继承的跟类不同：<ul>
<li><code>HashTable</code>&nbsp;继承自&nbsp;<code>Dictionary</code>&nbsp;类。</li>
<li><code>HashMap</code>&nbsp;继承自&nbsp;<code>AbstractMap</code>&nbsp;类并实现了&nbsp;<code>Map</code>&nbsp;接口。</li>
</ul>
</li>
<li>迭代器<ul>
<li><code>HashTable</code>&nbsp;使用&nbsp;<code>Enumerator</code>&nbsp;进行迭代。</li>
<li><code>HashMap</code>&nbsp;使用&nbsp;<code>Iterator</code>&nbsp;进行迭代。<code>Iterator</code>&nbsp;是fail-fast迭代器，如果在迭代过程中有其他线程修改了&nbsp;<code>HashMap</code>，则会抛出&nbsp;<code>ConcurrentModificationException</code>。</li>
</ul>
</li>
<li><strong>内部结构</strong>（Java 8 及以后）：<ul>
<li><code>HashMap</code>&nbsp;在解决哈希冲突时，当链表长度大于阈值（默认为8）时，链表转换为红黑树，以提高搜索效率。</li>
<li><code>HashTable</code>&nbsp;不具备这种链表到红黑树的转换机制。</li>
</ul>
</li>
</ol>
<h3 id="ConcurrentHashMap相关"><a href="#ConcurrentHashMap相关" class="headerlink" title="ConcurrentHashMap相关"></a>ConcurrentHashMap相关</h3><h3 id="MySQL索引-1"><a href="#MySQL索引-1" class="headerlink" title="MySQL索引"></a>MySQL索引</h3><h3 id="索引有什么用"><a href="#索引有什么用" class="headerlink" title="索引有什么用"></a>索引有什么用</h3><h4 id="索引失效场景"><a href="#索引失效场景" class="headerlink" title="索引失效场景"></a>索引失效场景</h4><p>建议搭配自己项目中的场景介绍</p>
<h3 id="工作流"><a href="#工作流" class="headerlink" title="工作流"></a>工作流</h3><h3 id="摄像头识别分析数据类的场景了解过没"><a href="#摄像头识别分析数据类的场景了解过没" class="headerlink" title="摄像头识别分析数据类的场景了解过没"></a>摄像头识别分析数据类的场景了解过没</h3><h2 id="2024-07-03-神州灵云一面-已过，已发ofifer"><a href="#2024-07-03-神州灵云一面-已过，已发ofifer" class="headerlink" title="2024-07-03 神州灵云一面(已过，已发ofifer)"></a>2024-07-03 神州灵云一面(已过，已发ofifer)</h2><h3 id="流程-1"><a href="#流程-1" class="headerlink" title="流程"></a>流程</h3><ol>
<li>自我介绍</li>
<li>介绍工作室</li>
<li>项目上线了or实验室项目</li>
<li>已经学完的课程</li>
<li>关于笔试题的提问：<ul>
<li>解题的关键点是什么</li>
<li>或运算和＋运算有什么区别，这个题目中两种运算有什么区别</li>
<li>整型转字符串</li>
</ul>
</li>
<li>一周几天/时间/最快到岗</li>
<li>项目代码/几人开发 </li>
<li>反问:<ul>
<li>多久出面试结果 答：技术面，还有二面</li>
<li>面的怎么样，有什么建议，答：面的还可以</li>
<li>职位的职责， 答：文档，简单开发，对网络要求较高。</li>
</ul>
</li>
</ol>
<h3 id="TCP握手过程-忘了。。。"><a href="#TCP握手过程-忘了。。。" class="headerlink" title="TCP握手过程(忘了。。。)"></a>TCP握手过程(忘了。。。)</h3><ol>
<li>客户端发送带有同步序列编号(SYN)报文到服务器，然后客户端进入SYN-SENT的状态</li>
<li>服务器收到带有SYN的报文之后，如果统一建立连接，就会发送一个SYN-ACK报文作文响应，这个报文包含服务器自己的初始序列号，同时对客户端的SYN报文进行确认</li>
<li>客户端收到服务器的STN-ACK报文之后会发送一个ACK报文作为响应，之后客户端进入ESTABLISHED状态，之后服务器接收到之后也进入连接状态。</li>
</ol>
<h3 id="JWT是什么，JWT就是Token的一种格式"><a href="#JWT是什么，JWT就是Token的一种格式" class="headerlink" title="JWT是什么，JWT就是Token的一种格式"></a>JWT是什么，JWT就是Token的一种格式</h3><h3 id="MongoDB基础提问（不会-还有ES的命令"><a href="#MongoDB基础提问（不会-还有ES的命令" class="headerlink" title="MongoDB基础提问（不会)还有ES的命令"></a>MongoDB基础提问（不会)还有ES的命令</h3><p>背背主要的查询语句去</p>
<h3 id="权限管理的设计"><a href="#权限管理的设计" class="headerlink" title="权限管理的设计"></a>权限管理的设计</h3><h4 id="RBAC-（Role-Based-Access-Control）基于角色的访问控制"><a href="#RBAC-（Role-Based-Access-Control）基于角色的访问控制" class="headerlink" title="RBAC （Role-Based Access Control）基于角色的访问控制"></a>RBAC （<strong>Role-Based Access Control</strong>）基于角色的访问控制</h4><p><img src="/2024/06/07/17/RABC.png"><br>将权限赋予角色，然后将角色赋予用户，这样的设计就可以很方柏霓的更改角色内所有用户的权限，也方便将用户的权限变更</p>
<h4 id="ABAC-Attribute-Based-Access-Control-基于属性的访问控制"><a href="#ABAC-Attribute-Based-Access-Control-基于属性的访问控制" class="headerlink" title="ABAC (**Attribute-Based Access Control ) 基于属性的访问控制"></a>ABAC (**Attribute-Based Access Control ) 基于属性的访问控制</h4><p>通过各种属性来动态判断一个操作是否可以被允许。<br>比如赋予某个人可以查看某个文档的权限，但是不可以修改。<br>是基于对象、资源、操作、环境（上下文，时间和位置，协议等），具体的实现</p>
<h4 id="新权限系统"><a href="#新权限系统" class="headerlink" title="新权限系统"></a>新权限系统</h4><p><img src="/2024/06/07/17/%E6%96%B0%E6%9D%83%E9%99%90.png"><br>主要就是在RBAC的基础上，允许绕过角色来直接给用户添加一些权限</p>
<h3 id="集群怎么设计的，有什么用，如何应对脑裂"><a href="#集群怎么设计的，有什么用，如何应对脑裂" class="headerlink" title="集群怎么设计的，有什么用，如何应对脑裂"></a>集群怎么设计的，有什么用，如何应对脑裂</h3><h3 id="如何中止SQL语句"><a href="#如何中止SQL语句" class="headerlink" title="如何中止SQL语句"></a>如何中止SQL语句</h3><p>场景：有一个访问需要查询一个很大的数据库，然后前端那边等不及了刷新，就会不断发送这个请求，我数据库该如何处理这些无效的查询？</p>
<h2 id="2024-08-28-北京用友一面"><a href="#2024-08-28-北京用友一面" class="headerlink" title="2024-08-28 北京用友一面"></a>2024-08-28 北京用友一面</h2><p>自我介绍</p>
<h3 id="介绍旁路缓存，旁路缓存一定能保证一致性吗"><a href="#介绍旁路缓存，旁路缓存一定能保证一致性吗" class="headerlink" title="介绍旁路缓存，旁路缓存一定能保证一致性吗"></a>介绍旁路缓存，旁路缓存一定能保证一致性吗</h3><p>旁路缓存是由应用程序来保证缓存和数据库的一致性，特点是直接更新数据库，删除缓存。<br>可以保证一致性，因为缓存写入的速度是远远快于数据库的写入的。</p>
<h3 id="为什么使用Redisson而不是使用synchronized"><a href="#为什么使用Redisson而不是使用synchronized" class="headerlink" title="为什么使用Redisson而不是使用synchronized"></a>为什么使用Redisson而不是使用synchronized</h3><ol>
<li>分布式锁，Synchronized只能在单个JVM内部工作</li>
<li>可重入性，Redisson提供了可重入性锁的实现，而Synchronized需要手动管理可重入性</li>
<li>锁超时，Redisson支持超时释放防止死锁发生</li>
</ol>
<h3 id="HashMap、ConcurrentHashMap-jdk1-7的区别"><a href="#HashMap、ConcurrentHashMap-jdk1-7的区别" class="headerlink" title="HashMap、ConcurrentHashMap jdk1.7的区别"></a>HashMap、ConcurrentHashMap jdk1.7的区别</h3><h3 id="Sentinel-相关"><a href="#Sentinel-相关" class="headerlink" title="Sentinel 相关"></a>Sentinel 相关</h3><h3 id="建立索引有哪些考量"><a href="#建立索引有哪些考量" class="headerlink" title="建立索引有哪些考量"></a>建立索引有哪些考量</h3><h3 id="索引失效场景-1"><a href="#索引失效场景-1" class="headerlink" title="索引失效场景"></a>索引失效场景</h3><ol>
<li>查询条件不符合索引列的顺序</li>
<li>使用函数或表达式</li>
<li>隐式类型转换</li>
<li>不等于操作</li>
<li>范围查询</li>
</ol>
<h3 id="ES和MySQL区别"><a href="#ES和MySQL区别" class="headerlink" title="ES和MySQL区别"></a>ES和MySQL区别</h3><h3 id="Redis常见数据结构，string底层"><a href="#Redis常见数据结构，string底层" class="headerlink" title="Redis常见数据结构，string底层"></a>Redis常见数据结构，string底层</h3><h3 id="JVM内存泄漏如何定位、排查"><a href="#JVM内存泄漏如何定位、排查" class="headerlink" title="JVM内存泄漏如何定位、排查"></a>JVM内存泄漏如何定位、排查</h3><h3 id="docker常见指令"><a href="#docker常见指令" class="headerlink" title="docker常见指令"></a>docker常见指令</h3><h3 id="并行Stream流的底层"><a href="#并行Stream流的底层" class="headerlink" title="并行Stream流的底层"></a>并行Stream流的底层</h3><h2 id="ks测开一面-2024-09-04"><a href="#ks测开一面-2024-09-04" class="headerlink" title="ks测开一面 2024.09.04"></a>ks测开一面 2024.09.04</h2><p>自我介绍<br>实习负责的业务<br> 面向对象的三大特性，分别介绍什么场景下使用<br> 重载</p>
<blockquote>
<p>多态（Polymorphism）是面向对象编程（OOP）中的一个核心概念，它允许对象以多种形式出现。多态性使得相同的操作可以作用于不同的对象，并且这些对象可以根据具体的实现表现出不同的行为。多态性主要通过继承和接口实现。</p>
<ol>
<li><strong>编译时多态（静态多态）</strong>：<br> 通过方法重载（Method Overloading）实现。同一个类中可以有多个方法，它们具有相同的名字但参数不同。<br> <strong>运行时多态（动态多态）</strong>：<br>  通过方法重写（Method Overriding）实现。子类可以重写父类的方法，并且在运行时可以根据对象的实际类型调用相应的方法。</li>
</ol>
</blockquote>
<h3 id="垃圾回收机制，怎么判断哪些对象是回收对象"><a href="#垃圾回收机制，怎么判断哪些对象是回收对象" class="headerlink" title="垃圾回收机制，怎么判断哪些对象是回收对象"></a>垃圾回收机制，怎么判断哪些对象是回收对象</h3><ol>
<li>引用计数法，每个对象有一个引用计数器，当有一个新的引用指向该对象时，计数器+1，当一个引用不再指向该对象时，计数器-1。如果引用计数器为0，则可以被回收。缺点是：循环引用，两个对象互相引用对方，并且不再被其他对象引用，引用计数器永远不会为0，导致内存泄漏</li>
<li>可达性算法：通过GC Roots的对象为起点，从这些对象开始，通过引用链可达的就不会被回收，不可达的就会被回收。(常见的GC Roots是虚拟机栈中的引用对象，方法区中的类静态属性引用对象，方法去中的常量引用对象，本地方法栈中的Native方法引用的对象)</li>
<li>标记-清除算法(Mark-Sweep) <ol>
<li>从GC Roots开始标记可达对象</li>
<li>遍历堆中的所有对象，清除那些没有被标记的对象。</li>
</ol>
</li>
</ol>
<h3 id="常见的集合的实现类，集合的好处"><a href="#常见的集合的实现类，集合的好处" class="headerlink" title="常见的集合的实现类，集合的好处"></a>常见的集合的实现类，集合的好处</h3><ol>
<li>简化代码，简化数据结构的使用</li>
<li>提高开发效率</li>
<li>性能优化</li>
<li>类型安全，使用泛型可以确保集合中的元素类型一致避免了类型转化错误</li>
<li>丰富的工具类</li>
</ol>
<h3 id="MySQL常见命令"><a href="#MySQL常见命令" class="headerlink" title="MySQL常见命令"></a>MySQL常见命令</h3><ol>
<li>库 CREATE DATABEASE, DROP DATABASE,USE ,SHOW DATABASES</li>
<li>表 CREATE TABLE,DROP TABLE,SHOW TABLES, ALTER TABLE ADD/DROP/MODIFY</li>
<li>数据 INSERT INTO,UPDATE,DELETE FROM,SELECT</li>
</ol>
<p>查一个表的第10行和20行，limit 9,10</p>
<h3 id="MySQL默认索引的数据结构是什么"><a href="#MySQL默认索引的数据结构是什么" class="headerlink" title="MySQL默认索引的数据结构是什么"></a>MySQL默认索引的数据结构是什么</h3><p>默认数据结构是B树，InnoDB存储引擎使用的是B+树作为索引数据结构<br>B树和B+树的区别：将所有的值存在叶子节点中</p>
<h3 id="Redis和MySQL的区别"><a href="#Redis和MySQL的区别" class="headerlink" title="Redis和MySQL的区别"></a>Redis和MySQL的区别</h3><h3 id="Linux常见命令"><a href="#Linux常见命令" class="headerlink" title="Linux常见命令"></a>Linux常见命令</h3><h3 id="为什么使用了Kafka"><a href="#为什么使用了Kafka" class="headerlink" title="为什么使用了Kafka"></a>为什么使用了Kafka</h3><ol>
<li>解耦</li>
<li>异步处理</li>
<li>流量削峰</li>
<li>可靠性</li>
<li>可扩展性</li>
</ol>
<h3 id="介绍一下实习项目之间的服务调用"><a href="#介绍一下实习项目之间的服务调用" class="headerlink" title="介绍一下实习项目之间的服务调用"></a>介绍一下实习项目之间的服务调用</h3><h3 id="有用过测试吗"><a href="#有用过测试吗" class="headerlink" title="有用过测试吗"></a>有用过测试吗</h3><p>如何进行压测</p>
<h3 id="分布式锁如何实现的，有哪些实现方式"><a href="#分布式锁如何实现的，有哪些实现方式" class="headerlink" title="分布式锁如何实现的，有哪些实现方式"></a>分布式锁如何实现的，有哪些实现方式</h3><ol>
<li>基于Redis实现的分布式锁，</li>
<li>基于ZooKeeper实现</li>
</ol>
<h4 id="ZooKeeper实现"><a href="#ZooKeeper实现" class="headerlink" title="ZooKeeper实现"></a>ZooKeeper实现</h4><p>有更高的可靠性之外，功能外层还有一个分厂有用的特性：Watch机制。这个机制可以用来实现公平的分布式锁。性能方面较差</p>
<h5 id="如何实现"><a href="#如何实现" class="headerlink" title="如何实现"></a>如何实现</h5><p><img src="/2024/06/07/17/ZooKeeper%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81.png" alt="|525"><br>ZooKeeper分布式锁是基于临时顺序节点和Watcher(事件监听器)实现的</p>
<ol>
<li>首先要有一个持久节点/locks，客户端获取锁就是在locks下创建临时顺序节点</li>
<li>创建/locks/lock1节点之后，会判断lock1是否是/locks下最小的子节点</li>
<li>如果是最小的子节点，则获取锁成功，否则获取失败。</li>
<li>如果获取失败，客户端会在/locks/lock0上注册一个时间监听器，这个监听器的作业用是当前一个节点释放锁之后通知客户端1，避免无效自旋<br>释放锁：</li>
<li>成功获取锁的客户端在执行完任务流程之后，会将对应的子节点删除</li>
<li>成功获取锁的客户端出现故障之后，对应的子节点是临时顺序节点，会被自动删除，避免了锁无法被释放</li>
<li>事件监听器就是监听这个子节点删除事件</li>
</ol>
<h5 id="为什么要使用临时顺序节点"><a href="#为什么要使用临时顺序节点" class="headerlink" title="为什么要使用临时顺序节点"></a>为什么要使用临时顺序节点</h5><p>znode是ZooKeeper中数据的最小单元<br>znode有4大分类</p>
<ol>
<li>持久节点：一旦创建就一直存在，即使ZooKeeper集群宕机</li>
<li>临时节点：与客户端会话绑定，会话小时则节点消失，临时节点只能作为叶子节点，不能再创建子节点</li>
<li>持久顺序节点：持久+顺序性</li>
<li>临时顺寻节点：临时+顺序性</li>
</ol>
<h5 id="为什么要对前一个节点监听"><a href="#为什么要对前一个节点监听" class="headerlink" title="为什么要对前一个节点监听"></a>为什么要对前一个节点监听</h5><blockquote>
<p>当前一个节点对应的客户端释放锁之后（也就是前一个节点被删除之后，监听的是删除事件），通知获取锁失败的客户端（唤醒等待的线程，Java 中的 <code>wait/notifyAll</code> ），让它尝试去获取锁，然后就成功获取锁了。</p>
</blockquote>
<h3 id="反问"><a href="#反问" class="headerlink" title="反问"></a>反问</h3><ol>
<li>实习生该做什么：给啥做啥</li>
<li>测试开发比例多少：至少7：3</li>
<li>面试结果如何，表现如何：代码能力可以，对测试的了解不太行，对测试是否感兴趣</li>
<li>测试挂了对其他岗位有什么影响：只有不来会影响</li>
</ol>
<h2 id="算法题-1"><a href="#算法题-1" class="headerlink" title="算法题"></a>算法题</h2><p>最大路径和(最小路径和变体) mid难度<br>如何验证算法题是对的</p>
<h2 id="其他人面试遇到的问题"><a href="#其他人面试遇到的问题" class="headerlink" title="其他人面试遇到的问题"></a>其他人面试遇到的问题</h2><h3 id="什么是动态代理-x2F-静态代理"><a href="#什么是动态代理-x2F-静态代理" class="headerlink" title="什么是动态代理/静态代理"></a>什么是动态代理/静态代理</h3><p>动态代理<br>动态代理是在运行时创建代理对象的机制。代理对象可以在不修改原始对象代码的情况下，拦截对目标对象的方法调用，并在调用前后添加额外的逻辑。Java 中的动态代理主要有两种实现方式：<br>静态代理<br>静态代理是在编译时创建代理类的机制。代理类在编译时就已经存在，并且实现了与目标对象相同的接口。静态代理通过在代理类中调用目标对象的方法来实现对目标对象的代理。</p>
<h3 id="什么是事务传播"><a href="#什么是事务传播" class="headerlink" title="什么是事务传播"></a>什么是事务传播</h3><p>事务传播 Transaction Propagation 是指Spring框架中定义事务在方法调用的过程中如何传播的机制。决定了一个方法在调用另一个方法时，事务应该如何进行管理。</p>
<ul>
<li>REQUIRED：默认支持当前事务，如果当前没有事务，就创建一个事务。这是默认的<img src="/2024/06/07/17/REQUIRED.png"></li>
<li>REQUIRED_NEW：总是创建一个新事务，当前存在事务就把当前事务挂起<img src="/2024/06/07/17/REQUIRED_NEW.png"></li>
<li>SUPPORTS：如果存在事务，就加入该事务，如果没有，就以非事务的方式执行</li>
<li>NOT_SUPPORTED：即使当前存在事务，也不进行事务操作。</li>
<li>MANDATORY：存在就加入，没有就抛出异常</li>
<li>NEVER：总是以非事务的方式运行，存在事务就抛出异常</li>
<li>NESTED：存在事务就嵌套事务内执行，没有事务就创建一个事务。可以读到嵌套事务</li>
</ul>
<h3 id="g1-full-gc退化过程"><a href="#g1-full-gc退化过程" class="headerlink" title="g1 full gc退化过程"></a>g1 full gc退化过程</h3><h4 id="G1的工作原理"><a href="#G1的工作原理" class="headerlink" title="G1的工作原理"></a>G1的工作原理</h4><ol>
<li>分代收集:G1将堆内存划分为多个大小相等的区域，Yong GC 主要收集Eden区和Survivor区的垃圾对象</li>
<li>混合收集Mixed GC：不仅年轻代，还收集部分老年代的垃圾对象</li>
<li>并发标记周期：并发标记，垃圾收集可以与应用程序并发执行，减少垃圾收集对应用程序的影响标记老年代中存活对象，以便在混合收集中回收。</li>
</ol>
<h4 id="退化的原因"><a href="#退化的原因" class="headerlink" title="退化的原因"></a>退化的原因</h4><ol>
<li>内存不足：当内存不足以分配新的对象或无法通过Yong GC和Mixed GC会搜狐，足够的内存时，会触发Full GC</li>
<li>并发失败：在并发标记周期中，如果无法即使完成标记或者回收，可能会退化为Full GC</li>
<li>晋升失败：当对象从年轻代晋升到老年代时，如果老年代没有足够的空间</li>
<li>元数据空间不足</li>
</ol>
<h4 id="退化过程"><a href="#退化过程" class="headerlink" title="退化过程"></a>退化过程</h4><ol>
<li>内存分配失败，尝试触发Yong GC</li>
<li>Yong GC失败，触发Mixed GC</li>
<li>Mixed GC失败，JVM进入Full GC</li>
<li>Full GC会暂停所有应用线程，进行全站扫描和压缩，以会搜尽可能多的内存。</li>
</ol>
<h3 id="gRPC为什么可以提高效率"><a href="#gRPC为什么可以提高效率" class="headerlink" title="gRPC为什么可以提高效率"></a>gRPC为什么可以提高效率</h3><ol>
<li>高效的协议 Protocol Buffers</li>
<li>基于HTTP/2的传输协议：<ul>
<li>多路复用：HTTP/2允许在单个TCP连接上并行发送多个请求和响应，减少了连接建立的开销</li>
<li>头部压缩：使用HPACK算法对头部进行压缩</li>
<li>服务器推送，可以在客户端请求之前发送数据，减少延迟</li>
<li>流控制：更细力度的流控制，优化了带宽利用率</li>
</ul>
</li>
<li>双向流和流控制：允许客户端和服务器单个连接上同时接收和发送数据。</li>
<li>负载均衡和服务发现，支持多种负载均衡策略</li>
<li>高效的异步通信：</li>
<li>安全性：内置对TLS的支持<br><img src="/2024/06/07/17/grpc%E5%8E%9F%E7%90%86.png"></li>
</ol>
<h3 id="synchronized介绍下？底层原理？和LOCK的区别是什么？具体优缺点是什么？"><a href="#synchronized介绍下？底层原理？和LOCK的区别是什么？具体优缺点是什么？" class="headerlink" title="synchronized介绍下？底层原理？和LOCK的区别是什么？具体优缺点是什么？"></a>synchronized介绍下？底层原理？和LOCK的区别是什么？具体优缺点是什么？</h3><p>用来实现线程之间的互斥访问，确保同一时刻只能由一个线程可以执行被修饰的代码。</p>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>通过对象头中的监视器锁Monitor实现，当一个线程进入同步代码块或者方法时，会尝试获取该对象的监视器锁。<br>监视器锁的组成:</p>
<ol>
<li>对象头：每个对象在内存中都一个对象头，包含对象的元数据和锁信息</li>
<li>Mark Word：对象头中的Mark Word存储了锁装填、哈希码、GC信息等</li>
<li>Monitor：每个对象都有一个关联的监视器，用于是实现同步。<br>和Lock的区别<br>synchronied是Java语言级别的关键字，使用方便，而且由JVM管理，是隐式锁，如果一个线程获取锁失败会被阻塞，不可中断，线程在等待锁时无法被中断。<br>Lock时显示锁，需要显示获取和释放，支持可重入锁，公平锁等，非阻塞，可中断</li>
</ol>
<h3 id="Kafka是如何保证消息的顺序性的？你了解底层的原理吗？"><a href="#Kafka是如何保证消息的顺序性的？你了解底层的原理吗？" class="headerlink" title="Kafka是如何保证消息的顺序性的？你了解底层的原理吗？"></a>Kafka是如何保证消息的顺序性的？你了解底层的原理吗？</h3><h3 id="保障服务稳定性最重要的一个环节是"><a href="#保障服务稳定性最重要的一个环节是" class="headerlink" title="保障服务稳定性最重要的一个环节是"></a>保障服务稳定性最重要的一个环节是</h3><p>监控和预警</p>
<h4 id="如何提前预估接口的QPS"><a href="#如何提前预估接口的QPS" class="headerlink" title="如何提前预估接口的QPS"></a>如何提前预估接口的QPS</h4><ol>
<li>历史数据分析：分析历史日志和监控数据，了解不同时间段的QPS</li>
<li>业务需求分析：</li>
<li>模拟测试：压测模拟</li>
</ol>
<h3 id="HTTP1-0-x2F-1-1-x2F-2-0的区别"><a href="#HTTP1-0-x2F-1-1-x2F-2-0的区别" class="headerlink" title="HTTP1.0/1.1/2.0的区别"></a>HTTP1.0/1.1/2.0的区别</h3><p>HTTP1.0 默认短链接，每次请求都需要建立一次连接<br>1.1 默认长连接，可以在一个TCP连接上传送多个HTTP请求和响应<br>2.0 增加多路复用，报文头压缩，允许服务端推送资源给客户端。</p>
<h3 id="队头阻塞"><a href="#队头阻塞" class="headerlink" title="队头阻塞"></a>队头阻塞</h3><h3 id="Redis相关"><a href="#Redis相关" class="headerlink" title="Redis相关"></a>Redis相关</h3><h4 id="大key问题"><a href="#大key问题" class="headerlink" title="大key问题"></a>大key问题</h4><p>解决：使用压缩gzip等，定时清理</p>
<h4 id="热key"><a href="#热key" class="headerlink" title="热key"></a>热key</h4><p>Redis中，频繁被访问的键，可能会导致Redis性能瓶颈。<br>解决方案：</p>
<ol>
<li>在Redis之前增加一个缓存层</li>
<li>数据分片，将热key的数据分片存储到多个Redis实例中</li>
<li>请求分摊</li>
</ol>
<h3 id="数据库相关"><a href="#数据库相关" class="headerlink" title="数据库相关"></a>数据库相关</h3><h4 id="在有多个索引时，数据库会如何选择使用哪个索引？"><a href="#在有多个索引时，数据库会如何选择使用哪个索引？" class="headerlink" title="在有多个索引时，数据库会如何选择使用哪个索引？"></a>在有多个索引时，数据库会如何选择使用哪个索引？</h4><p>会使用选择性高(索引列中的不通知的数量与总行数的比率)、索引覆盖(可以避免回表操作的)、索引类型()、查询条件(例如最左匹配，复合索引(A,B)不可单独作用于B)</p>
<h3 id="分布式相关"><a href="#分布式相关" class="headerlink" title="分布式相关"></a>分布式相关</h3><h4 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h4><p><a target="_blank" rel="noopener" href="https://xiaomi-info.github.io/2020/01/02/distributed-transaction/">https://xiaomi-info.github.io/2020/01/02/distributed-transaction/</a></p>
<h3 id="业务相关"><a href="#业务相关" class="headerlink" title="业务相关"></a>业务相关</h3><h4 id="如何实现延迟队列"><a href="#如何实现延迟队列" class="headerlink" title="如何实现延迟队列"></a>如何实现延迟队列</h4><ol>
<li>使用DelayQueue,<code>DelayQueue</code>的<code>put</code>方法是线程安全的，因为<code>put</code>方法内部使用了<code>ReentrantLock</code>锁进行线程同步。<code>DelayQueue</code>还提供了两种出队的方法 <code>poll()</code> 和 <code>take()</code> ， <code>poll()</code> 为非阻塞获取，没有到期的元素直接返回null；<code>take()</code> 阻塞方式获取，没有到期的元素线程将会等待。</li>
<li>基于定时任务</li>
<li>基于Redis过期键的回调函数</li>
</ol>
<h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><h4 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h4><p>反射的原理基于Java的元数据（metadata），这些元数据在编译时被嵌入到类文件中，并在运行时通过Java反射API进行访问。</p>
<h3 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h3><h4 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h4><blockquote>
<p>AOP基于动态代理，如果要代理的对象实现了某个接口，那额会使用JDKProxy，如果没实现接口，那么会使用基于asm框架字节流的Cglib动态代理来生成一个被代理对象的子类来作为代理。</p>
</blockquote>
<h3 id="创建对象的几种方式"><a href="#创建对象的几种方式" class="headerlink" title="创建对象的几种方式"></a>创建对象的几种方式</h3><ol>
<li>new</li>
<li>Class.newInstance：需要有public无参构造器</li>
<li>Contructor.newInstance：调用有参数和私有的构造函数</li>
<li>使用Clone</li>
<li>反序列化</li>
<li></li>
</ol>
<h4 id="Bean"><a href="#Bean" class="headerlink" title="Bean"></a>Bean</h4><h5 id="创建流程"><a href="#创建流程" class="headerlink" title="创建流程"></a>创建流程</h5><ol>
<li>实例化：也就是new</li>
<li>IOC注入</li>
</ol>
<h4 id="循环依赖"><a href="#循环依赖" class="headerlink" title="循环依赖"></a>循环依赖</h4><blockquote>
<p>两个或两个以上的Bean互相持有对方，形成相互持有对方，最终形成闭环。</p>
</blockquote>
<h5 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h5><p>三级缓存</p>
<ol>
<li>Spring容器通过构造器初始化对象之后提前暴漏到Spring容器的singletonFactorys(三级缓存)</li>
<li>调用另一个对象时，尝试从容器中获取，如果不存在就初始化，现将自己放在三级缓存中，之后从一级、二级、三级缓存中一次获取第一个对象</li>
<li>获取之后将自己放在单例池中，供第一个实例完成初始化。</li>
</ol>
<h2 id="同学的滴滴研发一面面经"><a href="#同学的滴滴研发一面面经" class="headerlink" title="同学的滴滴研发一面面经"></a>同学的滴滴研发一面面经</h2><ol>
<li>自我介绍</li>
<li>项目介绍：项目是否为网络上找的demo</li>
<li>个人职责</li>
<li>一些具体的功能实现逻辑</li>
<li>使用Redis进行优化的思路</li>
<li>HashMap的常见八股，如何进行扩容的(*)</li>
</ol>
<h3 id="如何保证多次请求-x2F-刷新的幂等性"><a href="#如何保证多次请求-x2F-刷新的幂等性" class="headerlink" title="如何保证多次请求/刷新的幂等性"></a>如何保证多次请求/刷新的幂等性</h3><ol>
<li>使用PRG(POST/Redirect/GET)：用户填写表单，之后服务器收到请求之后进行处理，然后通过返回重定向，后续用户通过GET进行请求</li>
<li>Token机制：服务端通过生成唯一有时效性的Token，之后客户端携带这个Token发送请求，如果Token失效则拒绝执行。并发场景下可以使用SETNX来保证有效，同时避免多个请求同时通过验证</li>
</ol>
<p>#todo </p>
<ul>
<li><input disabled="" type="checkbox"> leetcode手写LRU</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zuofw.github.io/2024/06/07/04/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="QingQiu">
      <meta itemprop="description" content="个人网站，学习记录，面试记录和经验总结、互联网中一块属于自己的小窝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="QingQiu'Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/06/07/04/" class="post-title-link" itemprop="url">深入浅出Spring</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-06-07 16:30:04" itemprop="dateCreated datePublished" datetime="2024-06-07T16:30:04+08:00">2024-06-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-07-29 17:43:41" itemprop="dateModified" datetime="2024-07-29T17:43:41+08:00">2024-07-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Spring/" itemprop="url" rel="index"><span itemprop="name">Spring</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>16k</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="面试常问"><a href="#面试常问" class="headerlink" title="面试常问"></a>面试常问</h1><h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><ul>
<li>@Nullable 注解的主要作用是为开发者和静态分析工具提供信息，指示某个字段、方法返回值或参数可以为 null。具体来说，它会：  帮助静态分析工具：静态分析工具可以利用 @Nullable 注解来检查代码中是否正确处理了可能为 null 的情况，并在发现潜在问题时发出警告。增强代码可读性：开发者可以通过查看注解来了解哪些变量或返回值可能为 null，从而在使用这些变量时进行适当的空值检查。文档生成：在生成文档时，@Nullable 注解可以帮助其他开发者理解哪些字段、方法返回值或参数可以为 null。它不会直接阻止 NullPointerException 的发生，但能帮助开发者在编写和维护代码时进行适当的空值检查，从而减少空指针异常的发生</li>
<li>Bean相关<ul>
<li>@Autowired和@Resource<br>  @Autowired默认注入方式是byType，也就是优先根据接口类型去匹配并注入Bean<br>  @Resource默认是byName注入的，如果不能通过name匹配会变为byType，可以使用只当以下两个属性其中之一来确定，不建议同时指定两个属性</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token annotation punctuation">@interface</span> <span class="token class-name">Resource</span> <span class="token punctuation">{</span>
    <span class="token class-name">String</span> <span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token string">""</span><span class="token punctuation">;</span>
    <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> <span class="token function">type</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token class-name">Object</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li><code>@RestController</code>注解是<code>@Controller</code>和<code>@ResponseBody</code>,会将函数的返回值直接填入HTTP响应体中，是REST风格的控制器</li>
<li>@Scope(““)生命作用域：<ul>
<li>singleton单例作用域，默认全是单例</li>
<li>prototype 每次请求都创建一个新的实例</li>
<li>request 每次HTTP请求都会创建一个bean，在当前HTTP request有效</li>
<li>session 在当前的HTTP session中有效</li>
</ul>
</li>
<li><code>@SpringBootApplication</code> 是<code>@Configuration</code>、<code>@EnableAutoConfiguration</code>、<code>@ComponentScan</code>&nbsp;注解的集合。<ul>
<li><code>@EnableAutoConfiguration</code> 启动自动装配</li>
<li><code>@ComponentScan</code>：扫描注解标记的组件，默认送奥妙该类所在的包下的所有的类</li>
<li><code>@Configuration</code> 允许在 Spring 上下文中注册额外的 bean 或导入其他配置类</li>
</ul>
</li>
<li>读取配置信息并且与bean绑定<ul>
<li><code>@Value("${property}")</code>&nbsp;读取比较简单的配置信息</li>
<li><code>@ConfigurationProperties</code>读取配置信息并与 bean 绑定。<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Component</span>
<span class="token annotation punctuation">@ConfigurationProperties</span><span class="token punctuation">(</span>prefix <span class="token operator">=</span> <span class="token string">"library"</span><span class="token punctuation">)</span>
<span class="token keyword">class</span> <span class="token class-name">LibraryProperties</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@NotEmpty</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> location<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Book</span><span class="token punctuation">&gt;</span></span> books<span class="token punctuation">;</span>

    <span class="token annotation punctuation">@Setter</span>
    <span class="token annotation punctuation">@Getter</span>
    <span class="token annotation punctuation">@ToString</span>
    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Book</span> <span class="token punctuation">{</span>
        <span class="token class-name">String</span> name<span class="token punctuation">;</span>
        <span class="token class-name">String</span> description<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  省略getter<span class="token operator">/</span>setter
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
</li>
</ul>
<h3 id="Bean"><a href="#Bean" class="headerlink" title="Bean"></a>Bean</h3><ul>
<li>Bean的作用域<ol>
<li>singleton单例：Spring中的bean默认都是单例的</li>
<li>prototype：每次获取都会创建一个新的Bean，也就是连续两次获取Bean都会是不同的Bean实例</li>
<li>request：每一次HTTP请求都会产生一个新的bean，bean在当前HTTP request内生效</li>
<li>sesson：在HTTP的session中有效，session是多个HTTP之间使用的连续会话</li>
<li><strong>application/global-session</strong>&nbsp;（仅 Web 应用可用）：每个 Web 应用在启动时创建一个 Bean（应用 Bean），该 bean 仅在当前应用启动时间内有效。</li>
<li>websocket：每一次WebSocket都会产生一个新的bean<br>配置方式：<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Bean</span>
<span class="token annotation punctuation">@Scope</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token class-name">ConfigurableBeanFactory</span><span class="token punctuation">.</span><span class="token constant">SCOPE_PROTOTYPE</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token class-name">Person</span> <span class="token function">personPrototype</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ol>
</li>
<li>Bean的生命周期<ol>
<li>创建Bean的实例：Bean容器会先找到Bean的定义，然后通过Java反射API来创建Bean的实例</li>
<li>Bean属性赋值/填充：为Bean设置相关属性和依赖，例如填入@Autowired等注解注入的对象，setter方法和构造函数</li>
<li>Bean初始化:：<img src="/2024/06/07/04/Bean%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96.png" alt="Bean的初始化"></li>
<li>销毁Bean：把Bean的销毁方法记录下来，将爱需要销毁Bean或者销毁容器时，调用这些方法去释放Bean所持有的资源<ul>
<li>如果 Bean 实现了 <code>DisposableBean</code> 接口，执行 <code>destroy()</code> 方法。</li>
<li>如果 Bean 在配置文件中的定义包含 <code>destroy-method</code> 属性，执行指定的 Bean 销毁方法。或者，也可以直接通过<code>@PreDestroy</code> 注解标记 Bean 销毁之前执行的方法。</li>
</ul>
</li>
</ol>
</li>
</ul>
<p><img src="/2024/06/07/04/Bean%E7%9A%84%E5%91%A8%E6%9C%9F.png" alt="|475"></p>
<hr>
<h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h3><h4 id="常见实现"><a href="#常见实现" class="headerlink" title="常见实现"></a>常见实现</h4><p>Spring AOP实现方式有动态代理、字节码等操作方式</p>
<h4 id="常见术语："><a href="#常见术语：" class="headerlink" title="常见术语："></a>常见术语：<img src="/2024/06/07/04/AOP%E5%B8%B8%E8%A7%81%E6%9C%AF%E8%AF%AD.png"></h4><h4 id="AspectJ定义的通知类型"><a href="#AspectJ定义的通知类型" class="headerlink" title="AspectJ定义的通知类型"></a>AspectJ定义的通知类型</h4><ul>
<li>Before 前置通知：在目标方法调用之前，所以获得不到目标方法的具体东西</li>
<li>After 后置通知：目标方法调用之后，类似于finally，无论方法是否成功都会调用</li>
<li>AfterReturing：目标方法调用之后，返回结果之后触发，只有方法完成成功会调用</li>
<li>AfterThrowing：异常通知，出现异常时触发，类似catch</li>
<li>Around环绕通知：可以拿到目标对象<br>对于多个切面的执行顺序可以通过@Order(数字) 来指定</li>
</ul>
<h3 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h3><p>MVC 是模型(Model)、视图(View)、控制器(Controller)的简写，其核心思想是通过将业务逻辑、数据、显示分离来组织代码。<img src="/2024/06/07/04/MVC.png"><br>核心组件：</p>
<ul>
<li>**<code>DispatcherServlet</code>**“：核心中央处理器，用汉语接受请求、分发请求，给予客户端响应</li>
<li>HandlerMapping：处理器映射器，根据URL去匹配查找能处理的Handler，并将涉及的拦截器和Handler一起封装</li>
<li>HandlerAdapter：处理器适配器，根据HandlerMapping找到的Handler，设配置型对应的Handler</li>
<li>Handler：请求处理器</li>
<li>ViewResolver：视图解析器，根据Handler返回的逻辑视图/试图，解析并渲染真正的试图，传递给DispatcherServlet响应客户端。<br><img src="/2024/06/07/04/MVC%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B.png"><br><strong>流程说明（重要）：</strong></li>
</ul>
<ol>
<li>客户端（浏览器）发送请求， <code>DispatcherServlet</code>拦截请求。</li>
<li><code>DispatcherServlet</code> 根据请求信息调用 <code>HandlerMapping</code> 。<code>HandlerMapping</code> 根据 URL 去匹配查找能处理的 <code>Handler</code>（也就是我们平常说的 <code>Controller</code> 控制器） ，并会将请求涉及到的拦截器和 <code>Handler</code> 一起封装。</li>
<li><code>DispatcherServlet</code> 调用 <code>HandlerAdapter</code>适配器执行 <code>Handler</code> 。</li>
<li><code>Handler</code> 完成对用户请求的处理后，会返回一个 <code>ModelAndView</code> 对象给<code>DispatcherServlet</code>，<code>ModelAndView</code> 顾名思义，包含了数据模型以及相应的视图的信息。<code>Model</code> 是返回的数据对象，<code>View</code> 是个逻辑上的 <code>View</code>。</li>
<li><code>ViewResolver</code> 会根据逻辑 <code>View</code> 查找实际的 <code>View</code>。</li>
<li><code>DispaterServlet</code> 把返回的 <code>Model</code> 传给 <code>View</code>（视图渲染）。</li>
<li>把 <code>View</code> 返回给请求者（浏览器）</li>
</ol>
<hr>
<p><a target="_blank" rel="noopener" href="https://javaguide.cn/system-design/framework/spring/spring-design-patterns-summary.html">Spring使用的设计模式：</a><br><img src="/2024/06/07/04/Spring%E4%BD%BF%E7%94%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.png"></p>
<h3 id="Spring事务"><a href="#Spring事务" class="headerlink" title="Spring事务"></a>Spring事务</h3><p>ACID AID是手段，最终目的是保证C</p>
<h5 id="相关接口"><a href="#相关接口" class="headerlink" title="相关接口"></a>相关接口</h5><ul>
<li><p>**<code>PlatformTransactionManager</code>**：（平台）事务管理器，Spring 事务策略的核心。</p>
</li>
<li><p>**<code>TransactionDefinition</code>**：事务定义信息(事务隔离级别、传播行为、超时、只读、回滚规则)。</p>
</li>
<li><p>**<code>TransactionStatus</code>**：事务运行状态。</p>
<ul>
<li>编程式事务 (推荐在分布式系统中使用)通过手动使用TransactionTemplate或者TranctionManager手动管理事务，事务范围过大会出现事务未提交导致超时，因此事务要比锁的颗粒度更小</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserService</span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> <span class="token class-name">TransactionTemplate</span> transactionTemplate<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">UserService</span><span class="token punctuation">(</span><span class="token class-name">TransactionTemplate</span> transactionTemplate<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>transactionTemplate <span class="token operator">=</span> transactionTemplate<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token class-name">User</span> <span class="token function">createUser</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token class-name">String</span> username<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> transactionTemplate<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">TransactionCallback</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token annotation punctuation">@Override</span>
            <span class="token keyword">public</span> <span class="token class-name">User</span> <span class="token function">doInTransaction</span><span class="token punctuation">(</span><span class="token class-name">TransactionStatus</span> status<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">try</span> <span class="token punctuation">{</span>
                    <span class="token comment">// 这里是你的业务代码</span>
                    <span class="token comment">// 如果在这里抛出了异常，TransactionTemplate会捕获这个异常并回滚事务</span>
                    <span class="token comment">// 如果这里没有抛出异常，TransactionTemplate会提交事务</span>
                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    status<span class="token punctuation">.</span><span class="token function">setRollbackOnly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword">throw</span> e<span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>声明式事务：通过使用@Tranctional全注解<br>事务<br>Spring事务中有哪几种传播行为</li>
</ul>
<ol>
<li>**<code>TransactionDefinition.PROPAGATION_REQUIRED</code>**，默认，如果当前存在事务，就加入该事务，否则创建一个新的 事务</li>
<li><strong><code>TransactionDefinition.PROPAGATION_REQUIRES_NEW</code></strong> 创建一个新事务，当前存在事务就把</li>
<li><strong><code>TransactionDefinition.PROPAGATION_NESTED</code></strong> 没有事务就创建一个事务左伟当前事务的嵌套事务，存在事务就和 1 相同</li>
<li><strong><code>TransactionDefinition.PROPAGATION_MANDATORY</code></strong> 如果存在事务就加入该事务，不存在事务就报错</li>
</ol>
<ul>
<li><strong><code>TransactionDefinition.PROPAGATION_SUPPORTS</code></strong>: 如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。</li>
<li><strong><code>TransactionDefinition.PROPAGATION_NOT_SUPPORTED</code></strong>: 以非事务方式运行，如果当前存在事务，则把当前事务挂起。</li>
<li><strong><code>TransactionDefinition.PROPAGATION_NEVER</code></strong>: 以非事务方式运行，如果当前存在事务，则抛出异常。</li>
</ul>
<hr>
<p>Spring事务隔离级别</p>
<ol>
<li>**<code>TransactionDefinition.ISOLATION_DEFAULT</code>**：使用后端数据库的默认隔离等级，MySQL采用可重复读，Oracle默认采用读已提交</li>
<li>**<code>TransactionDefinition.ISOLATION_READ_UNCOMMITTED</code>**：最低的隔离等级，允许读已提交，可能会导致脏读，幻读和不可重复读</li>
<li>**<code>TransactionDefinition.ISOLATION_READ_COMMITTED</code>**：允许读并发事务已提交的事务，可以阻止脏读，但是幻读和不可重复仍有可能发生。</li>
<li>**<code>TransactionDefinition.ISOLATION_REPEATABLE_READ</code>**：对同意字段多次读都是相同的，可以组织脏读和不可重复读，但是幻读仍然会发生</li>
<li>**<code>TransactionDefinition.ISOLATION_SERIALIZABLE</code>**： 序列化，最高的隔离级别，影响程序性能</li>
</ol>
<hr>
<h2 id="Transactional-rollbackFor-x3D-Exception-class-默认回滚是只有遇到RuntimeException运行时异常或者Error才进行回滚，而不会回滚，Checked-Exception-Checked-Exception是那些在编译时期就需要被处理的异常-，"><a href="#Transactional-rollbackFor-x3D-Exception-class-默认回滚是只有遇到RuntimeException运行时异常或者Error才进行回滚，而不会回滚，Checked-Exception-Checked-Exception是那些在编译时期就需要被处理的异常-，" class="headerlink" title="Transactional(rollbackFor = Exception.class)    默认回滚是只有遇到RuntimeException运行时异常或者Error才进行回滚，而不会回滚，Checked Exception(Checked Exception是那些在编译时期就需要被处理的异常)，"></a>Transactional(rollbackFor = Exception.class)<br>    默认回滚是只有遇到RuntimeException运行时异常或者Error才进行回滚，而不会回滚，Checked Exception(Checked Exception是那些在编译时期就需要被处理的异常)，<br><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Transactional</span><span class="token punctuation">(</span>rollbackFor <span class="token operator">=</span> <span class="token class-name">Exception</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span>rollbackFor <span class="token operator">=</span> <span class="token class-name">Exception</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">someMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token comment">// some business logic</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></h2><h3 id="Spirng-Data-JPA-Java-Persistence-API"><a href="#Spirng-Data-JPA-Java-Persistence-API" class="headerlink" title="Spirng Data JPA (Java Persistence API)"></a>Spirng Data JPA (Java Persistence API)</h3><p>是Java平台上的一个规范，用于将对象映射到关系数据库</p>
<h4 id="如何使用JPA在数据库中非持久化一个字段"><a href="#如何使用JPA在数据库中非持久化一个字段" class="headerlink" title="如何使用JPA在数据库中非持久化一个字段"></a>如何使用JPA在数据库中非持久化一个字段</h4><p>非持久化：也就是不被数据库存储<br>可以使用注解的方式：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Entity</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"student"</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Id</span>
    <span class="token annotation punctuation">@GeneratedValue</span><span class="token punctuation">(</span>strategy<span class="token operator">=</span> <span class="token class-name">GenerationType</span><span class="token punctuation">.</span><span class="token constant">AUTO</span><span class="token punctuation">)</span> <span class="token comment">// 自增</span>
    <span class="token annotation punctuation">@Column</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"id"</span><span class="token punctuation">)</span>
    <span class="token keyword">private</span> <span class="token class-name">Long</span> id<span class="token punctuation">;</span>
    <span class="token annotation punctuation">@Column</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"name"</span><span class="token punctuation">)</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>
    <span class="token annotation punctuation">@Column</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"age"</span><span class="token punctuation">)</span>
    <span class="token keyword">private</span> <span class="token class-name">Integer</span> age<span class="token punctuation">;</span>
    
    <span class="token annotation punctuation">@Transient</span> <span class="token comment">// 不映射到数据库</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> secrect<span class="token punctuation">;</span>
    
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="JPA审计功能"><a href="#JPA审计功能" class="headerlink" title="JPA审计功能"></a>JPA审计功能</h4><p>  审计功能主要是帮助我们记录数据库操作的具体行为比如某条记录是谁创建的、什么时间创建的、最后修改人是谁、最后修改时间是什么时候。<br>  示例：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Data</span>
<span class="token annotation punctuation">@AllArgsConstructor</span>
<span class="token annotation punctuation">@NoArgsConstructor</span>
<span class="token annotation punctuation">@MappedSuperclass</span>
<span class="token annotation punctuation">@EntityListeners</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token class-name">AuditingEntityListener</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">AbstractAuditBase</span> <span class="token punctuation">{</span>

    <span class="token annotation punctuation">@CreatedDate</span> <span class="token comment">//该字段为创建时间字段，在insert时会插入</span>
    <span class="token annotation punctuation">@Column</span><span class="token punctuation">(</span>updatable <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">)</span>
    <span class="token annotation punctuation">@JsonIgnore</span> <span class="token comment">//不进行序列化</span>
    <span class="token keyword">private</span> <span class="token class-name">Instant</span> createdAt<span class="token punctuation">;</span>

    <span class="token annotation punctuation">@LastModifiedDate</span> <span class="token comment">//最后一次更新时间</span>
    <span class="token annotation punctuation">@JsonIgnore</span>
    <span class="token keyword">private</span> <span class="token class-name">Instant</span> updatedAt<span class="token punctuation">;</span>

    <span class="token annotation punctuation">@CreatedBy</span> <span class="token comment">//标记创建人</span>
    <span class="token annotation punctuation">@Column</span><span class="token punctuation">(</span>updatable <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token comment">//不允许更新</span>
    <span class="token annotation punctuation">@JsonIgnore</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> createdBy<span class="token punctuation">;</span>

    <span class="token annotation punctuation">@LastModifiedBy</span> <span class="token comment">//最后一次更新人</span>
    <span class="token annotation punctuation">@JsonIgnore</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> updatedBy<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="Spring-Security"><a href="#Spring-Security" class="headerlink" title="Spring Security"></a>Spring Security</h3><h4 id="控制访问权限的方法："><a href="#控制访问权限的方法：" class="headerlink" title="控制访问权限的方法："></a>控制访问权限的方法：</h4><ul>
<li><code>permitAll()</code>：无条件允许任何形式访问，不管你登录还是没有登录。</li>
<li><code>anonymous()</code>：允许匿名访问，也就是没有登录才可以访问。</li>
<li><code>denyAll()</code>：无条件决绝任何形式的访问。</li>
<li><code>authenticated()</code>：只允许已认证的用户访问。</li>
<li><code>fullyAuthenticated()</code>：只允许已经登录或者通过 remember-me 登录的用户访问。</li>
<li><code>hasRole(String)</code> : 只允许指定的角色访问。</li>
<li><code>hasAnyRole(String)</code> : 指定一个或者多个角色，满足其一的用户即可访问。</li>
<li><code>hasAuthority(String)</code>：只允许具有指定权限的用户访问</li>
<li><code>hasAnyAuthority(String)</code>：指定一个或者多个权限，满足其一的用户即可访问。</li>
<li><code>hasIpAddress(String)</code> : 只允许指定 ip 的用户访问。</li>
</ul>
<hr>
<h1 id="参数校验"><a href="#参数校验" class="headerlink" title="参数校验"></a>参数校验</h1><h4 id="Hibernate-Validator"><a href="#Hibernate-Validator" class="headerlink" title="Hibernate Validator"></a>Hibernate Validator</h4><p>使用时建议使用**<code>javax.validation.constraints</code>**中的注解<br>常见的注解：</p>
<ul>
<li><code>@NotEmpty</code> 被注释的字符串的不能为 null 也不能为空</li>
<li><code>@NotBlank</code> 被注释的字符串非 null，并且必须包含一个非空白字符</li>
<li><code>@Null</code> 被注释的元素必须为 null</li>
<li><code>@NotNull</code> 被注释的元素必须不为 null</li>
<li><code>@AssertTrue</code> 被注释的元素必须为 true</li>
<li><code>@AssertFalse</code> 被注释的元素必须为 false</li>
<li><code>@Pattern(regex=,flag=)</code>被注释的元素必须符合指定的正则表达式</li>
<li><code>@Email</code> 被注释的元素必须是 Email 格式。</li>
<li><code>@Min(value)</code>被注释的元素必须是一个数字，其值必须大于等于指定的最小值</li>
<li><code>@Max(value)</code>被注释的元素必须是一个数字，其值必须小于等于指定的最大值</li>
<li><code>@DecimalMin(value)</code>被注释的元素必须是一个数字，其值必须大于等于指定的最小值</li>
<li><code>@DecimalMax(value)</code> 被注释的元素必须是一个数字，其值必须小于等于指定的最大值</li>
<li><code>@Size(max=, min=)</code>被注释的元素的大小必须在指定的范围内</li>
<li><code>@Digits(integer, fraction)</code>被注释的元素必须是一个数字，其值必须在可接受的范围内</li>
<li><code>@Past</code>被注释的元素必须是一个过去的日期</li>
<li><code>@Future</code> 被注释的元素必须是一个将来的日期</li>
<li><code>@Positive</code>和<code>@PositiveOrZero</code>验证数字必须为正数/包括0，同理 <code>@Negative</code>为负数</li>
</ul>
<hr>
<p>示例1：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Data</span>
<span class="token annotation punctuation">@AllArgsConstructor</span>
<span class="token annotation punctuation">@NoArgsConstructor</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>

    <span class="token annotation punctuation">@NotNull</span><span class="token punctuation">(</span>message <span class="token operator">=</span> <span class="token string">"classId 不能为空"</span><span class="token punctuation">)</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> classId<span class="token punctuation">;</span>

    <span class="token annotation punctuation">@Size</span><span class="token punctuation">(</span>max <span class="token operator">=</span> <span class="token number">33</span><span class="token punctuation">)</span>
    <span class="token annotation punctuation">@NotNull</span><span class="token punctuation">(</span>message <span class="token operator">=</span> <span class="token string">"name 不能为空"</span><span class="token punctuation">)</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>

    <span class="token annotation punctuation">@Pattern</span><span class="token punctuation">(</span>regexp <span class="token operator">=</span> <span class="token string">"((^Man$|^Woman$|^UGM$))"</span><span class="token punctuation">,</span> message <span class="token operator">=</span> <span class="token string">"sex 值不在可选范围"</span><span class="token punctuation">)</span>
    <span class="token annotation punctuation">@NotNull</span><span class="token punctuation">(</span>message <span class="token operator">=</span> <span class="token string">"sex 不能为空"</span><span class="token punctuation">)</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> sex<span class="token punctuation">;</span>

    <span class="token annotation punctuation">@Email</span><span class="token punctuation">(</span>message <span class="token operator">=</span> <span class="token string">"email 格式不正确"</span><span class="token punctuation">)</span>
    <span class="token annotation punctuation">@NotNull</span><span class="token punctuation">(</span>message <span class="token operator">=</span> <span class="token string">"email 不能为空"</span><span class="token punctuation">)</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> email<span class="token punctuation">;</span>

<span class="token punctuation">}</span>
<span class="token comment">//在需要校验的参数上使用@Valid，如果验证失败，会抛出我们在需要验证的参数上加上了`@Valid`注解，如果验证失败，它将抛出MethodArgumentNotValidException</span>
<span class="token annotation punctuation">@RestController</span>
<span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/api"</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PersonController</span> <span class="token punctuation">{</span>

    <span class="token annotation punctuation">@PostMapping</span><span class="token punctuation">(</span><span class="token string">"/person"</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token class-name">ResponseEntity</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Person</span><span class="token punctuation">&gt;</span></span> <span class="token function">getPerson</span><span class="token punctuation">(</span><span class="token annotation punctuation">@RequestBody</span> <span class="token annotation punctuation">@Valid</span> <span class="token class-name">Person</span> person<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token class-name">ResponseEntity</span><span class="token punctuation">.</span><span class="token function">ok</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">body</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>示例2：验证请求参数，要求在类上加@Validated注解</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@RestController</span>
<span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/api"</span><span class="token punctuation">)</span>
<span class="token annotation punctuation">@Validated</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PersonController</span> <span class="token punctuation">{</span>

    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/person/{id}"</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token class-name">ResponseEntity</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> <span class="token function">getPersonByID</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Valid</span> <span class="token annotation punctuation">@PathVariable</span><span class="token punctuation">(</span><span class="token string">"id"</span><span class="token punctuation">)</span> <span class="token annotation punctuation">@Max</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">,</span>message <span class="token operator">=</span> <span class="token string">"超过 id 的范围了"</span><span class="token punctuation">)</span> <span class="token class-name">Integer</span> id<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token class-name">ResponseEntity</span><span class="token punctuation">.</span><span class="token function">ok</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">body</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="使用-Validated来指定不同的组别条件下使用不同的校验方法"><a href="#使用-Validated来指定不同的组别条件下使用不同的校验方法" class="headerlink" title="使用@Validated来指定不同的组别条件下使用不同的校验方法"></a>使用@Validated来指定不同的组别条件下使用不同的校验方法</h4><ol>
<li>定义组别接口，为空即可<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>

    <span class="token annotation punctuation">@NotBlank</span><span class="token punctuation">(</span>groups <span class="token operator">=</span> <span class="token class-name">CreateGroup</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token comment">// 创建时需要校验</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> username<span class="token punctuation">;</span>

    <span class="token annotation punctuation">@Size</span><span class="token punctuation">(</span>min <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">,</span> max <span class="token operator">=</span> <span class="token number">14</span><span class="token punctuation">,</span> groups <span class="token operator">=</span> <span class="token class-name">UpdateGroup</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token comment">// 更新时需要校验</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> password<span class="token punctuation">;</span>

    <span class="token comment">// getters and setters</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li>定义类的校验规则，根据组别来写<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>

    <span class="token annotation punctuation">@NotBlank</span><span class="token punctuation">(</span>groups <span class="token operator">=</span> <span class="token class-name">CreateGroup</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token comment">// 创建时需要校验</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> username<span class="token punctuation">;</span>

    <span class="token annotation punctuation">@Size</span><span class="token punctuation">(</span>min <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">,</span> max <span class="token operator">=</span> <span class="token number">14</span><span class="token punctuation">,</span> groups <span class="token operator">=</span> <span class="token class-name">UpdateGroup</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token comment">// 更新时需要校验</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> password<span class="token punctuation">;</span>

    <span class="token comment">// getters and setters</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li>不同的方法上的传参使用不同的组别来进行校验<pre class="line-numbers language-java" data-language="java"><code class="language-java">
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>

    <span class="token annotation punctuation">@NotBlank</span><span class="token punctuation">(</span>groups <span class="token operator">=</span> <span class="token class-name">CreateGroup</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token comment">// 创建时需要校验</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> username<span class="token punctuation">;</span>

    <span class="token annotation punctuation">@Size</span><span class="token punctuation">(</span>min <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">,</span> max <span class="token operator">=</span> <span class="token number">14</span><span class="token punctuation">,</span> groups <span class="token operator">=</span> <span class="token class-name">UpdateGroup</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token comment">// 更新时需要校验</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> password<span class="token punctuation">;</span>

    <span class="token comment">// getters and setters</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ol>
<h4 id="全局处理Controller层异常"><a href="#全局处理Controller层异常" class="headerlink" title="全局处理Controller层异常"></a>全局处理Controller层异常</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@ControllerAdvice</span>
<span class="token annotation punctuation">@ResponseBody</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GlobalExceptionHandler</span> <span class="token punctuation">{</span>

    <span class="token comment">/**
     * 请求参数异常处理
     */</span>
    <span class="token annotation punctuation">@ExceptionHandler</span><span class="token punctuation">(</span><span class="token class-name">MethodArgumentNotValidException</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token class-name">ResponseEntity</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> <span class="token function">handleMethodArgumentNotValidException</span><span class="token punctuation">(</span><span class="token class-name">MethodArgumentNotValidException</span> ex<span class="token punctuation">,</span> <span class="token class-name">HttpServletRequest</span> request<span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="JPA"><a href="#JPA" class="headerlink" title="JPA"></a>JPA</h3><ul>
<li><code>@Entity</code>声明一个类对应一个数据库实体。</li>
<li><code>@Table</code>&nbsp;设置表名</li>
<li><code>@Id</code>声明主键</li>
<li><code>GeneratedValue</code> 主键填充策略<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">enum</span> <span class="token class-name">GenerationType</span> <span class="token punctuation">{</span>

    <span class="token comment">/**
     * 使用一个特定的数据库表格来保存主键
     * 持久化引擎通过关系数据库的一张特定的表格来生成主键,
     */</span>
    <span class="token constant">TABLE</span><span class="token punctuation">,</span>

    <span class="token comment">/**
     *在某些数据库中,不支持主键自增长,比如Oracle、PostgreSQL其提供了一种叫做"序列(sequence)"的机制生成主键
     */</span>
    <span class="token constant">SEQUENCE</span><span class="token punctuation">,</span>

    <span class="token comment">/**
     * 主键自增长
     */</span>
    <span class="token constant">IDENTITY</span><span class="token punctuation">,</span>

    <span class="token comment">/**
     *把主键生成策略交给持久化引擎(persistence engine),
     *持久化引擎会根据数据库在以上三种主键生成 策略中选择其中一种
     */</span>
    <span class="token constant">AUTO</span> <span class="token comment">//默认</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><code>@Column</code> 设置字段<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//设置字段类型，并且增加一个默认值</span>
<span class="token annotation punctuation">@Column</span><span class="token punctuation">(</span>columnDefinition <span class="token operator">=</span> <span class="token string">"tinyint(1) default 1"</span><span class="token punctuation">)</span>
<span class="token keyword">private</span> <span class="token class-name">Boolean</span> enabled<span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li>
<li><code>@Transient</code> 声明不需要持久化的字段，也就是不需要保存进数据库</li>
<li>声明大字段:<ul>
<li>TEXT：用于存储大量的非二进制字符串（字符数据）。它可以存储最多 2^16 - 1 字符。  </li>
<li>BLOB：用于存储大量的二进制数据。它可以存储最多 2^16 - 1 字节的数据。  </li>
<li>MEDIUMTEXT 和 MEDIUMBLOB：这两种类型可以存储更多的数据，最多 2^24 - 1 字符或字节。  </li>
<li>LONGTEXT 和 LONGBLOB：这两种类型可以存储最多 2^32 - 1 字符或字节的数据，适用于非常大的数据。<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Lob</span>
<span class="token comment">//指定 Lob 类型数据的获取策略， FetchType.EAGER 表示非延迟加载，而 FetchType.LAZY 表示延迟加载 ；</span>
<span class="token annotation punctuation">@Basic</span><span class="token punctuation">(</span>fetch <span class="token operator">=</span> <span class="token class-name">FetchType</span><span class="token punctuation">.</span><span class="token constant">EAGER</span><span class="token punctuation">)</span>
<span class="token comment">//columnDefinition 属性指定数据表对应的 Lob 字段类型</span>
<span class="token annotation punctuation">@Column</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"content"</span><span class="token punctuation">,</span> columnDefinition <span class="token operator">=</span> <span class="token string">"LONGTEXT NOT NULL"</span><span class="token punctuation">)</span>
<span class="token keyword">private</span> <span class="token class-name">String</span> content<span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
</li>
<li>创建枚举字段：自己创建枚举类，然后在枚举字段上加上@Enumerated注解即可<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">enum</span> <span class="token class-name">Gender</span> <span class="token punctuation">{</span>
    <span class="token function">MALE</span><span class="token punctuation">(</span><span class="token string">"男性"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token function">FEMALE</span><span class="token punctuation">(</span><span class="token string">"女性"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">private</span> <span class="token class-name">String</span> value<span class="token punctuation">;</span>
    <span class="token class-name">Gender</span><span class="token punctuation">(</span><span class="token class-name">String</span> str<span class="token punctuation">)</span><span class="token punctuation">{</span>
        value<span class="token operator">=</span>str<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token annotation punctuation">@Entity</span>
<span class="token annotation punctuation">@Table</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"role"</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Role</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Id</span>
    <span class="token annotation punctuation">@GeneratedValue</span><span class="token punctuation">(</span>strategy <span class="token operator">=</span> <span class="token class-name">GenerationType</span><span class="token punctuation">.</span><span class="token constant">IDENTITY</span><span class="token punctuation">)</span>
    <span class="token keyword">private</span> <span class="token class-name">Long</span> id<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> description<span class="token punctuation">;</span>
    <span class="token annotation punctuation">@Enumerated</span><span class="token punctuation">(</span><span class="token class-name">EnumType</span><span class="token punctuation">.</span><span class="token constant">STRING</span><span class="token punctuation">)</span>
    <span class="token keyword">private</span> <span class="token class-name">Gender</span> gender<span class="token punctuation">;</span>
    省略getter<span class="token operator">/</span>setter<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li>审计: <del>待补</del></li>
<li>删除/修改数据:<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Repository</span>
<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">UserRepository</span> <span class="token keyword">extends</span> <span class="token class-name">JpaRepository</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>

    <span class="token annotation punctuation">@Modifying</span>
    <span class="token annotation punctuation">@Transactional</span><span class="token punctuation">(</span>rollbackFor <span class="token operator">=</span> <span class="token class-name">Exception</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>
    <span class="token keyword">void</span> <span class="token function">deleteByUserName</span><span class="token punctuation">(</span><span class="token class-name">String</span> userName<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li>关联关系：<ul>
<li><code>@OneToOne</code>&nbsp;声明一对一关系</li>
<li><code>@OneToMany</code>&nbsp;声明一对多关系</li>
<li><code>@ManyToOne</code>&nbsp;声明多对一关系</li>
<li><code>@ManyToMany</code>&nbsp;声明多对多关系</li>
</ul>
</li>
</ul>
<h3 id="JSON处理"><a href="#JSON处理" class="headerlink" title="JSON处理"></a>JSON处理</h3><ul>
<li><code>@JsonIgnoreProperties</code> 用于类上</li>
<li><code>JsonIgnore</code> 用于属性上<br>进行序列化时，会忽略标记的值，示例：<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token punctuation">{</span>
    <span class="token string">"from"</span><span class="token operator">:</span> <span class="token string">"user1"</span><span class="token punctuation">,</span>
    <span class="token string">"to"</span><span class="token operator">:</span> <span class="token string">"user2"</span><span class="token punctuation">,</span>
    <span class="token string">"content"</span><span class="token operator">:</span> <span class="token punctuation">{</span><span class="token string">"text"</span><span class="token operator">:</span> <span class="token string">"Hello"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token string">"image"</span><span class="token operator">:</span> <span class="token string">"image_url"</span><span class="token punctuation">,</span>
    <span class="token string">"readed"</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
    <span class="token string">"date"</span><span class="token operator">:</span> <span class="token string">"2023-01-01 12:00:00"</span>
<span class="token punctuation">}</span>
<span class="token comment">//在类上的image字段上标记 @Ignore</span>
那么序列化之后的结果是
<span class="token punctuation">{</span>
    <span class="token string">"from"</span><span class="token operator">:</span> <span class="token string">"user1"</span><span class="token punctuation">,</span>
    <span class="token string">"to"</span><span class="token operator">:</span> <span class="token string">"user2"</span><span class="token punctuation">,</span>
    <span class="token string">"content"</span><span class="token operator">:</span> <span class="token punctuation">{</span><span class="token string">"text"</span><span class="token operator">:</span> <span class="token string">"Hello"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token string">"readed"</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
    <span class="token string">"date"</span><span class="token operator">:</span> <span class="token string">"2023-01-01 12:00:00"</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li>JSON扁平化：<code>@JsonUnwrapped</code>.</li>
</ul>
<h3 id="测试相关"><a href="#测试相关" class="headerlink" title="测试相关"></a>测试相关</h3><ul>
<li>@ActiveProfiles(“prod”) 作用于类上，用于生命生效的Spring配置文件<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@SpringBootTest</span><span class="token punctuation">(</span>webEnvironment <span class="token operator">=</span> <span class="token constant">RANDOM_PORT</span><span class="token punctuation">)</span>
<span class="token annotation punctuation">@ActiveProfiles</span><span class="token punctuation">(</span><span class="token string">"test"</span><span class="token punctuation">)</span>
<span class="token annotation punctuation">@Slf4j</span>
<span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">TestBase</span> <span class="token punctuation">{</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><code>@Test</code> 声明为一个测试方法，<code>@Transactional</code>用于回滚测试数据， <strong>注意：</strong> @Transactional无法回滚MongoDB等NoSQL数据库，MongoDB支持副本集回滚事务</li>
</ul>
<h3 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h3><p>控制反转，将new 交由Spring框架管理，Bean的生命周期都由Spring调用<br>优点：</p>
<ol>
<li>资源变得容易管理：</li>
<li>降低对象之间的耦合和依赖</li>
</ol>
<h1 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h1><h3 id="自动装配"><a href="#自动装配" class="headerlink" title="自动装配"></a>自动装配</h3><h5 id="EnableAutoConfiguration：实现自动装配的核心"><a href="#EnableAutoConfiguration：实现自动装配的核心" class="headerlink" title="@EnableAutoConfiguration：实现自动装配的核心"></a>@EnableAutoConfiguration：实现自动装配的核心</h5><h1 id="Spring源码阅读"><a href="#Spring源码阅读" class="headerlink" title="Spring源码阅读"></a>Spring源码阅读</h1><p>推荐文章：<a target="_blank" rel="noopener" href="https://github.com/xuchengsheng/spring-reading/tree/master">xuchengsheng/spring-reading(github.com)</a></p>
<h2 id="Resource"><a href="#Resource" class="headerlink" title="Resource"></a>Resource</h2><p><code>Resource</code> 是Spring框架中用于简化和统一对底层资源（如文件、classpath 资源、URL 等）的访问的一个核心接口。</p>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>classpath 是 Java 虚拟机（JVM）和 Java 编译器用来查找类文件和资源文件的路径。它指定了 Java 应用程序在运行时或编译时需要的类和资源的位置。classpath 可以包含目录、JAR 文件或 ZIP 文件。</p>
<h3 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h3><ol>
<li>统一的资源抽象，无论资源来自文件系统、classpath、URL还是其他，Resource提供统一的抽象</li>
<li>资源描述通过getDescription来获得底层资源提供的描述性信息</li>
<li>读取能力：Resource提供了getInputStream方法，允许直接读取资源内容而无需关心资源的实际来源。</li>
<li>存在与可读性：Resource提供了两个方法来确定资源是否存在以及是否可读。</li>
<li>开放性检查：isOpen()用来检查资源是否标识一个已经打开的流，有助于避免重复读取流资源。</li>
<li>文件访问：当资源代表一个文件夹中的文件时，可以通过getFile()直接访问该文件</li>
<li>Spring提供了多种Resource的实现</li>
</ol>
<h3 id="源码："><a href="#源码：" class="headerlink" title="源码："></a>源码：</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/**
 * 表示可以提供输入流的资源或对象的接口。
 */</span>
<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">InputStreamSource</span> <span class="token punctuation">{</span>

	<span class="token comment">/**
	 * 返回基础资源内容的 InputStream。
	 * 期望每次调用都会创建一个新的流。
	 * 当我们考虑到像 JavaMail 这样的API时，这个要求尤为重要，因为在创建邮件附件时，JavaMail需要能够多次读取流。对于这样的用例，要求每个 getInputStream() 调用都返回一个新的流。
	 * @return 基础资源的输入流（不能为 null）
	 * @throws java.io.FileNotFoundException 如果基础资源不存在
	 * @throws IOException 如果无法打开内容流
	 */</span>
	<span class="token class-name">InputStream</span> <span class="token function">getInputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span><span class="token punctuation">;</span>

<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="ResourceLoader"><a href="#ResourceLoader" class="headerlink" title="ResourceLoader"></a>ResourceLoader</h2><p>Spring 框架中的一个关键接口，它定义了如何获取资源（例如类路径资源、文件系统资源或网页资源）的策略。这个接口是 Spring 资源加载抽象的核心，使得应用程序可以从不同的资源位置以统一的方式加载资源。<br>用于获取Resource对象的工厂。</p>
<h3 id="主要功能-1"><a href="#主要功能-1" class="headerlink" title="主要功能"></a>主要功能</h3><ol>
<li>统一的资源加载，提供了一个标准化的方法来加载资源，不论资源是存放在类路径、文件系统、网络URL还是其他位置</li>
<li>资源位置解析：根据提供的资源字符串位置，可以确定资源的类型，并且为其创建响应的Resource实例</li>
<li>返回Resource实例：getResource(String location)方法，返回一个Resource对象，代表了指定位置的资源。</li>
<li>与ClassLoader交互：通过getClassLoader()方法返回其关联的ClassLoader</li>
<li>扩展性：<code>ResourceLoader</code>&nbsp;是一个接口，这意味着我们可以实现自己的资源加载策略，或者扩展默认的策略以满足特定需求。</li>
<li>内置实现与整合：Spring 提供了默认的&nbsp;<code>ResourceLoader</code>&nbsp;实现，如&nbsp;<code>DefaultResourceLoader</code>。但更重要的是，<code>org.springframework.context.ApplicationContext</code>&nbsp;也实现了&nbsp;<code>ResourceLoader</code>，这意味着 Spring 上下文本身就是一个资源加载器。</li>
</ol>
<h3 id="源码：-1"><a href="#源码：-1" class="headerlink" title="源码："></a>源码：</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">ResourceLoader</span> <span class="token punctuation">{</span>
	<span class="token comment">//默认的classpath路径</span>
    <span class="token class-name">String</span> <span class="token constant">CLASSPATH_URL_PREFIX</span> <span class="token operator">=</span> <span class="token string">"classpath:"</span><span class="token punctuation">;</span>

    <span class="token class-name">Resource</span> <span class="token function">getResource</span><span class="token punctuation">(</span><span class="token class-name">String</span> var1<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token annotation punctuation">@Nullable</span>
    <span class="token class-name">ClassLoader</span> <span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>默认实现</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DefaultResourceLoader</span> <span class="token keyword">implements</span> <span class="token class-name">ResourceLoader</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Nullable</span>
    <span class="token keyword">private</span> <span class="token class-name">ClassLoader</span> classLoader<span class="token punctuation">;</span>
    <span class="token comment">//自定义的协议</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ProtocolResolver</span><span class="token punctuation">&gt;</span></span> protocolResolvers <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedHashSet</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">//缓存</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Class</span><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span><span class="token punctuation">,</span> <span class="token class-name">Map</span><span class="token punctuation">&lt;</span><span class="token class-name">Resource</span><span class="token punctuation">,</span> <span class="token operator">?</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> resourceCaches <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentHashMap</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    
<span class="token comment">/* 
省略构造方法和一些不重要的方法
*/</span>

    <span class="token keyword">public</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Resource</span><span class="token punctuation">,</span> <span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token function">getResourceCache</span><span class="token punctuation">(</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> valueType<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token class-name">Map</span><span class="token punctuation">)</span><span class="token keyword">this</span><span class="token punctuation">.</span>resourceCaches<span class="token punctuation">.</span><span class="token function">computeIfAbsent</span><span class="token punctuation">(</span>valueType<span class="token punctuation">,</span> <span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentHashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>


<span class="token comment">// 根据不同的路径参数来返回对应的Resource</span>
    <span class="token keyword">public</span> <span class="token class-name">Resource</span> <span class="token function">getResource</span><span class="token punctuation">(</span><span class="token class-name">String</span> location<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Assert</span><span class="token punctuation">.</span><span class="token function">notNull</span><span class="token punctuation">(</span>location<span class="token punctuation">,</span> <span class="token string">"Location must not be null"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Iterator</span> var2 <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getProtocolResolvers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">Resource</span> resource<span class="token punctuation">;</span>
        <span class="token keyword">do</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>var2<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>location<span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getResourceByPath</span><span class="token punctuation">(</span>location<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>

                <span class="token keyword">if</span> <span class="token punctuation">(</span>location<span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token string">"classpath:"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ClassPathResource</span><span class="token punctuation">(</span>location<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token string">"classpath:"</span><span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>

                <span class="token keyword">try</span> <span class="token punctuation">{</span>
                    <span class="token class-name">URL</span> url <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">URL</span><span class="token punctuation">(</span>location<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token class-name">Resource</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token class-name">ResourceUtils</span><span class="token punctuation">.</span><span class="token function">isFileURL</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token keyword">new</span> <span class="token class-name">FileUrlResource</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token keyword">new</span> <span class="token class-name">UrlResource</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">MalformedURLException</span> var5<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getResourceByPath</span><span class="token punctuation">(</span>location<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>

            <span class="token class-name">ProtocolResolver</span> protocolResolver <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">ProtocolResolver</span><span class="token punctuation">)</span>var2<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            resource <span class="token operator">=</span> protocolResolver<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>location<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">while</span><span class="token punctuation">(</span>resource <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">return</span> resource<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">protected</span> <span class="token class-name">Resource</span> <span class="token function">getResourceByPath</span><span class="token punctuation">(</span><span class="token class-name">String</span> path<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ClassPathContextResource</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">protected</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">ClassPathContextResource</span> <span class="token keyword">extends</span> <span class="token class-name">ClassPathResource</span> <span class="token keyword">implements</span> <span class="token class-name">ContextResource</span> <span class="token punctuation">{</span>
        <span class="token keyword">public</span> <span class="token class-name">ClassPathContextResource</span><span class="token punctuation">(</span><span class="token class-name">String</span> path<span class="token punctuation">,</span> <span class="token annotation punctuation">@Nullable</span> <span class="token class-name">ClassLoader</span> classLoader<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">super</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span> classLoader<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getPathWithinContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getPath</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">public</span> <span class="token class-name">Resource</span> <span class="token function">createRelative</span><span class="token punctuation">(</span><span class="token class-name">String</span> relativePath<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">String</span> pathToUse <span class="token operator">=</span> <span class="token class-name">StringUtils</span><span class="token punctuation">.</span><span class="token function">applyRelativePath</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getPath</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> relativePath<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ClassPathContextResource</span><span class="token punctuation">(</span>pathToUse<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>computeIfAbsent 是 Java 8 引入的 Map 接口中的一个默认方法。它用于在 Map 中查找指定键的值，如果该键不存在，则使用提供的映射函数计算该键的值，并将其插入到 Map 中，第二个参数可以传入lambda</p>
<h2 id="ResourcePatternResolver"><a href="#ResourcePatternResolver" class="headerlink" title="ResourcePatternResolver"></a>ResourcePatternResolver</h2><p>用于解析资源模式，支持通过模式匹配检索多个资源，支持通过模式匹配检索多个资源。</p>
<h3 id="主要功能-2"><a href="#主要功能-2" class="headerlink" title="主要功能"></a>主要功能</h3><ol>
<li><p><strong>资源模式解析</strong></p>
<ul>
<li>通过<code>getResources(String locationPattern)</code>方法，支持使用通配符的资源模式，如<code>classpath*:com/example/**/*.xml</code>，用于检索匹配特定模式的多个资源。</li>
</ul>
</li>
<li><p><strong>资源获取</strong></p>
<ul>
<li>通过<code>getResources(Resource location)</code>方法，根据给定的资源对象，返回匹配的资源数组。这使得可以获取与特定资源相关联的其他资源，例如获取与给定类路径下的一个文件相关的所有资源。</li>
</ul>
</li>
<li><p><strong>多种资源位置支持</strong></p>
<ul>
<li>可以处理不同的资源位置，包括类路径（classpath）、文件系统、URL等。这使得应用程序能够以不同的方式组织和存储资源，而不影响资源的检索和加载。</li>
</ul>
</li>
<li><p><strong>灵活的资源加载</strong></p>
<ul>
<li>结合<code>ResourceLoader</code>的能力，<code>ResourcePatternResolver</code>允许在应用程序中以统一的方式加载各种资源，而无需关心底层资源的存储位置或形式。</li>
</ul>
</li>
<li><p><strong>通用资源操作</strong></p>
<ul>
<li>通过<code>Resource</code>接口，提供了对资源的通用操作，例如获取资源的URL、输入流、文件句柄等。</li>
</ul>
</li>
</ol>
<h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">ResourcePatternResolver</span> <span class="token keyword">extends</span> <span class="token class-name">ResourceLoader</span> <span class="token punctuation">{</span>

    <span class="token comment">/**
     * 类路径匹配所有资源的伪 URL 前缀："classpath*:"
     * 这与 ResourceLoader 的类路径 URL 前缀不同，它检索给定名称（例如 "/beans.xml"）的
     * 所有匹配资源，例如在所有部署的 JAR 文件的根目录中。
     * 详见 org.springframework.core.io.ResourceLoader#CLASSPATH_URL_PREFIX
     */</span>
    <span class="token class-name">String</span> <span class="token constant">CLASSPATH_ALL_URL_PREFIX</span> <span class="token operator">=</span> <span class="token string">"classpath*:"</span><span class="token punctuation">;</span>

    <span class="token comment">/**
     * 将给定的位置模式解析为 Resource 对象。
     * 应尽可能避免指向相同物理资源的重叠资源条目。结果应具有集合语义。
     * @param locationPattern 要解析的位置模式
     * @return 相应的 Resource 对象数组
     * @throws IOException 如果发生 I/O 错误
     */</span>
    <span class="token class-name">Resource</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">getResources</span><span class="token punctuation">(</span><span class="token class-name">String</span> locationPattern<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="DocumentLoader"><a href="#DocumentLoader" class="headerlink" title="DocumentLoader"></a>DocumentLoader</h2><p>用于加载和解析 XML 文档</p>
<h3 id="主要功能-3"><a href="#主要功能-3" class="headerlink" title="主要功能"></a>主要功能</h3><ol>
<li>加载XML文档</li>
<li>解析XML文档</li>
<li>支持验证：通过指定验证模式（如 DTD 或 XML Schema 验证），可以确保文档的结构和内容符合规定的标准。</li>
<li>处理实体引用</li>
<li>错误处理</li>
</ol>
<h2 id="MetadataReader"><a href="#MetadataReader" class="headerlink" title="MetadataReader"></a>MetadataReader</h2><h3 id="一些重要概念"><a href="#一些重要概念" class="headerlink" title="一些重要概念"></a>一些重要概念</h3><p>内部类在编译后，其文件名格式为 OuterClass$InnerClass.class。</p>
<h3 id="主要功能-4"><a href="#主要功能-4" class="headerlink" title="主要功能"></a>主要功能</h3><ol>
<li>获取类的基本信息</li>
<li>获取类上的注解信息</li>
<li>获取方法上的注解信息</li>
<li>获取类的成员类信息</li>
<li>获取类的资源信息</li>
<li>获取类的超类信息</li>
</ol>
<h3 id="源码-1"><a href="#源码-1" class="headerlink" title="源码"></a>源码</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">MetadataReaderFactory</span> <span class="token punctuation">{</span>
    <span class="token class-name">MetadataReader</span> <span class="token function">getMetadataReader</span><span class="token punctuation">(</span><span class="token class-name">String</span> var1<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span><span class="token punctuation">;</span>

    <span class="token class-name">MetadataReader</span> <span class="token function">getMetadataReader</span><span class="token punctuation">(</span><span class="token class-name">Resource</span> var1<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">QingQiu</p>
  <div class="site-description" itemprop="description">个人网站，学习记录，面试记录和经验总结、互联网中一块属于自己的小窝</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">51</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">19</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Zuofw/zuofw-rpc" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Zuofw&#x2F;zuofw-rpc" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2022 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">QingQiu</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="站点总字数">408k</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  















  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
