<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"zuofw.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Kafka常见问题## Java API- 一个独立的Kafka服务器被称作broker,broker是集群的组成部分，每个集群都有一个broker同时充当了集群控制器的角色- kafka的主题被分为多个分区，分区存储在磁盘中- kafka的消息特点：消息会保留一段时间，即使应用程序下线，消息仍然会保存在kafka里，是基于磁盘的数据存储。- API使用：    - producer">
<meta property="og:type" content="article">
<meta property="og:title" content="深入浅出Kafka">
<meta property="og:url" content="https://zuofw.github.io/2024/09/03/19/index.html">
<meta property="og:site_name" content="QingQiu&#39;Blog">
<meta property="og:description" content="Kafka常见问题## Java API- 一个独立的Kafka服务器被称作broker,broker是集群的组成部分，每个集群都有一个broker同时充当了集群控制器的角色- kafka的主题被分为多个分区，分区存储在磁盘中- kafka的消息特点：消息会保留一段时间，即使应用程序下线，消息仍然会保存在kafka里，是基于磁盘的数据存储。- API使用：    - producer">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2024-09-03T06:58:19.000Z">
<meta property="article:modified_time" content="2024-09-08T09:43:22.792Z">
<meta property="article:author" content="QingQiu">
<meta property="article:tag" content="博客，学习，成长">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://zuofw.github.io/2024/09/03/19/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>深入浅出Kafka | QingQiu'Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>


<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">QingQiu'Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">清秋的博客</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-fa fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-fa fa-archive"></i>归档</a>

  </li>
        <li class="menu-item menu-item-github">

    <a href="https://github.com/Zuofw" rel="noopener" target="_blank"><i class="fa fa-fw fa-fab fa-github"></i>Github</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zuofw.github.io/2024/09/03/19/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="QingQiu">
      <meta itemprop="description" content="个人网站，学习记录，面试记录和经验总结、互联网中一块属于自己的小窝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="QingQiu'Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          深入浅出Kafka
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-09-03 14:58:19" itemprop="dateCreated datePublished" datetime="2024-09-03T14:58:19+08:00">2024-09-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-09-08 17:43:22" itemprop="dateModified" datetime="2024-09-08T17:43:22+08:00">2024-09-08</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.6k</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h1><h2 id="常见问题-Java-API-一个独立的Kafka服务器被称作broker-broker是集群的组成部分，每个集群都有一个broker同时充当了集群控制器的角色-kafka的主题被分为多个分区，分区存储在磁盘中-kafka的消息特点：消息会保留一段时间，即使应用程序下线，消息仍然会保存在kafka里，是基于磁盘的数据存储。-API使用：-producer-record的参数，topic-key-value-key可以省略，当省略时就是一个没有key的value，key一般用于把相同key的数据写入同一个分区里-send默认是发送并忘记，send会返回一个Future对象使用-get方法得到RecordMetadata对象，可以获取消息的偏移量-异步发送-send-record-回调函数类-，回调函数需要实现Callback类，并且重写其中的方法-配置设置：-1-acks-x3D-0-生产者无需等待服务器的响应，但消息丢失时不会知晓，-x3D-1，只要集群的首领节点收到即可，-x3D-all需要所有参与复制的节点都受到消息才会受到服务器的响应，不建议-2-buffer-memory设置producer内存缓冲区大小，-3-compression-type设置消息的压缩格式，默认不会压缩-4-retries重试次数-5-batch-size-当多个消息被发送到同一个分区时，producer会把他们放在一起，当作一个批次，这个参数指定一个批次可以使用的最大内存-6-max-in-flight-requests-per-connection-生产者在接收到服务器响应之前可以发送多少个消息，设置为-1-时可以保证消息是按照顺序写入的，适合在银行等严格要求顺序的时候使用-自定义分区：-consumer-API-1-consumer类的创建方式和producer一致，但是推荐指定-group-id来指定属于哪个群组，-2-consumer-subscirbe-订阅相关的topic，同时支持正则表达式-consumer-subscribe-Arrays-asList-quot-topic1-quot-quot-topic2-quot-3-consumer-poll-xxx-参数是轮询的阻塞时间，会等待broker返回数据-4-记得-close-5-建议一个线程中只有一个消费者-配置：-大部分和producer类似-fetch-min-bytes消费者从服务器获取记录的最小字节数，当数据量大于等于这个值才会被返回给消费者-提交和偏移量：消费者往-consumer-offset特殊主题发送消息，消息包含每个分区的偏移量，当触发再均衡时，消费者会读取每个分区组后一次提交的偏移量，然后从偏移量指定的地方开始处理-提交方式：-1-自动提交-每隔一段时间自动提交一次-2-提交当前偏移量-设置auto-commit-offset为false-然后使用commitSync-提交偏移量，会提交最新的一次由poll获得的偏移量-3-异步提交：commitAsync-，也可使用回调函数来处理-4-可以提交特定偏移量，而不是最后一次poll得到的偏移量-通过实现-ConsumerRebalanceListener接口来定义在consumer失去对分区的所有权时需要处理的事件，可在这里使用-seek-方法加上自定义的函数来实现从数据库中获得偏移量-Kafka本体-优势高吞吐，高性能，持久化-将消息持久化到磁盘，通过将数据持久化硬盘，以及follower节点来防止数据丢失-缺点是异步的不适合电商场景-架构设计-Producer-Consumer-Topic-主题，由用户定义并配置在Kafka服务器，建立Producer和Consumer之间的订阅关系，身缠这发送消息到特定的Topic下，消费者从这个Topic下消费消息。逻辑概念，相当于数据库中的表-Partition-消息分区，一个Topic可以分为多个partition，partition是一个有序的队列，partition的每条消息都会被分配一个有序的id-offset-物理实际概念，每一个partition对应一个log，producer生产的数据会不断地追加到该log文件末端，且每条数据都有自己的offset。系哦啊飞着组中的每个消费者都会实时记录自己消费到哪个offset-Broker-一台Kafka就是一个broker，一个集群由多个broker组成，一个broker可以容纳多个topic-ConsumerGroup-消费者组，用于归组同类消费者。每个consumer属于一个特定的consumer-group，多个消费者可以共同消费一个Topic下的消息，每个消费者获取部分消息。-一个Partition对应一个唯一的文件夹，文件夹下使用的是Segment-File的存储方式进行存储。将大文件拆成小文件，分为索引未见和数据文件-基本流程-producer先从zookeeper的broker-x2F-x2F-state节点找到该partiton的leader-producer将消息发送给该leader-leader将消息写出本地log-follower从leader-pull-消息-写入本地log，后向leader发送ACK-leader收到所有ISR中的replication的ACK，增加HT-high-watermark-，最后commit-的offset-并向producer发送ACK-生产过程1-Producer创建时，先创建一个Sender线程并且设置守护线程2-生产的消息经过拦截器-gt-序列化器-gt-分区器，将消息存在缓冲区3-批量发送的条件：缓冲区数据大小达到batch-size或者linger-ms达到上限4-发往指定分区，最后到达broker-acks-x3D-0，消息放到缓冲区就认为发送完成-acks-x3D-1消息写到主分区即可完成，如果主分区收到消息之后宕机，副本分区来不及同步消息，消息就会丢失-acks-x3D-all-等待所有的ISR副本的缺人记录5-如果设置了重试次数并且大于0，就会进行重试6-成功，返回元数据给生产者ISR（In-Sync-Replicas）是指与领导者副本保持同步的副本集合-生产者Offset消息写入的时候，每一个分区都有一个offset，即每个分区的最新最大的offset。-消费者Offset不同消费组中的消费者可以针对一个分区存储不同的Offset，互不影响。-LogSegment日志文件的组成部分-Leader选举-Kafka会在Zookeeper上针对每个Topic维护一个成为ISR的集合-当集合中副本都跟Leader同的副本同步之后，kafka才会认为消息已提交-只有这些跟Leader保持同步的Follower才应该被选作新的Leader"><a href="#常见问题-Java-API-一个独立的Kafka服务器被称作broker-broker是集群的组成部分，每个集群都有一个broker同时充当了集群控制器的角色-kafka的主题被分为多个分区，分区存储在磁盘中-kafka的消息特点：消息会保留一段时间，即使应用程序下线，消息仍然会保存在kafka里，是基于磁盘的数据存储。-API使用：-producer-record的参数，topic-key-value-key可以省略，当省略时就是一个没有key的value，key一般用于把相同key的数据写入同一个分区里-send默认是发送并忘记，send会返回一个Future对象使用-get方法得到RecordMetadata对象，可以获取消息的偏移量-异步发送-send-record-回调函数类-，回调函数需要实现Callback类，并且重写其中的方法-配置设置：-1-acks-x3D-0-生产者无需等待服务器的响应，但消息丢失时不会知晓，-x3D-1，只要集群的首领节点收到即可，-x3D-all需要所有参与复制的节点都受到消息才会受到服务器的响应，不建议-2-buffer-memory设置producer内存缓冲区大小，-3-compression-type设置消息的压缩格式，默认不会压缩-4-retries重试次数-5-batch-size-当多个消息被发送到同一个分区时，producer会把他们放在一起，当作一个批次，这个参数指定一个批次可以使用的最大内存-6-max-in-flight-requests-per-connection-生产者在接收到服务器响应之前可以发送多少个消息，设置为-1-时可以保证消息是按照顺序写入的，适合在银行等严格要求顺序的时候使用-自定义分区：-consumer-API-1-consumer类的创建方式和producer一致，但是推荐指定-group-id来指定属于哪个群组，-2-consumer-subscirbe-订阅相关的topic，同时支持正则表达式-consumer-subscribe-Arrays-asList-quot-topic1-quot-quot-topic2-quot-3-consumer-poll-xxx-参数是轮询的阻塞时间，会等待broker返回数据-4-记得-close-5-建议一个线程中只有一个消费者-配置：-大部分和producer类似-fetch-min-bytes消费者从服务器获取记录的最小字节数，当数据量大于等于这个值才会被返回给消费者-提交和偏移量：消费者往-consumer-offset特殊主题发送消息，消息包含每个分区的偏移量，当触发再均衡时，消费者会读取每个分区组后一次提交的偏移量，然后从偏移量指定的地方开始处理-提交方式：-1-自动提交-每隔一段时间自动提交一次-2-提交当前偏移量-设置auto-commit-offset为false-然后使用commitSync-提交偏移量，会提交最新的一次由poll获得的偏移量-3-异步提交：commitAsync-，也可使用回调函数来处理-4-可以提交特定偏移量，而不是最后一次poll得到的偏移量-通过实现-ConsumerRebalanceListener接口来定义在consumer失去对分区的所有权时需要处理的事件，可在这里使用-seek-方法加上自定义的函数来实现从数据库中获得偏移量-Kafka本体-优势高吞吐，高性能，持久化-将消息持久化到磁盘，通过将数据持久化硬盘，以及follower节点来防止数据丢失-缺点是异步的不适合电商场景-架构设计-Producer-Consumer-Topic-主题，由用户定义并配置在Kafka服务器，建立Producer和Consumer之间的订阅关系，身缠这发送消息到特定的Topic下，消费者从这个Topic下消费消息。逻辑概念，相当于数据库中的表-Partition-消息分区，一个Topic可以分为多个partition，partition是一个有序的队列，partition的每条消息都会被分配一个有序的id-offset-物理实际概念，每一个partition对应一个log，producer生产的数据会不断地追加到该log文件末端，且每条数据都有自己的offset。系哦啊飞着组中的每个消费者都会实时记录自己消费到哪个offset-Broker-一台Kafka就是一个broker，一个集群由多个broker组成，一个broker可以容纳多个topic-ConsumerGroup-消费者组，用于归组同类消费者。每个consumer属于一个特定的consumer-group，多个消费者可以共同消费一个Topic下的消息，每个消费者获取部分消息。-一个Partition对应一个唯一的文件夹，文件夹下使用的是Segment-File的存储方式进行存储。将大文件拆成小文件，分为索引未见和数据文件-基本流程-producer先从zookeeper的broker-x2F-x2F-state节点找到该partiton的leader-producer将消息发送给该leader-leader将消息写出本地log-follower从leader-pull-消息-写入本地log，后向leader发送ACK-leader收到所有ISR中的replication的ACK，增加HT-high-watermark-，最后commit-的offset-并向producer发送ACK-生产过程1-Producer创建时，先创建一个Sender线程并且设置守护线程2-生产的消息经过拦截器-gt-序列化器-gt-分区器，将消息存在缓冲区3-批量发送的条件：缓冲区数据大小达到batch-size或者linger-ms达到上限4-发往指定分区，最后到达broker-acks-x3D-0，消息放到缓冲区就认为发送完成-acks-x3D-1消息写到主分区即可完成，如果主分区收到消息之后宕机，副本分区来不及同步消息，消息就会丢失-acks-x3D-all-等待所有的ISR副本的缺人记录5-如果设置了重试次数并且大于0，就会进行重试6-成功，返回元数据给生产者ISR（In-Sync-Replicas）是指与领导者副本保持同步的副本集合-生产者Offset消息写入的时候，每一个分区都有一个offset，即每个分区的最新最大的offset。-消费者Offset不同消费组中的消费者可以针对一个分区存储不同的Offset，互不影响。-LogSegment日志文件的组成部分-Leader选举-Kafka会在Zookeeper上针对每个Topic维护一个成为ISR的集合-当集合中副本都跟Leader同的副本同步之后，kafka才会认为消息已提交-只有这些跟Leader保持同步的Follower才应该被选作新的Leader" class="headerlink" title="常见问题## Java API- 一个独立的Kafka服务器被称作broker,broker是集群的组成部分，每个集群都有一个broker同时充当了集群控制器的角色- kafka的主题被分为多个分区，分区存储在磁盘中- kafka的消息特点：消息会保留一段时间，即使应用程序下线，消息仍然会保存在kafka里，是基于磁盘的数据存储。- API使用：    - producer        - record的参数，topic , key ,value key可以省略，当省略时就是一个没有key的value，key一般用于把相同key的数据写入同一个分区里        - send默认是发送并忘记，send会返回一个Future对象使用.get方法得到RecordMetadata对象，可以获取消息的偏移量        - 异步发送.send(record,回调函数类)，回调函数需要实现Callback类，并且重写其中的方法        - 配置设置：            1. acks = 0 生产者无需等待服务器的响应，但消息丢失时不会知晓， = 1，只要集群的首领节点收到即可，= all需要所有参与复制的节点都受到消息才会受到服务器的响应，不建议            2. buffer.memory设置producer内存缓冲区大小，            3. compression.type设置消息的压缩格式，默认不会压缩            4. retries重试次数            5. batch.size 当多个消息被发送到同一个分区时，producer会把他们放在一起，当作一个批次，这个参数指定一个批次可以使用的最大内存            6. max.in.flight.requests.per.connection 生产者在接收到服务器响应之前可以发送多少个消息，设置为 1 时可以保证消息是按照顺序写入的，适合在银行等严格要求顺序的时候使用        - 自定义分区：        -  consumer:        - API:            1. consumer类的创建方式和producer一致，但是推荐指定 group.id来指定属于哪个群组，            2. consumer.subscirbe()订阅相关的topic，同时支持正则表达式 consumer.subscribe(Arrays.asList(&quot;topic1&quot;, &quot;topic2&quot;));            3. consumer.poll(xxx) 参数是轮询的阻塞时间，会等待broker返回数据            4. 记得.close()            5. 建议一个线程中只有一个消费者        - 配置：            - 大部分和producer类似            - fetch.min.bytes消费者从服务器获取记录的最小字节数，当数据量大于等于这个值才会被返回给消费者        - 提交和偏移量：消费者往_consumer_offset特殊主题发送消息，消息包含每个分区的偏移量，当触发再均衡时，消费者会读取每个分区组后一次提交的偏移量，然后从偏移量指定的地方开始处理            - 提交方式：                1. 自动提交:每隔一段时间自动提交一次                2. 提交当前偏移量:设置auto.commit.offset为false.然后使用commitSync()提交偏移量，会提交最新的一次由poll获得的偏移量                3. 异步提交：commitAsync()，也可使用回调函数来处理                4. 可以提交特定偏移量，而不是最后一次poll得到的偏移量        - 通过实现 ConsumerRebalanceListener接口来定义在consumer失去对分区的所有权时需要处理的事件，可在这里使用.seek()方法加上自定义的函数来实现从数据库中获得偏移量## Kafka本体### 优势高吞吐，高性能，持久化(将消息持久化到磁盘，通过将数据持久化硬盘，以及follower节点来防止数据丢失)缺点是异步的不适合电商场景### 架构设计- Producer- Consumer- Topic 主题，由用户定义并配置在Kafka服务器，建立Producer和Consumer之间的订阅关系，身缠这发送消息到特定的Topic下，消费者从这个Topic下消费消息。逻辑概念，相当于数据库中的表- Partition 消息分区，一个Topic可以分为多个partition，partition是一个有序的队列，partition的每条消息都会被分配一个有序的id(offset) 物理实际概念，每一个partition对应一个log，producer生产的数据会不断地追加到该log文件末端，且每条数据都有自己的offset。系哦啊飞着组中的每个消费者都会实时记录自己消费到哪个offset- Broker 一台Kafka就是一个broker，一个集群由多个broker组成，一个broker可以容纳多个topic- ConsumerGroup 消费者组，用于归组同类消费者。每个consumer属于一个特定的consumer group，多个消费者可以共同消费一个Topic下的消息，每个消费者获取部分消息。- 一个Partition对应一个唯一的文件夹，文件夹下使用的是Segment File的存储方式进行存储。将大文件拆成小文件，分为索引未见和数据文件### 基本流程- producer先从zookeeper的broker/**/state节点找到该partiton的leader- producer将消息发送给该leader- leader将消息写出本地log- follower从leader pull 消息- 写入本地log，后向leader发送ACK- leader收到所有ISR中的replication的ACK，增加HT(high watermark ，最后commit 的offset)并向producer发送ACK#### 生产过程1. Producer创建时，先创建一个Sender线程并且设置守护线程2. 生产的消息经过拦截器->序列化器->分区器，将消息存在缓冲区3. 批量发送的条件：缓冲区数据大小达到batch.size或者linger.ms达到上限4. 发往指定分区，最后到达broker    - acks = 0，消息放到缓冲区就认为发送完成    - acks = 1消息写到主分区即可完成，如果主分区收到消息之后宕机，副本分区来不及同步消息，消息就会丢失    - acks = all 等待所有的ISR副本的缺人记录5. 如果设置了重试次数并且大于0，就会进行重试6. 成功，返回元数据给生产者ISR（In-Sync Replicas）是指与领导者副本保持同步的副本集合#### 生产者Offset消息写入的时候，每一个分区都有一个offset，即每个分区的最新最大的offset。#### 消费者Offset不同消费组中的消费者可以针对一个分区存储不同的Offset，互不影响。#### LogSegment日志文件的组成部分#### Leader选举- Kafka会在Zookeeper上针对每个Topic维护一个成为ISR的集合- 当集合中副本都跟Leader同的副本同步之后，kafka才会认为消息已提交- 只有这些跟Leader保持同步的Follower才应该被选作新的Leader"></a><a target="_blank" rel="noopener" href="https://javaguide.cn/high-performance/message-queue/kafka-questions-01.html">常见问题</a><br>## Java API<br>- 一个独立的Kafka服务器被称作broker,broker是集群的组成部分，每个集群都有一个broker同时充当了集群控制器的角色<br>- kafka的主题被分为多个分区，分区存储在磁盘中<br>- kafka的消息特点：消息会保留一段时间，即使应用程序下线，消息仍然会保存在kafka里，是基于磁盘的数据存储。<br>- API使用：<br>    - producer<br>        - record的参数，topic , key ,value key可以省略，当省略时就是一个没有key的value，key一般用于把相同key的数据写入同一个分区里<br>        - send默认是发送并忘记，send会返回一个Future对象使用.get方法得到RecordMetadata对象，可以获取消息的偏移量<br>        - 异步发送.send(record,回调函数类)，回调函数需要实现Callback类，并且重写其中的方法<br>        - 配置设置：<br>            1. acks = 0 生产者无需等待服务器的响应，但消息丢失时不会知晓， = 1，只要集群的首领节点收到即可，= all需要所有参与复制的节点都受到消息才会受到服务器的响应，不建议<br>            2. buffer.memory设置producer内存缓冲区大小，<br>            3. compression.type设置消息的压缩格式，默认不会压缩<br>            4. retries重试次数<br>            5. batch.size 当多个消息被发送到同一个分区时，producer会把他们放在一起，当作一个批次，这个参数指定一个批次可以使用的最大内存<br>            6. max.in.flight.requests.per.connection 生产者在接收到服务器响应之前可以发送多少个消息，设置为 1 时可以保证消息是按照顺序写入的，适合在银行等严格要求顺序的时候使用<br>        - 自定义分区：<br>    <pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DemoPartitionser</span> <span class="token keyword">implements</span> <span class="token class-name">Partitioner</span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> <span class="token class-name">String</span> myKey<span class="token punctuation">;</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">partition</span><span class="token punctuation">(</span><span class="token class-name">String</span> topic<span class="token punctuation">,</span> <span class="token class-name">Object</span> key<span class="token punctuation">,</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> keyBytes<span class="token punctuation">,</span> <span class="token class-name">Object</span> value<span class="token punctuation">,</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> valueBytes<span class="token punctuation">,</span> <span class="token class-name">Cluster</span> cluster<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 获取分区列表</span>
        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">PartitionInfo</span><span class="token punctuation">&gt;</span></span> partitionInfos <span class="token operator">=</span> cluster<span class="token punctuation">.</span><span class="token function">partitionsForTopic</span><span class="token punctuation">(</span>topic<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 获取分区数</span>
        <span class="token keyword">int</span> partitionNum <span class="token operator">=</span> partitionInfos<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>keyBytes <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>key <span class="token keyword">instanceof</span> <span class="token class-name">String</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"key is null or not a string"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 如果key为key，则分配到最后一个分区</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token string">"key"</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">return</span> partitionNum<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">//其余的消息都分配到最后一个分区</span>
        <span class="token keyword">return</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">abs</span><span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token punctuation">(</span>partitionNum <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token punctuation">}</span>

    <span class="token comment">/*
     * @description:
     * @author bronya
     * @date: 2024/4/20 14:50
     * @param map
     */</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">configure</span><span class="token punctuation">(</span><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token operator">?</span><span class="token punctuation">&gt;</span></span> map<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        myKey <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">)</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"key"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>    -  consumer:<br>        - API:<br>            1. consumer类的创建方式和producer一致，但是推荐指定 group.id来指定属于哪个群组，<br>            2. consumer.subscirbe()订阅相关的topic，同时支持正则表达式 <code>consumer.subscribe(Arrays.asList("topic1", "topic2"));</code><br>            3. consumer.poll(xxx) 参数是轮询的阻塞时间，会等待broker返回数据<br>            4. 记得.close()<br>            5. 建议一个线程中只有一个消费者<br>        - 配置：<br>            - 大部分和producer类似<br>            - fetch.min.bytes消费者从服务器获取记录的最小字节数，当数据量大于等于这个值才会被返回给消费者<br>        - 提交和偏移量：消费者往_consumer_offset特殊主题发送消息，消息包含每个分区的偏移量，当触发再均衡时，消费者会读取每个分区组后一次提交的偏移量，然后从偏移量指定的地方开始处理<br>            - 提交方式：<br>                1. 自动提交:每隔一段时间自动提交一次<br>                2. 提交当前偏移量:设置auto.commit.offset为false.然后使用commitSync()提交偏移量，会提交最新的一次由poll获得的偏移量<br>                3. 异步提交：commitAsync()，也可使用回调函数来处理<br>                4. 可以提交特定偏移量，而不是最后一次poll得到的偏移量<br>        - 通过实现 ConsumerRebalanceListener接口来定义在consumer失去对分区的所有权时需要处理的事件，可在这里使用.seek()方法加上自定义的函数来实现从数据库中获得偏移量<br>## Kafka本体<br>### 优势<br>高吞吐，高性能，持久化(将消息持久化到磁盘，通过将数据持久化硬盘，以及follower节点来防止数据丢失)<br>缺点是异步的不适合电商场景<br>### 架构设计<br>- Producer<br>- Consumer<br>- Topic 主题，由用户定义并配置在Kafka服务器，建立Producer和Consumer之间的订阅关系，身缠这发送消息到特定的Topic下，消费者从这个Topic下消费消息。逻辑概念，相当于数据库中的表<br>- Partition 消息分区，一个Topic可以分为多个partition，partition是一个有序的队列，partition的每条消息都会被分配一个有序的id(offset) 物理实际概念，每一个partition对应一个log，producer生产的数据会不断地追加到该log文件末端，且每条数据都有自己的offset。系哦啊飞着组中的每个消费者都会实时记录自己消费到哪个offset<br>- Broker 一台Kafka就是一个broker，一个集群由多个broker组成，一个broker可以容纳多个topic<br>- ConsumerGroup 消费者组，用于归组同类消费者。每个consumer属于一个特定的consumer group，多个消费者可以共同消费一个Topic下的消息，每个消费者获取部分消息。<br>- 一个Partition对应一个唯一的文件夹，文件夹下使用的是Segment File的存储方式进行存储。将大文件拆成小文件，分为索引未见和数据文件<br>### 基本流程<br>- producer先从zookeeper的broker/**/state节点找到该partiton的leader<br>- producer将消息发送给该leader<br>- leader将消息写出本地log<br>- follower从leader pull 消息<br>- 写入本地log，后向leader发送ACK<br>- leader收到所有ISR中的replication的ACK，增加HT(high watermark ，最后commit 的offset)并向producer发送ACK<br>#### 生产过程<br>1. Producer创建时，先创建一个Sender线程并且设置守护线程<br>2. 生产的消息经过拦截器-&gt;序列化器-&gt;分区器，将消息存在缓冲区<br>3. 批量发送的条件：缓冲区数据大小达到batch.size或者linger.ms达到上限<br>4. 发往指定分区，最后到达broker<br>    - acks = 0，消息放到缓冲区就认为发送完成<br>    - acks = 1消息写到主分区即可完成，如果主分区收到消息之后宕机，副本分区来不及同步消息，消息就会丢失<br>    - acks = all 等待所有的ISR副本的缺人记录<br>5. 如果设置了重试次数并且大于0，就会进行重试<br>6. 成功，返回元数据给生产者<br>ISR（In-Sync Replicas）是指与领导者副本保持同步的副本集合<br>#### 生产者Offset<br>消息写入的时候，每一个分区都有一个offset，即每个分区的最新最大的offset。<br>#### 消费者Offset<br>不同消费组中的消费者可以针对一个分区存储不同的Offset，互不影响。<br>#### LogSegment<br>日志文件的组成部分<br>#### Leader选举<br>- Kafka会在Zookeeper上针对每个Topic维护一个成为ISR的集合<br>- 当集合中副本都跟Leader同的副本同步之后，kafka才会认为消息已提交<br>- 只有这些跟Leader保持同步的Follower才应该被选作新的Leader</h2>
    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2024/09/02/00/" rel="prev" title="手写rpc">
      <i class="fa fa-chevron-left"></i> 手写rpc
    </a></div>
      <div class="post-nav-item">
    <a href="/2024/09/09/30/" rel="next" title="美团测开一面">
      美团测开一面 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Kafka"><span class="nav-number">1.</span> <span class="nav-text">Kafka</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98-Java-API-%E4%B8%80%E4%B8%AA%E7%8B%AC%E7%AB%8B%E7%9A%84Kafka%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%A2%AB%E7%A7%B0%E4%BD%9Cbroker-broker%E6%98%AF%E9%9B%86%E7%BE%A4%E7%9A%84%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86%EF%BC%8C%E6%AF%8F%E4%B8%AA%E9%9B%86%E7%BE%A4%E9%83%BD%E6%9C%89%E4%B8%80%E4%B8%AAbroker%E5%90%8C%E6%97%B6%E5%85%85%E5%BD%93%E4%BA%86%E9%9B%86%E7%BE%A4%E6%8E%A7%E5%88%B6%E5%99%A8%E7%9A%84%E8%A7%92%E8%89%B2-kafka%E7%9A%84%E4%B8%BB%E9%A2%98%E8%A2%AB%E5%88%86%E4%B8%BA%E5%A4%9A%E4%B8%AA%E5%88%86%E5%8C%BA%EF%BC%8C%E5%88%86%E5%8C%BA%E5%AD%98%E5%82%A8%E5%9C%A8%E7%A3%81%E7%9B%98%E4%B8%AD-kafka%E7%9A%84%E6%B6%88%E6%81%AF%E7%89%B9%E7%82%B9%EF%BC%9A%E6%B6%88%E6%81%AF%E4%BC%9A%E4%BF%9D%E7%95%99%E4%B8%80%E6%AE%B5%E6%97%B6%E9%97%B4%EF%BC%8C%E5%8D%B3%E4%BD%BF%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E4%B8%8B%E7%BA%BF%EF%BC%8C%E6%B6%88%E6%81%AF%E4%BB%8D%E7%84%B6%E4%BC%9A%E4%BF%9D%E5%AD%98%E5%9C%A8kafka%E9%87%8C%EF%BC%8C%E6%98%AF%E5%9F%BA%E4%BA%8E%E7%A3%81%E7%9B%98%E7%9A%84%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E3%80%82-API%E4%BD%BF%E7%94%A8%EF%BC%9A-producer-record%E7%9A%84%E5%8F%82%E6%95%B0%EF%BC%8Ctopic-key-value-key%E5%8F%AF%E4%BB%A5%E7%9C%81%E7%95%A5%EF%BC%8C%E5%BD%93%E7%9C%81%E7%95%A5%E6%97%B6%E5%B0%B1%E6%98%AF%E4%B8%80%E4%B8%AA%E6%B2%A1%E6%9C%89key%E7%9A%84value%EF%BC%8Ckey%E4%B8%80%E8%88%AC%E7%94%A8%E4%BA%8E%E6%8A%8A%E7%9B%B8%E5%90%8Ckey%E7%9A%84%E6%95%B0%E6%8D%AE%E5%86%99%E5%85%A5%E5%90%8C%E4%B8%80%E4%B8%AA%E5%88%86%E5%8C%BA%E9%87%8C-send%E9%BB%98%E8%AE%A4%E6%98%AF%E5%8F%91%E9%80%81%E5%B9%B6%E5%BF%98%E8%AE%B0%EF%BC%8Csend%E4%BC%9A%E8%BF%94%E5%9B%9E%E4%B8%80%E4%B8%AAFuture%E5%AF%B9%E8%B1%A1%E4%BD%BF%E7%94%A8-get%E6%96%B9%E6%B3%95%E5%BE%97%E5%88%B0RecordMetadata%E5%AF%B9%E8%B1%A1%EF%BC%8C%E5%8F%AF%E4%BB%A5%E8%8E%B7%E5%8F%96%E6%B6%88%E6%81%AF%E7%9A%84%E5%81%8F%E7%A7%BB%E9%87%8F-%E5%BC%82%E6%AD%A5%E5%8F%91%E9%80%81-send-record-%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E7%B1%BB-%EF%BC%8C%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E9%9C%80%E8%A6%81%E5%AE%9E%E7%8E%B0Callback%E7%B1%BB%EF%BC%8C%E5%B9%B6%E4%B8%94%E9%87%8D%E5%86%99%E5%85%B6%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95-%E9%85%8D%E7%BD%AE%E8%AE%BE%E7%BD%AE%EF%BC%9A-1-acks-x3D-0-%E7%94%9F%E4%BA%A7%E8%80%85%E6%97%A0%E9%9C%80%E7%AD%89%E5%BE%85%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E5%93%8D%E5%BA%94%EF%BC%8C%E4%BD%86%E6%B6%88%E6%81%AF%E4%B8%A2%E5%A4%B1%E6%97%B6%E4%B8%8D%E4%BC%9A%E7%9F%A5%E6%99%93%EF%BC%8C-x3D-1%EF%BC%8C%E5%8F%AA%E8%A6%81%E9%9B%86%E7%BE%A4%E7%9A%84%E9%A6%96%E9%A2%86%E8%8A%82%E7%82%B9%E6%94%B6%E5%88%B0%E5%8D%B3%E5%8F%AF%EF%BC%8C-x3D-all%E9%9C%80%E8%A6%81%E6%89%80%E6%9C%89%E5%8F%82%E4%B8%8E%E5%A4%8D%E5%88%B6%E7%9A%84%E8%8A%82%E7%82%B9%E9%83%BD%E5%8F%97%E5%88%B0%E6%B6%88%E6%81%AF%E6%89%8D%E4%BC%9A%E5%8F%97%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E5%93%8D%E5%BA%94%EF%BC%8C%E4%B8%8D%E5%BB%BA%E8%AE%AE-2-buffer-memory%E8%AE%BE%E7%BD%AEproducer%E5%86%85%E5%AD%98%E7%BC%93%E5%86%B2%E5%8C%BA%E5%A4%A7%E5%B0%8F%EF%BC%8C-3-compression-type%E8%AE%BE%E7%BD%AE%E6%B6%88%E6%81%AF%E7%9A%84%E5%8E%8B%E7%BC%A9%E6%A0%BC%E5%BC%8F%EF%BC%8C%E9%BB%98%E8%AE%A4%E4%B8%8D%E4%BC%9A%E5%8E%8B%E7%BC%A9-4-retries%E9%87%8D%E8%AF%95%E6%AC%A1%E6%95%B0-5-batch-size-%E5%BD%93%E5%A4%9A%E4%B8%AA%E6%B6%88%E6%81%AF%E8%A2%AB%E5%8F%91%E9%80%81%E5%88%B0%E5%90%8C%E4%B8%80%E4%B8%AA%E5%88%86%E5%8C%BA%E6%97%B6%EF%BC%8Cproducer%E4%BC%9A%E6%8A%8A%E4%BB%96%E4%BB%AC%E6%94%BE%E5%9C%A8%E4%B8%80%E8%B5%B7%EF%BC%8C%E5%BD%93%E4%BD%9C%E4%B8%80%E4%B8%AA%E6%89%B9%E6%AC%A1%EF%BC%8C%E8%BF%99%E4%B8%AA%E5%8F%82%E6%95%B0%E6%8C%87%E5%AE%9A%E4%B8%80%E4%B8%AA%E6%89%B9%E6%AC%A1%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E7%9A%84%E6%9C%80%E5%A4%A7%E5%86%85%E5%AD%98-6-max-in-flight-requests-per-connection-%E7%94%9F%E4%BA%A7%E8%80%85%E5%9C%A8%E6%8E%A5%E6%94%B6%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%93%8D%E5%BA%94%E4%B9%8B%E5%89%8D%E5%8F%AF%E4%BB%A5%E5%8F%91%E9%80%81%E5%A4%9A%E5%B0%91%E4%B8%AA%E6%B6%88%E6%81%AF%EF%BC%8C%E8%AE%BE%E7%BD%AE%E4%B8%BA-1-%E6%97%B6%E5%8F%AF%E4%BB%A5%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E6%98%AF%E6%8C%89%E7%85%A7%E9%A1%BA%E5%BA%8F%E5%86%99%E5%85%A5%E7%9A%84%EF%BC%8C%E9%80%82%E5%90%88%E5%9C%A8%E9%93%B6%E8%A1%8C%E7%AD%89%E4%B8%A5%E6%A0%BC%E8%A6%81%E6%B1%82%E9%A1%BA%E5%BA%8F%E7%9A%84%E6%97%B6%E5%80%99%E4%BD%BF%E7%94%A8-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%88%86%E5%8C%BA%EF%BC%9A-consumer-API-1-consumer%E7%B1%BB%E7%9A%84%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F%E5%92%8Cproducer%E4%B8%80%E8%87%B4%EF%BC%8C%E4%BD%86%E6%98%AF%E6%8E%A8%E8%8D%90%E6%8C%87%E5%AE%9A-group-id%E6%9D%A5%E6%8C%87%E5%AE%9A%E5%B1%9E%E4%BA%8E%E5%93%AA%E4%B8%AA%E7%BE%A4%E7%BB%84%EF%BC%8C-2-consumer-subscirbe-%E8%AE%A2%E9%98%85%E7%9B%B8%E5%85%B3%E7%9A%84topic%EF%BC%8C%E5%90%8C%E6%97%B6%E6%94%AF%E6%8C%81%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F-consumer-subscribe-Arrays-asList-quot-topic1-quot-quot-topic2-quot-3-consumer-poll-xxx-%E5%8F%82%E6%95%B0%E6%98%AF%E8%BD%AE%E8%AF%A2%E7%9A%84%E9%98%BB%E5%A1%9E%E6%97%B6%E9%97%B4%EF%BC%8C%E4%BC%9A%E7%AD%89%E5%BE%85broker%E8%BF%94%E5%9B%9E%E6%95%B0%E6%8D%AE-4-%E8%AE%B0%E5%BE%97-close-5-%E5%BB%BA%E8%AE%AE%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E4%B8%AD%E5%8F%AA%E6%9C%89%E4%B8%80%E4%B8%AA%E6%B6%88%E8%B4%B9%E8%80%85-%E9%85%8D%E7%BD%AE%EF%BC%9A-%E5%A4%A7%E9%83%A8%E5%88%86%E5%92%8Cproducer%E7%B1%BB%E4%BC%BC-fetch-min-bytes%E6%B6%88%E8%B4%B9%E8%80%85%E4%BB%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%8E%B7%E5%8F%96%E8%AE%B0%E5%BD%95%E7%9A%84%E6%9C%80%E5%B0%8F%E5%AD%97%E8%8A%82%E6%95%B0%EF%BC%8C%E5%BD%93%E6%95%B0%E6%8D%AE%E9%87%8F%E5%A4%A7%E4%BA%8E%E7%AD%89%E4%BA%8E%E8%BF%99%E4%B8%AA%E5%80%BC%E6%89%8D%E4%BC%9A%E8%A2%AB%E8%BF%94%E5%9B%9E%E7%BB%99%E6%B6%88%E8%B4%B9%E8%80%85-%E6%8F%90%E4%BA%A4%E5%92%8C%E5%81%8F%E7%A7%BB%E9%87%8F%EF%BC%9A%E6%B6%88%E8%B4%B9%E8%80%85%E5%BE%80-consumer-offset%E7%89%B9%E6%AE%8A%E4%B8%BB%E9%A2%98%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF%EF%BC%8C%E6%B6%88%E6%81%AF%E5%8C%85%E5%90%AB%E6%AF%8F%E4%B8%AA%E5%88%86%E5%8C%BA%E7%9A%84%E5%81%8F%E7%A7%BB%E9%87%8F%EF%BC%8C%E5%BD%93%E8%A7%A6%E5%8F%91%E5%86%8D%E5%9D%87%E8%A1%A1%E6%97%B6%EF%BC%8C%E6%B6%88%E8%B4%B9%E8%80%85%E4%BC%9A%E8%AF%BB%E5%8F%96%E6%AF%8F%E4%B8%AA%E5%88%86%E5%8C%BA%E7%BB%84%E5%90%8E%E4%B8%80%E6%AC%A1%E6%8F%90%E4%BA%A4%E7%9A%84%E5%81%8F%E7%A7%BB%E9%87%8F%EF%BC%8C%E7%84%B6%E5%90%8E%E4%BB%8E%E5%81%8F%E7%A7%BB%E9%87%8F%E6%8C%87%E5%AE%9A%E7%9A%84%E5%9C%B0%E6%96%B9%E5%BC%80%E5%A7%8B%E5%A4%84%E7%90%86-%E6%8F%90%E4%BA%A4%E6%96%B9%E5%BC%8F%EF%BC%9A-1-%E8%87%AA%E5%8A%A8%E6%8F%90%E4%BA%A4-%E6%AF%8F%E9%9A%94%E4%B8%80%E6%AE%B5%E6%97%B6%E9%97%B4%E8%87%AA%E5%8A%A8%E6%8F%90%E4%BA%A4%E4%B8%80%E6%AC%A1-2-%E6%8F%90%E4%BA%A4%E5%BD%93%E5%89%8D%E5%81%8F%E7%A7%BB%E9%87%8F-%E8%AE%BE%E7%BD%AEauto-commit-offset%E4%B8%BAfalse-%E7%84%B6%E5%90%8E%E4%BD%BF%E7%94%A8commitSync-%E6%8F%90%E4%BA%A4%E5%81%8F%E7%A7%BB%E9%87%8F%EF%BC%8C%E4%BC%9A%E6%8F%90%E4%BA%A4%E6%9C%80%E6%96%B0%E7%9A%84%E4%B8%80%E6%AC%A1%E7%94%B1poll%E8%8E%B7%E5%BE%97%E7%9A%84%E5%81%8F%E7%A7%BB%E9%87%8F-3-%E5%BC%82%E6%AD%A5%E6%8F%90%E4%BA%A4%EF%BC%9AcommitAsync-%EF%BC%8C%E4%B9%9F%E5%8F%AF%E4%BD%BF%E7%94%A8%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E6%9D%A5%E5%A4%84%E7%90%86-4-%E5%8F%AF%E4%BB%A5%E6%8F%90%E4%BA%A4%E7%89%B9%E5%AE%9A%E5%81%8F%E7%A7%BB%E9%87%8F%EF%BC%8C%E8%80%8C%E4%B8%8D%E6%98%AF%E6%9C%80%E5%90%8E%E4%B8%80%E6%AC%A1poll%E5%BE%97%E5%88%B0%E7%9A%84%E5%81%8F%E7%A7%BB%E9%87%8F-%E9%80%9A%E8%BF%87%E5%AE%9E%E7%8E%B0-ConsumerRebalanceListener%E6%8E%A5%E5%8F%A3%E6%9D%A5%E5%AE%9A%E4%B9%89%E5%9C%A8consumer%E5%A4%B1%E5%8E%BB%E5%AF%B9%E5%88%86%E5%8C%BA%E7%9A%84%E6%89%80%E6%9C%89%E6%9D%83%E6%97%B6%E9%9C%80%E8%A6%81%E5%A4%84%E7%90%86%E7%9A%84%E4%BA%8B%E4%BB%B6%EF%BC%8C%E5%8F%AF%E5%9C%A8%E8%BF%99%E9%87%8C%E4%BD%BF%E7%94%A8-seek-%E6%96%B9%E6%B3%95%E5%8A%A0%E4%B8%8A%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E5%87%BD%E6%95%B0%E6%9D%A5%E5%AE%9E%E7%8E%B0%E4%BB%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E8%8E%B7%E5%BE%97%E5%81%8F%E7%A7%BB%E9%87%8F-Kafka%E6%9C%AC%E4%BD%93-%E4%BC%98%E5%8A%BF%E9%AB%98%E5%90%9E%E5%90%90%EF%BC%8C%E9%AB%98%E6%80%A7%E8%83%BD%EF%BC%8C%E6%8C%81%E4%B9%85%E5%8C%96-%E5%B0%86%E6%B6%88%E6%81%AF%E6%8C%81%E4%B9%85%E5%8C%96%E5%88%B0%E7%A3%81%E7%9B%98%EF%BC%8C%E9%80%9A%E8%BF%87%E5%B0%86%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96%E7%A1%AC%E7%9B%98%EF%BC%8C%E4%BB%A5%E5%8F%8Afollower%E8%8A%82%E7%82%B9%E6%9D%A5%E9%98%B2%E6%AD%A2%E6%95%B0%E6%8D%AE%E4%B8%A2%E5%A4%B1-%E7%BC%BA%E7%82%B9%E6%98%AF%E5%BC%82%E6%AD%A5%E7%9A%84%E4%B8%8D%E9%80%82%E5%90%88%E7%94%B5%E5%95%86%E5%9C%BA%E6%99%AF-%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1-Producer-Consumer-Topic-%E4%B8%BB%E9%A2%98%EF%BC%8C%E7%94%B1%E7%94%A8%E6%88%B7%E5%AE%9A%E4%B9%89%E5%B9%B6%E9%85%8D%E7%BD%AE%E5%9C%A8Kafka%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%8C%E5%BB%BA%E7%AB%8BProducer%E5%92%8CConsumer%E4%B9%8B%E9%97%B4%E7%9A%84%E8%AE%A2%E9%98%85%E5%85%B3%E7%B3%BB%EF%BC%8C%E8%BA%AB%E7%BC%A0%E8%BF%99%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF%E5%88%B0%E7%89%B9%E5%AE%9A%E7%9A%84Topic%E4%B8%8B%EF%BC%8C%E6%B6%88%E8%B4%B9%E8%80%85%E4%BB%8E%E8%BF%99%E4%B8%AATopic%E4%B8%8B%E6%B6%88%E8%B4%B9%E6%B6%88%E6%81%AF%E3%80%82%E9%80%BB%E8%BE%91%E6%A6%82%E5%BF%B5%EF%BC%8C%E7%9B%B8%E5%BD%93%E4%BA%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E7%9A%84%E8%A1%A8-Partition-%E6%B6%88%E6%81%AF%E5%88%86%E5%8C%BA%EF%BC%8C%E4%B8%80%E4%B8%AATopic%E5%8F%AF%E4%BB%A5%E5%88%86%E4%B8%BA%E5%A4%9A%E4%B8%AApartition%EF%BC%8Cpartition%E6%98%AF%E4%B8%80%E4%B8%AA%E6%9C%89%E5%BA%8F%E7%9A%84%E9%98%9F%E5%88%97%EF%BC%8Cpartition%E7%9A%84%E6%AF%8F%E6%9D%A1%E6%B6%88%E6%81%AF%E9%83%BD%E4%BC%9A%E8%A2%AB%E5%88%86%E9%85%8D%E4%B8%80%E4%B8%AA%E6%9C%89%E5%BA%8F%E7%9A%84id-offset-%E7%89%A9%E7%90%86%E5%AE%9E%E9%99%85%E6%A6%82%E5%BF%B5%EF%BC%8C%E6%AF%8F%E4%B8%80%E4%B8%AApartition%E5%AF%B9%E5%BA%94%E4%B8%80%E4%B8%AAlog%EF%BC%8Cproducer%E7%94%9F%E4%BA%A7%E7%9A%84%E6%95%B0%E6%8D%AE%E4%BC%9A%E4%B8%8D%E6%96%AD%E5%9C%B0%E8%BF%BD%E5%8A%A0%E5%88%B0%E8%AF%A5log%E6%96%87%E4%BB%B6%E6%9C%AB%E7%AB%AF%EF%BC%8C%E4%B8%94%E6%AF%8F%E6%9D%A1%E6%95%B0%E6%8D%AE%E9%83%BD%E6%9C%89%E8%87%AA%E5%B7%B1%E7%9A%84offset%E3%80%82%E7%B3%BB%E5%93%A6%E5%95%8A%E9%A3%9E%E7%9D%80%E7%BB%84%E4%B8%AD%E7%9A%84%E6%AF%8F%E4%B8%AA%E6%B6%88%E8%B4%B9%E8%80%85%E9%83%BD%E4%BC%9A%E5%AE%9E%E6%97%B6%E8%AE%B0%E5%BD%95%E8%87%AA%E5%B7%B1%E6%B6%88%E8%B4%B9%E5%88%B0%E5%93%AA%E4%B8%AAoffset-Broker-%E4%B8%80%E5%8F%B0Kafka%E5%B0%B1%E6%98%AF%E4%B8%80%E4%B8%AAbroker%EF%BC%8C%E4%B8%80%E4%B8%AA%E9%9B%86%E7%BE%A4%E7%94%B1%E5%A4%9A%E4%B8%AAbroker%E7%BB%84%E6%88%90%EF%BC%8C%E4%B8%80%E4%B8%AAbroker%E5%8F%AF%E4%BB%A5%E5%AE%B9%E7%BA%B3%E5%A4%9A%E4%B8%AAtopic-ConsumerGroup-%E6%B6%88%E8%B4%B9%E8%80%85%E7%BB%84%EF%BC%8C%E7%94%A8%E4%BA%8E%E5%BD%92%E7%BB%84%E5%90%8C%E7%B1%BB%E6%B6%88%E8%B4%B9%E8%80%85%E3%80%82%E6%AF%8F%E4%B8%AAconsumer%E5%B1%9E%E4%BA%8E%E4%B8%80%E4%B8%AA%E7%89%B9%E5%AE%9A%E7%9A%84consumer-group%EF%BC%8C%E5%A4%9A%E4%B8%AA%E6%B6%88%E8%B4%B9%E8%80%85%E5%8F%AF%E4%BB%A5%E5%85%B1%E5%90%8C%E6%B6%88%E8%B4%B9%E4%B8%80%E4%B8%AATopic%E4%B8%8B%E7%9A%84%E6%B6%88%E6%81%AF%EF%BC%8C%E6%AF%8F%E4%B8%AA%E6%B6%88%E8%B4%B9%E8%80%85%E8%8E%B7%E5%8F%96%E9%83%A8%E5%88%86%E6%B6%88%E6%81%AF%E3%80%82-%E4%B8%80%E4%B8%AAPartition%E5%AF%B9%E5%BA%94%E4%B8%80%E4%B8%AA%E5%94%AF%E4%B8%80%E7%9A%84%E6%96%87%E4%BB%B6%E5%A4%B9%EF%BC%8C%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%8B%E4%BD%BF%E7%94%A8%E7%9A%84%E6%98%AFSegment-File%E7%9A%84%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F%E8%BF%9B%E8%A1%8C%E5%AD%98%E5%82%A8%E3%80%82%E5%B0%86%E5%A4%A7%E6%96%87%E4%BB%B6%E6%8B%86%E6%88%90%E5%B0%8F%E6%96%87%E4%BB%B6%EF%BC%8C%E5%88%86%E4%B8%BA%E7%B4%A2%E5%BC%95%E6%9C%AA%E8%A7%81%E5%92%8C%E6%95%B0%E6%8D%AE%E6%96%87%E4%BB%B6-%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B-producer%E5%85%88%E4%BB%8Ezookeeper%E7%9A%84broker-x2F-x2F-state%E8%8A%82%E7%82%B9%E6%89%BE%E5%88%B0%E8%AF%A5partiton%E7%9A%84leader-producer%E5%B0%86%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81%E7%BB%99%E8%AF%A5leader-leader%E5%B0%86%E6%B6%88%E6%81%AF%E5%86%99%E5%87%BA%E6%9C%AC%E5%9C%B0log-follower%E4%BB%8Eleader-pull-%E6%B6%88%E6%81%AF-%E5%86%99%E5%85%A5%E6%9C%AC%E5%9C%B0log%EF%BC%8C%E5%90%8E%E5%90%91leader%E5%8F%91%E9%80%81ACK-leader%E6%94%B6%E5%88%B0%E6%89%80%E6%9C%89ISR%E4%B8%AD%E7%9A%84replication%E7%9A%84ACK%EF%BC%8C%E5%A2%9E%E5%8A%A0HT-high-watermark-%EF%BC%8C%E6%9C%80%E5%90%8Ecommit-%E7%9A%84offset-%E5%B9%B6%E5%90%91producer%E5%8F%91%E9%80%81ACK-%E7%94%9F%E4%BA%A7%E8%BF%87%E7%A8%8B1-Producer%E5%88%9B%E5%BB%BA%E6%97%B6%EF%BC%8C%E5%85%88%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AASender%E7%BA%BF%E7%A8%8B%E5%B9%B6%E4%B8%94%E8%AE%BE%E7%BD%AE%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B2-%E7%94%9F%E4%BA%A7%E7%9A%84%E6%B6%88%E6%81%AF%E7%BB%8F%E8%BF%87%E6%8B%A6%E6%88%AA%E5%99%A8-gt-%E5%BA%8F%E5%88%97%E5%8C%96%E5%99%A8-gt-%E5%88%86%E5%8C%BA%E5%99%A8%EF%BC%8C%E5%B0%86%E6%B6%88%E6%81%AF%E5%AD%98%E5%9C%A8%E7%BC%93%E5%86%B2%E5%8C%BA3-%E6%89%B9%E9%87%8F%E5%8F%91%E9%80%81%E7%9A%84%E6%9D%A1%E4%BB%B6%EF%BC%9A%E7%BC%93%E5%86%B2%E5%8C%BA%E6%95%B0%E6%8D%AE%E5%A4%A7%E5%B0%8F%E8%BE%BE%E5%88%B0batch-size%E6%88%96%E8%80%85linger-ms%E8%BE%BE%E5%88%B0%E4%B8%8A%E9%99%904-%E5%8F%91%E5%BE%80%E6%8C%87%E5%AE%9A%E5%88%86%E5%8C%BA%EF%BC%8C%E6%9C%80%E5%90%8E%E5%88%B0%E8%BE%BEbroker-acks-x3D-0%EF%BC%8C%E6%B6%88%E6%81%AF%E6%94%BE%E5%88%B0%E7%BC%93%E5%86%B2%E5%8C%BA%E5%B0%B1%E8%AE%A4%E4%B8%BA%E5%8F%91%E9%80%81%E5%AE%8C%E6%88%90-acks-x3D-1%E6%B6%88%E6%81%AF%E5%86%99%E5%88%B0%E4%B8%BB%E5%88%86%E5%8C%BA%E5%8D%B3%E5%8F%AF%E5%AE%8C%E6%88%90%EF%BC%8C%E5%A6%82%E6%9E%9C%E4%B8%BB%E5%88%86%E5%8C%BA%E6%94%B6%E5%88%B0%E6%B6%88%E6%81%AF%E4%B9%8B%E5%90%8E%E5%AE%95%E6%9C%BA%EF%BC%8C%E5%89%AF%E6%9C%AC%E5%88%86%E5%8C%BA%E6%9D%A5%E4%B8%8D%E5%8F%8A%E5%90%8C%E6%AD%A5%E6%B6%88%E6%81%AF%EF%BC%8C%E6%B6%88%E6%81%AF%E5%B0%B1%E4%BC%9A%E4%B8%A2%E5%A4%B1-acks-x3D-all-%E7%AD%89%E5%BE%85%E6%89%80%E6%9C%89%E7%9A%84ISR%E5%89%AF%E6%9C%AC%E7%9A%84%E7%BC%BA%E4%BA%BA%E8%AE%B0%E5%BD%955-%E5%A6%82%E6%9E%9C%E8%AE%BE%E7%BD%AE%E4%BA%86%E9%87%8D%E8%AF%95%E6%AC%A1%E6%95%B0%E5%B9%B6%E4%B8%94%E5%A4%A7%E4%BA%8E0%EF%BC%8C%E5%B0%B1%E4%BC%9A%E8%BF%9B%E8%A1%8C%E9%87%8D%E8%AF%956-%E6%88%90%E5%8A%9F%EF%BC%8C%E8%BF%94%E5%9B%9E%E5%85%83%E6%95%B0%E6%8D%AE%E7%BB%99%E7%94%9F%E4%BA%A7%E8%80%85ISR%EF%BC%88In-Sync-Replicas%EF%BC%89%E6%98%AF%E6%8C%87%E4%B8%8E%E9%A2%86%E5%AF%BC%E8%80%85%E5%89%AF%E6%9C%AC%E4%BF%9D%E6%8C%81%E5%90%8C%E6%AD%A5%E7%9A%84%E5%89%AF%E6%9C%AC%E9%9B%86%E5%90%88-%E7%94%9F%E4%BA%A7%E8%80%85Offset%E6%B6%88%E6%81%AF%E5%86%99%E5%85%A5%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E6%AF%8F%E4%B8%80%E4%B8%AA%E5%88%86%E5%8C%BA%E9%83%BD%E6%9C%89%E4%B8%80%E4%B8%AAoffset%EF%BC%8C%E5%8D%B3%E6%AF%8F%E4%B8%AA%E5%88%86%E5%8C%BA%E7%9A%84%E6%9C%80%E6%96%B0%E6%9C%80%E5%A4%A7%E7%9A%84offset%E3%80%82-%E6%B6%88%E8%B4%B9%E8%80%85Offset%E4%B8%8D%E5%90%8C%E6%B6%88%E8%B4%B9%E7%BB%84%E4%B8%AD%E7%9A%84%E6%B6%88%E8%B4%B9%E8%80%85%E5%8F%AF%E4%BB%A5%E9%92%88%E5%AF%B9%E4%B8%80%E4%B8%AA%E5%88%86%E5%8C%BA%E5%AD%98%E5%82%A8%E4%B8%8D%E5%90%8C%E7%9A%84Offset%EF%BC%8C%E4%BA%92%E4%B8%8D%E5%BD%B1%E5%93%8D%E3%80%82-LogSegment%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%E7%9A%84%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86-Leader%E9%80%89%E4%B8%BE-Kafka%E4%BC%9A%E5%9C%A8Zookeeper%E4%B8%8A%E9%92%88%E5%AF%B9%E6%AF%8F%E4%B8%AATopic%E7%BB%B4%E6%8A%A4%E4%B8%80%E4%B8%AA%E6%88%90%E4%B8%BAISR%E7%9A%84%E9%9B%86%E5%90%88-%E5%BD%93%E9%9B%86%E5%90%88%E4%B8%AD%E5%89%AF%E6%9C%AC%E9%83%BD%E8%B7%9FLeader%E5%90%8C%E7%9A%84%E5%89%AF%E6%9C%AC%E5%90%8C%E6%AD%A5%E4%B9%8B%E5%90%8E%EF%BC%8Ckafka%E6%89%8D%E4%BC%9A%E8%AE%A4%E4%B8%BA%E6%B6%88%E6%81%AF%E5%B7%B2%E6%8F%90%E4%BA%A4-%E5%8F%AA%E6%9C%89%E8%BF%99%E4%BA%9B%E8%B7%9FLeader%E4%BF%9D%E6%8C%81%E5%90%8C%E6%AD%A5%E7%9A%84Follower%E6%89%8D%E5%BA%94%E8%AF%A5%E8%A2%AB%E9%80%89%E4%BD%9C%E6%96%B0%E7%9A%84Leader"><span class="nav-number">1.1.</span> <span class="nav-text">常见问题## Java API- 一个独立的Kafka服务器被称作broker,broker是集群的组成部分，每个集群都有一个broker同时充当了集群控制器的角色- kafka的主题被分为多个分区，分区存储在磁盘中- kafka的消息特点：消息会保留一段时间，即使应用程序下线，消息仍然会保存在kafka里，是基于磁盘的数据存储。- API使用：    - producer        - record的参数，topic , key ,value key可以省略，当省略时就是一个没有key的value，key一般用于把相同key的数据写入同一个分区里        - send默认是发送并忘记，send会返回一个Future对象使用.get方法得到RecordMetadata对象，可以获取消息的偏移量        - 异步发送.send(record,回调函数类)，回调函数需要实现Callback类，并且重写其中的方法        - 配置设置：            1. acks &#x3D; 0 生产者无需等待服务器的响应，但消息丢失时不会知晓， &#x3D; 1，只要集群的首领节点收到即可，&#x3D; all需要所有参与复制的节点都受到消息才会受到服务器的响应，不建议            2. buffer.memory设置producer内存缓冲区大小，            3. compression.type设置消息的压缩格式，默认不会压缩            4. retries重试次数            5. batch.size 当多个消息被发送到同一个分区时，producer会把他们放在一起，当作一个批次，这个参数指定一个批次可以使用的最大内存            6. max.in.flight.requests.per.connection 生产者在接收到服务器响应之前可以发送多少个消息，设置为 1 时可以保证消息是按照顺序写入的，适合在银行等严格要求顺序的时候使用        - 自定义分区：    public class DemoPartitionser implements Partitioner {

    private String myKey;
    @Override
    public int partition(String topic, Object key, byte[] keyBytes, Object value, byte[] valueBytes, Cluster cluster) {
        &#x2F;&#x2F; 获取分区列表
        List&lt;PartitionInfo&gt; partitionInfos &#x3D; cluster.partitionsForTopic(topic);
        &#x2F;&#x2F; 获取分区数
        int partitionNum &#x3D; partitionInfos.size();
        if((keyBytes &#x3D;&#x3D; null) || (!(key instanceof String))){
            throw new IllegalArgumentException(&quot;key is null or not a string&quot;);
        }
        &#x2F;&#x2F; 如果key为key，则分配到最后一个分区
        if(&quot;key&quot;.equals(key)){
            return partitionNum;
        }
        &#x2F;&#x2F;其余的消息都分配到最后一个分区
        return Math.abs(key.hashCode()) % (partitionNum - 1);
    }

    @Override
    public void close() {

    }

    &#x2F;*
     * @description:
     * @author bronya
     * @date: 2024&#x2F;4&#x2F;20 14:50
     * @param map
     *&#x2F;
    @Override
    public void configure(Map&lt;String, ?&gt; map) {
        myKey &#x3D; (String) map.get(&quot;key&quot;);
    }
}    -  consumer:        - API:            1. consumer类的创建方式和producer一致，但是推荐指定 group.id来指定属于哪个群组，            2. consumer.subscirbe()订阅相关的topic，同时支持正则表达式 consumer.subscribe(Arrays.asList(&quot;topic1&quot;, &quot;topic2&quot;));            3. consumer.poll(xxx) 参数是轮询的阻塞时间，会等待broker返回数据            4. 记得.close()            5. 建议一个线程中只有一个消费者        - 配置：            - 大部分和producer类似            - fetch.min.bytes消费者从服务器获取记录的最小字节数，当数据量大于等于这个值才会被返回给消费者        - 提交和偏移量：消费者往_consumer_offset特殊主题发送消息，消息包含每个分区的偏移量，当触发再均衡时，消费者会读取每个分区组后一次提交的偏移量，然后从偏移量指定的地方开始处理            - 提交方式：                1. 自动提交:每隔一段时间自动提交一次                2. 提交当前偏移量:设置auto.commit.offset为false.然后使用commitSync()提交偏移量，会提交最新的一次由poll获得的偏移量                3. 异步提交：commitAsync()，也可使用回调函数来处理                4. 可以提交特定偏移量，而不是最后一次poll得到的偏移量        - 通过实现 ConsumerRebalanceListener接口来定义在consumer失去对分区的所有权时需要处理的事件，可在这里使用.seek()方法加上自定义的函数来实现从数据库中获得偏移量## Kafka本体### 优势高吞吐，高性能，持久化(将消息持久化到磁盘，通过将数据持久化硬盘，以及follower节点来防止数据丢失)缺点是异步的不适合电商场景### 架构设计- Producer- Consumer- Topic 主题，由用户定义并配置在Kafka服务器，建立Producer和Consumer之间的订阅关系，身缠这发送消息到特定的Topic下，消费者从这个Topic下消费消息。逻辑概念，相当于数据库中的表- Partition 消息分区，一个Topic可以分为多个partition，partition是一个有序的队列，partition的每条消息都会被分配一个有序的id(offset) 物理实际概念，每一个partition对应一个log，producer生产的数据会不断地追加到该log文件末端，且每条数据都有自己的offset。系哦啊飞着组中的每个消费者都会实时记录自己消费到哪个offset- Broker 一台Kafka就是一个broker，一个集群由多个broker组成，一个broker可以容纳多个topic- ConsumerGroup 消费者组，用于归组同类消费者。每个consumer属于一个特定的consumer group，多个消费者可以共同消费一个Topic下的消息，每个消费者获取部分消息。- 一个Partition对应一个唯一的文件夹，文件夹下使用的是Segment File的存储方式进行存储。将大文件拆成小文件，分为索引未见和数据文件### 基本流程- producer先从zookeeper的broker&#x2F;**&#x2F;state节点找到该partiton的leader- producer将消息发送给该leader- leader将消息写出本地log- follower从leader pull 消息- 写入本地log，后向leader发送ACK- leader收到所有ISR中的replication的ACK，增加HT(high watermark ，最后commit 的offset)并向producer发送ACK#### 生产过程1. Producer创建时，先创建一个Sender线程并且设置守护线程2. 生产的消息经过拦截器-&gt;序列化器-&gt;分区器，将消息存在缓冲区3. 批量发送的条件：缓冲区数据大小达到batch.size或者linger.ms达到上限4. 发往指定分区，最后到达broker    - acks &#x3D; 0，消息放到缓冲区就认为发送完成    - acks &#x3D; 1消息写到主分区即可完成，如果主分区收到消息之后宕机，副本分区来不及同步消息，消息就会丢失    - acks &#x3D; all 等待所有的ISR副本的缺人记录5. 如果设置了重试次数并且大于0，就会进行重试6. 成功，返回元数据给生产者ISR（In-Sync Replicas）是指与领导者副本保持同步的副本集合#### 生产者Offset消息写入的时候，每一个分区都有一个offset，即每个分区的最新最大的offset。#### 消费者Offset不同消费组中的消费者可以针对一个分区存储不同的Offset，互不影响。#### LogSegment日志文件的组成部分#### Leader选举- Kafka会在Zookeeper上针对每个Topic维护一个成为ISR的集合- 当集合中副本都跟Leader同的副本同步之后，kafka才会认为消息已提交- 只有这些跟Leader保持同步的Follower才应该被选作新的Leader</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">QingQiu</p>
  <div class="site-description" itemprop="description">个人网站，学习记录，面试记录和经验总结、互联网中一块属于自己的小窝</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">44</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">19</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Zuofw/zuofw-rpc" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Zuofw&#x2F;zuofw-rpc" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2022 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">QingQiu</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="站点总字数">365k</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  















  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
