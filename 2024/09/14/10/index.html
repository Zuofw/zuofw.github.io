<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"zuofw.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="深入浅出MySQL以下内容参考自 《MySQL是怎样运行的：从根儿上理解MySQL》一书，强烈推荐 存储引擎对于不同的表可以设置不同的存储引擎 CREATE TABLE tableName ( 	xxxx ) ENGINE &#x3D; 引擎名称; # 修改 ALTER TABLE tableName ENGINE &#x3D; xxx; 编码格式mysql中的utf8默认的是使用的自定义的1~3字节表示的uft8m">
<meta property="og:type" content="article">
<meta property="og:title" content="深入浅出MySQL">
<meta property="og:url" content="https://zuofw.github.io/2024/09/14/10/index.html">
<meta property="og:site_name" content="QingQiu&#39;Blog">
<meta property="og:description" content="深入浅出MySQL以下内容参考自 《MySQL是怎样运行的：从根儿上理解MySQL》一书，强烈推荐 存储引擎对于不同的表可以设置不同的存储引擎 CREATE TABLE tableName ( 	xxxx ) ENGINE &#x3D; 引擎名称; # 修改 ALTER TABLE tableName ENGINE &#x3D; xxx; 编码格式mysql中的utf8默认的是使用的自定义的1~3字节表示的uft8m">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://zuofw.github.io/2024/09/14/10/Compact.png">
<meta property="og:image" content="https://zuofw.github.io/2024/09/14/10/NULL%E5%80%BC%E8%A1%A8%E7%A4%BA.png">
<meta property="og:image" content="https://zuofw.github.io/2024/09/14/10/%E8%AE%B0%E5%BD%95%E5%A4%B4%E4%BF%A1%E6%81%AF.png">
<meta property="og:image" content="https://zuofw.github.io/2024/09/14/10/%E9%9A%90%E8%97%8F%E5%88%97.png">
<meta property="og:image" content="https://zuofw.github.io/2024/09/14/10/InnoDB%E6%95%B0%E6%8D%AE%E9%A1%B5.png">
<meta property="og:image" content="https://zuofw.github.io/2024/09/14/10/%E6%9C%80%E5%B0%8F%E8%AE%B0%E5%BD%95%E5%92%8C%E6%9C%80%E5%A4%A7%E8%AE%B0%E5%BD%95.png">
<meta property="og:image" content="https://zuofw.github.io/2024/09/14/10/%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84%E5%9B%9E%E9%A1%BE.png">
<meta property="og:image" content="https://zuofw.github.io/2024/09/14/10/%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%841.png">
<meta property="og:image" content="https://zuofw.github.io/2024/09/14/10/%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%842.png">
<meta property="og:image" content="https://zuofw.github.io/2024/09/14/10/%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%843.png">
<meta property="og:image" content="https://zuofw.github.io/2024/09/14/10/%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95.png">
<meta property="og:image" content="https://zuofw.github.io/2024/09/14/10/redolog.png">
<meta property="og:image" content="https://zuofw.github.io/2024/09/14/10/undolog%E6%A0%BC%E5%BC%8F.png">
<meta property="og:image" content="https://zuofw.github.io/2024/09/14/10/PAGE_FREE.png">
<meta property="og:image" content="https://zuofw.github.io/2024/09/14/10/%E7%89%88%E6%9C%AC%E9%93%BE.png">
<meta property="og:image" content="https://zuofw.github.io/2024/09/14/10/%E9%94%81%E7%9A%84%E7%BB%93%E6%9E%84.png">
<meta property="article:published_time" content="2024-09-14T14:21:10.000Z">
<meta property="article:modified_time" content="2024-09-29T14:09:38.134Z">
<meta property="article:author" content="QingQiu">
<meta property="article:tag" content="博客，学习，成长">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zuofw.github.io/2024/09/14/10/Compact.png">

<link rel="canonical" href="https://zuofw.github.io/2024/09/14/10/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>深入浅出MySQL | QingQiu'Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>


<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">QingQiu'Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">清秋的博客</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-fa fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-fa fa-archive"></i>归档</a>

  </li>
        <li class="menu-item menu-item-github">

    <a href="https://github.com/Zuofw" rel="noopener" target="_blank"><i class="fa fa-fw fa-fab fa-github"></i>Github</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zuofw.github.io/2024/09/14/10/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="QingQiu">
      <meta itemprop="description" content="个人网站，学习记录，面试记录和经验总结、互联网中一块属于自己的小窝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="QingQiu'Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          深入浅出MySQL
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-09-14 22:21:10" itemprop="dateCreated datePublished" datetime="2024-09-14T22:21:10+08:00">2024-09-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-09-29 22:09:38" itemprop="dateModified" datetime="2024-09-29T22:09:38+08:00">2024-09-29</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>9.2k</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="深入浅出MySQL"><a href="#深入浅出MySQL" class="headerlink" title="深入浅出MySQL"></a>深入浅出MySQL</h1><p>以下内容参考自 《MySQL是怎样运行的：从根儿上理解MySQL》一书，强烈推荐</p>
<h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><p>对于不同的表可以设置不同的存储引擎</p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">CREATE TABLE tableName (
	xxxx
) ENGINE = 引擎名称;
# 修改
ALTER TABLE tableName ENGINE = xxx;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="编码格式"><a href="#编码格式" class="headerlink" title="编码格式"></a>编码格式</h3><p>mysql中的utf8默认的是使用的自定义的1~3字节表示的uft8mb3，对于一些特殊的字符，比如emoji，需要我们指定为utf8mb4才能够存储。</p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">CREATE / ALTER DATABASE 数据库名
 CHARACTER SET 字符集名称
 COLLATE 比较规则名称
# 或者对于表来修改
	CREATE TABLE tableName(
	)
	CHARACTER SET 字符集
	COLLATE 比较规则
ALTER tableName CHARACTER SET 字符集名称
## 或者对于某一列
CREATE TABLE 表名(
列名 字符串类型 [CHARACTER SET 字符集名称] [COLLATE 比较规则名称],
其他列...
);
ALTER TABLE 表名 MODIFY 列名 字符串类型 [CHARACTER SET 字符集名称] [COLLATE 比较规则名称];<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h2><h2 id="物理存储结构"><a href="#物理存储结构" class="headerlink" title="物理存储结构"></a>物理存储结构</h2><ol>
<li>页<br>将数据划分为页，以页为单位作为磁盘和内存交互的单位，默认页大小为16KB</li>
<li>行结构<br>记录的单位是行。</li>
</ol>
<h3 id="行格式"><a href="#行格式" class="headerlink" title="行格式"></a>行格式</h3><p>行/记录格式有很多，可以在建表的时候指定行格式</p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">CREATE TABLE tableName(
xxxx;
) ROW_FORMAT=COMPACT;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<ol>
<li>COMPACT格式 （重点，最常用）<br><img src="/2024/09/14/10/Compact.png"></li>
</ol>
<ul>
<li>变长字段长度列表，<strong>只会存放变长字段的长度</strong><br>支持VARCHAR等变成字段类型的，结构</li>
</ul>
<ol>
<li>真正的数据内容</li>
<li>占用的字节数<br>所有变长字段的真实占用长度，按照列顺序的<strong>逆序</strong>来进行存放。<br>这个长度占用的字节数：<br>如果可变字段允许的最大字节数超过255字节，并且真实存储的字节数超过127字节，就使用两个字节来表示这个长度，否则使用一个字节来表示。</li>
</ol>
<ul>
<li>NULL值列表<br>Compact将列中的NULL值统一进行管理。而不是放在真实数据里面，从而减少存储占用<br>进行的流程：</li>
</ul>
<ol>
<li>统计允许存储NULL值的列有哪些，如果不存在，NULL值列表就不存在了</li>
<li>表示形式：使用1表示为NULL值，0表示不为NULL，按照<strong>逆序</strong>排序。</li>
<li>要求NULL值列表必须使用整个字节的位来表示，如果不足位数，就在最前面补0<img src="/2024/09/14/10/NULL%E5%80%BC%E8%A1%A8%E7%A4%BA.png"></li>
</ol>
<ul>
<li><p>记录头信息<img src="/2024/09/14/10/%E8%AE%B0%E5%BD%95%E5%A4%B4%E4%BF%A1%E6%81%AF.png"></p>
</li>
<li><p>记录的真实数据</p>
<blockquote>
<p>记录的真实数据除了会有我们定义的数据，还会有MySQL为每一条记录添加的一些隐藏列<img src="/2024/09/14/10/%E9%9A%90%E8%97%8F%E5%88%97.png"></p>
<ol>
<li>row_id 行id，唯一标识一条记录<br>2.(trx_id) transaction_id 事务ID，MVCC中会使用</li>
<li>roll_pointer 回滚指针，事务回滚会用到，undo_log相关</li>
</ol>
</blockquote>
</li>
<li><p>主键选取：<br>优先使用用户定义的主键，如果没设置就选择一个Unique的键作为主键，如果不存在这种，就生成一个隐藏的row_id作为主键，所以 row_id不是 <strong>必须的</strong></p>
</li>
</ul>
<p><em>对于CHAR(M)，MySQL会为分配大于这个值的空间，并且要求至少占用M个字节，即使存的是一个空字符串也会占用M个字节，而VARCHAR(M)没有这个要求。</em></p>
<p>目的是：如果后续更新CHAR(M)的大小，就无需分配一个额外的记录空间，直接在原记录上进行更新即可。就不会造成碎片空间。</p>
<ul>
<li>Redundant行格式(老东西，不常用了)</li>
</ul>
<h4 id="溢出数据存储"><a href="#溢出数据存储" class="headerlink" title="溢出数据存储"></a>溢出数据存储</h4><p>可变数据类型需要占用3部分的存储空间：</p>
<ol>
<li>真实数据</li>
<li>真实数据占用字节的长度</li>
<li>NULL值标识，如果该列有NOT NULL属性则可以没有这部分存储空间<br>如果要存储的列非常大 ，只会保存实际真实数据的一部分，把剩余的数据分散在几个其他页中。</li>
</ol>
<h2 id="数据页-重点，重中之重"><a href="#数据页-重点，重中之重" class="headerlink" title="数据页(重点，重中之重)"></a>数据页(重点，重中之重)</h2><p><img src="/2024/09/14/10/InnoDB%E6%95%B0%E6%8D%AE%E9%A1%B5.png"><br>大小16KB</p>
<ul>
<li>File Header 文件头部，记录页的一些通用信息</li>
<li>Page Header 页面头部，数据页专有</li>
<li>Infimum + Supremum 最小记录和最大记录， 虚拟行记录</li>
<li>User Records 用户记录  实际存储的行记录内容，一开始没有，每次从Free Space中分配空间</li>
<li>Free Space 空闲空间 页中未使用的空间</li>
<li>PageDirectory 页面目录  页中某些记录的相对位置</li>
<li>File Trailer 文件尾部   检验页是否完整</li>
</ul>
<h3 id="记录头信息"><a href="#记录头信息" class="headerlink" title="记录头信息"></a>记录头信息</h3><ol>
<li>delete_mask 标记记录是否被删除，先做一个标记实际还在磁盘里还没删除。所有删除掉的记录会组成一个垃圾链表，如果后续有新的记录插入表中，可能会直接覆盖这些被删除的记录空间</li>
<li>min_rec_mask B+树的每层非叶子节点中的最小记录都会添加该标记</li>
<li>n_owned 表示当前记录拥有的记录数</li>
<li>heap_no 表示当前记录在记录堆的位置信息。</li>
<li>record_type 记录类型  0普通记录， 1 B+树非叶子节点记录 2最小记录 3最大记录</li>
<li>next_record 表示从当前记录的<strong>真实数据</strong>到下一条记录的<strong>真实数据</strong>的地址偏移量。 指向这个位置，向左就是记录头信息，向右读就是真实数据，同时因为变长字段列表和NULL值列表都是逆序存放的 ，所以可以使得真实数据和他们对应的长度在内存中的地址更近，能够提高缓存的命中率</li>
</ol>
<h3 id="最小记录和最大记录"><a href="#最小记录和最大记录" class="headerlink" title="最小记录和最大记录"></a>最小记录和最大记录</h3><p>最小记录heap_no = 0<br>最大记录heap_no = 1<br><img src="/2024/09/14/10/%E6%9C%80%E5%B0%8F%E8%AE%B0%E5%BD%95%E5%92%8C%E6%9C%80%E5%A4%A7%E8%AE%B0%E5%BD%95.png"><br>这两个记录是自动生成的，所以不放在User_Record中<br><strong>链表中的节点是按照主键值从小到大的顺序连接起来的</strong></p>
<h3 id="MySQL是如何进行查找的"><a href="#MySQL是如何进行查找的" class="headerlink" title="MySQL是如何进行查找的"></a>MySQL是如何进行查找的</h3><p>对于主键查找记录：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token keyword">user</span> <span class="token keyword">where</span> id <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>我们知道MySQL中的记录是根据链表从小到大连接起来的，那么如何快速从不支持随机访问的链表中找到我们需要的数据呢？</p>
<h3 id="Page-Directory"><a href="#Page-Directory" class="headerlink" title="Page Directory"></a>Page Directory</h3><p>MySQL中的设计：</p>
<ol>
<li>将所有的正常记录(不包括最小和最大记录)划分为多个组</li>
<li>每个组的最后一条信息记录的n_owned记录这个组中有多少条记录</li>
<li>将每个组的最后一条记录的地址偏移量单独提取出出来按照顺序存储到靠近 页 尾部的地方，也就是Page Directory页目录，这些偏移量被称为Slot 槽</li>
<li>最小记录为单独一个组，最大记录所在的分组条数只能在1<del>8条，其余分组只能有4</del>8条记录</li>
</ol>
<h3 id="查找过程"><a href="#查找过程" class="headerlink" title="查找过程"></a>查找过程</h3><ol>
<li>根据槽列表通过二分法来计算中间值，默认low 是最小记录的值，也就是0， high是最大记录的偏移量</li>
<li>通过对比中间槽的偏移量的值快速定位到所在的记录的位置，比对这条记录的主键值</li>
<li>对比之后接着通过二分法反复定位，直到 heigh -  low = 1时，也就确认所需要的记录的数据所在的组</li>
<li>通过遍历链表找到该槽中的主键值值最小的那条记录，也就是上一个槽所对应的那条记录的下一条</li>
<li>通过next_record即可遍历该槽所在的组的各个记录</li>
</ol>
<h3 id="Page-Header-页面头部"><a href="#Page-Header-页面头部" class="headerlink" title="Page Header 页面头部"></a>Page Header 页面头部</h3><blockquote>
<p>All problems in computer science can be solved by another level of indirection<br>计算机科学中的所有问题都可以通过增加一个间接层来解决</p>
</blockquote>
<p>在上文中，我们已经可以在一个数据页内部快速定位到我们所需要的记录，但是一张表中不仅仅存在一个数据页，如何快速定位到我们所需要的数据页呢?<br>答案是再加一层抽象：对于每一个下层，我们都对其进行抽象，屏蔽掉其内部细节，方便上层使用。</p>
<blockquote>
<p>Page Header 位于页结构的第二部分，用于存储页总的各种信息，比如第一条记录的地址是什么，本页存储了多少地址，页目录存储了多少个槽</p>
</blockquote>
<p>主要的信息：</p>
<ul>
<li>FIL_PAGE_SPAE_OR_CHECKSUM：校验和，通过算法来计算一个值，方便我们去比较</li>
<li>FIL_PAGE_OFFSET：页号，用于定位页</li>
<li>FIL_PAGE_TYPE：页类型，存放记录的页就是索引页，也是数据页</li>
<li>FIL_PAGE_PREV和FIL_PAGE_NEXT：用于组成双向链表</li>
</ul>
<h3 id="File-Trailer"><a href="#File-Trailer" class="headerlink" title="File Trailer"></a>File Trailer</h3><ol>
<li>存储页的校验和：与Header部分中的校验和对应，如果同步磁盘中同步到一半就失败了，那么Header中的校验和就会变成已经修改后的校验和，而Trailer的校验和还代表着原来的校验和，从而确定同步出现错误</li>
<li>页面最后被修改时对应的日志序列位置LSN</li>
</ol>
<h3 id="数据页结构总结"><a href="#数据页结构总结" class="headerlink" title="数据页结构总结"></a>数据页结构总结</h3><ul>
<li>File Header </li>
<li>Page Header</li>
<li>Infimum + Supremum </li>
<li>User Records</li>
<li>Free Space</li>
<li>Page Directory</li>
<li>File Trailer</li>
</ul>
<h2 id="索引！"><a href="#索引！" class="headerlink" title="索引！"></a>索引！</h2><p>以下部分是重中之重，可以说这篇文章就是为了这里才有写的必要的<br><del>指面试的时候因为忘了而被疯狂拷打</del></p>
<h3 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h3><ol>
<li>InnoDB中数据页通过双向链表连接起来</li>
<li>数据页内部的记录通过双向链表连接起来，并且按照主键从小到大进行排序</li>
<li>Page Directory 保存了每组记录最后一条记录的偏移量，方便我们快速定位到每个组<br><img src="/2024/09/14/10/%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84%E5%9B%9E%E9%A1%BE.png"></li>
</ol>
<h3 id="索引为什么会出现"><a href="#索引为什么会出现" class="headerlink" title="索引为什么会出现"></a>索引为什么会出现</h3><ol>
<li>对于主键查找，我们可以使用设计快速定位，而对于其他列，我们没有这种方便的方式可以快速定位</li>
<li>对于不同的页，我们也没办法快速定位到满足查询条件的记录所在的页在哪里，从而只能一个一个进行查找</li>
</ol>
<h3 id="索引的结构与实现原理"><a href="#索引的结构与实现原理" class="headerlink" title="索引的结构与实现原理"></a>索引的结构与实现原理</h3><ol>
<li>数据页链表中，后一个数据页中的主键值必须大于上一个页中用户记录的主键值。</li>
<li>仿照Page Directory，将数据页中的链表项建立目录</li>
<li>key为数据页中最小的主键，page_no为页号<img src="/2024/09/14/10/%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%841.png"></li>
</ol>
<h4 id="MySQL中的实现"><a href="#MySQL中的实现" class="headerlink" title="MySQL中的实现"></a>MySQL中的实现</h4><ol>
<li>使用数据页来存储目录项，通过record_type(0用户记录，1目录项记录，2最小记录，3最大记录)  来与用户记录进行区分<img src="/2024/09/14/10/%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%842.png"></li>
<li>一个数据页中存储的记录是有限的，所以需要使用链表的形式将目录串起来，保证后一个页中的页号要大于前一个</li>
<li>为了方便我们使用二分查找从目录链表中快速定位，我们可以再次将其使用目录记录<img src="/2024/09/14/10/%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%843.png"></li>
<li>反复之后就形成了B+树</li>
</ol>
<blockquote>
<p>B+树和B树的区别：<br>B+树只在最底层的节点上存储真实数据，其余都是用来存储目录项的，B树的任何一个节点都能保存数据</p>
</blockquote>
<h3 id="聚簇索引-重点"><a href="#聚簇索引-重点" class="headerlink" title="聚簇索引(重点)"></a>聚簇索引(重点)</h3><p>定义：</p>
<ol>
<li>使用主键值的大小进行记录和页的排序：<ul>
<li>页内记录按照主键大小的单向链表</li>
<li>存放用户记录的页根据主键大小排成双向链表</li>
<li>存放目录项的页也是同一层次排成双向链表</li>
</ul>
</li>
<li>叶子节点存储的是完整记录(包括隐藏列)<br>索引即数据，数据即索引。</li>
</ol>
<h3 id="二级索引"><a href="#二级索引" class="headerlink" title="二级索引"></a>二级索引</h3><ol>
<li>使用非主键值作为排序标准<ul>
<li>同聚簇索引，不过标准是我们使用的非主键</li>
</ul>
</li>
<li>B+树的叶子节点存储的是 这个列 + 主键两个列的值</li>
<li>目录项记录存的是 这个列 + 页号 + 主键<img src="/2024/09/14/10/%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95.png"><br>查询过程：<br>例如查询c2的值为4的记录：</li>
<li>根据页44， 2 &lt; 4 &lt; 9，可以定位到页42</li>
<li>c2没有唯一约束，所以4可能在多个记录中，由此对比可以确定应该在页34和页35，因为 2 &lt;4 &lt; 5</li>
<li>定位到具体的记录</li>
<li>通过具体记录中的主键值进行回表操作—&gt; 也就是根据主键值去聚簇索引中再查找一遍完整的用户记录</li>
</ol>
<h4 id="回表的好坏"><a href="#回表的好坏" class="headerlink" title="回表的好坏"></a>回表的好坏</h4><p>优点：<br>可以不用重新存储完整的数据，减少空间占用<br>缺点：<br>回表会浪费额外的时间</p>
<h3 id="联合索引-重点，加个书签"><a href="#联合索引-重点，加个书签" class="headerlink" title="联合索引(重点，加个书签)"></a>联合索引(重点，加个书签)</h3><p>比如对c2、c3建立联合索引</p>
<ol>
<li>记录和页按照c2进行排序</li>
<li>在这个基础上对c3进行排序</li>
<li>叶子节点存储的是c2、c3和主键的值</li>
<li>仍然是一个二级索引，也是需要回表的</li>
</ol>
<h3 id="MyISAM索引方案的差别"><a href="#MyISAM索引方案的差别" class="headerlink" title="MyISAM索引方案的差别"></a>MyISAM索引方案的差别</h3><ol>
<li>InnoDB使用索引即数据，而MyISAM将索引和数据分开存储。</li>
<li>将数据存在一个文件中，使用行号来快速访问，而不是使用主键值进行排序，无法进行二分查找</li>
<li>索引文件中存储的是主键值 + 行号，也就是所有查询都需要回表，全是二级索引</li>
<li>联合索引存储的也是行号 + 相应的列</li>
</ol>
<h3 id="创建和删除索引的sql"><a href="#创建和删除索引的sql" class="headerlink" title="创建和删除索引的sql"></a>创建和删除索引的sql</h3><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">CREATE TABLE 表名(
	列信息,
	KEY / INDEX 索引名 (需要被索引的单个列或者多个列，联合索引使用 , 隔开列)
)
ALTER TABLE 表名 ADD INDEX / KEY 索引名 (列)
ALTER TABLE 表名 DROP INDEX / KEY 索引名<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="索引的一些常见八股和如何合理使用B-树索引"><a href="#索引的一些常见八股和如何合理使用B-树索引" class="headerlink" title="索引的一些常见八股和如何合理使用B+树索引"></a>索引的一些常见八股和如何合理使用B+树索引</h3><h4 id="如何避免回表？"><a href="#如何避免回表？" class="headerlink" title="如何避免回表？"></a>如何避免回表？</h4><p>需要回表记录越多，使用二级索引的性能就越低。<br>覆盖索引：<br>在查询列表中只包含索引列，即可避免回表。所以一般不建议使用 * 作为查询列表，最好把需要查询的列都依次标明</p>
<h4 id="访问方法"><a href="#访问方法" class="headerlink" title="访问方法"></a>访问方法</h4><h5 id="全表扫描"><a href="#全表扫描" class="headerlink" title="全表扫描"></a>全表扫描</h5><h5 id="索引扫描"><a href="#索引扫描" class="headerlink" title="索引扫描"></a>索引扫描</h5><p>p139，接着看</p>
<h4 id="最适合建立索引的场景"><a href="#最适合建立索引的场景" class="headerlink" title="最适合建立索引的场景"></a>最适合建立索引的场景</h4><ol>
<li>全值匹配：搜索条件的列和索引列一致，可以快速使用索引</li>
<li>联合索引最左匹配原则</li>
<li>前缀匹配 abc%</li>
<li>索引列的范围查找</li>
<li>对查找出的索引列数据进行排序：索引列本来就是基于排序的，所以可以不需要再内存或文件中进行排序</li>
</ol>
<h4 id="索引失效的场景"><a href="#索引失效的场景" class="headerlink" title="索引失效的场景"></a>索引失效的场景</h4><ol>
<li>LiIKE操作符以通配符开头例如 “%xx”或 “%xx%” ，但是 “xx%” 可以使用索引。</li>
<li>对索引使用函数或者表达式操作 <code>select * from t_user where length(name)=6 </code>， 因为索引存的是原始值</li>
<li>对索引隐式转换，如果查询条件中的类型和列的类型不匹配，MySQL可能会进行类型转换，索引就会失效。因为索引存的是原始值</li>
<li>联合索引非最左匹配，多个普通字段组合在一起创建的索引叫做联合索引，不遵循最左优先的方式就会失效。</li>
<li>where子句中使用了OR，如果OR后的条件不是索引列就会失效</li>
<li>出现NULL值：<strong>不一定不走索引</strong> ，需要看查询的cost和优化器的选择。</li>
<li>联合索引没有对最左列进行范围查找<br>为何失效</li>
<li>like %xx：我们索引是根据列的值大小进行排列的，也就是说，例如我们对 小写字母建立索引，那么我们的索引全是基于 a -&gt; z的大小顺序排列的，同时我们是按照字典序的方式进行排序，也就是说如果前一个相同才会去根据后面的字母进行排序，也就是说当我们匹配abc%xxx的时候，我们可以顺着这个索引去查询，而我们匹配 %abc时，我们无法确认%之前的的字母是什么，于是我们必须走一次全表匹配所以无法走索引去去匹配</li>
<li>使用函数修改的列不满足最原始的排序了</li>
<li>联合索引，通过上文，我们可以很清楚的明白联合索引实际上就是先按照列的顺序去建立索引，只有前一个列相同，我们才会根据后一个列进行排序，也就是说，我们只有这种顺序能够保证是按照大小排序。如果我们没有遵循最左匹配，也就是将顺序倒置，那么后面的列是不能满足大小排序的，也就无法走索引</li>
<li>联合索引只有最左列是完全按照大小排序的，同时数据是基于链表，也就是我们可以很轻易将最左列的范围查找取出。</li>
</ol>
<h4 id="建立索引时应该考虑什么？重点"><a href="#建立索引时应该考虑什么？重点" class="headerlink" title="建立索引时应该考虑什么？重点"></a>建立索引时应该考虑什么？重点</h4><ol>
<li>只为用于搜索、排序、分组的列建立索引，出现在查询列表中的列就没必要建立索引了，因为走不走索引还是看查询条件、排序条件、分组条件，而不是查询的列</li>
<li>考虑列的基数(不重复的数据的个数)，为基数大的列建立索引效果更好</li>
<li>索引的类型尽量小，因为数据类型越小，查询时占用的存储空间越少，查询速度越快，数据页中可以放下更多的记录。</li>
<li>对于一些较长的字符串，可以只对其前缀建立索引<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">CREATE TABLE person_info(
 name VARCHAR(100) NOT NULL,
 birthday DATE NOT NULL,
 phone_number CHAR(11) NOT NULL,
 country varchar(100) NOT NULL,
 KEY idx_name_birthday_phone_number (name(10), birthday, phone_number)
);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li>让索引列在比较表达式中单独出现：这个和使用函数去修饰索引列是一个问题，会改变索引列的原来的形式，从而不能够走索引。例如:<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">WHERE c1 * 2 &lt; 4
替换为
WHERE c1 &lt; 4 / 2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li>
<li>插入数据时应该注意主键的顺序，因为当数据页满了，再插入记录时，会导致页分裂-&gt;将本页中的一些记录移动到新创建的野种，从而需要将记录转移，带来性能消耗，所以推荐让主键具有AUTO_INCREMENT</li>
</ol>
<h2 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h2><h3 id="循环嵌套连接"><a href="#循环嵌套连接" class="headerlink" title="循环嵌套连接"></a>循环嵌套连接</h3><p>两表连接，驱动表只访问一次，而被驱动表要访问多次。<br>左外连接左边的是驱动表。右外连接右边的表是驱动表<br>然后每一个被驱动表其实都是一次循环，多个表循环嵌套，驱动表的每一行都要去遍历被驱动表。这种连接被称为嵌套循环连接。</p>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h3 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h3><p>redo log 会把事务在执行过程中对数据库所做的所有的修改都记录下来，之后系统崩溃重启后可以把事务所做的任何操作都回复出来。</p>
<h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><p><img src="/2024/09/14/10/redolog.png"></p>
<ul>
<li>type：表示该redo日志的类型</li>
<li>space ID：表空间ID</li>
<li>page number：页号</li>
<li>data：该条redo 日志的具体内容<br>刷盘时机：</li>
<li>当log buffer空间不足时，当redo log占满了log buffer的一半左右</li>
<li>事务提交时</li>
<li>后台线程自动刷新，约是每秒一次</li>
<li>正常关闭服务器时</li>
</ul>
<h3 id="redo-log-如何保证事务的完整性的"><a href="#redo-log-如何保证事务的完整性的" class="headerlink" title="redo log 如何保证事务的完整性的"></a>redo log 如何保证事务的完整性的</h3><h2 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h2><p>undo log 是单独存储的</p>
<p><img src="/2024/09/14/10/undolog%E6%A0%BC%E5%BC%8F.png"></p>
<ul>
<li>trx_id事务id<br>被删除的记录也会通过记录头信息中的next_record组成一个单项链表，然后指向PAGE_FREE空间<img src="/2024/09/14/10/PAGE_FREE.png"><br>事务提交之前，被删除的记录的delete_mask会被设置为1，但是不会被加入垃圾链表中，也就是会处于中间态</li>
</ul>
<h2 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h2><p>只靠MVCC不能解决幻读，需要额外使用锁</p>
<h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><ol>
<li>每一行的数据都有多个版本，更新时不会覆盖原来的数据，而是生成新的版本。</li>
<li>读操作根据ReadView去读</li>
<li>写操作，旧的版本不会被删除，而是放在垃圾链表，将原来的数据写入undo log之后，通过roll_id指向这一行的undo log</li>
</ol>
<h3 id="事务隔离等级和几个并发会出现的问题"><a href="#事务隔离等级和几个并发会出现的问题" class="headerlink" title="事务隔离等级和几个并发会出现的问题"></a>事务隔离等级和几个并发会出现的问题</h3><h4 id="并发常见到的问题"><a href="#并发常见到的问题" class="headerlink" title="并发常见到的问题"></a>并发常见到的问题</h4><ol>
<li>脏读：一个事务读到了另一个未提交事务修改过的数据</li>
<li>不可重复读：一个事务两次读取读取到的数据不同，也就是两次读取之间被其他事务修改了数据</li>
<li>幻读：相同的查询，查出来的结果不同<br>几个等级：<br>脏写 &lt; 脏读 &lt; 不可重复读 &lt; 幻读</li>
</ol>
<h4 id="事务隔离等级"><a href="#事务隔离等级" class="headerlink" title="事务隔离等级"></a>事务隔离等级</h4><ol>
<li>读未提交：允许一个事务读取另一个事务未提交的数据 阻止不了上面几种</li>
<li>读已提交：只允许一个事务读取另一个事务已经提交的修改，可以阻止脏读</li>
<li>可重复读：保证同一个事务多次读取获得的数据是相同的，避免了脏读、不可重复读</li>
<li>可串行化：完全隔离事务，确保事务按照顺序执行，彷佛他们是串行执行的</li>
</ol>
<h4 id="版本链"><a href="#版本链" class="headerlink" title="版本链"></a>版本链</h4><p>rolle_pointer：每次对某条聚簇索引进行改动时，会将原来的旧版本写入到undo日志中，然后这个隐藏列就相当于一个指针，可以通过它来找到该记录修改之前的信息。<img src="/2024/09/14/10/%E7%89%88%E6%9C%AC%E9%93%BE.png"><br>每次对记录进行更新后，都会将旧值放到一条undo日志中，就算是该记录中的一个旧版本，随着更新次数的增多，所有的版本都会被role_pointer连接成一个链表，版本链的头节点就是当前记录的最新值，另外，每个版本还包含该版本时对应的事务id</p>
<h4 id="ReadView"><a href="#ReadView" class="headerlink" title="ReadView"></a>ReadView</h4><p>如何判断一条记录是否可以被某个事务可见。<br>ReadView的内容</p>
<ul>
<li>m_ids：表示生成ReadView时当前系统中活跃读写事务id列表</li>
<li>min_trx_id：表示生成ReadView时，当前系统中活跃的最小事务中的最小事务id，也就是m_ids的最小值</li>
<li>max_trx_id：生成ReadView时系统应该分配给下一个事务的id值。</li>
<li>creator_trx_id：表示生成该ReadView的事务的事务id<br>当事务访问某条记录时，进行一下判断访问是否可见：</li>
<li>被访问版本的trx_id == ReadView中的creator_trx_id时，意味着当前事务访问的是自己修改过的记录，可以被当前事务访问</li>
<li>trx_id &lt; ReadView中的min_trx_id，表示该版本是在当前事务之前旧已经提交了，可以访问</li>
<li>trx_id &gt; max_trx_id，表示当前记录的事务是在当前事务之后才开始的，不能访问</li>
<li>min_trx_id &lt; trx_id &lt; max_trx_id，说明创建ReadView时，该版本的事务还是活跃的，需要从m_ids中判断是否存在，如果存在就不能访问，否则就可以访问<br>如果某个版本的数据对于当前的事务不可见，就沿着版本链去找下一个版本的数据，如果版本链中所有的数据都不可见，才意味着这条记录对当前事务不可见，查询条件就不会包括这条记录。</li>
</ul>
<h4 id="读已提交和可重复读的区别"><a href="#读已提交和可重复读的区别" class="headerlink" title="读已提交和可重复读的区别"></a>读已提交和可重复读的区别</h4><p>区别就是二者的ReadView生成时机不同：</p>
<ul>
<li>读已提交在每次执行查询语句时生成一个ReadView，此后不会再重复生成了</li>
<li>可重复读只在第一次进行查询语句时生成一个ReadView，此后查询操作都重复使用这个ReadView，从而做到保证多次读取读取到相同的数据。</li>
</ul>
<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><h3 id="锁的结构"><a href="#锁的结构" class="headerlink" title="锁的结构"></a>锁的结构</h3><p><img src="/2024/09/14/10/%E9%94%81%E7%9A%84%E7%BB%93%E6%9E%84.png"><br>对于每一条记录，都会有一个锁对应。当一个事务相对这条记录做改动时，首先会看看内存中是否有与这条记录想关联的锁结构，如果没有就需要生成一个锁结构与之关联。<br>所结构中的最重要的两个属性：</p>
<ul>
<li>trx信息：这个锁结构是由哪个事务生成的</li>
<li>is_waiting：代表当前事务是否在等待</li>
</ul>
<ol>
<li>获取锁成功/加锁：当事务修改这条记录时，如果不存在锁，就会在修改记录之后生成一个锁机构1，trx是这个事务的id，is_waiting是false。</li>
<li>获取锁失败：当其他事务尝试修改这条记录时发现存在了如果发现已经存在了这个锁1，那么就会给自己生成一个锁2，但是is_waiting是true，表示需要等待。</li>
<li>当事务1正常提交之后会把该事务生成的锁结构1删除，然后查看是否还有其他别的事务在等待获取锁，发现事务2在等待，于是就将锁2的is_waiting设置为false，之后将这个事务的线程唤醒，继续执行。</li>
</ol>
<h4 id="一致性读"><a href="#一致性读" class="headerlink" title="一致性读"></a>一致性读</h4><p>事务使用MVCC进行读取被称为一致性读，或者一致性无锁读，也叫快照读。</p>
<h4 id="锁定读"><a href="#锁定读" class="headerlink" title="锁定读"></a>锁定读</h4><p>行级锁<br>对于读写冲突问题，MySQL使用了MVCC+锁来解决</p>
<ol>
<li>共享锁：Shared Locks S锁，读取记录时需要先获取该记录的S锁</li>
<li>独占锁：也叫排他锁， X锁，修改记录时需要鲜活的该记录的X锁。<br>主动加锁的sql<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SELECT ... LOCK IN SHARE MODE; # 加S锁
SELECT ... FOR UPDATE; # 加X锁<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li>
</ol>
<h3 id="多粒度锁"><a href="#多粒度锁" class="headerlink" title="多粒度锁"></a>多粒度锁</h3><p>上文提到的都是行级锁</p>
<ul>
<li>意向共享锁 IS锁：表级锁</li>
<li>意向独占锁 IX锁：表级锁<br>这两个锁时为了之后对表添加表级别的S锁和X锁时可以快判断表中的记录是否被上锁，以免需要使用遍历来确定是否有记录被上锁了。</li>
</ul>
<h3 id="InnoDB中的锁"><a href="#InnoDB中的锁" class="headerlink" title="InnoDB中的锁"></a>InnoDB中的锁</h3><h4 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h4><ul>
<li>表级的S锁、X锁：</li>
<li>表级的IS锁、IX锁：</li>
<li>表级的AUTO-INC锁：自增AUTO_INCREMENT修饰的列递增赋值</li>
</ul>
<h4 id="行级锁-重点"><a href="#行级锁-重点" class="headerlink" title="行级锁(重点)"></a>行级锁(重点)</h4><ul>
<li>Record Locks：正经记录锁，分为S锁和X锁</li>
<li>Gap Locks：间隙锁，加锁方案解决幻读的关键</li>
<li>Next-Key锁：简单来说就是 record locks + gap locks</li>
<li>Insert Intention Locks：事务在等待的时候也需要在内存中生成一个锁结构，表明有事务想在某个间隙中插入新记录。叫做插入意向锁，目的是避免插入操作的相互阻塞</li>
</ul>
<h4 id="Gap-Locks"><a href="#Gap-Locks" class="headerlink" title="Gap Locks"></a>Gap Locks</h4><p>对于幻读中出现的幻影记录，我们没法加锁，因为他们还未存在。<br>间隙锁就是所著一个范围内所有的间隙，从而阻止其事务在这些间隙中插入数据</p>
<h1 id="八股"><a href="#八股" class="headerlink" title="八股"></a>八股</h1><h2 id="InnoDB为什么是默认引擎"><a href="#InnoDB为什么是默认引擎" class="headerlink" title="InnoDB为什么是默认引擎"></a>InnoDB为什么是默认引擎</h2><ol>
<li>唯一支持事务的引擎</li>
<li>行级锁</li>
<li>支持外键约束</li>
<li>崩溃恢复，redolog和undolog</li>
</ol>
<h2 id="为什么InnoDB使用B-树"><a href="#为什么InnoDB使用B-树" class="headerlink" title="为什么InnoDB使用B+树"></a>为什么InnoDB使用B+树</h2><ol>
<li>支持快速查找：平衡多路查找树，高度较低</li>
<li>有序性：翻遍范围查找分组</li>
<li>插入和删除更搞笑：使用双向链表</li>
<li>适应磁盘存储：节点的大小控制在磁盘页面大小范围内，减少I/O操作</li>
<li>支持有序查找和范围查找</li>
</ol>
<h2 id="MVCC-1"><a href="#MVCC-1" class="headerlink" title="MVCC"></a>MVCC</h2><p>多版本并发控制</p>
<ol>
<li>每一行的记录都维护多个版本，每一行更新时，不会覆盖原来的数据，而是会生成新的版本</li>
<li>读操作只读事务创建之前的</li>
</ol>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2024/09/09/30/" rel="prev" title="美团测开一面">
      <i class="fa fa-chevron-left"></i> 美团测开一面
    </a></div>
      <div class="post-nav-item">
    <a href="/2024/09/22/32/" rel="next" title="深入浅出动态代理">
      深入浅出动态代理 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAMySQL"><span class="nav-number">1.</span> <span class="nav-text">深入浅出MySQL</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="nav-number">1.1.</span> <span class="nav-text">存储引擎</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%96%E7%A0%81%E6%A0%BC%E5%BC%8F"><span class="nav-number">1.1.1.</span> <span class="nav-text">编码格式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#InnoDB"><span class="nav-number">1.2.</span> <span class="nav-text">InnoDB</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%89%A9%E7%90%86%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-number">1.3.</span> <span class="nav-text">物理存储结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A1%8C%E6%A0%BC%E5%BC%8F"><span class="nav-number">1.3.1.</span> <span class="nav-text">行格式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%BA%A2%E5%87%BA%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8"><span class="nav-number">1.3.1.1.</span> <span class="nav-text">溢出数据存储</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E9%A1%B5-%E9%87%8D%E7%82%B9%EF%BC%8C%E9%87%8D%E4%B8%AD%E4%B9%8B%E9%87%8D"><span class="nav-number">1.4.</span> <span class="nav-text">数据页(重点，重中之重)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%B0%E5%BD%95%E5%A4%B4%E4%BF%A1%E6%81%AF"><span class="nav-number">1.4.1.</span> <span class="nav-text">记录头信息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E5%B0%8F%E8%AE%B0%E5%BD%95%E5%92%8C%E6%9C%80%E5%A4%A7%E8%AE%B0%E5%BD%95"><span class="nav-number">1.4.2.</span> <span class="nav-text">最小记录和最大记录</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MySQL%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E6%9F%A5%E6%89%BE%E7%9A%84"><span class="nav-number">1.4.3.</span> <span class="nav-text">MySQL是如何进行查找的</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Page-Directory"><span class="nav-number">1.4.4.</span> <span class="nav-text">Page Directory</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E6%89%BE%E8%BF%87%E7%A8%8B"><span class="nav-number">1.4.5.</span> <span class="nav-text">查找过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Page-Header-%E9%A1%B5%E9%9D%A2%E5%A4%B4%E9%83%A8"><span class="nav-number">1.4.6.</span> <span class="nav-text">Page Header 页面头部</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#File-Trailer"><span class="nav-number">1.4.7.</span> <span class="nav-text">File Trailer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E9%A1%B5%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93"><span class="nav-number">1.4.8.</span> <span class="nav-text">数据页结构总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%EF%BC%81"><span class="nav-number">1.5.</span> <span class="nav-text">索引！</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9E%E9%A1%BE"><span class="nav-number">1.5.1.</span> <span class="nav-text">回顾</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%87%BA%E7%8E%B0"><span class="nav-number">1.5.2.</span> <span class="nav-text">索引为什么会出现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">1.5.3.</span> <span class="nav-text">索引的结构与实现原理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#MySQL%E4%B8%AD%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.5.3.1.</span> <span class="nav-text">MySQL中的实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95-%E9%87%8D%E7%82%B9"><span class="nav-number">1.5.4.</span> <span class="nav-text">聚簇索引(重点)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95"><span class="nav-number">1.5.5.</span> <span class="nav-text">二级索引</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%9E%E8%A1%A8%E7%9A%84%E5%A5%BD%E5%9D%8F"><span class="nav-number">1.5.5.1.</span> <span class="nav-text">回表的好坏</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95-%E9%87%8D%E7%82%B9%EF%BC%8C%E5%8A%A0%E4%B8%AA%E4%B9%A6%E7%AD%BE"><span class="nav-number">1.5.6.</span> <span class="nav-text">联合索引(重点，加个书签)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MyISAM%E7%B4%A2%E5%BC%95%E6%96%B9%E6%A1%88%E7%9A%84%E5%B7%AE%E5%88%AB"><span class="nav-number">1.5.7.</span> <span class="nav-text">MyISAM索引方案的差别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%92%8C%E5%88%A0%E9%99%A4%E7%B4%A2%E5%BC%95%E7%9A%84sql"><span class="nav-number">1.5.8.</span> <span class="nav-text">创建和删除索引的sql</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%A7%81%E5%85%AB%E8%82%A1%E5%92%8C%E5%A6%82%E4%BD%95%E5%90%88%E7%90%86%E4%BD%BF%E7%94%A8B-%E6%A0%91%E7%B4%A2%E5%BC%95"><span class="nav-number">1.5.9.</span> <span class="nav-text">索引的一些常见八股和如何合理使用B+树索引</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%9B%9E%E8%A1%A8%EF%BC%9F"><span class="nav-number">1.5.9.1.</span> <span class="nav-text">如何避免回表？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%BF%E9%97%AE%E6%96%B9%E6%B3%95"><span class="nav-number">1.5.9.2.</span> <span class="nav-text">访问方法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%A8%E8%A1%A8%E6%89%AB%E6%8F%8F"><span class="nav-number">1.5.9.2.1.</span> <span class="nav-text">全表扫描</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E6%89%AB%E6%8F%8F"><span class="nav-number">1.5.9.2.2.</span> <span class="nav-text">索引扫描</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%80%E9%80%82%E5%90%88%E5%BB%BA%E7%AB%8B%E7%B4%A2%E5%BC%95%E7%9A%84%E5%9C%BA%E6%99%AF"><span class="nav-number">1.5.9.3.</span> <span class="nav-text">最适合建立索引的场景</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E7%9A%84%E5%9C%BA%E6%99%AF"><span class="nav-number">1.5.9.4.</span> <span class="nav-text">索引失效的场景</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BB%BA%E7%AB%8B%E7%B4%A2%E5%BC%95%E6%97%B6%E5%BA%94%E8%AF%A5%E8%80%83%E8%99%91%E4%BB%80%E4%B9%88%EF%BC%9F%E9%87%8D%E7%82%B9"><span class="nav-number">1.5.9.5.</span> <span class="nav-text">建立索引时应该考虑什么？重点</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9E%E6%8E%A5"><span class="nav-number">1.6.</span> <span class="nav-text">连接</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E5%B5%8C%E5%A5%97%E8%BF%9E%E6%8E%A5"><span class="nav-number">1.6.1.</span> <span class="nav-text">循环嵌套连接</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1"><span class="nav-number">1.7.</span> <span class="nav-text">事务</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#redo-log"><span class="nav-number">1.7.1.</span> <span class="nav-text">redo log</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%BC%E5%BC%8F"><span class="nav-number">1.7.2.</span> <span class="nav-text">格式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#redo-log-%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%AE%8C%E6%95%B4%E6%80%A7%E7%9A%84"><span class="nav-number">1.7.3.</span> <span class="nav-text">redo log 如何保证事务的完整性的</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#undo-log"><span class="nav-number">1.8.</span> <span class="nav-text">undo log</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MVCC"><span class="nav-number">1.9.</span> <span class="nav-text">MVCC</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">1.9.1.</span> <span class="nav-text">实现原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%AD%89%E7%BA%A7%E5%92%8C%E5%87%A0%E4%B8%AA%E5%B9%B6%E5%8F%91%E4%BC%9A%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-number">1.9.2.</span> <span class="nav-text">事务隔离等级和几个并发会出现的问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E5%B8%B8%E8%A7%81%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-number">1.9.2.1.</span> <span class="nav-text">并发常见到的问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%AD%89%E7%BA%A7"><span class="nav-number">1.9.2.2.</span> <span class="nav-text">事务隔离等级</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%89%88%E6%9C%AC%E9%93%BE"><span class="nav-number">1.9.2.3.</span> <span class="nav-text">版本链</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ReadView"><span class="nav-number">1.9.2.4.</span> <span class="nav-text">ReadView</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%BB%E5%B7%B2%E6%8F%90%E4%BA%A4%E5%92%8C%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.9.2.5.</span> <span class="nav-text">读已提交和可重复读的区别</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%94%81"><span class="nav-number">1.10.</span> <span class="nav-text">锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%81%E7%9A%84%E7%BB%93%E6%9E%84"><span class="nav-number">1.10.1.</span> <span class="nav-text">锁的结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%80%E8%87%B4%E6%80%A7%E8%AF%BB"><span class="nav-number">1.10.1.1.</span> <span class="nav-text">一致性读</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%94%81%E5%AE%9A%E8%AF%BB"><span class="nav-number">1.10.1.2.</span> <span class="nav-text">锁定读</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E7%B2%92%E5%BA%A6%E9%94%81"><span class="nav-number">1.10.2.</span> <span class="nav-text">多粒度锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#InnoDB%E4%B8%AD%E7%9A%84%E9%94%81"><span class="nav-number">1.10.3.</span> <span class="nav-text">InnoDB中的锁</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A1%A8%E7%BA%A7%E9%94%81"><span class="nav-number">1.10.3.1.</span> <span class="nav-text">表级锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A1%8C%E7%BA%A7%E9%94%81-%E9%87%8D%E7%82%B9"><span class="nav-number">1.10.3.2.</span> <span class="nav-text">行级锁(重点)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Gap-Locks"><span class="nav-number">1.10.3.3.</span> <span class="nav-text">Gap Locks</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%AB%E8%82%A1"><span class="nav-number">2.</span> <span class="nav-text">八股</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#InnoDB%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E9%BB%98%E8%AE%A4%E5%BC%95%E6%93%8E"><span class="nav-number">2.1.</span> <span class="nav-text">InnoDB为什么是默认引擎</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88InnoDB%E4%BD%BF%E7%94%A8B-%E6%A0%91"><span class="nav-number">2.2.</span> <span class="nav-text">为什么InnoDB使用B+树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MVCC-1"><span class="nav-number">2.3.</span> <span class="nav-text">MVCC</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">QingQiu</p>
  <div class="site-description" itemprop="description">个人网站，学习记录，面试记录和经验总结、互联网中一块属于自己的小窝</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">51</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">19</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Zuofw/zuofw-rpc" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Zuofw&#x2F;zuofw-rpc" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2022 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">QingQiu</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="站点总字数">408k</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  















  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
