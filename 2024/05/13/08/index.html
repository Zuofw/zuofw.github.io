<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"zuofw.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="多线程#todo    金三银四精选面试题系列-徐庶 (yuque.com)专门写一个线程池相关的文章  泛型相关的👍 2024金三银四100道面试题笔记资料 (yuque.com)  基本概念 CAS (Compare-And-Swap，比较并交换)，是一种用于实现多线程同步的原子操作。主要原理：1.比较内存中的某个位置的当前值和预期值 2.交换如果当前值与预期值相等，则将该位置的值更新为新值">
<meta property="og:type" content="article">
<meta property="og:title" content="多线程">
<meta property="og:url" content="https://zuofw.github.io/2024/05/13/08/index.html">
<meta property="og:site_name" content="QingQiu&#39;Blog">
<meta property="og:description" content="多线程#todo    金三银四精选面试题系列-徐庶 (yuque.com)专门写一个线程池相关的文章  泛型相关的👍 2024金三银四100道面试题笔记资料 (yuque.com)  基本概念 CAS (Compare-And-Swap，比较并交换)，是一种用于实现多线程同步的原子操作。主要原理：1.比较内存中的某个位置的当前值和预期值 2.交换如果当前值与预期值相等，则将该位置的值更新为新值">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://zuofw.github.io/2024/05/13/08/CPU%E6%A6%82%E5%BF%B5.png">
<meta property="og:image" content="https://zuofw.github.io/2024/05/13/08/i++.png">
<meta property="og:image" content="https://zuofw.github.io/2024/05/13/08/%E9%94%81%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9.png">
<meta property="og:image" content="https://zuofw.github.io/2024/05/13/08/%E5%89%8D%E7%BD%AE%E6%A6%82%E5%BF%B5.png">
<meta property="og:image" content="https://zuofw.github.io/2024/05/13/08/%E9%87%8D%E6%8E%92%E5%BA%8F.png">
<meta property="og:image" content="https://zuofw.github.io/2024/05/13/08/Java%E5%AF%B9%E8%B1%A1%E5%A4%B4.png">
<meta property="og:image" content="https://zuofw.github.io/2024/05/13/08/%E5%AF%B9%E8%B1%A1%E5%A4%B4%E4%BC%9A%E9%9A%8F%E7%9D%80%E9%94%81%E6%A0%87%E5%BF%97%E4%BD%8D%E7%9A%84%E5%8F%98%E5%8C%96%E8%80%8C%E5%8F%98%E5%8C%96.png">
<meta property="og:image" content="https://zuofw.github.io/2024/05/13/08/Java%E7%BA%BF%E7%A8%8B%E5%86%85%E5%AD%98%E5%85%B1%E4%BA%AB.png">
<meta property="og:image" content="https://zuofw.github.io/2024/05/13/08/JDK1.67%E5%AE%9E%E7%8E%B0.png">
<meta property="og:image" content="https://zuofw.github.io/2024/05/13/08/JDK1.8%E5%AE%9E%E7%8E%B0.png">
<meta property="og:image" content="https://zuofw.github.io/2024/05/13/08/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%89%A7%E8%A1%8C%E7%A4%BA%E6%84%8F%E5%9B%BE.png">
<meta property="og:image" content="https://zuofw.github.io/2024/05/13/08/jdk%E7%BA%BF%E7%A8%8B%E6%B1%A0.png">
<meta property="og:image" content="https://zuofw.github.io/2024/05/13/08/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F.png">
<meta property="article:published_time" content="2024-05-13T10:05:08.000Z">
<meta property="article:modified_time" content="2024-10-11T02:52:06.000Z">
<meta property="article:author" content="QingQiu">
<meta property="article:tag" content="多线程">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zuofw.github.io/2024/05/13/08/CPU%E6%A6%82%E5%BF%B5.png">

<link rel="canonical" href="https://zuofw.github.io/2024/05/13/08/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>多线程 | QingQiu'Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>


<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">QingQiu'Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">清秋的博客</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-fa fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-fa fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-fa fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-fa fa-archive"></i>归档</a>

  </li>
        <li class="menu-item menu-item-github">

    <a href="https://github.com/Zuofw" rel="noopener" target="_blank"><i class="fa fa-fw fa-fab fa-github"></i>Github</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zuofw.github.io/2024/05/13/08/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="QingQiu">
      <meta itemprop="description" content="个人网站，学习记录，面试记录和经验总结、互联网中一块属于自己的小窝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="QingQiu'Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          多线程
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-05-13 18:05:08" itemprop="dateCreated datePublished" datetime="2024-05-13T18:05:08+08:00">2024-05-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-10-11 10:52:06" itemprop="dateModified" datetime="2024-10-11T10:52:06+08:00">2024-10-11</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B9%B6%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">并发</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>8.7k</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><p>#todo </p>
<ul>
<li><input disabled type="checkbox"> <a target="_blank" rel="noopener" href="https://www.yuque.com/tulingzhouyu/db22bv/gd98aqe6nn6e73qq">金三银四精选面试题系列-徐庶 (yuque.com)</a>专门写一个线程池相关的文章</li>
<li><input disabled type="checkbox"> 泛型相关的<a target="_blank" rel="noopener" href="https://www.yuque.com/tulingzhouyu/db22bv/avpxs3qirk1w4qod">👍 2024金三银四100道面试题笔记资料 (yuque.com)</a></li>
</ul>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ol>
<li>CAS (Compare-And-Swap，比较并交换)，是一种用于实现多线程同步的原子操作。主要原理：1.比较内存中的某个位置的当前值和预期值 2.交换如果当前值与预期值相等，则将该位置的值更新为新值，否则不进行任何操作。<ul>
<li>因为是原子操作所以在多线程中很高效。可以实现无锁编程，避免了上下文切换的开销。</li>
<li>缺点是如果CAS操作失败后，通常会进行自旋，消耗CPU资源。</li>
</ul>
</li>
<li>自旋：当一个线程尝试获取锁但是所以经被其他线程获取时，该线程不会进入睡眠模式，而是会在一个循环中不断的检查锁的状态，直到锁被释放，这种方式叫做自旋。<ul>
<li>优点是：低开销，可以避免线程上下文切换的开销，因为线程不会进入睡眠状态。适用于短时间的锁定，因为时间段，自旋等待的开销可能比线程切换开销更低。</li>
<li>缺点是：CPU消耗搞，自旋不断等待占用CPU，也不适合长时间锁定，因为线程会长时间占用CPU资源进行无效的检查。</li>
</ul>
</li>
<li>并发：一段时间内进行  并行：同一时刻同时进行</li>
</ol>
<h2 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h2><p><img src="/2024/05/13/08/CPU%E6%A6%82%E5%BF%B5.png"></p>
<h3 id="处理器如何实现原子操作的"><a href="#处理器如何实现原子操作的" class="headerlink" title="处理器如何实现原子操作的"></a>处理器如何实现原子操作的</h3><ol>
<li>使用总线锁来保证原子性：如果多个处理器同时对共享变量进行读改写操作(例如i++)，共享会被多个处理器同时进行操作，导致共享变量的值与期望不同。<img src="/2024/05/13/08/i++.png">因为他们会从自己的缓存中读取变量i，然后分别进行+1，之后分别写入系统内存中<ul>
<li>处理器总线锁：使用了处理器提供的LOCK#信号，当一个处理器在总线上发出这个信号，其他处理器的请求将被阻塞住。从而实现独占共享内存。</li>
</ul>
</li>
<li>使用缓存锁：总线锁会导致其他处理器不能处理其他内存地址的数据，我们只需要保证对某个内存地址的操作是原子的就行。<ul>
<li>频繁使用的内存会缓存在处理器的L1、L2、L3高速缓存中。</li>
<li>缓存锁定：缓存锁定是某个CPU对缓存数据进行更改时，会通知缓存了该数据的该数据的CPU抛弃缓存的数据或者从内存重新读取。</li>
</ul>
</li>
</ol>
<h2 id="多线程就一定快吗？"><a href="#多线程就一定快吗？" class="headerlink" title="多线程就一定快吗？"></a>多线程就一定快吗？</h2><p>不一定，因为线程切换涉及到上下文切换和线程创建的开销</p>
<h2 id="如何减少上下文的切换次数"><a href="#如何减少上下文的切换次数" class="headerlink" title="如何减少上下文的切换次数"></a>如何减少上下文的切换次数</h2><ol>
<li>无锁并发编程：避免使用锁，利用将数据的ID按照Hash算法取模运算，不同线程处理不同段的数据</li>
<li>CAS算法：不需要加锁</li>
<li>使用最少线程：避免创建不需要的线程</li>
<li>协程：单线程中实现多任务的调度，并且再单线程中维持多个任务间的切</li>
</ol>
<h2 id="资源限制"><a href="#资源限制" class="headerlink" title="资源限制"></a>资源限制</h2><p>并发编程中，如果多线程占用的资源超过系统资源的限制，实际上仍然是串行执行的，而且因为有上下文切换的影响，反而会更慢</p>
<h2 id="如何避免死锁"><a href="#如何避免死锁" class="headerlink" title="如何避免死锁"></a>如何避免死锁</h2><ol>
<li>避免一个线程同时获得多个锁</li>
<li>避免一个线程在锁内同事占用多个资源，尽量保证每个锁只占用一个资源</li>
<li>尝试使用定时锁 <code>lock.tryLock(timeout)</code>来替代内部锁机制</li>
<li>对于数据库锁，枷锁和解锁必须在一个数据库连接里，否则会出现解锁失败的情况</li>
</ol>
<h2 id="常用的线程分析工具"><a href="#常用的线程分析工具" class="headerlink" title="常用的线程分析工具"></a>常用的线程分析工具</h2><h3 id="vmstat"><a href="#vmstat" class="headerlink" title="vmstat"></a>vmstat</h3><p>常用指令，具体的参数自己去搜，这里主要看的是cs指标，代表每秒上下文切换次数</p>
<pre class="line-numbers language-css" data-language="css"><code class="language-css">vmstat [delay] [count] 后面参数可选
每隔delay秒输出一次统计信息，总共输出count次
vmstat -s 显示系统的累计统计信息
	   -d 显示统计信息
	   -p +指定分区 显示指定分区的统计信息
	   -a 显示活动内存和非活动内存的信息
	   -m 显示slabinfo信息<span class="token punctuation">(</span>`slabinfo` 是 Linux 内核中用于显示 slab 分配器（slab allocator）信息的工具<span class="token punctuation">)</span>
	   -t 在输出中添加时间戳<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="Java中的多线程"><a href="#Java中的多线程" class="headerlink" title="Java中的多线程"></a>Java中的多线程</h2><p>当在一个JVM进程里面开多个线程时，这些线程被分成两类：守护线程和非守护线程。默认开的都是非守护线程。在Java中有一个规定：当所有的非守护线程退出后，整个JVM进程就会退出。意思就是守护线程“不算作数”，守护线程不影响整个 JVM 进程的退出。例如，垃圾回收线程就是守护线程，它们在后台默默工作，当开发者的所有前台线程（非守护线程）都退出之后，整个JVM进程就退出了。</p>
<h2 id="Wait方法为什么不定义在Thread中？"><a href="#Wait方法为什么不定义在Thread中？" class="headerlink" title="Wait方法为什么不定义在Thread中？"></a>Wait方法为什么不定义在Thread中？</h2><p>Wait释放的锁是写在Java对象头中，所以是写在Object中而非当前线程</p>
<h3 id="锁的分类和对比"><a href="#锁的分类和对比" class="headerlink" title="锁的分类和对比"></a>锁的分类和对比</h3><p>Java中锁存在四种状态</p>
<ol>
<li>无锁状态</li>
<li>偏向锁状态</li>
<li>轻量级锁状态</li>
<li>重量级锁状态<br>锁可以升级但是不能降级，这种设定能够提高获得锁和释放锁的效率<br><img src="/2024/05/13/08/%E9%94%81%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9.png"></li>
</ol>
<h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><p>大多数情况下锁不仅不存在多线程竞争，而且总是由同意线程多次获得。<br>当一个线程访问同步块并且获得锁时，会在对象头和栈帧中的锁记录里面存锁偏向的线程ID，以后该线程进入/推出额同步块块时，不需要进行CAS来进行枷锁和解锁，只需要测试对象头Mark Word里是否存储着这项当前线程的偏向锁。<br>如果测试失败就看偏向锁的标识是否为1，1是偏向锁，如果不是就用CAS竞争锁，否则尝试使用CAS将偏向锁设置为当前线程</p>
<h5 id="偏向锁的撤销"><a href="#偏向锁的撤销" class="headerlink" title="偏向锁的撤销"></a>偏向锁的撤销</h5><ol>
<li>偏向锁只有其他线程尝试竞争偏向锁时持有偏向锁的线程才会释放锁。</li>
<li>偏向锁的撤销，需要在全局安全点(在这个事件电商没有正在执行的字节码)，会先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否或者，如果线程处于不活跃状态，则将对象头设置成无锁状态；如果线程仍然存活，则拥有偏向锁的栈会被执行，便利偏向对象的锁记录，要么重新偏向其他线程，要么恢复到无锁或者标记独享不适合作为偏向锁，最后唤醒暂停的线程。</li>
</ol>
<h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><h5 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h5><blockquote>
<p>线程在执行同步块之前，JVM会在当前线程的栈帧中创建用于存储锁记录的空间，并且将对象头中的Mark Word复制到锁记录中(Displaced Mark Word替)。然后线程尝试使用CAS将对象头中的Mark Word替换为只想所记录的指针。如果成功，当前线程获得锁，如果失败，尝试使用自旋来获得锁。</p>
</blockquote>
<h5 id="解锁"><a href="#解锁" class="headerlink" title="解锁"></a>解锁</h5><blockquote>
<p>会使用原子的CAS操作将Displaced Mark Word替换回对象头。如果成功则说明没有竞争发生，如果失败，标识当前锁存在竞争。锁会升级成重量级锁。</p>
</blockquote>
<h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><p>volatile是轻量级的synchronized，保证了共享变量的可见性，同时不会引起上下文的切换和调度。<br>但是i++不能保证原子性的，因为i++是读写两次操作。<br>JVM中并没有要求64位long/double写入是原子的。所以多线程读取时又可以读到的是”一半”的值。这个时候就需要使用volatile了</p>
<h4 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h4><ol>
<li>保证单词写入/读入原子性</li>
<li>内存可见性</li>
<li>禁止重排序</li>
</ol>
<h4 id="前置概念"><a href="#前置概念" class="headerlink" title="前置概念"></a>前置概念</h4><p><img src="/2024/05/13/08/%E5%89%8D%E7%BD%AE%E6%A6%82%E5%BF%B5.png"></p>
<h4 id="volatile是如何实现的？"><a href="#volatile是如何实现的？" class="headerlink" title="volatile是如何实现的？"></a>volatile是如何实现的？</h4><ol>
<li>转变成汇编语言之后会多一个Lock前缀，这个前缀会将当前处理器缓存行的数据写回系统内存，同时其他CPU中缓存了该内存地址的数据无效。修改volatile变量会强制将修改之后的值刷新到内存中同时导致其他线程中的该变量值失效。</li>
<li>处理器会根据MESI(修改、独占、共享、无效)控制协议去维护内部缓存。处理器使用嗅探技术保证它的内部缓存、系统内存和其他处理器的缓存的数据在总线上保持一致。</li>
</ol>
<p>可见性：<br>修改volatile变量会强制将修改之后的值刷新到内存中<br>同时导致其他线程中的该变量值失效。<br>有序性：遵循happen-before<br>内存屏障：JVM通过内存屏障来实现的</p>
<h4 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h4><p>CPU防止代码进行重排序而提供的指令。<br>Unsafe提供了以下的内存屏障方法</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//内存屏障，禁止load操作重排序。屏障前的load操作不能被重排序到屏障后，屏障后的load操作不能被重排序到屏障前</span>
<span class="token keyword">public</span> <span class="token keyword">native</span> <span class="token keyword">void</span> <span class="token function">loadFence</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//内存屏障，禁止store操作重排序。屏障前的store操作不能被重排序到屏障后，屏障后的store操作不能被重排序到屏障前</span>
<span class="token keyword">public</span> <span class="token keyword">native</span> <span class="token keyword">void</span> <span class="token function">storeFence</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//内存屏障，禁止load、store操作重排序</span>
<span class="token keyword">public</span> <span class="token keyword">native</span> <span class="token keyword">void</span> <span class="token function">fullFence</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="重排序问题"><a href="#重排序问题" class="headerlink" title="重排序问题"></a>重排序问题</h4><blockquote>
<p>执行程序时，为了提高性能编译器和处理器常常会对执行进行重排序。</p>
<ol>
<li>编译器优化的重排序：不改变单线程语义的情况下，可以重新安排语句的执行顺序</li>
<li>指令级并行的重排序：现代处理器采用了指令级并行技术来讲多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</li>
<li>内存系统的重排序：由于处理器使用缓存和读/写缓冲区，是的加载和存储操作看上去可能时再乱序执行</li>
</ol>
</blockquote>
<p><img src="/2024/05/13/08/%E9%87%8D%E6%8E%92%E5%BA%8F.png"></p>
<h5 id="as-if-serial"><a href="#as-if-serial" class="headerlink" title="as-if-serial"></a>as-if-serial</h5><p>多线程程序中的重排序，编译器和CPU只能保证每个线程的线程内部之间都是“看似完全串行的”，但是多个线程会相互读取和写入共享的变量不会进行考虑。</p>
<h5 id="happen-before"><a href="#happen-before" class="headerlink" title="happen-before"></a>happen-before</h5><p>保证一个线程的执行结果对另一个线程可见。<br>#todo </p>
<ul>
<li><input disabled type="checkbox"> synchronized原理</li>
</ul>
<h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><h4 id="是可重入的吗"><a href="#是可重入的吗" class="headerlink" title="是可重入的吗"></a>是可重入的吗</h4><blockquote>
<p>可重入（Reentrant）是指在多线程环境中，一个函数可以被多个线程同时调用而不会引起任何问题。</p>
</blockquote>
<p>是可重入的，因为synchronized关键字是基于JVM内部的监视器锁，这种锁是依赖于对象头中的标记字段来管理锁的状态。<br>当线程第一次获得锁时，他的线程ID会被记录在对象头的标记字段中，并且计数器设置为1，如果同一线程需要再次进入由自己持有锁的synchronized块时，计数器就会+1，当synchronized块时，计数器-1。当计数器回到0时，锁才真正被释放，此时其他线程可以尝试获取这个锁。</p>
<h4 id="synchronized可以锁的类型"><a href="#synchronized可以锁的类型" class="headerlink" title="synchronized可以锁的类型"></a>synchronized可以锁的类型</h4><ol>
<li>对于普通同步方法，锁的是实例对象</li>
<li>对于静态同步方法，锁的是当前类的Class对象，包括这个类的所有对象</li>
<li>对于同步方法块，锁的是Synchornized括号里的对象</li>
</ol>
<h4 id="实现和原理"><a href="#实现和原理" class="headerlink" title="实现和原理"></a>实现和原理</h4><ol>
<li>synchronized用的锁是存在Java对象头里的，如果对象是数组类型，则虚拟机用三个字宽存储对象头。<img src="/2024/05/13/08/Java%E5%AF%B9%E8%B1%A1%E5%A4%B4.png"></li>
<li>对象头会随着锁标志位的变化而变化 <img src="/2024/05/13/08/%E5%AF%B9%E8%B1%A1%E5%A4%B4%E4%BC%9A%E9%9A%8F%E7%9D%80%E9%94%81%E6%A0%87%E5%BF%97%E4%BD%8D%E7%9A%84%E5%8F%98%E5%8C%96%E8%80%8C%E5%8F%98%E5%8C%96.png" alt="对象头会随着锁标志位的变化而变化"></li>
</ol>
<h3 id="Java内存模型的基础"><a href="#Java内存模型的基础" class="headerlink" title="Java内存模型的基础"></a>Java内存模型的基础</h3><p>并发编程中常常需要解决线程之间如何进行通信和如何进行同步。<br>在命令式编程中，线程之间的通信机制有两种：共享内存和消息传递。</p>
<blockquote>
<p>共享内存是线程共享程序的公共状态，通过读写内存的公共状态来进行通信。消息传递则是线程之间必须通过发送消息来显示的进行通信。</p>
</blockquote>
<p>Java中使用的是共享内存模型。<img src="/2024/05/13/08/Java%E7%BA%BF%E7%A8%8B%E5%86%85%E5%AD%98%E5%85%B1%E4%BA%AB.png"><br>他们之间的通信需要修改共享变量，然后由另一个去读取共享变量来实现。<br>JDK5 开始，Java使用JSP-133内存模型，使用happens-before：前一个操作的结果对后一个操作可见 </p>
<h3 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h3><h4 id="什么是CountDownLatch？"><a href="#什么是CountDownLatch？" class="headerlink" title="什么是CountDownLatch？"></a>什么是CountDownLatch？</h4><p>CountDownLatch 是通过一个计数器来实现的，计数器的初始值就是线程的数量，每当一个线程执行完毕之后，计数器的值就-1，然后在闭锁上等待的线程就可以恢复工作了。<br>主要使用场景：</p>
<ul>
<li>用于等待多个线程完成一个整体的前提任务<br>实例：在进行业务之前将两个数据库中的数据进行同步(非集群的数据库)<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span></span><span class="token class-name">CountDownLatch</span></span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DatabaseSync</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">syncDatabase1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 这里是同步数据库1的代码</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">syncDatabase2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 这里是同步数据库2的代码</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sync</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>
        <span class="token class-name">CountDownLatch</span> latch <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountDownLatch</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
            <span class="token function">syncDatabase1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            latch<span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
            <span class="token function">syncDatabase2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            latch<span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 等待两个数据库同步操作完成</span>
        latch<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Both databases have been synchronized."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>
        <span class="token keyword">new</span> <span class="token class-name">DatabaseSync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
<h3 id="JUC包"><a href="#JUC包" class="headerlink" title="JUC包"></a>JUC包</h3><h4 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a>CompletableFuture</h4><p>Future的缺点：不支持异步任务的编排，同时get方法是阻塞调用<br>完全可控的Fututure<br>使⽤线程池时，我们应该尽量避免将耗时任务提交到线程池中执⾏。对于⼀些⽐较耗时的操作，如<br>⽹络请求、⽂件读写等，可以采⽤ CompletableFuture 等其他异步操作的⽅式来处理，以避<br>免阻塞线程池中的线程<br>示例代码：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">CompletableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Map</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Map</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> future <span class="token operator">=</span> <span class="token class-name">CompletableFuture</span><span class="token punctuation">.</span><span class="token function">supplyAsync</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> adminClient<span class="token punctuation">.</span><span class="token function">distributedInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h4 id="CompletableFuture源码分析"><a href="#CompletableFuture源码分析" class="headerlink" title="CompletableFuture源码分析"></a>CompletableFuture源码分析</h4><ul>
<li>runAsync不允许返回值，适合需要一步操作但是不关心返回结果 </li>
<li>supplyAsync需要返回值，适合需要返回值的异步操作</li>
<li>thenApply、thenAccept、thenRun、whenComplete 可以对结果进行进一步处理</li>
<li>异常处理使用handle</li>
<li>合并future结果，thenCompose是链接两个CompletabelFuture，并将前一个结果作为下一个任务参数，thenCombine会将两个任务都结束之后，将两个任务的结果合并，并行执行</li>
<li>allOf等待所有的执行完成之后再调用<br>默认使用的是ForkJoinPool.commonPool作为执行器，这个线程池全局共享，可能会被其他任务占用</li>
</ul>
<h4 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h4><p>线程安全的HashMap，多线程情况下HashMap进行put操作会进入死循环。而使用HashTable效率又很低，因为当一个线程访问HashTable的同步方法，其他线程也访问时，会进入阻塞或轮询状态，所有的线程都必须竞争同一把锁。而我们只需要有多把锁，每一把锁都只锁住某一部分数据即可。这就是ConcurrentHashMap使用的锁分段技术。<br>JDK1.7使用的是分段的数据+链表实现的，JDK1.8使用的数据结构跟HashMap一职，数组+链表/红黑树。使用的是Node数组+链表+红黑树，通过synchronized和CAS操作来帮正线程安全</p>
<h4 id="实现原理-具体看源码"><a href="#实现原理-具体看源码" class="headerlink" title="实现原理 具体看源码"></a>实现原理 具体看源码</h4><h5 id="1-7"><a href="#1-7" class="headerlink" title="1.7"></a>1.7</h5><p>Segment数组(不可扩容) 作为分段锁，是可重入锁，对其中的一部分加锁<img src="/2024/05/13/08/JDK1.67%E5%AE%9E%E7%8E%B0.png"></p>
<h4 id="1-8"><a href="#1-8" class="headerlink" title="1.8"></a>1.8</h4><p>使用的是Node数组+链表/红黑树，Node只适用于链表的情况，而红黑树需要TreeNode。使用Node+CAS+synchronized来保证线程安全<img src="/2024/05/13/08/JDK1.8%E5%AE%9E%E7%8E%B0.png"></p>
<h5 id="常用的api"><a href="#常用的api" class="headerlink" title="常用的api"></a>常用的api</h5><h6 id="get"><a href="#get" class="headerlink" title="get"></a>get</h6><p>先进性一次散列，然后使用这个散列值定位到Segment，再进行散列定位到元素。<br>get不需要加锁，因为get方法中使用的共享变量都顶i成volatile类型，额能够在线程之间保持可见性。保证不会读到过期的值，但是只能被单线程写(如果写入的值依赖原值)<br>根据happen before原则，对volatile字段的写是优先于读的。</p>
<h6 id="put"><a href="#put" class="headerlink" title="put"></a>put</h6><p>对共享变量进行写入操作，为了线程安全必须加锁。<br>先定位到Segment，之后再Segment里进行操作，所以只需要锁住一个Segment即可<br>扩容机制：只会对某个segment进行扩容。</p>
<h6 id="count"><a href="#count" class="headerlink" title="count"></a>count</h6><p>先尝试不加锁来统计各个Segment的大小，如果两次中出现了不同的数值，就采用加锁的方式来统计所有Segment大小。<br>原理是格局modCount变量，put、remove、clean方法都会把modCount+1</p>
<h4 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h4><p>线程安全的&nbsp;List，用来替代Vector<br>Vector的核心思想是每次访问都上锁，使用synchronized进行加锁，会导致性能很差<br>而CopyOnWriteArrayList则是使用了跟读写锁相似的思想，读读不互斥。写不会堵塞读取操作，只有写写才会出现互斥，核心思想是写时复制：不会直接修改原数组，而是先创建底层数组的副本，对副本进行修改，修改完之后再将修改后的数据赋值回去。</p>
<h4 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h4><p>线程安全的队列，是非阻塞实现的</p>
<h5 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h5><p>入队<br>使用CAS算法实现的</p>
<ol>
<li>定位尾节点</li>
<li>使用CAS算法来不断尝试将节点加入队列：如果尾节点的next是null表示已经是尾节点了，如果不是说明其他县城更新了尾节点，需要重新或如当前队列的尾节点。<br>出队<br>先获得头节点的元素，判断头节点元素是否为空，如果为空就是已经被别的线程取走，如果不为空就用CAS尝试出队</li>
</ol>
<h4 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h4><p>有多种实现<br>值得注意的时Pirority和Delay<br>阻塞队列，当队列满时，队列会阻塞插入元素的线程，之道队列布满。<br>当队列为空时，获取元素的线程会等待队列变成非空<br>常用于成缠着消费者问题</p>
<h5 id="实现原理-1"><a href="#实现原理-1" class="headerlink" title="实现原理"></a>实现原理</h5><p>通知模式实现</p>
<blockquote>
<p>通知模式是生产者往满的队列中添加队列时会阻塞住生产者。当消费者消费了一个队列中的元素后，会通知生产者当前的队列可用</p>
</blockquote>
<h4 id="CountDownLatch-1"><a href="#CountDownLatch-1" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h4><p>示例代码</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>

    <span class="token keyword">static</span> <span class="token class-name">CountDownLatch</span> countDownLatch <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountDownLatch</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>
        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token punctuation">{</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            countDownLatch<span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            countDownLatch<span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        countDownLatch<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h4><p>同步屏障<br>功能是让一组线程到达一个屏障(同步点)时被阻塞，直到最后一个线程到达屏障时才开门，所有被阻塞的线程才会继续运行。<br>与CountDownLatch的区别：countdownlatch只能使用一次，计数器无法重置。cyclicbarrier可以多次重复使用，当所有的线程到达同步点之后屏障会重置。</p>
<p><strong>CyclicBarrier：用于让一组线程互相等待，直到所有线程都到达某个屏障点，然后所有线程再继续执行。可以重用。<br>CountDownLatch：用于一个或多个线程等待其他线程完成某些操作。不能重用。</strong> </p>
<p>二者使用方法相似<br>如何选择：<br>简单的一次性同步任务可以使用countdownlatch，例如初始化一些配置<br>多阶段反复同步线程或者并发任务需要分阶段执行，每个阶段都需要等待所有的线程完成，选择cyclicbarrier</p>
<h4 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h4><p>信号量，控制同时访问特定资源的线程数量。</p>
<h4 id="Exchanger"><a href="#Exchanger" class="headerlink" title="Exchanger"></a>Exchanger</h4><p>进行线程之间协作的工具类。提供一个同步点，两个线程可以在这个同步点交换彼此的数据。</p>
<h3 id="原子类"><a href="#原子类" class="headerlink" title="原子类"></a>原子类</h3><p>Atomic包</p>
<h3 id="Java中的线程池"><a href="#Java中的线程池" class="headerlink" title="Java中的线程池"></a>Java中的线程池</h3><h4 id="实现原理-2"><a href="#实现原理-2" class="headerlink" title="实现原理"></a>实现原理</h4><ol>
<li>判断核心线程池里的线程是否都在执行任务，如果不是则新建一个工作线程来执行任务；如果都在执行任务，则进入下一个流程</li>
<li>判断工作 队列是否已经满，如果没满，将新提交的任务存储在这个工作队列里，如果满了，进入下一个流程</li>
<li>判断线程池中 当线程是否都在工作中，如果没有就创建一个新的工作线程来执行任务，如果已经满了，则交给饱和策略来处理这个任务<br><img src="/2024/05/13/08/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%89%A7%E8%A1%8C%E7%A4%BA%E6%84%8F%E5%9B%BE.png"><br><img src="/2024/05/13/08/jdk%E7%BA%BF%E7%A8%8B%E6%B1%A0.png"></li>
</ol>
<h4 id="核心参数"><a href="#核心参数" class="headerlink" title="核心参数"></a>核心参数</h4><ol>
<li>核心线程数：任务队列没满时可以同时执行的最大线程数</li>
<li>最大线程数：任务队列满时，可以同时运行的线程数</li>
<li>线程空闲时间：线程数量超过核心线程数时，多余的空闲线程再中止前等待新任务的最长时间</li>
<li>时间单位</li>
<li>任务队列：</li>
<li>线程工厂</li>
<li>拒绝策略：当任务无法提交到线程池时的处理策略。<ul>
<li><code>AbortPolicy</code>：抛出&nbsp;<code>RejectedExecutionException</code>&nbsp;异常（默认策略）。</li>
<li><code>CallerRunsPolicy</code>：由调用线程处理该任务。</li>
<li><code>DiscardPolicy</code>：直接丢弃任务。</li>
<li><code>DiscardOldestPolicy</code>：丢弃队列中最旧的任务，然后重新提交新任务。<br><img src="/2024/05/13/08/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F.png"></li>
</ul>
</li>
</ol>
<h4 id="任务执行顺序"><a href="#任务执行顺序" class="headerlink" title="任务执行顺序"></a>任务执行顺序</h4><ol>
<li>当前运行中的线程数小于核心线程数，就新建一个线程来执行任务，即使线程池中存在空闲线程</li>
<li>如果大于等于核心线程数，但是小于最大线程数，就把任务加入到任务队列中</li>
<li>如果队列已满，但是线程数小于最大线程数，就新建一个线程来执行任务</li>
<li>如果新创建线程会导致当前运行中的线程数大于最大线程数，就会调用拒绝策略</li>
</ol>
<h3 id="生产者-消费者模型："><a href="#生产者-消费者模型：" class="headerlink" title="生产者-消费者模型："></a>生产者-消费者模型：</h3><p>一个内存队列，多个生产线程往内存队列中放数据，多个消费者线程从内存对俄中取数据。</p>
<ol>
<li>内存队列本身需要枷锁，才能实现线程安全</li>
<li>阻塞。当内存队列满了，生产者被阻塞，内存队列为空时消费者被阻塞。</li>
<li>双向通知：消费者被阻塞之后，生产者放入新数据，要通知消费者，反之要通知生产者。</li>
</ol>
<h1 id="Unsafe"><a href="#Unsafe" class="headerlink" title="Unsafe"></a>Unsafe</h1><p>主要功能</p>
<ol>
<li>内存屏障</li>
</ol>
<h1 id="ReenTrantLock"><a href="#ReenTrantLock" class="headerlink" title="ReenTrantLock"></a>ReenTrantLock</h1><h2 id="实现原理-3"><a href="#实现原理-3" class="headerlink" title="实现原理"></a>实现原理</h2><p>实现是一种自旋锁，使用循环调用CAS操作来进行加锁。</p>
<h1 id="线程同步的方法"><a href="#线程同步的方法" class="headerlink" title="线程同步的方法"></a>线程同步的方法</h1><ol>
<li>Synchronized</li>
<li>ReentrantLock</li>
<li>CountDownLatch</li>
<li>CyclicBarrier</li>
<li>Semaphore</li>
<li>Wait和No</li>
</ol>
<p>#todo </p>
<ul>
<li><input disabled type="checkbox"> 加上书签</li>
</ul>
<h1 id="Fork-x2F-Join与线程池的区别"><a href="#Fork-x2F-Join与线程池的区别" class="headerlink" title="Fork/Join与线程池的区别"></a>Fork/Join与线程池的区别</h1><p>核心是ForkJoinPool，使用的是工作窃取方来平衡</p>
<h1 id="AQS-AbstactQueuedSynchronizer"><a href="#AQS-AbstactQueuedSynchronizer" class="headerlink" title="AQS (AbstactQueuedSynchronizer)"></a>AQS (AbstactQueuedSynchronizer)</h1><p>是一个抽象类，提供了线程同步的底层实现机制，</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" rel="tag"># 多线程</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2024/05/13/00/" rel="prev" title="Spring 循环依赖会出现什么情况？ 如何解决?">
      <i class="fa fa-chevron-left"></i> Spring 循环依赖会出现什么情况？ 如何解决?
    </a></div>
      <div class="post-nav-item">
    <a href="/2024/05/16/42/" rel="next" title="Java新特性">
      Java新特性 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-number">1.</span> <span class="nav-text">多线程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">1.1.</span> <span class="nav-text">基本概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C"><span class="nav-number">1.2.</span> <span class="nav-text">原子操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E5%99%A8%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E7%9A%84"><span class="nav-number">1.2.1.</span> <span class="nav-text">处理器如何实现原子操作的</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B0%B1%E4%B8%80%E5%AE%9A%E5%BF%AB%E5%90%97%EF%BC%9F"><span class="nav-number">1.3.</span> <span class="nav-text">多线程就一定快吗？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%87%8F%E5%B0%91%E4%B8%8A%E4%B8%8B%E6%96%87%E7%9A%84%E5%88%87%E6%8D%A2%E6%AC%A1%E6%95%B0"><span class="nav-number">1.4.</span> <span class="nav-text">如何减少上下文的切换次数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B5%84%E6%BA%90%E9%99%90%E5%88%B6"><span class="nav-number">1.5.</span> <span class="nav-text">资源限制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81"><span class="nav-number">1.6.</span> <span class="nav-text">如何避免死锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7"><span class="nav-number">1.7.</span> <span class="nav-text">常用的线程分析工具</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#vmstat"><span class="nav-number">1.7.1.</span> <span class="nav-text">vmstat</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java%E4%B8%AD%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-number">1.8.</span> <span class="nav-text">Java中的多线程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Wait%E6%96%B9%E6%B3%95%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%AE%9A%E4%B9%89%E5%9C%A8Thread%E4%B8%AD%EF%BC%9F"><span class="nav-number">1.9.</span> <span class="nav-text">Wait方法为什么不定义在Thread中？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%81%E7%9A%84%E5%88%86%E7%B1%BB%E5%92%8C%E5%AF%B9%E6%AF%94"><span class="nav-number">1.9.1.</span> <span class="nav-text">锁的分类和对比</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%81%8F%E5%90%91%E9%94%81"><span class="nav-number">1.9.1.1.</span> <span class="nav-text">偏向锁</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%81%8F%E5%90%91%E9%94%81%E7%9A%84%E6%92%A4%E9%94%80"><span class="nav-number">1.9.1.1.1.</span> <span class="nav-text">偏向锁的撤销</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81"><span class="nav-number">1.9.1.2.</span> <span class="nav-text">轻量级锁</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8A%A0%E9%94%81"><span class="nav-number">1.9.1.2.1.</span> <span class="nav-text">加锁</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%A7%A3%E9%94%81"><span class="nav-number">1.9.1.2.2.</span> <span class="nav-text">解锁</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#volatile"><span class="nav-number">1.9.2.</span> <span class="nav-text">volatile</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BB%E8%A6%81%E5%8A%9F%E8%83%BD"><span class="nav-number">1.9.2.1.</span> <span class="nav-text">主要功能</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%8D%E7%BD%AE%E6%A6%82%E5%BF%B5"><span class="nav-number">1.9.2.2.</span> <span class="nav-text">前置概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#volatile%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F"><span class="nav-number">1.9.2.3.</span> <span class="nav-text">volatile是如何实现的？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C"><span class="nav-number">1.9.2.4.</span> <span class="nav-text">内存屏障</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%87%8D%E6%8E%92%E5%BA%8F%E9%97%AE%E9%A2%98"><span class="nav-number">1.9.2.5.</span> <span class="nav-text">重排序问题</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#as-if-serial"><span class="nav-number">1.9.2.5.1.</span> <span class="nav-text">as-if-serial</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#happen-before"><span class="nav-number">1.9.2.5.2.</span> <span class="nav-text">happen-before</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#synchronized"><span class="nav-number">1.9.3.</span> <span class="nav-text">synchronized</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%98%AF%E5%8F%AF%E9%87%8D%E5%85%A5%E7%9A%84%E5%90%97"><span class="nav-number">1.9.3.1.</span> <span class="nav-text">是可重入的吗</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#synchronized%E5%8F%AF%E4%BB%A5%E9%94%81%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.9.3.2.</span> <span class="nav-text">synchronized可以锁的类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E5%92%8C%E5%8E%9F%E7%90%86"><span class="nav-number">1.9.3.3.</span> <span class="nav-text">实现和原理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%9F%BA%E7%A1%80"><span class="nav-number">1.9.4.</span> <span class="nav-text">Java内存模型的基础</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CountDownLatch"><span class="nav-number">1.9.5.</span> <span class="nav-text">CountDownLatch</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFCountDownLatch%EF%BC%9F"><span class="nav-number">1.9.5.1.</span> <span class="nav-text">什么是CountDownLatch？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JUC%E5%8C%85"><span class="nav-number">1.9.6.</span> <span class="nav-text">JUC包</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#CompletableFuture"><span class="nav-number">1.9.6.1.</span> <span class="nav-text">CompletableFuture</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CompletableFuture%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="nav-number">1.9.6.2.</span> <span class="nav-text">CompletableFuture源码分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ConcurrentHashMap"><span class="nav-number">1.9.6.3.</span> <span class="nav-text">ConcurrentHashMap</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-%E5%85%B7%E4%BD%93%E7%9C%8B%E6%BA%90%E7%A0%81"><span class="nav-number">1.9.6.4.</span> <span class="nav-text">实现原理 具体看源码</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-7"><span class="nav-number">1.9.6.4.1.</span> <span class="nav-text">1.7</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-8"><span class="nav-number">1.9.6.5.</span> <span class="nav-text">1.8</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84api"><span class="nav-number">1.9.6.5.1.</span> <span class="nav-text">常用的api</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#get"><span class="nav-number">1.9.6.5.1.1.</span> <span class="nav-text">get</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#put"><span class="nav-number">1.9.6.5.1.2.</span> <span class="nav-text">put</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#count"><span class="nav-number">1.9.6.5.1.3.</span> <span class="nav-text">count</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CopyOnWriteArrayList"><span class="nav-number">1.9.6.6.</span> <span class="nav-text">CopyOnWriteArrayList</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ConcurrentLinkedQueue"><span class="nav-number">1.9.6.7.</span> <span class="nav-text">ConcurrentLinkedQueue</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">1.9.6.7.1.</span> <span class="nav-text">实现原理</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#BlockingQueue"><span class="nav-number">1.9.6.8.</span> <span class="nav-text">BlockingQueue</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-1"><span class="nav-number">1.9.6.8.1.</span> <span class="nav-text">实现原理</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CountDownLatch-1"><span class="nav-number">1.9.6.9.</span> <span class="nav-text">CountDownLatch</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CyclicBarrier"><span class="nav-number">1.9.6.10.</span> <span class="nav-text">CyclicBarrier</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Semaphore"><span class="nav-number">1.9.6.11.</span> <span class="nav-text">Semaphore</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Exchanger"><span class="nav-number">1.9.6.12.</span> <span class="nav-text">Exchanger</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%9F%E5%AD%90%E7%B1%BB"><span class="nav-number">1.9.7.</span> <span class="nav-text">原子类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-number">1.9.8.</span> <span class="nav-text">Java中的线程池</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-2"><span class="nav-number">1.9.8.1.</span> <span class="nav-text">实现原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%E5%8F%82%E6%95%B0"><span class="nav-number">1.9.8.2.</span> <span class="nav-text">核心参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="nav-number">1.9.8.3.</span> <span class="nav-text">任务执行顺序</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B%EF%BC%9A"><span class="nav-number">1.9.9.</span> <span class="nav-text">生产者-消费者模型：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Unsafe"><span class="nav-number">2.</span> <span class="nav-text">Unsafe</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ReenTrantLock"><span class="nav-number">3.</span> <span class="nav-text">ReenTrantLock</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-3"><span class="nav-number">3.1.</span> <span class="nav-text">实现原理</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">4.</span> <span class="nav-text">线程同步的方法</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Fork-x2F-Join%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">5.</span> <span class="nav-text">Fork&#x2F;Join与线程池的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#AQS-AbstactQueuedSynchronizer"><span class="nav-number">6.</span> <span class="nav-text">AQS (AbstactQueuedSynchronizer)</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">QingQiu</p>
  <div class="site-description" itemprop="description">个人网站，学习记录，面试记录和经验总结、互联网中一块属于自己的小窝</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">57</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">26</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Zuofw/zuofw-rpc" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Zuofw&#x2F;zuofw-rpc" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2022 – 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">QingQiu</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="站点总字数">470k</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  















  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
