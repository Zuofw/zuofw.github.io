<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"zuofw.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="计网概念MTU:网络中一次可以传输的最大数据包的大小MSS:TCP中除去TCP和IP的头部，能够传输的最大的数据量SDU，Service Data Unit，服务数据单元。ISP 是 Internet Service Provider 的缩写，翻译为互联网服务提供商。协议Telnet 客户端登录协议，属于应用层TLD 是 Top-Level Domain 的缩写，翻译为顶级域名GBN (Go-Ba">
<meta property="og:type" content="article">
<meta property="og:title" content="计网">
<meta property="og:url" content="https://zuofw.github.io/2023/10/23/46/index.html">
<meta property="og:site_name" content="QingQiu&#39;Blog">
<meta property="og:description" content="计网概念MTU:网络中一次可以传输的最大数据包的大小MSS:TCP中除去TCP和IP的头部，能够传输的最大的数据量SDU，Service Data Unit，服务数据单元。ISP 是 Internet Service Provider 的缩写，翻译为互联网服务提供商。协议Telnet 客户端登录协议，属于应用层TLD 是 Top-Level Domain 的缩写，翻译为顶级域名GBN (Go-Ba">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://zuofw.github.io/2023/10/23/46/TcpHeader.png">
<meta property="og:image" content="https://zuofw.github.io/2023/10/23/46/%E5%8F%91%E9%80%81%E6%96%B9%E7%AA%97%E5%8F%A3.png">
<meta property="og:image" content="https://zuofw.github.io/2023/10/23/46/%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98.png">
<meta property="og:image" content="https://zuofw.github.io/2023/10/23/46/CA%E7%AE%97%E6%B3%95.png">
<meta property="og:image" content="https://zuofw.github.io/2023/10/23/46/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D%E7%AE%97%E6%B3%95.png">
<meta property="og:image" content="https://zuofw.github.io/2023/10/23/46/%E4%BB%A3%E7%90%86%E4%BA%BA.webp">
<meta property="og:image" content="https://zuofw.github.io/2023/10/23/46/%E4%B8%89%E6%8F%A1%E5%9B%9B%E6%8C%A5.png">
<meta property="og:image" content="https://zuofw.github.io/2023/10/23/46/%E5%A4%B4%E9%83%A8.png">
<meta property="og:image" content="https://zuofw.github.io/2023/10/23/46/%E4%BD%BF%E7%94%A8cookie%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5.png">
<meta property="og:image" content="https://zuofw.github.io/2023/10/23/46/TCP%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3.png">
<meta property="og:image" content="https://zuofw.github.io/2023/10/23/46/%E5%BF%AB%E9%80%9F%E6%81%A2%E5%A4%8D.png">
<meta property="og:image" content="https://zuofw.github.io/2023/10/23/46/DNS%E8%AE%B0%E5%BD%95%E6%A0%BC%E5%BC%8F.png">
<meta property="og:image" content="https://zuofw.github.io/2023/10/23/46/tcp%E6%8A%A5%E6%96%87.png">
<meta property="article:published_time" content="2023-10-23T12:01:46.000Z">
<meta property="article:modified_time" content="2024-10-15T14:28:33.348Z">
<meta property="article:author" content="QingQiu">
<meta property="article:tag" content="计网">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zuofw.github.io/2023/10/23/46/TcpHeader.png">

<link rel="canonical" href="https://zuofw.github.io/2023/10/23/46/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>计网 | QingQiu'Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>


<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">QingQiu'Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">清秋的博客</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-fa fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-fa fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-fa fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-fa fa-archive"></i>归档</a>

  </li>
        <li class="menu-item menu-item-github">

    <a href="https://github.com/Zuofw" rel="noopener" target="_blank"><i class="fa fa-fw fa-fab fa-github"></i>Github</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zuofw.github.io/2023/10/23/46/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="QingQiu">
      <meta itemprop="description" content="个人网站，学习记录，面试记录和经验总结、互联网中一块属于自己的小窝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="QingQiu'Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          计网
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-10-23 20:01:46" itemprop="dateCreated datePublished" datetime="2023-10-23T20:01:46+08:00">2023-10-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-10-15 22:28:33" itemprop="dateModified" datetime="2024-10-15T22:28:33+08:00">2024-10-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">计算机基础</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>16k</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="计网"><a href="#计网" class="headerlink" title="计网"></a>计网</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>MTU:网络中一次可以传输的最大数据包的大小<br>MSS:TCP中除去TCP和IP的头部，能够传输的最大的数据量<br>SDU，Service Data Unit，服务数据单元。<br>ISP 是 Internet Service Provider 的缩写，翻译为互联网服务提供商。<br>协议<br>Telnet 客户端登录协议，属于应用层<br>TLD 是 Top-Level Domain 的缩写，翻译为顶级域名<br>GBN (Go-Back-N)  退回<br>SR 选择性重传<br>mask 子网掩码<br>SDN 是指软件定义网络（Software-Defined Networking）<br>OSPF（Open Shortest Path First）是一种开放式的链路状态路由协议，用于计算机网络中的动态路由。<br>Secure sockets layer (SSL)</p>
<p><strong>MSL:报文最大生存时间<br>TTL:经过的路由跳数</strong></p>
<p>序列号：在建立连接时由内核生成的随机数作为其初始值，通过 SYN 报文传给接收端主机，每发送一次数据，就「累加」一次该「数据字节数」的大小。用来解决网络包乱序问题。<br>确认号：指下一次「期望」收到的数据的序列号，发送端收到接收方发来的 ACK 确认报文以后，就可以认为在这个序号以前的数据都已经被正常接收。用来解决丢包的问题。<br><strong>控制位：</strong> 用来标识 TCP 报文是什么类型的报文，比如是 SYN 报文、数据报文、ACK 报文，FIN 报文等。</p>
<h1 id="面试常问"><a href="#面试常问" class="headerlink" title="面试常问"></a>面试常问</h1><ul>
<li>UDP是面向报文的：发送方不会对报文进行拆分，所以一个报文就是一个完整的消息，接收方使用队列来区分不同报文</li>
<li>TCP是面向字节流的：粘包问题：TCP报文会拆分成多个，取决于<strong>发送窗口、拥塞窗口以及当前发送缓冲区的大小等条件</strong>，所以不容易知道一个用户消息的边界<ul>
<li><img src="/2023/10/23/46/TcpHeader.png"></li>
<li>控制位是单独的留出来的几个位置</li>
<li>TCP面向字节流的，发送的是一个个连续的字节，而UDP是面向数据报的，一个UDP数据报就是一个完整的消息</li>
<li>重传机制：1.超时重传，重传时间最好略大于包的往返时间，2.快速重传3.SACK重传，选择性确认&nbsp;TCP 头部「选项」字段里加一个&nbsp;<code>SACK</code>&nbsp;的东西，它<strong>可以将已收到的数据的信息发送给「发送方」</strong>，这样发送方就可以知道哪些数据收到了，哪些数据没收到，知道了这些信息，就可以<strong>只重传丢失的数据</strong>。4.   Duplicate SACK,只告诉对方有哪些数据被重复接受了</li>
<li>滑动窗口：<strong>无需等待确认应答，而可以继续发送数据的最大值</strong></li>
<li><strong>拥塞窗口 cwnd</strong>是发送方维护的一个的状态变量，它会根据<strong>网络的拥塞程度动态变化的</strong>。 网络没出现拥塞，cwnd增加，出现拥塞cwnd减少</li>
</ul>
</li>
<li>HTTP：最常使用的是HTTP/1.1 <ul>
<li>优化 HTTP/1.1<ol>
<li>减少请求次数：1.使用客户端缓存，2.减少重定向次数，3.合并请求，4.延迟发送，只发送一部分内容</li>
<li>减少响应数据大小：使用压缩方式</li>
</ol>
</li>
</ul>
<ol>
<li>Keep-Alive：用于保持长连接，keepalive，TCP中的保活机制,HTTP1.1默认是开启的，在请求头中使用<code>Connection: Keep-Alive</code></li>
<li>强制缓存：服务器直接要求使用浏览器缓存的数据， 协商缓存：服务器会对比缓存过期时间，决定是否过期，返回给浏览器决定是否使用浏览器的缓存</li>
<li>队头阻塞：服务端在处理请求时耗时较长导致后面的请求无法即使发送，解决方式 ：使用管道：客户端可以直接发送多个请求，服务端根据发送顺序来解决，但是管道技术基本 <strong>没人使用</strong></li>
</ol>
<ul>
<li>演进过程：<ol>
<li>1.1 使用长连接改善短链接的性能开销，使用管道进传输，改善了队头阻塞。缺点是：header未压缩，只能压缩body,只能从客户端开始发送请求，没有请求优先级</li>
<li>2 头部压缩，当同时发送多个请求，如果请求头是一样或者相似的就把重复发部分消除，基于HTTPS的，头部全部使用二进制格式取代原来的纯文本，使用Stream,一个Stream可以包含多个Message,Message中可以包含多个Frame,Frame中包含Headers和Body,Stream都跑在同一个TCP上，客户端收到后会根据相同的Stream ID 有序组装成HTTP消息，Stream流用于多路复用TCP<ul>
<li>缺点是：由于TCP的是基于字节流的，必须保证收到的字节数据是完整且恋雪的才能将数据返回给应用层</li>
</ul>
</li>
<li>HTTP/3 使用UDP协议来解决响应的队头阻塞。<ol>
<li>使用基于UDP的QUIC协议，保证类似的可靠传输</li>
<li>QUIC 有自己的一套机制可以保证传输的可靠性的。当某个流发生丢包时，只会阻塞这个流，其他流不会受到影响，因此不存在队头阻塞问题。这与 HTTP/2 不同，HTTP/2 只要某个流中的数据包丢失了，其他流也会因此受影响。</li>
<li>当某个流丢包时，只会阻塞这个流，其他流不会阻塞，不存在队头阻塞问题</li>
<li><a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/2_http/https_rsa.html#tls-%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B">RSA算法</a>不支持前向加密，只要获取浏览器的私钥，即可破解</li>
<li></li>
</ol>
</li>
</ol>
</li>
</ul>
</li>
<li>HTTPS: <ol>
<li>使用混合加密：通信建立前使用非对称加密来交换会话密钥， 通信过程中使用对称加密的会话密钥来进行通信</li>
<li>公钥运算出的结果，只有使用私钥来进行逆运算得到结果。 发送时，发送者使用接收者的公钥，公钥是可知的，解决了密钥交换的问题，接收者使用自己的私钥进行解密。</li>
<li>公钥加密，私钥解密：保证传输过程中内容的加密</li>
<li>私钥加密，公钥解密：保证消息不会被篡改。—&gt;数字签名算法</li>
<li>使用权威机构CA(数字证书认证机构)来保存数字证书：个人信息+公钥+数字签名</li>
</ol>
</li>
<li>TCP<ul>
<li>三次握手的过程<ol>
<li>客户端发送带有SYN(同步序列)SEQ(序列号) = x  标志的数据包，客户端进入SYN_SEND状态</li>
<li>服务端发送带有SYN(SEQ = y) + ACK (ACK = x + 1) 标志的数据包，进入SYN_RECV状态</li>
<li>客户端发送 带有ACK(ACK = y + 1) 标志的数据包，二者进入ESTABLISHED状态</li>
</ol>
<ul>
<li>为什么要第二次传回SYN 用于表明所收到的是对应的客户端发送的信号</li>
</ul>
</li>
<li>四次挥手:<ol>
<li>客户端发送FIN(SEQ = x) ，进入FIN-WAIT-1状态</li>
<li>服务端发送ACK(ACK=x+1) 进入CLOSE-WAIT状态，客户端进入FIN-WAIT-2</li>
<li>服务端发送FIN(SEQ=y) 请求关闭,进入LAST-ACK</li>
<li>客户端发送，ACK(ACK=y+1) ，客户端进入TIME-WAIT，服务端接收后进入CLOSE，客户端等待一段时间之后如果没有收到回复，就关闭客户端。</li>
</ol>
</li>
<li>可不可以把ACK和FIN合并起来变成三次挥手： 不行，因为服务器收到断开请求时，可能还有一些数据没有传输完成，所以先发送ACK表明收到请求，等待所有数据发送完成之后发送FIN断开连接</li>
</ul>
</li>
<li>IP<ul>
<li>DNS:域名解析：</li>
<li>DHCP（动态主机配置协议）是一个网络协议，用于自动分配 IP 地址和其他相关配置信息给网络中的设备。这使得设备可以在加入网络时自动获取网络配置，无需手动设置。</li>
<li>ARP工作原理：广播问询，单播响应<ul>
<li>一个局域网中<ol>
<li>维护一个ARP表 &lt;IP,MAC,TTL&gt;</li>
<li>查询ARP表，如果不存在，则构造一个ARP查询分组，将其广播到局域网中，MAC地址为广播地址，然后希望收到的是IP地址</li>
<li>设备接收后查询是否为自己的IP，如果不是则丢弃，如果是，则构造ARP响应分组，发送给查询主机，并在自己的表中构造一条查询主机的IP-MAC映射表，使用的是单播，不再广播</li>
<li>查询的主机接受后，将其加入ARP表中</li>
</ol>
</li>
<li>不在一个局域网中：通过路由器转发查询</li>
</ul>
</li>
<li>NAT:同一个场景下将私有IP转化为共有IP地址</li>
<li>ICMP：互联网控制报文协议，确认Ip包是否<ul>
<li>ping：基于ICMP协议工作的，使用的ICMP类型中0和8，也就是回送应答和会送请求，根据这个来判断是否到达IP地址，如果路由器中间没有找到对应的接收端IP就会往发送端IP发送ICMP报文，8是源主机向目标主机的发送的请求，0是目标主机的回应</li>
<li>各种本地IP代指的区别：<ol>
<li>localhost 默认就是同于127.0.0.1，但是可以修改，是属于域名</li>
<li>0.0.0.0 IPv4中是无效地址，代指的是广播，监听本地的0.0.0.0时，代表的监听本机上所有的IPv4地址</li>
<li>127.0.0.1是回环地址</li>
</ol>
</li>
</ul>
</li>
<li>IGMP：Internet组管理协议，工作哎主机和最后一跳的路由之间。</li>
<li>为何断网了也能ping通127.0.0.1? 因为会把消息交给本地网卡，本地网卡直接把消息发送到本机接受到的消息链表中并触发软中断，由内核线程来传递给上层应用程序</li>
</ul>
</li>
</ul>
<h2 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h2><p>分类</p>
<h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><h2 id="如何解决粘包问题"><a href="#如何解决粘包问题" class="headerlink" title="如何解决粘包问题"></a>如何解决粘包问题</h2><p>找到消息的边界就能解决这个问题</p>
<ol>
<li>固定长度</li>
<li>特殊字符作为边界</li>
<li>自定义消息结构</li>
</ol>
<h3 id="重传机制"><a href="#重传机制" class="headerlink" title="重传机制"></a>重传机制</h3><p>重传是由序列号和确认应答来控制的</p>
<ol>
<li>超时重传，TCP的超时重传策略是间隔时间每次都设置为先前值的两倍，如果出现两次超时，说明网络环境差，不会重传了</li>
<li>快速重传：当收到三个相同ACK报文时，说明出现了丢包，会重传丢失的报文。</li>
</ol>
<h3 id="滑动窗口-4-2-TCP-重传、滑动窗口、流量控制、拥塞控制-小林coding-xiaolincoding-com"><a href="#滑动窗口-4-2-TCP-重传、滑动窗口、流量控制、拥塞控制-小林coding-xiaolincoding-com" class="headerlink" title="[滑动窗口](4.2 TCP 重传、滑动窗口、流量控制、拥塞控制 | 小林coding (xiaolincoding.com))"></a>[滑动窗口](<a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/3_tcp/tcp_feature.html#%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6">4.2 TCP 重传、滑动窗口、流量控制、拥塞控制 | 小林coding (xiaolincoding.com)</a>)</h3><p>TCP头中有一个Window字段，代表滑动窗口大小。表示接受方告诉对方自己还有多少缓冲区可以接受数据。</p>
<h4 id="发送方窗口"><a href="#发送方窗口" class="headerlink" title="发送方窗口"></a>发送方窗口</h4><p><img src="/2023/10/23/46/%E5%8F%91%E9%80%81%E6%96%B9%E7%AA%97%E5%8F%A3.png"></p>
<h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>HTTP是一个在计算机世界中专门在亮点之间传输文字、图片等超文本的约定与规范</p>
<h3 id="常见的状态码"><a href="#常见的状态码" class="headerlink" title="常见的状态码"></a>常见的状态码</h3><ol>
<li>1xx 是一种中间状态，实际使用较少</li>
<li>2xx 表示服务器成功处理了请求<ul>
<li>200 OK</li>
<li>204 No Content 与200基本相同，但是响应头没有body数据</li>
<li>206 Partial Content表示响应返回的body数据并不是资源的全部。</li>
</ul>
</li>
<li>3xx 重定向<ul>
<li>301 永久重定向</li>
<li>302 Found 临时重定向，注意301和302都会在响应头中使用Location字段知名后续需要跳转的URL，浏览器会自动重定向到新的URL</li>
<li>304  资源未修改，可以使用缓存资源</li>
</ul>
</li>
<li>4xx 客户端发送的报文有误<ul>
<li>400 请求有误，笼统的错误</li>
<li>403 服务器禁止访问资源</li>
<li>404 服务器不存在或未找到</li>
</ul>
</li>
<li>5xx 客户端请求报文正确，但是服务器处理时，内部出现了错误，属于服务端错误码<ul>
<li>500 笼统错误</li>
<li>501 客户端请求功能不支持，敬请期待</li>
<li>502 网关错误</li>
<li>503 服务器繁忙，无法咱是无法响应客户端。</li>
</ul>
</li>
</ol>
<h3 id="HTTP缓存"><a href="#HTTP缓存" class="headerlink" title="HTTP缓存"></a>HTTP缓存</h3><ol>
<li>强制缓存：浏览器判断缓存没过期就强制使用本地缓存。使用的是Cache-Control和Expires，第一个是相对时间，第二个是绝对时间。第一个优先级更高。<ul>
<li>浏览器第一次请求时，会加上这个过期时间</li>
<li>再次请求时，根据请求时间和这个过期时间进行比较，来判断是否过期，并且更新这个时间</li>
</ul>
</li>
<li>协商缓存： 与服务器协商之后，通过协商结果来判断是否使用本地缓存。<img src="/2023/10/23/46/%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98.png"></li>
</ol>
<h2 id="不同版本的HTTP特点"><a href="#不同版本的HTTP特点" class="headerlink" title="不同版本的HTTP特点"></a>不同版本的HTTP特点</h2><p>HTTP: 80<br>HTTPS: 443</p>
<h3 id="HTTP缓存-1"><a href="#HTTP缓存-1" class="headerlink" title="HTTP缓存"></a>HTTP缓存</h3><p>Cache-Control(相对时间)优先级高于Expires(绝对时间)<br>强制缓存是浏览器中的缓存没过期就强制使用缓存，协商缓存是每次与服务器协商是否过期。</p>
<h3 id="HTTP的迭代和对比"><a href="#HTTP的迭代和对比" class="headerlink" title="HTTP的迭代和对比"></a>HTTP的迭代和对比</h3><h4 id="HTTP1-1"><a href="#HTTP1-1" class="headerlink" title="HTTP1.1"></a>HTTP1.1</h4><p><strong>已经实现了长连接和管道网络传输(不需要一问一答，可以连续发送请求)</strong><br>解决了 <strong>请求的队头阻塞</strong>，但是没解决响应的队头阻塞。<br>头部冗长，未压缩，请求只能由客户端开始</p>
<h4 id="优点和缺点"><a href="#优点和缺点" class="headerlink" title="优点和缺点"></a>优点和缺点</h4><p>双刃剑：无状态、明文传输<br>缺点：不安全</p>
<ul>
<li>无状态可以使得浏览器不需要额外记忆HTTP的状态，缺点是处理有关联性的操作时会很麻烦<ul>
<li>解决方式就是使用Cookie</li>
</ul>
</li>
<li>明文传输：方便调试的同时不安全</li>
<li>不安全：1. 明文传输2.不验证通信双方的身份3.不能证明报文的完整性 <ul>
<li>解决方式使用HTTPS</li>
</ul>
</li>
</ul>
<h4 id="性能-长连接"><a href="#性能-长连接" class="headerlink" title="性能(长连接)"></a>性能(长连接)</h4><ol>
<li>相比较于1.0，1.1使用了长连接，一次TCP连接发起多次请求</li>
<li>可以使用管道通信，只要请求发送出去后，不需要等待响应结果即可发送下一个请求<br>解决了请求的队头阻塞，但是没有解决响应的队头阻塞，同时不是默认使用的<blockquote>
<p>队头阻塞是指当一个请求因为某种原因被阻塞，会导致后面排队的所有请求都一同被阻塞<br>进步：</p>
</blockquote>
</li>
<li>长连接</li>
<li>支持管道网络传输<br>缺点：</li>
<li>Header部分未经压缩就发送，延迟大，只能压缩Body部分</li>
<li>会出现队头阻塞：服务端响应慢，导致后续的请求不能及时发送</li>
<li>请求只能从客户端开始</li>
</ol>
<h4 id="HTTP-x2F-2"><a href="#HTTP-x2F-2" class="headerlink" title="HTTP/2"></a>HTTP/2</h4><p>进步：</p>
<ol>
<li>HTTP/2是基于HTTPS，安全有保证</li>
<li>队头压缩：如果同时发出多个请求，他们的请求头是一样的或者是相似的，就会消除重复的部分，原理是客户端和服务端同时维护一张头信息表，所有字段都会存在里面来进行索引</li>
<li>二进制格式：报文使用二进制格式，而不是使用纯文本的格式</li>
<li>并发传输，多路复用，一条TCP连接包含多个Stream，StreamID来区分，不同Stream的帧是可以乱序发送的</li>
<li>服务器可以主动推送资源<br>虽然在HTTP层解决了队头阻塞，但是TCP是字节流协议，导致必须满足一个一个字节才能够读取数据，从而降低效率，一旦丢包，必须进行TCP的重传，就会导致效率降低。</li>
</ol>
<h4 id="HTTP-x2F-3"><a href="#HTTP-x2F-3" class="headerlink" title="HTTP/3"></a>HTTP/3</h4><p>使用UDP来进行传输</p>
<h5 id="QUIC协议"><a href="#QUIC协议" class="headerlink" title="QUIC协议"></a>QUIC协议</h5><p>QUIC协议也实现了Stream的概念，从而某个流发生丢包时，只会则色这个流，而不会阻塞其他流，从而不会存在队头阻塞。<br>QUIC是google设计的一个基于UDP的网络传输协议，旨在替代TCP协议以提供更快的连接建立和数据传输速度。</p>
<ol>
<li>快速建立连接：使用基于TLS的安全连接，同时将连接的建立与TLS握手合并，从而减少了连接所需要的往返时间。</li>
<li>多路复用：允许在单个连接上同时进行多个独立的数据流，从避免了TCP连接中的队头阻塞</li>
<li>零RTT握手：QUIC支持零往返时间握手，允许客户端在第一次连接时发送数据，无需等待握手完成，进一步减少了连接建立时间。</li>
<li>动态调整拥塞控制：使用更先进的拥塞控制算法，能够动态的根据网络条件调增数据传输速率。</li>
<li>错误恢复：QUIC内置了一些错误恢复机制，包括快速重传和前向错误纠正，能够在发生丢包或网络拥塞时更快的恢复数据传输。</li>
</ol>
<p>HTTP/2 是⼀个应⽤层协议，是 HTTP/1.1 的后继版本，旨在提⾼ Web ⻚⾯加载速度和性能。 HTTP/2<br>在传输层使⽤了⼆进制分帧，头部压缩，多路复⽤等技术，以减少延迟和提⾼效率。 HTTP/2 不是⼀个<br>替代传输层协议，⽽是在传输层上实现的 HTTP 协议的增强版本。</p>
<h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><blockquote>
<p>HTTPS是在TCP和HTTP之间加入了SSL/TLS安全协议</p>
</blockquote>
<h4 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h4><ol>
<li>混合加密：对称加密和非对称加密的混合加密方式，通信建立之前使用的是非对称加密，建立之后通信使用的对称加密，对称加密只需要使用一个密钥，所以更加高效。</li>
<li>摘要算法 + 数字签名：通过摘要算法获得哈希值，来判断报文是否被修改。而数字签名则能保证通信双方的身份</li>
<li>数字证书：可信的第三方来保证双方身份，主要是CA通过私钥加密双方的公钥数字签名，然后CA的公钥是公开的，之后另一方通过CA的公钥解密获得对方的公钥，之后对方使用私钥加密，就可以使用公钥进行解密了或者是加密通信。<img src="/2023/10/23/46/CA%E7%AE%97%E6%B3%95.png"></li>
</ol>
<h4 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h4><ol>
<li>公钥加密，私钥解密：保证内容的安全，只有私钥可以解密内容</li>
<li>私钥加密，公钥解密：保证消息不可冒充，因为私钥是不可以泄漏的，验证双方身份，也就是数字签名算法<img src="/2023/10/23/46/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D%E7%AE%97%E6%B3%95.png" alt="|525"></li>
</ol>
<h4 id="流程-RSA算法为例"><a href="#流程-RSA算法为例" class="headerlink" title="流程(RSA算法为例)"></a>流程(RSA算法为例)</h4><ol>
<li>三次握手建立TCP连接</li>
<li>客户端发送ClientHello请求，携带客户端支持的TLS版本信息和客户端随机数Client Random，支持的密码套件列表(比如RSA算法)</li>
<li>ServerHello响应：确定TLS版本，浏览器不支持就断开，服务器随机数Server Random， 使用的加密算法，服务器的数字证书</li>
<li>客户端使用CA的公钥确定证书的真实性，之后取出公钥，加密报文发送：1. 随机数 pre-master key 2.加密通信算法改变通知，表示之后都将使用会话密钥(对称加密)进行通信，客户端握手结束通知，把之前所有的内容进行摘要，给服务器进行校验</li>
<li>双方使用这三个随机数和加密算法生成会话密钥</li>
<li>服务器最后1.加密算法改变 2.握手结束，生成摘要供客户端校验</li>
</ol>
<h4 id="HTTPS抓包-x2F-代理人"><a href="#HTTPS抓包-x2F-代理人" class="headerlink" title="HTTPS抓包/代理人"></a>HTTPS抓包/代理人</h4><p><img src="/2023/10/23/46/%E4%BB%A3%E7%90%86%E4%BA%BA.webp"></p>
<p>抓包工具的原理就是往系统受信任的根证书列表导入抓包工具生成的证书，这个证书会被浏览器新人，也就是转包工具给自己建立了一个CA。<br>如何解决中间人攻击：使用HTTPS双向认证，服务器也对客户端的认证信息进行验证。</p>
<h2 id="计网常问"><a href="#计网常问" class="headerlink" title="计网常问"></a>计网常问</h2><h3 id="一个请求整个网络的处理"><a href="#一个请求整个网络的处理" class="headerlink" title="一个请求整个网络的处理"></a>一个请求整个网络的处理</h3><ol>
<li>浏览器解析URL生成HTTP消息</li>
<li>通过DNS解析获得IP地址</li>
<li>之后将HTTP的传输工作通过调用Socket库交给操作系统的协议栈</li>
<li>TCP简历链接需要三次握手，保证双方都有发送和接收的能力</li>
<li>建立连接之后，TCP报文中的数据部分就是存放HTTP头部+数据，组装好TCP报文之后，交给下面的网络层处理</li>
<li>IP协议里需要源地址和目的地址IP，存在多个网卡时，需要根据路由表规则。</li>
<li>生成IP头部之后，需要在前面加上MAC头部，接收方的MAC地址通过ARP协议获得，并且放入ARP缓存</li>
<li>网卡驱动获得网络包，将其复制到网卡内的缓存区中，从开头加上包头和起始帧分节符，末尾加上用于校验错误的帧校验序列。之后网卡将包转为电信号，通过网线发送</li>
<li>电信号到达网线接口，交换机里的模块进行接收。之后将电信号转化为数字信号。FCS校验没问题后放入缓冲区，之后查询MAC地址，如果找不到，就发除了源端口的所有端口。</li>
<li>电信号到达⽹线接⼝部分，路由器中的模块会将电信号转成数字信号， FCS 进⾏错误校验没问题后确认接收⽅MAC地址，然后去掉MAC头部，查询路由表判断转发⽬标，如果⽹关为空则 IP 头部中的接收⽅ IP 地址就是要转发到的⽬标地址</li>
<li>知道对⽅的 IP 地址之后，接下来需要通过 ARP 协议根据 IP 地址查询 MAC 地址，加上MAC头部，发送⽹络包，通过交换机到达下⼀个路由器</li>
<li>最后数据包抵达了服务器</li>
</ol>
<h3 id="IPv6优点"><a href="#IPv6优点" class="headerlink" title="IPv6优点"></a>IPv6优点</h3><ol>
<li>更⼤的地址空间：IPv6将地址⻓度从IPv4的32位扩展到了128位，理论上可以分配⼤约3.4x10^38个唯⼀的IP地址。</li>
<li>简化的报⽂格式：IPv6头部格式更为简洁，减少了处理的复杂性，提⾼了路由效率。</li>
<li>改进的服务质量（QoS）：IPv6⽀持更好的流量分类和优先级处理，有助于提供更加可靠的服务质量。</li>
<li>内建的安全机制：IPv6原⽣⽀持IPsec（⽹络安全协议），为数据传输提供了端到端的加密和认证。</li>
<li>⾃动配置能⼒：IPv6⽀持有状态和⽆状态的地址⾃动配置（SLAAC），简化了⽹络设备的配置和管理</li>
</ol>
<h3 id="BGP、OSPF协议原理"><a href="#BGP、OSPF协议原理" class="headerlink" title="BGP、OSPF协议原理"></a>BGP、OSPF协议原理</h3><blockquote>
<p>边界⽹关协议(Border Gateway Protocol，简称BGP)和开放最短路径优先协议(Open Shortest Path<br>First，简称OSPF)是世界上最流⾏的两种基于标准的动态路由协议。</p>
</blockquote>
<h3 id="三握四挥"><a href="#三握四挥" class="headerlink" title="三握四挥"></a>三握四挥</h3><p><img src="/2023/10/23/46/%E4%B8%89%E6%8F%A1%E5%9B%9B%E6%8C%A5.png"></p>
<h3 id="TCP和UDP"><a href="#TCP和UDP" class="headerlink" title="TCP和UDP"></a>TCP和UDP</h3><p><img src="/2023/10/23/46/%E5%A4%B4%E9%83%A8.png" alt="|525"></p>
<ol>
<li>序列号：建立连接时，由计算机生成的随机数作为初始值，通过SYN包传给接收端主机，每发送一次，就累加一次该数据字节数的大小，解决网络包乱序问题。</li>
<li>确认应答号：下一次期望收到数据的序列号。发送端收到这个之后可以认为在这之前的数据都被正常接收，用于解决丢包问题。</li>
<li>控制位为1时：<ul>
<li>ACK：确认应答变为有效，TCP规定除了最初建立连接时的SYN包之外必须设为1</li>
<li>RST：标识连接异常必须强制断开连接</li>
<li>SYN：表示希望建立连接</li>
<li>FIN：今后不会再有数据发送，希望断开连接时，表示今后不再有数据发送，希望断开连接。当通信结束希望断开连接时，通信双方可以交换FIN位为1的TCP段。</li>
</ul>
</li>
</ol>
<h4 id="SYN攻击"><a href="#SYN攻击" class="headerlink" title="SYN攻击"></a>SYN攻击</h4><blockquote>
<p>攻击者短时间伪造不同的IP地址的SYN报文，沾满服务端的办理按揭队列，导致客户端无法和服务端建立连接。</p>
</blockquote>
<p>解决方案：</p>
<ol>
<li>增大netdev_max_backlog：网卡接收数据包的数据大于内核处理速度时保存数据包的队列长度</li>
<li>增大TCP半连接队列：<ul>
<li>增大net.ipv4.tcp_max_syn_backlog</li>
<li>增大listen()函数中的backlog</li>
<li>增大net.core.somaxconn</li>
</ul>
</li>
<li>开启net.ipv4.tcp_syncookies，就可以在使用SYN半连接的情况下成功建立连接。<img src="/2023/10/23/46/%E4%BD%BF%E7%94%A8cookie%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5.png" alt="|550"></li>
</ol>
<ul>
<li>减少SYN+ACK重传次数，tcp_synack_retries内核参数</li>
<li>Anti-DDoS系统拦截客⼾端发送的SYN报⽂，代替服务器向客⼾端发送SYN-ACK报⽂，如果客⼾端不应答，则认为该客⼾端为虚假源；如果客⼾端应答，则Anti-DDoS系统认为该客⼾端为真实源，并将其IP地址加⼊⽩名单，在⼀段时间允许该源发送的所有SYN报⽂通过，也不做代答。</li>
</ul>
<h4 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h4><p>滑动窗口机制允许发送方在等待接收方确认之前发送多个数据包，从而提高数据传输效率。<br>为了解决一发一答的效率问题。窗口的实现实际上是操作系统开辟一个缓存空间，发送方主机在等到确认应答返回之前，必须在缓冲区中保留已发送的数据，如果按期收到确认应答，这个数据就可以从缓冲区删除。<img src="/2023/10/23/46/TCP%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3.png"></p>
<h4 id="慢启动"><a href="#慢启动" class="headerlink" title="慢启动"></a>慢启动</h4><p>当连接开始时，以指数速率增加发送速率，直到第一次报文丢失事件发生为止。<br>初始：拥塞窗口值cwnd = 1 MSS<br>每RTT倍增cwnd<br>每收到一个ACK，增加cwnd<br>初始速率很低，但是以指数增加</p>
<h4 id="阻塞控制"><a href="#阻塞控制" class="headerlink" title="阻塞控制"></a>阻塞控制</h4><ol>
<li>慢启动：发送方每收到一个ACK，拥塞窗口cwnd大小指数增加</li>
<li>拥塞避免算法：当cwnd超过慢启动门限ssthresh就会进入拥塞避免算法：每个 RTT（往返时间）增加 1 个 MSS，而不是每个 ACK 增加 1 个 MSS。</li>
<li>拥塞发生：发生了 超时重传时，sshtresh设置为cwnd/2，cwnd恢复为初始化值，发生快速重传是，cwnd =cwnd/2，ssthresh=cwnd并进入快速恢复算法。</li>
<li>快速恢复<img src="/2023/10/23/46/%E5%BF%AB%E9%80%9F%E6%81%A2%E5%A4%8D.png"></li>
</ol>
<h4 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h4><p>主机名到IP地址的转换<br>主机别名：一个主机可以有一个规范主机名和多个主机别名。<br>邮件服务器别名：负载分配：DNS实现冗余服务器，一个IP地址集合可以对应同一个规范主机名。</p>
<p>DNS客⼾端设置使⽤的DNS服务器⼀般都是递归服务器，它负责全权处理客⼾端的DNS查询请求，直<br>到返回最终结果。⽽DNS服务器之间⼀般采⽤迭代查询⽅式。<br><img src="/2023/10/23/46/DNS%E8%AE%B0%E5%BD%95%E6%A0%BC%E5%BC%8F.png"></p>
<h4 id="DNS劫持"><a href="#DNS劫持" class="headerlink" title="DNS劫持"></a>DNS劫持</h4><blockquote>
<p>通过某些手段获得对某域名的解析控制权，修改此域名的解析结果，导致对该域名的访问由原IP转为修改后的指定IP，记过就是对特定网站不能访问/访问的是假网站</p>
</blockquote>
<p>防止：限制对DNS的访问、设置较小的TTL值，定期修改域名管理系统的账号，使用支持DNSSEC的注册商，使用可靠的DNS服务商。</p>
<blockquote>
<p>DNSSEC（Domain Name System Security Extensions，域名系统安全扩展）是一组用于保护 DNS（域名系统）信息安全的协议和技术。它通过数字签名验证 DNS 数据的真实性和完整性，防止 DNS 缓存投毒和其他类型的攻击。</p>
</blockquote>
<h2 id="网络核心"><a href="#网络核心" class="headerlink" title="网络核心"></a>网络核心</h2><p>概念：路由器的网状网络<br>提问： 数据怎么通过网络进行传输？</p>
<ul>
<li>电路电路交换：  不可共享资源，会造成资源浪费，不适合计算机之间的通讯，计算机通信的特点： 突发性，耗时短</li>
<li>分组交换： 存储 – 转发  ， 数据转发过程中使用所有的资源，而不是使用一部分pieces，会将所有的的分组都存储之后再进行转发，方便共享的实现</li>
</ul>
<h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><ol>
<li>应用架构<ul>
<li>CS体系 客户-服务器:<ul>
<li>服务器： 一直运行，固定ip和周知的端口号，扩展性差</li>
<li>客户端： 主动与服务器通信，可能是动态ip，不直接与其他客户端通信</li>
</ul>
</li>
<li>P2P 每个端都可以作为服务器，点对点</li>
<li>混合体 c/s + P2P</li>
</ul>
</li>
<li>TCP socket ：对于面向连接服务（TCP) 的应用而言，socket是四元组的一个具有本地意义的标示,相当于一个记录特定会话的指针，只需要用socket就可以指定这个应用<ul>
<li>socket 其实是应用层和传输层之间的，使得允许应用能发起通信，与其他主机上的应用进程进行通信</li>
<li>4元组  源IP 源port 目标IP 目标port</li>
<li>唯一指定了一个会话</li>
<li>应用使用这个标示，与远程的应用进程进行通讯</li>
<li>不必在每一个报文中都指定这四元组</li>
<li>udp 只提供源主机的ip 和 port</li>
</ul>
</li>
<li>WebSocket 工作过程：<ol>
<li>客户端发送一个HTTP请求，包含升级字段</li>
<li>服务器接收之后,进行协议升级，如果支持，会返回一个101状态码，包含一些对应响应头</li>
<li>进行双向通信，数据以帧的方式传送。</li>
<li>其中一方发送一个关闭帧，二者关闭TCP连接</li>
<li>通过心跳机制保证WebSocket的稳定性和活跃性</li>
</ol>
</li>
<li>UDP socket<br> UDP 两个进程之间的通信之前不需要建立连接，每个报文独立传输，前后报文可能给不同的分布式进程<br> udp socket 记录本IP 本port 但是传输报文时，需要提供对方ip， port ,接收报文时传输层需要上传对方IP port<br> 二元组： 源IP  源port</li>
</ol>
<p>TCP 服务：</p>
<ul>
<li><p>可靠的传输服务</p>
</li>
<li><p>流量控制：发送方不会淹</p>
</li>
</ul>
<p>没接受方</p>
<ul>
<li>拥塞控制：当网络出现拥</li>
</ul>
<p>塞时，能抑制发送方</p>
<ul>
<li><p>不能提供的服务：时间保证、最小吞吐保证和安全</p>
</li>
<li><p>面向连接：要求在客户端进程和服务器进程之间建立连接</p>
</li>
</ul>
<p>UDP 服务：</p>
<ul>
<li><p>不可靠数据传输</p>
</li>
<li><p>不提供的服务：可靠，流量控制、拥塞控制、时间、带宽保证、建立连接<br>UDP存在的必要性</p>
</li>
<li><p>能够区分不同的进程，而IP服务不能</p>
</li>
<li><p>在IP提供的主机到主机端到端功能的基础上，区分了主机的</p>
</li>
</ul>
<p>应用进程</p>
<ul>
<li>无需建立连接，省去了建立连接时间，适合事务性的</li>
</ul>
<p>应用</p>
<ul>
<li>不做可靠性的工作，例如检错重发，适合那些对实时</li>
</ul>
<p>性要求比较高而对正确性要求不高的应用</p>
<ul>
<li>因为为了实现可靠性（准确性、保序等），必须付出时间代</li>
</ul>
<p>价（检错重发）</p>
<ul>
<li>没有拥塞控制和流量控制，应用能够按照设定的速度</li>
</ul>
<p>发送数据</p>
<ul>
<li>而在TCP上面的应用，应用发送数据的速度和主机向网络发送</li>
</ul>
<p>的实际速度是不一致的，因为有流量控制和拥塞控制</p>
<ul>
<li>安全TCP<br>  TCP和UDP都没有加密，明文传输<br>  使用SSL协议来实现加密，在TCP的基础上实现，提供加密的TCP，私密性，数据完整性，段堆到端的鉴别<br>  SSL socket API 应用通过API将铭文交给socket，SSL将其加密<br>URL : 访问协议 + 用户名 + 口令字 + 端口等</li>
</ul>
<h3 id="常见的应用层协议"><a href="#常见的应用层协议" class="headerlink" title="常见的应用层协议"></a>常见的应用层协议</h3><h4 id="HTTP面试题"><a href="#HTTP面试题" class="headerlink" title="HTTP面试题"></a>HTTP面试题</h4><ul>
<li><p>状态码：</p>
<ol>
<li>200 </li>
<li>204 No Content 响应头没有body数据</li>
<li>206 &nbsp;<strong>Partial Content</strong> 表示返回的body数据不是资源的全部，只是一部分</li>
<li>301 <strong>Moved Permanently</strong> 永久重定向，请求的资源已经不存在的</li>
<li>302: Found: 表示临时重定向，301，302都会在响应头中使用字段Location指明后续要跳转URL,浏览器会自动重定向到新的URL</li>
<li>304：<strong>Not Modified</strong> 告诉客户端可以接着使用缓存资源</li>
<li>400<strong>Bad Request</strong> 报文有错</li>
<li>403 <strong>Forbidden</strong> 禁止访问</li>
<li>404 <strong>Not Found</strong> 资源不存在或者没找到</li>
<li>500 <strong>Internal Server Error</strong> 服务器内部错误</li>
<li><strong>501 Not Implemented</strong> 客户端请求还不支持</li>
<li><strong>502 Bad Gateway</strong> 通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。</li>
<li><strong>03 Service Unavailable</strong> 服务器忙，暂时无法响应</li>
</ol>
</li>
<li><p>缓存技术：把请求-响应的数据存到本地，下一次直接都本地数据，不需要等待服务器的想用了</p>
<ol>
<li>强制缓存<ul>
<li><code>Cache-Control</code>， 是一个相对时间；</li>
<li><code>Expires</code>，是一个绝对时间；</li>
</ul>
</li>
<li>协商缓存<ul>
<li>在强制缓存未命中时，服务器第一次请求资源时，会在Response头部加上ETag唯一表示</li>
<li>当浏览器再次请求访问服务器中的资源时，先检查缓存是否过期，如果没有过期直接使用本地缓存，如果过期了会在Request头部上加上If-None-Match紫萼段</li>
<li>服务器再次收到请求之后，会根据请求中的If-None-Match值是否与当前请求的资源生成的唯一标识比较<ul>
<li>如果值相等，返回304 Not Modified 不会返回资源</li>
<li>如果不相等，则返回 200 状态码和返回资源，并在 Response 头部加上新的 ETag 唯一标识；</li>
</ul>
</li>
<li>浏览器收到304响应码，会从本地加载资源否则更新资源。</li>
</ul>
</li>
</ol>
</li>
<li><p>HTTP/1.1 的优点：简单灵活、应用广泛</p>
<ul>
<li>缺点是：无状态一方面可以不需要服务器使用额外的资源来记录状态信息</li>
<li>坏处是：进行关联性操作时，需要每次都验证一次身份</li>
<li>解决方法：使用Cookie</li>
</ul>
</li>
<li></li>
<li><p>HTTP：超文本传输协议 HTTP默认80 HTTPS默认 443</p>
<ul>
<li>流程： 1. 客户发起一个与服务器的TCP连接，(建立socket) 2. 服务器接受TCP 连接 3. 浏览器和web服务器之间交换HTTP报文 4. TCP连接关闭 </li>
<li>HTTP 是无状态的连接，不会维护任何和客户有关的信息，这时候就需要websocket了</li>
<li>HTTP/1.1 之后默认使用持久连接，保证了多个u第项可以在一个TCP连接上传输 ，非持久连接下载多个文件需要及案例多个TCP连接<br> 响应时间<br> 往返时间 RTT round - trip - time： 一个小的分组从客户端到服务器，再回到客户端的时间，传输时间忽略不计<br> 响应时间为： 2RTT + 传输时间<br> 1. 一个RTT 用来发起TCP请求<br> 2. 一个用来HTTP请求和等待响应<br> 3. 文件传输时间<br> <strong>持久HTTP</strong> ： 一个TCP连接建立之后，不会断开然后进行多个HTTP请求<br> 服务器在发送响应之后仍然保持TCP连接<br> 在相同客户端和服务器之间的后续请求和响应报文通过相同的连接进行传送<br> 客户端，在遇到一个引用对象的时候就可以尽快的发送该对象的请求，<br> 1. 每个对象要两个RTT<br> 2. 操作系统必须为每一个TCP连接分配资源，但是浏览器通常并行打开TPC连接，以获得引用对象<br> 两种方式：<br>     1. 非流线方式的持久HTTP，客户端只能在前一个HTTP请求响应之后才能发送新的请求，每个引用对象花费一个RTT<br>     2. 流水线方式：客户端遇到一个引用对象（一个小的ui所指的资源）之后就立即产生一个请<br>     3. 所有(小)的引用对象只花费一个RTT是有可能的<br> HTTP 报文格式 ： 请求行 + 请求头 + (request body)<br> tips : PUT 请求是将实体对象中文件载到URL指定的路径(一般是更新资源)<br> POST 不需要在URL 中指定资源位置，一般用于创建资源<ul>
<li>缓存：命中率(h)： 百分之多少的请求可以在缓存中满足</li>
<li>接入链路的利用率:  (1-h) *  请求速率 / 带宽</li>
</ul>
</li>
</ul>
</li>
<li><p>FTP 文件传输协议(基于TCP)<br> ftp服务器端口号默认为 21，需要建立两个TCP连接，一个用于控制，一个用于传输</p>
</li>
<li><p>SMIT 电子邮件的邮件传输协议 (默认端口25)<br>  用于上传邮件，和HTTP的区别，HTTP的每个对象封装在各自的响应报文中，SMIT可以将多个 引用对象封装在一个报文中<br>  报文格式：<br>  HEAD<br>  To :<br>  From :<br>  Subject:<br>  BODY:<br>  报文</p>
<ul>
<li>MIME 多媒体邮件扩展</li>
<li>POP 邮局访问协议 用户确认身份(代理 &lt;–&gt;服务器)并下载<ul>
<li>POP3 不保留会话状态 本地管理文件夹</li>
</ul>
</li>
<li>IMAP Internet 邮件访问协议，保留用户状态 远程管理文件夹</li>
</ul>
</li>
<li><p><em>DNS</em> Domain Name System 建立IP 地址和 对应域名之间的映射<br>  <strong><em>DNS默认默认端口是53</em></strong><br>  主要思路：分层，基于域的命名机制，在若干分布式的数据库上完成转换<br>  也可以做到负载均衡<br>  域名结构：使用层次树状结构来进行命名<br>  域名结构：从本域开始往上直至树根，域严格遵循组织界限，而不是物理网络<br>  DNS 记录格式<br>  RP格式: (name,value,type , ttl)<br>  type=A  时， name 为主机 value 为IP<br>  =CNAME  Name 为规范名字的别名<br>  =NS           Name 为域名 (foo.com) value 为该域名的权威服务器的域名<br>  =MX          Value 为name对应邮件服务器名字</p>
<ul>
<li>应用调用 解析器(resolver)</li>
<li>解析器作为客户 向Name Server发出查询报文（封装在UDP段中）</li>
<li>Name Server返回响应报文(name/ip)</li>
<li>本地名字服务器 Local Name Server 起到代理的作用，将查询转发到DNS服务器<ul>
<li>不严格属于层次结构，每个ISP 都有一个本地DNS，优先去本地DNS服务器中查询</li>
<li>递归查询：本地LNS 无，<strong>直接</strong> 去找权威服务器，然后从权威服务器往下开始查询，只需要向一个服务器去请求，然后由这个服务器去查询或者去向其他服务器来进行查找，最终由这个服务器来返回结果</li>
<li>迭代查询：转发到服务器，如果这个服务器没有就告诉发起请求的服务器要去查询下个一个服务器，由请求服务器去接着请求其他服务器，最终由能查询到的服务器来返回结果，就可以降低根服务器的负荷了</li>
</ul>
</li>
<li>缓存，一旦名字服务器得到了一个映射，就将该映射缓存起来，根服务器一般在本地服务器中缓存着，使用TTL (Time to Live)</li>
<li>攻击DNS的方法： <ul>
<li>DDoS攻击：对根服务器进行流量轰炸，发送大量的ping</li>
<li>向TLD(权威，顶级域名)攻击</li>
<li>重定向攻击：</li>
</ul>
</li>
</ul>
</li>
<li><p>CDN 内容分发网络：在CDN节点中存储内容的多个拷贝，用户请求重定向到最近的一个CDN节点</p>
</li>
</ul>
<h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><p>提供服务：为运行在不同主机上应用程序提供逻辑通信<br>数据元为报文段<br>与网络层的区别：网络层提供不同主机之间的逻辑通信，传输层提供的应用程序之间的通讯<br>tips：TCP和UDP都不提供延时保证和带宽保证，都支持多路复用和解复用，TCP额外提供拥塞控制和流量控制，以及建立连接</p>
<ul>
<li>多路复用/解复用：多路复用指的是许多个信号或数据流共享同一物理通信通道，解复用指的是根据报文段的头背部信息中的IP地址和端口号将接受的报文段发给正确的socket</li>
<li>为何要有UDP ： <ol>
<li>不建立连接(会增加延时)</li>
<li>简单：在发送端和接收端没有连接状态</li>
<li>报文段的头部很小(开销小)</li>
<li>无阻塞控制和流量控制可以保证UDP尽快的发送报文段，应用-&gt; 传输速率 = 主机 -&gt; 网络的速率</li>
<li><u>UDP也会进行校验，但是只是通过校验和的方式来检测是否遭到篡改</u></li>
</ol>
</li>
<li>RDT 是一种模型: RDT（Reliable Data Transfer）是一种可靠的数据传输协议，用于在不可靠的通信信道上实现可靠的数据传输。<ol>
<li>RDT 1.0（停等协议）：相信信道可靠<ul>
<li>发送方只发送一次数据，不进行重传。</li>
<li>接收方只接受一次数据，不进行重传请求。</li>
<li>适用于理想化的通信信道，不考虑错误和丢失。</li>
</ul>
</li>
<li>RDT 2.0（回退N协议）： 相信会出现bits errors<ul>
<li>使用checksum 来进行错误检验</li>
<li>引入了有限状态自动机，来切换来指定发送者和接收者</li>
<li>发送方发送数据帧，并等待接收方的确认帧。</li>
<li>接收方接收数据帧，发送确认帧。</li>
<li>如果发送方未收到确认帧，它将重传数据帧。</li>
<li>接收方可能收到重复的数据帧，但通过带有序号的数据帧来排除重复。</li>
<li>问题：如果ACK或者NCK传错了，就会重复</li>
</ul>
</li>
<li>RDT 3.0 <ul>
<li>机制：在超过合理时间之后进行重传</li>
<li><ul>
<li>如果package（或ACK）只是被延迟了：</li>
<li>重传将会导致数据重复，但利用序列号已经可以处理这个问题</li>
<li>接收方必须指明被正确接收的序列号</li>
</ul>
</li>
</ul>
</li>
</ol>
<ul>
<li>需要一个倒计数定时器<ol>
<li>停等协议：发送方发送一个分组，然后等待接收方的应答</li>
<li>ACK NAK   NAK 是negative ACK</li>
</ol>
</li>
</ul>
</li>
<li>TCP:<ul>
<li>点对点：一个发送方，一个接收方 </li>
<li>可靠的、按顺序的字节流：没有报文边界 </li>
<li>管道化：TCP拥塞控制和流量控制设置窗口的大小</li>
<li>面向连接：交换数据之前，通过握手来初始化双方的状态变量</li>
<li>流量控制：发送方不会淹没接收方</li>
<li><img src="/2023/10/23/46/tcp%E6%8A%A5%E6%96%87.png" alt="tcp报文"></li>
<li>序号：报文段首字节在字节流的编号</li>
<li>确认号：期望从另一方收到的下一个字节的序号</li>
<li>TCP超时时间= EstimatedRTT + 安全边界时间</li>
<li>。。。。待续</li>
</ul>
</li>
</ul>
<h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><p>DU 为 数据包</p>
<ul>
<li>服务：在发送和接收主机之间传送段</li>
<li>功能：<ul>
<li>转发：将分组从路由器的输入接口转发到合适的输出接口上</li>
<li>路由：使用路由算法来决定分组从发送主机到目标接收主机的路径</li>
</ul>
</li>
<li>数据平面：转发</li>
<li>控制平面：路径</li>
<li>路由器的结构：<ul>
<li>路由：运行路由选择算法生成路由表</li>
<li>转发：从输入到输出链路交换数据报，根据路由表进行分组的转发</li>
</ul>
</li>
<li>查表方式： <ul>
<li>最长前缀匹配</li>
</ul>
</li>
<li>交换结构：<ul>
<li>通过内存交换，在cpu的直接控制下进行交换</li>
<li>使用总线进行交换： 数据报通过共享总线进行转发，交换速度受限于总线带宽</li>
<li>使用互联网络进行交换</li>
</ul>
</li>
<li>调度机制： 调度指的是选择下一个要通过链路交换的分组<ul>
<li>FIFO</li>
<li>优先权调度</li>
<li>轮询</li>
</ul>
</li>
<li>IP<ul>
<li>IP地址是对主机或者路由器的接口进行编址</li>
<li>接口指的是 主机/路由器 和 物理链路的连接处</li>
<li>关系是1 : 1</li>
<li><strong>子网</strong>：<ol>
<li>一个子网内的节点，他们IP地址的高位部分都相同，这些节点叫做子网</li>
<li>无需路由器介入，子网内的个主机在物理上是可以直接打到</li>
<li>将子网掩码转为二进制，则为1的部分代表着IP地址中的这一部分是网络中的地址，为0的部分是标识子网中的主机</li>
</ol>
</li>
<li>分类：根据第一个8位bit来进行分类<ul>
<li>A 类 最高位固定为0：也就是 1 - 126  7 位网络  24 位主机</li>
<li>B : 10  128 - 191 14位 网络 16主机</li>
<li>C : 110 192 - 223  21位 网络  8位主机</li>
<li>D : 224 - 239 用于多播</li>
<li>E : 240 - 255 保留用于实验和研究目的</li>
</ul>
</li>
<li>CIDR Classless InterDomain Routing 无类域间路由<ul>
<li>也就是 a.b.c.d/x x是子网掩码(mask)</li>
</ul>
</li>
<li>NAT 网络地址转换 <ul>
<li>将私有网络中的内部IP映射到公共网络中的单个IP地址</li>
</ul>
<ol>
<li><p>节省IP地址：NAT允许多个内部设备共享一个公共IP地址，因此可以延长IPv4地址池的使用寿命。</p>
</li>
<li><p>增强网络安全性：因为内部设备的私有IP地址不直接暴露在互联网上，NAT提供了一层基本的安全性，可以隐藏内部网络结构。</p>
</li>
<li><p>简化网络管理：NAT可以使网络管理员更轻松地管理多台设备，而无需为每个设备分配唯一的公共IP地址。</p>
</li>
</ol>
</li>
</ul>
</li>
<li>IPv6 <ul>
<li>IPv4和IPv6通信方式：隧道 Tunneling， 在IPv4路由器之间传输的IPv4报文中携带PIv6的报文</li>
</ul>
</li>
<li>SDN</li>
<li>OpenFlow</li>
<li>route 路由，按照某种指标找到一条从源节点到目标节点的较好路径<ul>
<li>路由算法分为 全局和 分布式</li>
<li>全局：<ul>
<li>所有边都拥有完整(所有的拓扑)的拓扑和边的代价的信息</li>
<li>link state  LS  链路状态路由选择算法</li>
</ul>
</li>
<li>分布式: <ul>
<li>路由器只知道与它物理连接关系的邻居路由器和到响应邻居路由器的代价</li>
<li>迭代的与邻居路由器交换路由信息，计算路由信息</li>
<li>distance vector DV算法  距离矢量路由选择算法</li>
</ul>
</li>
</ul>
</li>
<li>RIP（Routing Information Protocol）是一种用于计算机网络中的距离矢量路由协议</li>
<li>OSP</li>
<li>DNS 主机向要访问-&gt;向DNS查询IP地址-&gt;所查询的DNS服务器未知要查询的IP地址-&gt;向根域名服务器查询-&gt;根域名服务器收录了这个地址 -&gt;返回地址给客户端-&gt;客户端建立通信<br>网络层解决一个两个网络之间的问题，链路层要解决点对点传输的问题</li>
<li><strong>ARP</strong>:以目标IP地址为线索，来定位下一个应该接受数据分包的网络设备的MAC地址，沟通IP和MAC地址 **IP-&gt;MAC **数据元为 frame 帧，帧的头部时使用MAC地址来标示源和目的地<ul>
<li>ARP记录一个&lt;IP,MAC,TTL&gt; 的表，TTL是生存周期</li>
</ul>
</li>
<li><strong>RARP</strong> MAC-&gt;IP<br>实现是在适配器上实现的，例如以太网卡</li>
<li>WAN 广域网 网络形式采用点到点链路</li>
<li>LAN 局域网 一般采用多点连接的方式</li>
<li>奇偶校验<ul>
<li>单bit奇偶校验只能检测单个bit级别的错误，不能纠错</li>
<li>二维奇偶校验可以检测和纠正单个bit错误</li>
<li>checksum </li>
<li>CRC 循环冗余校验</li>
</ul>
</li>
</ul>
<h3 id="网络接口层：等价数据链路层，使用mac地址"><a href="#网络接口层：等价数据链路层，使用mac地址" class="headerlink" title="网络接口层：等价数据链路层，使用mac地址"></a>网络接口层：等价数据链路层，使用mac地址</h3><ul>
<li><p>NIC的驱动程序</p>
</li>
<li><p>NIC 是网络适配器，也就是网卡</p>
</li>
<li><p>PPP也属于数据链路层</p>
</li>
</ul>
<h2 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h2><h4 id="OSI参考模型-有七个分层"><a href="#OSI参考模型-有七个分层" class="headerlink" title="OSI参考模型 有七个分层"></a>OSI参考模型 有七个分层</h4><p>自上而下 每一层的功能和作用由协议规定，协议的内容是规范</p>
<ol>
<li><p><strong>应用层</strong></p>
<ul>
<li>针对特定应用的协议</li>
</ul>
</li>
<li><p><strong>表示层</strong></p>
<ul>
<li>设备固有数据格式和网络标准数据格式 比如：接受不同表现形式的信息</li>
</ul>
</li>
<li><p><em>会话层</em></p>
<ul>
<li>负责通信管理，负责建立连接和断开，管理传输层以下的分层</li>
</ul>
</li>
<li><p><strong>传输层</strong></p>
<ul>
<li>管理两个节点之间的数据传输，负责可靠传输</li>
</ul>
</li>
<li><p><strong>网络层</strong></p>
<ul>
<li>路由选择与地址管理</li>
</ul>
</li>
<li><p><strong>数据链路层</strong></p>
<ul>
<li>互连设备之间传送，和 识别数据帧</li>
</ul>
</li>
<li><p><strong>物理层</strong></p>
<ul>
<li>界定连接器和网线的规格，比特流和电子信号转换</li>
</ul>
</li>
</ol>
<h2 id="网络安全"><a href="#网络安全" class="headerlink" title="网络安全"></a>网络安全</h2><ul>
<li>对称加密：发送方和接收方的密钥相同</li>
<li>公开密钥加密：发送方使用接收方的公钥进行加密，接收方使用自己的私钥进行解密</li>
<li>数字签名：</li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E8%AE%A1%E7%BD%91/" rel="tag"># 计网</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/10/21/39/" rel="prev" title="简历">
      <i class="fa fa-chevron-left"></i> 简历
    </a></div>
      <div class="post-nav-item">
    <a href="/2024/02/27/04/" rel="next" title="python and web or ai">
      python and web or ai <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AE%A1%E7%BD%91"><span class="nav-number">1.</span> <span class="nav-text">计网</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A6%82%E5%BF%B5"><span class="nav-number">1.1.</span> <span class="nav-text">概念</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%9D%A2%E8%AF%95%E5%B8%B8%E9%97%AE"><span class="nav-number">2.</span> <span class="nav-text">面试常问</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#IP"><span class="nav-number">2.1.</span> <span class="nav-text">IP</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP"><span class="nav-number">2.2.</span> <span class="nav-text">TCP</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E7%B2%98%E5%8C%85%E9%97%AE%E9%A2%98"><span class="nav-number">2.3.</span> <span class="nav-text">如何解决粘包问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6"><span class="nav-number">2.3.1.</span> <span class="nav-text">重传机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3-4-2-TCP-%E9%87%8D%E4%BC%A0%E3%80%81%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E3%80%81%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E3%80%81%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6-%E5%B0%8F%E6%9E%97coding-xiaolincoding-com"><span class="nav-number">2.3.2.</span> <span class="nav-text">[滑动窗口](4.2 TCP 重传、滑动窗口、流量控制、拥塞控制 | 小林coding (xiaolincoding.com))</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%91%E9%80%81%E6%96%B9%E7%AA%97%E5%8F%A3"><span class="nav-number">2.3.2.1.</span> <span class="nav-text">发送方窗口</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HTTP"><span class="nav-number">2.4.</span> <span class="nav-text">HTTP</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">2.4.1.</span> <span class="nav-text">基本概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E7%8A%B6%E6%80%81%E7%A0%81"><span class="nav-number">2.4.2.</span> <span class="nav-text">常见的状态码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP%E7%BC%93%E5%AD%98"><span class="nav-number">2.4.3.</span> <span class="nav-text">HTTP缓存</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%AC%E7%9A%84HTTP%E7%89%B9%E7%82%B9"><span class="nav-number">2.5.</span> <span class="nav-text">不同版本的HTTP特点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP%E7%BC%93%E5%AD%98-1"><span class="nav-number">2.5.1.</span> <span class="nav-text">HTTP缓存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%92%8C%E5%AF%B9%E6%AF%94"><span class="nav-number">2.5.2.</span> <span class="nav-text">HTTP的迭代和对比</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#HTTP1-1"><span class="nav-number">2.5.2.1.</span> <span class="nav-text">HTTP1.1</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%98%E7%82%B9%E5%92%8C%E7%BC%BA%E7%82%B9"><span class="nav-number">2.5.2.2.</span> <span class="nav-text">优点和缺点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%A7%E8%83%BD-%E9%95%BF%E8%BF%9E%E6%8E%A5"><span class="nav-number">2.5.2.3.</span> <span class="nav-text">性能(长连接)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HTTP-x2F-2"><span class="nav-number">2.5.2.4.</span> <span class="nav-text">HTTP&#x2F;2</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HTTP-x2F-3"><span class="nav-number">2.5.2.5.</span> <span class="nav-text">HTTP&#x2F;3</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#QUIC%E5%8D%8F%E8%AE%AE"><span class="nav-number">2.5.2.5.1.</span> <span class="nav-text">QUIC协议</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTPS"><span class="nav-number">2.5.3.</span> <span class="nav-text">HTTPS</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83"><span class="nav-number">2.5.3.1.</span> <span class="nav-text">核心</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86"><span class="nav-number">2.5.3.2.</span> <span class="nav-text">非对称加密</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B5%81%E7%A8%8B-RSA%E7%AE%97%E6%B3%95%E4%B8%BA%E4%BE%8B"><span class="nav-number">2.5.3.3.</span> <span class="nav-text">流程(RSA算法为例)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HTTPS%E6%8A%93%E5%8C%85-x2F-%E4%BB%A3%E7%90%86%E4%BA%BA"><span class="nav-number">2.5.3.4.</span> <span class="nav-text">HTTPS抓包&#x2F;代理人</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%A1%E7%BD%91%E5%B8%B8%E9%97%AE"><span class="nav-number">2.6.</span> <span class="nav-text">计网常问</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E4%B8%AA%E8%AF%B7%E6%B1%82%E6%95%B4%E4%B8%AA%E7%BD%91%E7%BB%9C%E7%9A%84%E5%A4%84%E7%90%86"><span class="nav-number">2.6.1.</span> <span class="nav-text">一个请求整个网络的处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IPv6%E4%BC%98%E7%82%B9"><span class="nav-number">2.6.2.</span> <span class="nav-text">IPv6优点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BGP%E3%80%81OSPF%E5%8D%8F%E8%AE%AE%E5%8E%9F%E7%90%86"><span class="nav-number">2.6.3.</span> <span class="nav-text">BGP、OSPF协议原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89%E6%8F%A1%E5%9B%9B%E6%8C%A5"><span class="nav-number">2.6.4.</span> <span class="nav-text">三握四挥</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP%E5%92%8CUDP"><span class="nav-number">2.6.5.</span> <span class="nav-text">TCP和UDP</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#SYN%E6%94%BB%E5%87%BB"><span class="nav-number">2.6.5.1.</span> <span class="nav-text">SYN攻击</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3"><span class="nav-number">2.6.5.2.</span> <span class="nav-text">滑动窗口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%85%A2%E5%90%AF%E5%8A%A8"><span class="nav-number">2.6.5.3.</span> <span class="nav-text">慢启动</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%98%BB%E5%A1%9E%E6%8E%A7%E5%88%B6"><span class="nav-number">2.6.5.4.</span> <span class="nav-text">阻塞控制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#DNS"><span class="nav-number">2.6.5.5.</span> <span class="nav-text">DNS</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#DNS%E5%8A%AB%E6%8C%81"><span class="nav-number">2.6.5.6.</span> <span class="nav-text">DNS劫持</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E6%A0%B8%E5%BF%83"><span class="nav-number">2.7.</span> <span class="nav-text">网络核心</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E5%B1%82"><span class="nav-number">2.8.</span> <span class="nav-text">应用层</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E5%BA%94%E7%94%A8%E5%B1%82%E5%8D%8F%E8%AE%AE"><span class="nav-number">2.8.1.</span> <span class="nav-text">常见的应用层协议</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#HTTP%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="nav-number">2.8.1.1.</span> <span class="nav-text">HTTP面试题</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BC%A0%E8%BE%93%E5%B1%82"><span class="nav-number">2.9.</span> <span class="nav-text">传输层</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E5%B1%82"><span class="nav-number">2.10.</span> <span class="nav-text">网络层</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E6%8E%A5%E5%8F%A3%E5%B1%82%EF%BC%9A%E7%AD%89%E4%BB%B7%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%8C%E4%BD%BF%E7%94%A8mac%E5%9C%B0%E5%9D%80"><span class="nav-number">2.10.1.</span> <span class="nav-text">网络接口层：等价数据链路层，使用mac地址</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%89%A9%E7%90%86%E5%B1%82"><span class="nav-number">2.11.</span> <span class="nav-text">物理层</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#OSI%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B-%E6%9C%89%E4%B8%83%E4%B8%AA%E5%88%86%E5%B1%82"><span class="nav-number">2.11.0.1.</span> <span class="nav-text">OSI参考模型 有七个分层</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8"><span class="nav-number">2.12.</span> <span class="nav-text">网络安全</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">QingQiu</p>
  <div class="site-description" itemprop="description">个人网站，学习记录，面试记录和经验总结、互联网中一块属于自己的小窝</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">53</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">26</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Zuofw/zuofw-rpc" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Zuofw&#x2F;zuofw-rpc" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2022 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">QingQiu</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="站点总字数">440k</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  















  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
