<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"zuofw.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="数据库数据库同步问题： Mysql面试指南60 道 MySQL 精选面试题👍 | 二哥的Java进阶之路 (javabetter.cn) InnoDB为什么是默认的引擎 是mysql中唯一支持事务的引擎 锁机制：使用行级锁，而不是表级锁 支持外键约束 具有崩溃恢复  索引为什么使用B+树 支出快速查找：B+树高度相对较低，查找效率高 有序性：节点的键值是有序排列的 支持高效插入和删除操作：叶子节">
<meta property="og:type" content="article">
<meta property="og:title" content="数据库">
<meta property="og:url" content="https://zuofw.github.io/2023/08/02/58/index.html">
<meta property="og:site_name" content="QingQiu&#39;Blog">
<meta property="og:description" content="数据库数据库同步问题： Mysql面试指南60 道 MySQL 精选面试题👍 | 二哥的Java进阶之路 (javabetter.cn) InnoDB为什么是默认的引擎 是mysql中唯一支持事务的引擎 锁机制：使用行级锁，而不是表级锁 支持外键约束 具有崩溃恢复  索引为什么使用B+树 支出快速查找：B+树高度相对较低，查找效率高 有序性：节点的键值是有序排列的 支持高效插入和删除操作：叶子节">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://zuofw.github.io/2023/08/02/58/%E6%85%A2%E6%9F%A5%E8%AF%A2%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96.png">
<meta property="og:image" content="https://zuofw.github.io/2023/08/02/58/%E9%9A%94%E7%A6%BB%E7%AD%89%E7%BA%A7.png">
<meta property="og:image" content="https://zuofw.github.io/2023/08/02/58/ReadView%E5%8F%AF%E8%A7%81%E6%80%A7.png">
<meta property="og:image" content="https://zuofw.github.io/2023/08/02/58/undolog.png">
<meta property="og:image" content="https://zuofw.github.io/2023/08/02/58/undolog%E8%A1%A8.png">
<meta property="og:image" content="https://zuofw.github.io/2023/08/02/58/InnoDB%E6%95%B0%E6%8D%AE%E9%A1%B5.png">
<meta property="og:image" content="https://zuofw.github.io/2023/08/02/58/FileHeader.png">
<meta property="og:image" content="https://zuofw.github.io/2023/08/02/58/PageHeader.png">
<meta property="og:image" content="https://zuofw.github.io/2023/08/02/58/%E6%95%B0%E6%8D%AE%E9%A1%B5%E8%AF%A6%E8%A7%A3.png">
<meta property="og:image" content="https://zuofw.github.io/2023/08/02/58/next_record%E7%A4%BA%E4%BE%8B.png">
<meta property="og:image" content="https://zuofw.github.io/2023/08/02/58/%E8%AE%B0%E5%BD%95%E5%A4%B4%E4%BF%A1%E6%81%AF.png">
<meta property="og:image" content="https://zuofw.github.io/2023/08/02/58/%E9%9A%90%E8%97%8F%E5%88%97.png">
<meta property="og:image" content="https://zuofw.github.io/2023/08/02/58/PageDirectory%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F.png">
<meta property="og:image" content="https://zuofw.github.io/2023/08/02/58/%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86.png">
<meta property="og:image" content="https://zuofw.github.io/2023/08/02/58/%E7%B4%A2%E5%BC%95.png">
<meta property="og:image" content="https://zuofw.github.io/2023/08/02/58/B+%E6%A0%91.png">
<meta property="og:image" content="https://zuofw.github.io/2023/08/02/58/%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95.png">
<meta property="og:image" content="https://zuofw.github.io/2023/08/02/58/sql%E5%BB%BA%E7%AB%8B%E7%B4%A2%E5%BC%95.png">
<meta property="og:image" content="https://zuofw.github.io/2023/08/02/58/%E8%A1%A8%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84.png">
<meta property="og:image" content="https://zuofw.github.io/2023/08/02/58/compact.png">
<meta property="og:image" content="https://zuofw.github.io/2023/08/02/58/join.jpg">
<meta property="og:image" content="https://zuofw.github.io/2023/08/02/58/1.png">
<meta property="og:image" content="https://zuofw.github.io/2023/08/02/58/%E5%93%A8%E5%85%B5%E5%8E%9F%E7%90%86.png">
<meta property="og:image" content="https://zuofw.github.io/2023/08/02/58/%E5%85%A8%E9%87%8F%E5%90%8C%E6%AD%A5.png">
<meta property="og:image" content="https://zuofw.github.io/2023/08/02/58/%E5%A2%9E%E9%87%8F%E5%90%8C%E6%AD%A5.png">
<meta property="og:image" content="https://zuofw.github.io/2023/08/02/58/%E7%8E%AF%E5%BD%A2%E6%95%B0%E7%BB%84.png">
<meta property="og:image" content="https://zuofw.github.io/2023/08/02/58/%E5%88%86%E7%89%87%E9%9B%86%E7%BE%A4.png">
<meta property="og:image" content="https://zuofw.github.io/2023/08/02/58/redis%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5.png">
<meta property="og:image" content="https://zuofw.github.io/2023/08/02/58/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8.png">
<meta property="og:image" content="https://zuofw.github.io/2023/08/02/58/%E8%81%9A%E5%90%88%E7%AE%A1%E9%81%93.png">
<meta property="og:image" content="https://zuofw.github.io/2023/08/02/58/SQL%E5%AF%B9%E6%AF%94%E8%81%9A%E5%90%88.png">
<meta property="article:published_time" content="2023-08-02T07:36:58.000Z">
<meta property="article:modified_time" content="2024-09-14T06:31:12.213Z">
<meta property="article:author" content="QingQiu">
<meta property="article:tag" content="database">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zuofw.github.io/2023/08/02/58/%E6%85%A2%E6%9F%A5%E8%AF%A2%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96.png">

<link rel="canonical" href="https://zuofw.github.io/2023/08/02/58/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>数据库 | QingQiu'Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>


<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">QingQiu'Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">清秋的博客</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-fa fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-fa fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-fa fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-fa fa-archive"></i>归档</a>

  </li>
        <li class="menu-item menu-item-github">

    <a href="https://github.com/Zuofw" rel="noopener" target="_blank"><i class="fa fa-fw fa-fab fa-github"></i>Github</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zuofw.github.io/2023/08/02/58/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="QingQiu">
      <meta itemprop="description" content="个人网站，学习记录，面试记录和经验总结、互联网中一块属于自己的小窝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="QingQiu'Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          数据库
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-08-02 15:36:58" itemprop="dateCreated datePublished" datetime="2023-08-02T15:36:58+08:00">2023-08-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-09-14 14:31:12" itemprop="dateModified" datetime="2024-09-14T14:31:12+08:00">2024-09-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>39k</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><p>数据库同步问题：</p>
<h2 id="Mysql面试指南"><a href="#Mysql面试指南" class="headerlink" title="Mysql面试指南"></a>Mysql面试指南</h2><p><a target="_blank" rel="noopener" href="https://javabetter.cn/interview/mysql-60.html">60 道 MySQL 精选面试题👍 | 二哥的Java进阶之路 (javabetter.cn)</a></p>
<h3 id="InnoDB为什么是默认的引擎"><a href="#InnoDB为什么是默认的引擎" class="headerlink" title="InnoDB为什么是默认的引擎"></a>InnoDB为什么是默认的引擎</h3><ol>
<li>是mysql中唯一支持事务的引擎</li>
<li>锁机制：使用行级锁，而不是表级锁</li>
<li>支持外键约束</li>
<li>具有崩溃恢复</li>
</ol>
<h3 id="索引为什么使用B-树"><a href="#索引为什么使用B-树" class="headerlink" title="索引为什么使用B+树"></a>索引为什么使用B+树</h3><ol>
<li>支出快速查找：B+树高度相对较低，查找效率高</li>
<li>有序性：节点的键值是有序排列的</li>
<li>支持高效插入和删除操作：叶子节点之间使用双向链表链接，可以快读定位到要插入和删除的位置</li>
<li>适应硬盘存储：B+树节点被控制在硬盘大小的范围内</li>
<li>支持数据点有序存储和范围查找</li>
</ol>
<h3 id="如何进行回滚的"><a href="#如何进行回滚的" class="headerlink" title="如何进行回滚的"></a>如何进行回滚的</h3><ol>
<li>使用Undo Log进行回滚，</li>
<li>混滚时，按照事务的执行的逆序进行回滚。</li>
<li>Undo Log记录了事务对数据库的修改操作</li>
</ol>
<h3 id="慢查询如何考虑优化"><a href="#慢查询如何考虑优化" class="headerlink" title="慢查询如何考虑优化"></a>慢查询如何考虑优化</h3><p><img src="/2023/08/02/58/%E6%85%A2%E6%9F%A5%E8%AF%A2%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96.png"></p>
<h3 id="数据库中的CAP"><a href="#数据库中的CAP" class="headerlink" title="数据库中的CAP"></a>数据库中的CAP</h3><p>C：Consistency强一致性，系统在执行某项操作之后，仍然能够保持一致。更新操作执行成功，所有的用户都应该读到最新的值<br>A：Availabliy可用性，每个操作总是能够在一定时间内返回结果。结果可以是成功或者失败<br>P：分区容错性，出现网络分区时，系统能够正常运行。</p>
<h3 id="怎么对plan进行优化"><a href="#怎么对plan进行优化" class="headerlink" title="怎么对plan进行优化"></a>怎么对plan进行优化</h3><ol>
<li>谓词下推：查询时，竟遭过滤掉不需要的数据<code>SELECT * FROM orders WHERE order_date &gt; '2023-01-01';</code></li>
<li>索引下推：使用索引来加速查询，尤其是在索引覆盖查询中</li>
<li>表达式优化：简化和重写表达式来提高效率</li>
<li>最左匹配优化选择索引：使用索引的最左前缀原则来优化查询</li>
<li>避免SELECT * </li>
<li>使用适当的JOIN类型</li>
<li>使用索引覆盖：创建包含所有查询列的索引避免回表</li>
<li></li>
</ol>
<h3 id="介绍一下MySQL的索引"><a href="#介绍一下MySQL的索引" class="headerlink" title="介绍一下MySQL的索引"></a>介绍一下MySQL的索引</h3><p>MySQL的索引是一种数据结构，可以帮助MySQL快速搞笑的查询，更新数据库中的数据。</p>
<h3 id="B-树的特征，为什么-MySQL-要使用-B-树"><a href="#B-树的特征，为什么-MySQL-要使用-B-树" class="headerlink" title="B+树的特征，为什么 MySQL 要使用 B+树"></a>B+树的特征，为什么 MySQL 要使用 B+树</h3><p>特点： </p>
<ol>
<li>只有叶子节点会存放实际的数据，包括索引+记录，非叶子节只存放索引</li>
<li>所有索引都在叶子节点中出现，叶子节点之间构成一个有序链表</li>
<li>非叶子节点的索引也会同时存在叶子节点中，并且是叶子节点中索引中的最大值或者最小值</li>
<li>非叶子节点有多少个子节点，就有多少个索引</li>
</ol>
<p>看看几个隔离级别和解决办法<br>GBKh和UTF-8不是一种编码方式<br>mysql中使用的utf-8是utf8mb3 使用1<del>3个字节来表示一个字符<br>而utf-8使用1</del>4<br>MVCC （Multi-Version Concurrency Control ，多版本并发控制）MVCC （Multi-Version Concurrency Control ，多版本并发控制）指的就是在使用 READ COMMITTD 、 REPEATABLE READ 这两种隔离级别的事务在执行普通的 SEELCT 操作时访问记录的版本链的过程，这样子可以使不同事务的 读-写 、 写-读 操作并发执行，从而提升系统性能。</p>
<ul>
<li>sql语句的执行过程：mysql8.0 client发送sql语句-&gt;sql解析-&gt;执行优化和执行计划生成-&gt;执行-&gt;返回结果</li>
<li>隔离等级：<img src="/2023/08/02/58/%E9%9A%94%E7%A6%BB%E7%AD%89%E7%BA%A7.png" alt="|575"><ul>
<li>MySQL默认是可重复读，可以解决幻读。然后串行化是基于锁实现的，可重复读和读已提交都是基于MVCC实现的，可重复读在当前读的情况下需要加锁才能保证不会出现幻读，所以仅仅使用MVCC不能解决幻读</li>
</ul>
</li>
<li>日志：<ul>
<li>种类：错误日志，查询日志，慢查询日志，Binary Log, 中继日志，事务日志</li>
</ul>
<ol>
<li>undo log 有两种<ul>
<li>insert undo log 执行insert 操作产生的undo log isnert只对事务本身可见，其他事务不可见，所以事务提交之后可以直接删除</li>
<li>update undo log 提供MVCC机制，提交时放入undo log 链表，等待purge线程进行最后的删除<ul>
<li>purge：会定期检查 undo log 和数据行，找出那些已经不再需要的，然后将它们从磁盘上删除，从而回收磁盘空间。</li>
</ul>
</li>
</ul>
</li>
<li>慢查询日志：记录执行时间查过指定阈值的所有SQL查询，</li>
<li>Binlog: 主要记录了数据库的修改操作，事务信息和一些特殊事件：服务器的启动和停止，主从复制状态变更事件等</li>
<li>redo log 如何保证事务的持久性？ <ul>
<li>事务执行时，首先记录在redo log而不是直接修改数据文件，redo log 保存在内存中的log buffer，然后被异步刷新到磁盘中的redo log file中</li>
<li>事务提交时，相关的数据还没有没刷新到磁盘中，只要保证redo log 被刷新到磁盘中，即使系统在事务提交后崩溃了，也可以在系统重启之后通过redo log 里恢复数据，</li>
<li>为什么要先写入redo log ，因为redo log 时顺序写入的，而写数据需要涉及随机I/O，能够提高数据库的性能</li>
</ul>
</li>
<li>页表修改之后为什么不直接刷盘？因为刷新到磁盘中非常耗时，所以使用预写式日志的技术，先写入redolog，之后异步刷新内存中的redolog到磁盘中，之后写入数据到内存中的数据页中，之后写入binlog，内存中的数据页会在适当实际刷新到磁盘中。</li>
<li>binlog和redolog的区别：<ul>
<li>用途上：binlog用于主从复制和数据恢复，复制时会把主服务器上的binlog发给从服务器，然后从服务器根据binlog中的记录来更新;而redo log 用于保证事务的持久性</li>
<li>格式：binlog:可以是语句格式或者行格式，语句记录SQL执行的语句，行格式记录每一行的数据变化。redo log以物理格式记录数据页的修改，记录的是某个数据页的某个位置，将某个数据修改为了什么</li>
<li>写入时机：binlog 事务提交时，redo log 事务执行过程中就开始写入，事务提交时确保已经将redo log 写入磁盘中</li>
<li>清理方式：binlog 需手动清理或者设置过期时间清理； redo log 当数据页的修改刷新到磁盘中之后，redo log 即可被覆盖重新使用</li>
</ul>
</li>
<li>undo log 如何保证事务的原子性：事务开始执行时，udno log 中会记录修改前的数据，如果事务体骄傲成功，undo log 即可以被清理，如果失败就会使用undo log 回滚事务。</li>
<li>MVCC(乐观锁)如何实现：每个数据行中都有两个隐藏列：一个用于记录改行创建时的事务ID，一个记录删除该行的事务ID，当事务开始时，他会根据当前所有活跃的事务产生Read View ，其中记录了：<ul>
<li>创建这个Read View时下个即将被分配的事务ID m_low_limit_id</li>
<li>活跃列表中最小的事务ID m_up_limit_id</li>
<li>Read View创建时，其他未提交的活跃事务ID列表 m_ids</li>
<li>创建该Read View 的事务ID m_creator_trx_id<br> 之后对数据行进行读取时，检查该行的创建事务ID和删除事务ID <img src="/2023/08/02/58/ReadView%E5%8F%AF%E8%A7%81%E6%80%A7.png" alt="ReadView可见性|525"></li>
<li>如果创建ID大于m_low_limit_id，说明是在当前事务之后创建的，不可见</li>
<li>如果删除ID小于m_up_limit_id，说明在当前事务开始前就已经被删除了，不可见</li>
<li>如果创建事务ID小于m_low_limit_id但删除ID大于m_up_limit_id，需要与m_ids列表中比对，如果存在于m_ids列表中，则不可见</li>
</ul>
</li>
<li></li>
</ol>
</li>
<li>外键：<ul>
<li>不建议使用外键，外键应该在应用层中保证，而不是在数据库上使用外键，因为外键对分库分表无法生效，同时需要维护外键，当我们做一些涉及外键的CUD操作时，需要触发相关的操作去检查，保证数据的一致性和正确性，从而消耗额外资源，</li>
</ul>
</li>
<li>集群：<ul>
<li>redo log 和 undo log都是由InnoDB引擎实现的</li>
<li>bin log 是由mysql级别的日志<ul>
<li>redo和bin 的区别：Redo log是记录了数据的修改，大小到一定程度，新的日志会覆盖，先写redo再写bin，目的是为了保证事务的持久性</li>
<li>Binlog是记录了执行了什么sql语句，不会覆盖旧日志，用于实现mysql的主从复制</li>
</ul>
</li>
<li>redolog的优势：顺序写，预写入，磁盘同步过程中可以一次同步多个事务的Redo log：先把修改写入redolog，再修改内存中的数据，事务提交时再入bin log，之后再将数据写入磁盘中 </li>
<li>主从复制：<ul>
<li>master节点会不断将sql命令写入Binary Log，子节点使用I/O线程读入master节点中的Bin Log</li>
<li>字节点使用SQL线程执行Bin Log的语句</li>
</ul>
</li>
</ul>
</li>
<li>存储引擎的区别：MyISAM 和 InnoDB 的区别<ul>
<li>MySQL的存储引擎采用的是插件式架构，支持多种存储引擎，我们甚至可以为不同的数据库表设计不同的存储引擎，存储引擎是基于表而不是数据库的。</li>
<li>InnodDB支持事务</li>
<li>InnoDB支持行级锁定，MyISAM操作时直接锁定整个表</li>
<li>InnoDB支持外键和级联删除/更新</li>
<li>InnoBD存储数据更大</li>
<li>崩溃恢复更好</li>
<li>InnoDB以聚簇的方式存储数据，MyISAM是将数据和索引分开存储</li>
<li>InnoDB支持MVCC</li>
</ul>
</li>
<li>事务：<ul>
<li>并发事务带来了哪些问题：<ol>
<li>脏读：一个事务读到了另一个事务修改后回滚的数据</li>
<li>丢失修改:两个事务同时修改一个数据，先提交的会丢失修改</li>
<li>不可重复读：执行相同的两个语句，结果不一样</li>
<li>幻读：多了记录或者是少了记录<ul>
<li>3和4的区别：3是记录被修改，4是记录条数变化</li>
</ul>
</li>
</ol>
</li>
<li>mysql中的隔离等级： 默认是可重复读，能够防止幻读 实现是通过 <strong>锁和MVCC(多版本控制并发控制)</strong> 实现的<ol>
<li>读未提交：允许事务读取未提交的事务的修改，会出现脏读，幻读，不可重复读</li>
<li>读已提交：只能读到提交的事务的修改，避免脏读，但是还有幻读 （读数据时加上共享锁，读取后立刻释放）</li>
<li>可重复读：同一事务中，多次读取统一数据返回结果要一致 (事务结束才释放锁，同时使用MVCC来保证每个事务都看到一个一致的快照)</li>
<li>可串行化：强制事务串行执行，影响效率</li>
</ol>
</li>
<li>MVCC的原理：</li>
<li>这两个隐藏的列就是undo log日志<img src="/2023/08/02/58/undolog.png" alt="|700"><ul>
<li>这俩就是隐藏列，trx_id当前修改之后的事务id，roll_pointer指向修改之前的信息</li>
<li><img src="/2023/08/02/58/undolog%E8%A1%A8.png" alt="|725"></li>
<li>MVCC实现原理：ReadView<ul>
<li>主要内容：<ul>
<li>m_ids:生成ReadView时当前系统活跃的读写事务id列表</li>
<li>min_trx_id:在生成ReadView时当前系统活跃的读写事务中最小的事务id，也就是min (m_ids)</li>
<li>max_trx_id:表示生成ReadVeiw时系统应该分配给下下一个事务的id值</li>
<li>creator_trx_id：表示生成该ReadView的事务id</li>
</ul>
</li>
<li>原理：在访问某条记录时根据以下方式来判断：<ol>
<li>trx_id == creator_trx_id，表示是自己修改过的记录，可见</li>
<li>trx_id &lt; min_trx_id 可以被访问</li>
<li>trx_id &gt; max_trx_id，不可被访问</li>
<li>trx_id &gt; min  &amp;&amp; trx_id &lt; max 需要判断：如果trx_id在m_ids中，表示仍然活跃，不可访问，不在表示已经被提交，可以访问了</li>
<li>如果某个版本对当前事务不可见，则顺着版本连找下一个版本的数据，直到最后，如果最后一个版本也不可见的话，意味着这条记录对这个事务完全不可见，查询结果不返回这个记录</li>
</ol>
</li>
<li>读已提交每次读都会生成一个ReadView，而可重复读智慧在第一次执行查询语句时生成一个ReadView</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>索引常问：<ul>
<li>覆盖索引：查询使用了索引，并且查询过程中已经找到了所有需要的列，不需要继续回表了</li>
<li>索引失效问题：<ol>
<li>使用了!= &lt; &gt; LIKE ，函数操作或者表达式操作</li>
<li>联合索引中没有遵循最左前缀，跳过了中间的索引字段</li>
<li></li>
</ol>
</li>
</ul>
</li>
<li>SQL语句：<ul>
<li>常见函数：<ol>
<li>Concat()把多列拼接在一起</li>
<li>RTrim() 去除多有空格</li>
<li>AS给列起别名</li>
</ol>
</li>
<li>存储过程：存储过程是一种在数据库中存储的预编译的SQL语句集合，可以通过调用它的名字来执行。存储过程可以接收参数，并且可以返回值，长哟个与进行批处理<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">USE test;
CREATE PROCEDURE productpricing()
BEGIN
	SELECT * FROM hello;
END;

调用
CALL productpricing()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
</li>
</ul>
<h3 id="InooDB详解"><a href="#InooDB详解" class="headerlink" title="InooDB详解"></a>InooDB详解</h3><ol>
<li>InooDB大小一般为16kb</li>
<li>InooDB页表:<img src="/2023/08/02/58/InnoDB%E6%95%B0%E6%8D%AE%E9%A1%B5.png"></li>
<li>File Header：<img src="/2023/08/02/58/FileHeader.png"></li>
<li>Page Header：<img src="/2023/08/02/58/PageHeader.png"></li>
<li>infimumu+supremum 最小记录和最大记录。不存放真是数据<img src="/2023/08/02/58/%E6%95%B0%E6%8D%AE%E9%A1%B5%E8%AF%A6%E8%A7%A3.png"><ul>
<li>heap_no分别为0和1， record_type分为4种，0普通记录，1表示B+树非叶节点记录，2最小记录，3最大记录。</li>
<li>next_record 由当前真实数据指向吓一跳记录的真实数据。吓一跳记录不是按照插入顺序的下一条，而是根据主键排序之后的下一条。infimum的下一条记录是用户记录中主键最小的，用户记录中主键最大的下一条指向supremum</li>
<li>为什么指向的是真是数据的开头？<ul>
<li>因为向左读取为记录头信息，向右读取真实数据。 记录头信息刚好是<strong>逆序的！</strong></li>
</ul>
</li>
<li><img src="/2023/08/02/58/next_record%E7%A4%BA%E4%BE%8B.png"></li>
</ul>
</li>
<li>User Record ： <ul>
<li>由额外记录信息和实际信息组成</li>
<li>额外记录：<ul>
<li>变长字段的真实数据的字节长度都放在记录的开头，逆序存放。不存放NULL的字节长度</li>
<li>NULLL值列表，NULL值存储在这里，并且是逆序存储，如果存在NULL值就不会存在这个列表</li>
<li>记录头信息：<img src="/2023/08/02/58/%E8%AE%B0%E5%BD%95%E5%A4%B4%E4%BF%A1%E6%81%AF.png"><ul>
<li>delete_mask标记的记录不会理科删除，而是会放在垃圾列表中，等待覆盖。</li>
<li>heap_no是根据主键的大小来确定的</li>
</ul>
</li>
</ul>
</li>
<li>真实信息：<ul>
<li><img src="/2023/08/02/58/%E9%9A%90%E8%97%8F%E5%88%97.png"></li>
<li>如果未指定主键，会生成row_id隐藏列</li>
</ul>
</li>
</ul>
</li>
<li>Page  Directory ：<ul>
<li>将正常的所有记录划分为几个组，包括最大和最小记录，不包括已删除的记录,最小记录所在的分组只包括自己。</li>
<li>每组最后一个记录的头信息中的n_ownd来表示该组中记录数。</li>
<li>将每组的最后一条记录的地址偏移量拿出来放入PageDirectory中，偏移量被称为槽(slot)</li>
<li><img src="/2023/08/02/58/PageDirectory%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F.png"></li>
</ul>
</li>
<li>File Trailer: 用于检验一个页是否完整：</li>
</ol>
<h3 id="索引："><a href="#索引：" class="headerlink" title="索引："></a>索引：</h3><h4 id="回表问题"><a href="#回表问题" class="headerlink" title="回表问题"></a>回表问题</h4><p>当查询的数据在索引树中找不到时，就需要回到主键索引树种去获取。<br>覆盖索引：<br>查询时从索引列就能够获取了，就不需要回到主键树中查找了</p>
<ul>
<li>前提<ol>
<li>数据页链表中的前后保证前一个数据页中的主键的最大值大于后一个页表中主键的最小值，也就主键递增，每一个页表内，主键也递增</li>
<li>建立一个目录项：包括 key:页中主键最小值 page_no:页号。</li>
<li><img src="/2023/08/02/58/%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86.png"></li>
</ol>
</li>
<li>mysql中的实现：<ol>
<li>使用用户记录的数据页来存储目录项，并且使用record_type = 1来标明，只包含key和page_no即可</li>
<li>使用双向列表来维护多个目录项</li>
<li>使用树的结构来重复建立索引，加快访问<img src="/2023/08/02/58/%E7%B4%A2%E5%BC%95.png"><img src="/2023/08/02/58/B+%E6%A0%91.png"></li>
<li>真正的数据页都放在最底层的叶子节点</li>
</ol>
<ul>
<li>聚簇索引：1. 使用主键值大小进行记录和排序 2. 叶子节点是完整的用户记录。索引即数据，数据即索引</li>
<li>二级索引：1.使用非主键值来进行记录和排序 2. 叶子节点存储的是索引键和主键的值 3. 查询到叶子节点之后需要再查找一变主键的索引来找到真正的用户记录。 优点是节省空间。<img src="/2023/08/02/58/%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95.png"></li>
<li>联合索引：1.使用多个列的大小来进行排序。先按照一个列排序，列大小相同时，使用下一个列大小来排序。2. 对于这多个列只需要建立一个B+树即可，节省了空间3.实质上也是二级索引</li>
<li>对比：MyISAM<ul>
<li>存储在一个文件中，按照插入顺序，有行号</li>
<li>索引放在另一个文件中，使用主键值+行号作为索引，所以全是二级索引，而且不能二分查找。</li>
</ul>
</li>
<li>SQL建立索引：每一个表会自动为主键或者unique建立一个聚簇索引，可使用语句指定建立其他列的索引<img src="/2023/08/02/58/sql%E5%BB%BA%E7%AB%8B%E7%B4%A2%E5%BC%95.png"></li>
<li>删除索引：ALTER TABLE index_demo DROP INDEX idx_c2_c3;</li>
</ul>
</li>
<li>独立表空间：<ol>
<li>区：表空间分为多个区，区包含多个页</li>
</ol>
</li>
</ul>
<h3 id="指令执行过程"><a href="#指令执行过程" class="headerlink" title="指令执行过程"></a>指令执行过程</h3><ul>
<li>select <ol>
<li>使用连接器连接mysql server,期间通过三次握手 show processlist来查看多少个客户端连接了</li>
<li>查询缓存(8.0) 已抛弃</li>
<li>解析SQL ：<ol>
<li>词法分析，根据字符串识别关键词，分类字符串</li>
<li>语法分析，语法解析器会根据语法规则来判断是否符合MySQL语法秒如果没问题就会构出SQL语法树</li>
</ol>
</li>
<li>执行SQL语句，<code>SELECT</code>&nbsp;查询语句流程主要可以分为下面这三个阶段：<ul>
<li>prepare 阶段，也就是预处理阶段；检查表和字段是否存在，将* 扩展为表上的列</li>
<li>optimize 阶段，也就是优化阶段；<strong>优化器主要负责将 SQL 查询语句的执行方案确定下来</strong>，比如在表里面有多个索引的时候，优化器会基于查询成本的考虑，来决定选择使用哪个索引。</li>
<li>execute 阶段，也就是执行阶段；根据执行计划执行 SQL 查询语句，从存储引擎读取记录，返回给客户端；</li>
</ul>
</li>
</ol>
</li>
<li>MySQL一行记录如何<ul>
<li>每建立一个数据库都会咋/var.lib/mysql/下建立一个同名的文件夹</li>
<li>文件夹中有三个文件</li>
<li>db.opt 用来存储数据库的默认字符集和字符检验规则</li>
<li>tableNaem.frm 对应的表结构会保存在这个文件，主要包含表结构的定义</li>
<li>tableName.ibd 表中的数据会保存在这个文件中</li>
</ul>
</li>
<li>表空间文件的结构 ：<ul>
<li><img src="/2023/08/02/58/%E8%A1%A8%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84.png"></li>
<li>段 <ul>
<li>索引段：存放 B + 树的非叶子节点的区的集合；</li>
<li>数据段：存放 B + 树的叶子节点的区的集合；</li>
<li>回滚段：存放的是回滚数据的区的集合，之前讲<a target="_blank" rel="noopener" href="https://xiaolincoding.com/mysql/transaction/mvcc.html">事务隔离&nbsp;(opens new window)</a>的时候就介绍到了 MVCC 利用了回滚段实现了多版本查询数据。</li>
</ul>
</li>
<li>区 InnoDB 使用的是B+树 以页为单位来来分配空间时，链表中相邻的两个页的物理位置是不连续的，为了防止随机I/O，可以按照区来分配，一个区可以包含多个页，这样页在位置上就是相邻的了可以使用顺序I/O</li>
<li>页 读取数据以页为单位，当读取一行时，会将一页一同读取出来，放入内存中 默认页 16kb ,页是 InnoDB 存储引擎磁盘管理的最小单元，</li>
<li>行 记录按照行<ul>
<li>行格式：COMPACT <img src="/2023/08/02/58/compact.png"><ul>
<li>变长字段长度列表，用于保存数据占用的大小， 在列表中采用逆序存放数据占用的实际字节，当一行中没有变长字段时，例如全int时，就不会存在变长字段列表了。</li>
<li>NULL列表，数据中为NULL 的数据会放在NULL值列表中的。NULL值也是按照逆序存储的，使用二进制 0 1 来表示是否为NULL值，1 为是  <strong>当数据表的字段都定义成 NOT NULL 的时候，这时候表里的行格式就不会有 NULL 值列表了</strong>。</li>
<li>记录头信息</li>
<li>delete_mask ：标识此条数据是否被删除。从这里可以知道，我们执行 detele 删除记录的时候，并不会真正的删除记录，只是将这个记录的 delete_mask 标记为 1。</li>
<li>next_record：下一条记录的位置。从这里可以知道，记录与记录之间是通过链表组织的。在前面我也提到了，指向的是下一条记录的「记录头信息」和「真实数据」之间的位置，这样的好处是向左读就是记录头信息，向右读就是真实数据，比较方便。</li>
<li>record_type：表示当前记录的类型，0表示普通记录，1表示B+树非叶子节点记录，2表示最小记录，3表示最大记录</li>
</ul>
</li>
<li>真实数据部分<ul>
<li>row_id 未指定主键或者唯一约束列时，会有，占用6个字节</li>
<li>trx_id事务id表示数据由哪个事务生成的，必需</li>
<li>roll_pointer 记录上一个版本的指针，必需</li>
</ul>
</li>
</ul>
</li>
<li><strong>一行数据的最大字节数 65535(不包含 TEXT、BLOBs 这种大对象类型)，其实是包含「变长字段长度列表」和 「NULL 值列表」所占用的字节数的</strong></li>
<li>如果一个数据页存不了一条记录，InnoDB 存储引擎会自动将溢出的数据存放到「溢出页」中。</li>
</ul>
</li>
</ul>
<p>Compact 行格式针对行溢出的处理是这样的：当发生行溢出时，在记录的真实数据处只会保存该列的一部分数据，而把剩余的数据放在「溢出页」中，然后真实数据处用 20 字节存储指向溢出页的地址，从而可以找到剩余数据所在的页。</p>
<p>Compressed 和 Dynamic 这两种格式采用完全的行溢出方式，记录的真实数据处不会存储该列的一部分数据，只存储 20 个字节的指针来指向溢出页。而实际的数据都存储在溢出页中。<br>索引分类：</p>
<ul>
<li>按「数据结构」分类：<strong>B+tree索引、Hash索引、Full-text索引</strong>。</li>
<li>按「物理存储」分类：<strong>聚簇索引（主键索引）、二级索引（辅助索引）</strong>。</li>
<li>按「字段特性」分类：<strong>主键索引、唯一索引、普通索引、前缀索引</strong>。</li>
<li>按「字段个数」分类：<strong>单列索引、联合索引</strong>。</li>
</ul>
<h3 id="MySql查询优化"><a href="#MySql查询优化" class="headerlink" title="MySql查询优化"></a>MySql查询优化</h3><ul>
<li>单表 <ol>
<li>根据搜索条件，找出所有可能使用的索引</li>
<li>计算全表扫描的代价</li>
<li>计算使用不同索引执行查询的代价</li>
<li>对比各种执行方案的代价，找出成本最低的那一个</li>
</ol>
</li>
<li>多表连接：<ol>
<li>单次查询驱动表的成本</li>
<li>多次查询被驱动表的成本（具体查询多少次取决于对驱动表查询的结果集中有多少条记录）</li>
</ol>
</li>
<li>连接查询成本占大头的其实是 驱动表扇出数 x 单次访问被驱动表的成本 ，所以我们的优化<ol>
<li>重点其实是下边这两个部分：</li>
<li>尽量减少驱动表的扇出</li>
<li>对被驱动表的访问成本尽量低</li>
</ol>
</li>
</ul>
<h3 id="Buffer-Pool-缓冲池"><a href="#Buffer-Pool-缓冲池" class="headerlink" title="Buffer Pool 缓冲池"></a>Buffer Pool 缓冲池</h3><p>脏页：缓冲池中的数据已经修改但是没有同步到磁盘中</p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h3><ul>
<li>模式: 逻辑模式，是开发者可见的模式，是数据库中全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图。</li>
<li>外模式:子模式，用户模式，用户可见</li>
<li>内模式: 存储模式，是物理存储模式</li>
</ul>
<h2 id="schema-和-database-区别"><a href="#schema-和-database-区别" class="headerlink" title="schema 和 database 区别"></a>schema 和 database 区别</h2><p>database 是一栋楼，schema(模式) 是一个个房间，但是在mysql中两种没有区别。</p>
<ul>
<li>视图和表的区别：视图是表的子集，常用于将查询结果保存在视图中，方便再次调用</li>
<li>语法：’CREATE VIEW viewName AS 查询出来的表’</li>
</ul>
<h2 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h2><ul>
<li>1NF 保证原子性即可，不可再分割了</li>
<li>2NF 要有主键，且不存在部份依赖，也就是其他非主键的部分要治理来于主键即可</li>
<li>3NF 非主键之间不存在传递依赖，例如 学号, 姓名, 年龄, 学院名称, 学院电话，满足第二范式，因为后面几个属性都要和主键相关联，不能独立存在，但是通过 学号 -&gt; 学生 -&gt; 所在院 -&gt; 院电话 ，所以存在传递依赖应修改为：学生：(学号, 姓名, 年龄, 所在学院)；学院：(学院，学院名称， 电话)。</li>
<li>BCNF 消除几个主键之间的传递依赖</li>
</ul>
<h2 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a><a target="_blank" rel="noopener" href="https://xiaolincoding.com/mysql/transaction/mvcc.html#%E4%BA%8B%E5%8A%A1%E6%9C%89%E5%93%AA%E4%BA%9B%E7%89%B9%E6%80%A7">ACID</a></h2><ul>
<li><p>Atomicity（原子性）：一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被恢复（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。</p>
</li>
<li><p>Consistency（一致性）：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。</p>
</li>
<li><p>Isolation（隔离性）：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。</p>
</li>
<li><p>Durability（持久性）：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</p>
</li>
</ul>
<h2 id="E-R模型"><a href="#E-R模型" class="headerlink" title="E-R模型"></a>E-R模型</h2><p>E-R模型是Entity-Relationship模型的缩写，是一种用于数据库设计的概念性数据模型。它用来描述现实世界中的数据之间的关系，以及这些数据的属性。E-R模型提供了一种图形化的方式来表示数据模型，使数据库设计师能够更容易地理解和规划数据库结构。</p>
<p>E-R模型包括以下几个核心概念：</p>
<ol>
<li><p>实体（Entity）：实体是现实世界中可以被识别的独立对象，例如人、物品、地点或概念。每个实体都有一些属性，用来描述这个实体的特征。</p>
</li>
<li><p>属性（Attribute）：属性是描述实体的特征或属性，它们用来存储有关实体的信息。例如，对于一个”人”实体，属性可以包括姓名、年龄、性别等。</p>
</li>
<li><p>关系（Relationship）：关系表示不同实体之间的联系或连接。关系可以是一对一、一对多或多对多的。例如，一个”雇员”实体可以与一个”部门”实体之间有一个”属于”关系，表示雇员属于某个部门。</p>
</li>
<li><p>主键（Primary Key）：主键是一个属性或属性组合，用来唯一标识实体集中的每个实体。它确保了每个实体都具有唯一的标识。</p>
</li>
<li><p>外键（Foreign Key）：外键是一个实体中的属性，它引用了另一个实体的主键，用于建立实体之间的关联。</p>
</li>
</ol>
<p>通过使用E-R模型，数据库设计师可以更好地理解数据之间的关系，从而规划数据库的结构，包括表的设计、关系的建立和数据的存储。一旦E-R模型完成，它可以用作设计数据库架构的基础，进而创建物理数据库模式（如关系模型），以实际存储和管理数据。这有助于确保数据库能够有效地存储和检索信息，并满足应用程序的需求。</p>
<h2 id="自联结，变量不会，补一补去"><a href="#自联结，变量不会，补一补去" class="headerlink" title="自联结，变量不会，补一补去"></a>自联结，变量不会，补一补去</h2><p>打开</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mysql <span class="token parameter variable">-u</span> root <span class="token parameter variable">-p</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><strong>数据类型</strong></p>
<p>关系型数据库：建立在关系模型基础上，由多张相互链接的二维表组成的数据库</p>
<h2 id="SQL语句"><a href="#SQL语句" class="headerlink" title="SQL语句"></a>SQL语句</h2><ol>
<li><p><strong>数值类型</strong></p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">TINYINT 1byte -128 - 127  0 - 255 /*后面加上unsigned 即可指定为无符号*/
SMALLINT 2
MEDIUMINT 3
INT 4
BIGINT 8
FLOAT 4
DOUBLE 8
DECIMAL 看精度和标度  125.25 精度为5 标度为2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

</li>
<li><p><strong>字符串类型</strong></p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">CHAR() 定长字符串
VARCHAR 根据内容计算字符串长度
TINYTEXT 短文本字符串<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li>
<li><p><strong>日期类</strong></p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">DATE YYYY-MM-DD
TIME HH:MM:SS
YEAR YYYY
DATETIME YYYY-MM-DD HH:MM:SS
TIMESTAMP YYYY-MM-DD HH:MM:SS 时间戳<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>常用函数</p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">DATE_FORMAT()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<blockquote>
<p><strong>时间戳记</strong>或称为<strong>时间标记</strong>（英语：timestamp）是指字符串或编码信息用于辨识记录下来的时间日期。国际标准为<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/ISO_8601" title="ISO 8601">ISO 8601</a>。</p>
<p>时间戳记的范例如下：</p>
<ul>
<li>2016-12-25T00:15:22Z</li>
<li>2005-10-30 10:45&nbsp;<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/UTC" title="UTC">UTC</a></li>
<li>Sat Jul 23 02:16:57 2005</li>
<li>2016年12月25日 (日) 00:14 (UTC)</li>
</ul>
</blockquote>
</li>
</ol>
<p>注释 # 或者 /**/</p>
<ol>
<li>DDL (Data Definition Language 数据定义语言）用于操作对象及对象本身，这种对象包括数据库,表对象，及视图对象，表头 ^c501f6</li>
<li>DML （Data Manipulation Language 数据操控语言) 用于操作数据库对象对象中包含的数据</li>
<li>DQL (Data Query Language 数据查询语言 )用于查询数据</li>
<li>DCL （Data Control Language 数据控制语句） 用于操作数据库对象的权限</li>
</ol>
<h3 id="DDL-Data-Definition-Language-数据定义语言）用于操作对象及对象本身，这种对象包括数据库-表对象，及视图对象，表头"><a href="#DDL-Data-Definition-Language-数据定义语言）用于操作对象及对象本身，这种对象包括数据库-表对象，及视图对象，表头" class="headerlink" title="DDL (Data Definition Language 数据定义语言）用于操作对象及对象本身，这种对象包括数据库,表对象，及视图对象，表头"></a>DDL (Data Definition Language 数据定义语言）用于操作对象及对象本身，这种对象包括数据库,表对象，及视图对象，表头</h3><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SHOW DATABASES 查询所有的数据库
SELECT DATABASE(); 查询当前所处数据库
CREATE DATABASE  创建
DROP DATABASE XXX 删除
USE xxx  使用数据库
SHOW TABLES 查询当前数据库的所有表
DESC 表名   查询表结构
SHOW CREATE TABLE 表明 查询指定表的建表语句
	字段1 字段1类型 COMMENT 'XXX',/*注释*/
     ........
    
) COMMENTT 'XXX'/*注释可以省略*/
/*字符串类型是varchar(指定的字符长度)*/
/*修改表*/
ALTER TABLE tablename 
1.ADD字段名 类型 comment xxx 添加表头
2.CHANGE 旧 新 类型 comment xxx 修改
3.DROP name
4.RENAME TO name 修改表名

DROP TABLE name 删除
TRUNCATE TABLE name 删除并重新创建同名表，数据依旧会删除<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="DML-（Data-Manipulation-Language-数据操控语言-用于操作数据库对象对象中包含的数据"><a href="#DML-（Data-Manipulation-Language-数据操控语言-用于操作数据库对象对象中包含的数据" class="headerlink" title="DML （Data Manipulation Language 数据操控语言) 用于操作数据库对象对象中包含的数据"></a>DML （Data Manipulation Language 数据操控语言) 用于操作数据库对象对象中包含的数据</h3><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">/*添加数据*/
INSERT INTO 表名(字段名) VALUES (数值) 给指定字段添加数据
INSERT INTO 表名  VALUES (数值) 给所有字段加上数据
INSERT INTO 表明(字段名) VALUES (数据) ,(数据)
INSERT INTO 表明 VALUE (数据),(数据)...
/*修改*/
UPDATE 表名 SET 字段名=值, .... WHERE 条件
DELETE 表名 (WHERE 条件) /*删除*/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><p>语句：INSERT</p>
<p>前提:<em><strong><u>获得权限</u></strong></em></p>
<p>用法：</p>
<blockquote>
<p> 插入完整的行；</p>
<p> 插入行的一部分；</p>
<p> 插入某些查询的结果。</p>
</blockquote>
<p>语法：</p>
   <pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">INSERT INTO Customers 
VALUES('1000000006', 
 'Toy Land', 
 '123 Any Street', 
 'New York', 
 'NY', 
 '11111', 
 'USA', 
 NULL, 
 NULL);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>   更加安全的操作,将要插入的列也列出</p>
   <pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">INSERT INTO Customers(cust_id, 
 cust_name, 
 cust_address, 
 cust_city, 
 cust_state, 
 cust_zip, 
 cust_country, 
 cust_contact, 
 cust_email) 
VALUES('1000000006', 
 'Toy Land', 
 '123 Any Street', 
 'New York', 
 'NY', 
 '11111', 
 'USA', 
 NULL, 
 NULL);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ol start="2">
<li><p>插入列的一部分，语法和上面一样，只是不需要插入的列可以省略不写，列名不写，对应的数据也不写</p>
</li>
<li><p>插入检索出的数据</p>
<p>语法：</p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SELECT cust_id, 
 cust_contact, 
 cust_email, 
 cust_name, 
 cust_address, 
 cust_city, 
 cust_state, 
 cust_zip, 
 cust_country 
FROM CustNew;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><u>它使用的是列的位置，因此 SELECT 中的第一列（不管</u></p>
<p><u>其列名）将用来填充表列中指定的第一列，第二列将用来填充表列中</u></p>
<p><u>指定的第二列，如此等等</u></p>
<p>INSERT SELECT 中 SELECT 语句可以包含 WHERE 子句，以过滤插入的数据。</p>
<p>INSERT 通常只插入一行。要插入多行，必须执行多个 INSERT 语句。</p>
<p>INSERT SELECT是个例外，它可以用一条INSERT插入多行，不管SELECT</p>
<p>语句返回多少行，都</p>
</li>
<li><p>从一个表复制到另一个表</p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">CREATE TABLE CustCopy AS 
SELECT * FROM Customers;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p><u>SELECT INTO 是试验新 SQL 语句前进行表复制的很好工具。先进行复</u></p>
<p><u>制，可在复制的数据上测试 SQL 代码，而不会影响实际的数据。</u></p>
<h2 id="更新与删除"><a href="#更新与删除" class="headerlink" title="更新与删除"></a>更新与删除</h2><h3 id="更新：UPDATE-注意要用WHERE-否则会出事"><a href="#更新：UPDATE-注意要用WHERE-否则会出事" class="headerlink" title="更新：UPDATE 注意要用WHERE 否则会出事"></a>更新：UPDATE 注意要用WHERE 否则会出事</h3><ol>
<li><p>更新特定行</p>
<p>语法：</p>
<p> 要更新的表；</p>
<p> 列名和它们的新值；</p>
<p> 确定要更新哪些行的过滤条件。</p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">UPDATE Customers 
SET cust_email = 'kim@thetoystore.com' 
WHERE cust_id = '1000000005';<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>UPDATE 语句以 WHERE 子句结束，它告诉 DBMS 更新哪一行。没有 WHERE</p>
<p>子句，DBMS 将会用这个电子邮件地址更新 Customers 表中的所有行，</p>
<p>这不是我们希望的。</p>
</blockquote>
</li>
<li><p>更新特定列</p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">UPDATE Customers 
SET cust_contact = 'Sam Roberts', 
 cust_email = 'sam@toyland.com' 
WHERE cust_id = '1000000006';<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>在更新多个列时，只需要使用一条 SET 命令，每个“列=值”对之间用</p>
<p>UPDATE 语句中可以使用子查询，使得能用 SELECT 语句检索出的数据</p>
<p>更新列数据</p>
<p>要删除某个列的值，可设置它为 NULL（假如表定义允许 NULL 值）</p>
</blockquote>
</li>
</ol>
</li>
</ol>
<h4 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h4><p>DELETE  注意WHERE 缺少是会出事的</p>
<p> 从表中删除特定的行</p>
<p> 从表中删除所有行。</p>
<ol>
<li><p>删除特定行</p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">DELETE FROM Customers 
WHERE cust_id = '1000000006';<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<blockquote>
<p>DELETE 语句从表中删除行，甚至是删除表中所有行。但是，DELETE</p>
<p>不删除表本身</p>
<p>果想从表中删除所有行，不要使用 DELETE。可使用 TRUNCATE +TABLE +表名</p>
<p>语句，它完成相同的工作，而速度更快（因为不记录数据的变动）。</p>
</blockquote>
</li>
<li><p>删除全部行</p>
<blockquote>
<p>如果执行 DELETE 语句而不带 WHERE</p>
<p>子句，表的所有数据都将被删除</p>
</blockquote>
</li>
</ol>
<h3 id="DQL-Data-Query-Language-数据查询语言-用于查询数据"><a href="#DQL-Data-Query-Language-数据查询语言-用于查询数据" class="headerlink" title="DQL (Data Query Language 数据查询语言 )用于查询数据"></a>DQL (Data Query Language 数据查询语言 )用于查询数据</h3><blockquote>
<p>SELECT + 字段列表<br>FROM  表名列表<br>WHERE 条件列表<br>[[数据库#^aa4a30|GROUP BY 分组字段列表]]<br>HAVING 分组后条件列表<br>ORDER BY 排序<br>LIMIT  分页参数<br>[[数据库#^1cd456|AS 设置别名]]<br>WHRER 和 HAVING 的区别，WHERE 在分组之前起作用，HAVING在分组之后起作用</p>
</blockquote>
<h4 id="SELECT"><a href="#SELECT" class="headerlink" title="SELECT"></a>SELECT</h4><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SELECT 字段1，... FROM 表 或者 SELECT * FROM
SELECT DISTINCT 去重
SELECT 字段 AS 别名  ... FROM 设置字段的别名
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>条件</p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SELECT XXX FROM XXX WHERE +
&gt; &gt;= &lt; &lt;= = &lt;&gt;(不等于，相当于!=) BETWEEN ... AND ... 
IN (...) 满足列表中的其一
LIKE 包含这个字符 模糊匹配
'%a'     //以a结尾的数据
'a%'     //以a开头的数据
'%a%'    //含有a的数据
'_a_'    //三位且中间字母是a的
'_a'     //两位且结尾字母是a的
'a_'     //两位且开头字母是a的
'___'    //含有三个字符的
'[]'     //类似正则表达式
'[^]'    //不包含括号之内的单个字符<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>聚合函数:将一列数据作为一个整体，进行纵向计算</p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SELECT +
count 
max
min
avg 平均值
sum
+ 字段列表
+  FROM 表名<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>分组查询 ^aa4a30</p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SELECT 字段名 FROM 表 WHERE GROUP BY 分组字段名 HAVING 分组之后的过滤条件<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>排序查询</p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SELECT xx FROM 表名 ORDER BY 字段1 排序方式(ASC升序，DESC 降序)
，字段2 XXX <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><u>分页查询</u></p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SELECT xx FROM XXX LIMIT (起始索引，查询记录数)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>等于OFFSET n ROWS<br>FETCH NEXY M ROWS ONLY 跳过n行，并返回接下来的m行</p>
<h3 id="DCL-（Data-Control-Language-数据控制语句）-用于操作数据库对象的权限"><a href="#DCL-（Data-Control-Language-数据控制语句）-用于操作数据库对象的权限" class="headerlink" title="DCL （Data Control Language 数据控制语句） 用于操作数据库对象的权限"></a>DCL （Data Control Language 数据控制语句） 用于操作数据库对象的权限</h3><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SELECT * FORM user
CREATE USER '用户名'@'主机名' IDENTIFIED BY '/'/*使用%来指定任意主机都可以访问*/
ALTER USER '用户名' @ '主机名' IDENTIFIED WITH  mysql_native_password BY '新密码'  修改密码
DROP USER '用户名' @ '主机名' 删除用户
/*权限控制*/
SHOW GRANT FOR '用户名'@'主机名'
GRANT 权限列表 ON 数据库名 表名 TO '用户名'@'主机名'
取消权限
REVOKE 权限列表 ON 数据库名 表名 FROM '用户名'@'主机名'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="函数-配合SELECT-使用"><a href="#函数-配合SELECT-使用" class="headerlink" title="函数 配合SELECT 使用"></a>函数 配合SELECT 使用</h2><h3 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h3><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">CONCAT (s1,s2...) 拼接
LOWER(str)
UPPER(str)
LPAD(str,n,pad) 左填充，用pad来填充原字符串，填充n次
RPAD 右填充
TRIM(str) 去掉首位的空格
SUBSTRING(str,start,len) <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="数值函数"><a href="#数值函数" class="headerlink" title="数值函数"></a>数值函数</h3><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">CEIL() 向上取整
FLOOR() 向下取整
MOD(x,y) x % y
RAND() 0-1内的随机数
ROUND(x,y) 四舍五入保留y位小数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a><em>日期函数</em></h3><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">CURDATE() 返回当前日期
CURTIME()
NOW() 当前日期和时间
YEAR(date) 获取指定日期的年份
MONTH(date)
DAY(date)
DATE_ADD(date,interval expr type) 返回一个日期/时间加上时间间隔expr后的时间
DATEDIFF(date1,date2) 返回两个日期相差的天数
timestampdiff(间隔类型，前一个时间，后一个时间) 计算日期查
例如: timestampdiff(YEAR,hiredate,now()))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="流程函数"><a href="#流程函数" class="headerlink" title="流程函数"></a><em>流程函数</em></h3><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">if (value,t,f) 如果value true 返回t 否则返回f
IFNULL(v1,v2) 如果v1不为空返回v1,否则返回v2
CASE WHEN (v1) THEN (res1)
WHEN (v2) THEN (res2)
....
ELSE default END
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="约束-作用域表中字段上的规则，用于限制存储在表中的数据"><a href="#约束-作用域表中字段上的规则，用于限制存储在表中的数据" class="headerlink" title="约束 作用域表中字段上的规则，用于限制存储在表中的数据"></a>约束 作用域表中字段上的规则，用于限制存储在表中的数据</h2><p>目的是未来保证数据库中数据的正确性和完整性有效性<br>分类</p>
<blockquote>
<p>非空约束，字段不能为null     关键字: NOT NULL<br>唯一约束 字段不能重复           UNIQUE<br>主键约束 主键是一行数据的唯一表示，要求非空且唯一 PRIMARY KEY<br>默认约束 使用默认值 DEFAULT<br>检查约束 保证字段值满足某一个条件 CHECK<br>外键约束 来让两整表之间建立练习，保证数据的一致性 FOREIGN KEY</p>
</blockquote>
<p>示例：</p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">create table user  
(  
    name   varchar(10) not null unique comment '姓名不为空且不能重复',  
    age    int check ( age &gt; 0 &amp;&amp; age &lt;= 120) comment '年龄检查为0-120',  
    status char(1) default '1' comment '状态默认为1',  
    gender char(1) comment '性别'  
) comment '用户表';
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>外键</p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">1.建表时
CREATE TABLE (
 ....
 ....
 CONSTRAINT 外键名称 FOREGIN KEY (外键字段名) REFERENCES 主表列名
)
2. ALTER TABLE 表 ADD CONSTRAINT 外键名(自定义) FOREIGN KEY (本表)字段名 REFERENCES 外表+(字段名)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>删除/更新</p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">ALTER TABLE 表 ADD CONSTRAINT 外键名(自定义) FOREIGN KEY (本表)字段名 REFERENCES 外表+(字段名) ON UPDATE 更新时的操作  ON DELETE 删除时要执行的操作
操作有
NO ACTION 在父表中删除/更新时，首先检查，该记录是否有外键，如果有则不允许更新或者删除
RESTRICT  同 NO ACTION 
CASCADE 可以删除/更新外键在子表中的记录
SET NULL 设置子表中的外键记录为NULL
SET DEFAULT 设置为一个默认值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h2><blockquote>
<p>多表关系：<br>一对多 多的一方建立外键指向一<br>多对多 建立第三张中间表，中间表至少包含两个外键，分别关联两方<br>一对一 任意一方加上外键并设置为UNIQUE</p>
</blockquote>
<h3 id="子查询："><a href="#子查询：" class="headerlink" title="子查询："></a>子查询：</h3><p>查询嵌套，括号内的查询结果作为括号外的条件 例子：</p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SELECT cust_id 
FROM Orders 
WHERE order_num IN (SELECT order_num 
 FROM OrderItems 
 WHERE prod_id = 'RGAN01');			<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>或者</p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SELECT cust_name, 
 cust_state, 
 (SELECT COUNT(*) 
 FROM Orders 
 WHERE Orders.cust_id = Customers.cust_id) AS orders 
FROM Customers 
ORDER BY cust_name;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>标量子查询<br>子查询返回单个值<br>列子查询，返回结果是一列或者多行<br>常用操作符号</p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">IN
NOT IN
ANY
SOME  和ANY相同
ALL <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>行子查询，返回一行或者是多列</p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">= &lt; &gt; IN NOT IN <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>表子查询<br>返回多行多列<br>常用IN 来进行查询</p>
<h2 id="联结表"><a href="#联结表" class="headerlink" title="联结表"></a>联结表</h2><ol>
<li>内联结</li>
</ol>
<p>比如</p>
<p>进行数据存储的时候，会指定一种联系方式</p>
<p>可以类比为散列表或者map</p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SELECT vend_name, prod_name, prod_price 
FROM Vendors, Products 
WHERE Vendors.vend_id = Products.vend_id;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>正式用法</p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SELECT vend_name, prod_name, prod_price 
FROM Vendors INNER JOIN Products 
 ON Vendors.vend_id = Products.vend_id;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>on之后的式匹配规则，同时为了防止冲突，尽量用点来获取每个不同的库的数据</p>
<p>联结多个表</p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SELECT prod_name, vend_name, prod_price, quantity 
FROM OrderItems, Products, Vendors 
WHERE Products.vend_id = Vendors.vend_id 
 AND OrderItems.prod_id = Products.prod_id 
 AND order_num = 20007;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>2.自联结</p>
<p><u>联结中仍然可以使用内聚函数</u></p>
<p>例如</p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SELECT Customers.cust_id, 
 COUNT(Orders.order_num) AS num_ord 
FROM Customers INNER JOIN Orders 
 ON Customers.cust_id = Orders.cust_id 
GROUP BY Customers.cust_id;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p>统一表内联结自己</p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SELECT c1.cust_id, c1.cust_name, c1.cust_contact 
FROM Customers AS c1, Customers AS c2 
WHERE c1.cust_name = c2.cust_name 
 AND c2.cust_contact = 'Jim Jones';<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>



<p>3.自然联结</p>
<blockquote>
<p>自然联结排除多次出现，使每一列只返回一次。</p>
</blockquote>
<blockquote>
<p>自然联结要求你只能选择那些唯一的列，一般通过对一个表使用通配符</p>
<p>（SELECT *），而对其他表的列使用明确的子集来完成。</p>
</blockquote>
<p>要自己完成，系统不提供</p>
<p>事实上，我们迄今为止建立的每个内联结都是自然联结，很可能永远都</p>
<p>不会用到不是自然联结的内联结。</p>
<p>4.外联结</p>
<blockquote>
<p>联结包含了那些在相关表中没有关联行的行。这种联结</p>
<p>称为外联结。</p>
</blockquote>
<p>语法：</p>
<p>內联结：</p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SELECT Customers.cust_id, Orders.order_num 
FROM Customers INNER JOIN Orders 
 ON Customers.cust_id = Orders.cust_id;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>外联结：<br>使用场景</p>
<ul>
<li><p><input disabled="" type="checkbox"> 
对每个顾客下的订单进行计数，包括那些至今尚未下订单的顾客；</p>
</li>
<li><p><input disabled="" type="checkbox"> 
列出所有产品以及订购数量，包括没有人订购的产品；</p>
</li>
<li><p><input disabled="" type="checkbox"> 
计算平均销售规模，包括那些至今尚未下订单的顾客。</p>
</li>
</ul>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SELECT Customers.cust_id, Orders.order_num 
FROM Customers LEFT OUTER JOIN Orders 
 ON Customers.cust_id = Orders.cust_id;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>在使用 OUTER </p>
<p>JOIN 语法时，必须使用 RIGHT 或 LEFT 关键字指定包括其所有行的表</p>
<p>（RIGHT 指出的是 OUTER JOIN 右边的表，而 LEFT 指出的是 OUTER JOIN</p>
<p>左边的表）。</p>
<p>也就是left 将要联结左侧的那个表全部选出</p>
<p>right 将右侧的那个表全选出</p>
</blockquote>
<p><strong>全外联结</strong></p>
<p><u><em>Access、MariaDB、MySQL、Open Office Base 和 SQLite 不支持 FULL</em></u></p>
<blockquote>
<p>还存在另一种外联结，就是全外联结（full outer join），它检索两个表中</p>
<p>的所有行并关联那些可以关联的行。与左外联结或右外联结包含一个表</p>
<p>的不关联的行不同，全外联结包含两个表的不关联的行。</p>
</blockquote>
<h2 id="联结使用条件"><a href="#联结使用条件" class="headerlink" title="联结使用条件"></a>联结使用条件</h2><blockquote>
<p><strong><u> 注意所使用的联结类型。一般我们使用内联结，但使用外联结也有效。</u></strong></p>
<p><u><strong> 关于确切的联结语法，应该查看具体的文档，看相应的 DBMS 支持何</strong></u><u><strong>种语法（大多数 DBMS 使用这两课中描述的某种语法）。</strong></u></p>
<p><u><strong> 保证使用正确的联结条件（不管采用哪种语法），否则会返回不正确</strong></u></p>
<p><u><strong>的数据。</strong></u></p>
<p><u><strong> 应该总是提供联结条件，否则会得出笛卡儿积。</strong></u></p>
<p><u><strong> 在一个联结中可以包含多个表，甚至可以对每个联结采用不同的联结</strong></u></p>
<p><u><strong>类型。虽然这样做是合法的，一般也很有用，但应该在一起测试它们</strong></u></p>
<p><strong><u><strong>前分别测试每个联结。这会使故障排除更为简单。</strong></u></strong> </p>
</blockquote>
<h3 id="join区别"><a href="#join区别" class="headerlink" title="join区别"></a>join区别</h3><p><strong>普通的join是笛卡尔积，即为两张表的排列组合</strong></p>
<p><img src="/2023/08/02/58/join.jpg"></p>
<h2 id="起别名"><a href="#起别名" class="headerlink" title="起别名"></a>起别名</h2><p>在使用时直接用AS +别名就可以用了 ^1cd456</p>
<p><strong>只能每次用的时候起一次别名并且当时使用</strong></p>
<p>下一个语句别名就不能用了，要重新起名字</p>
<h2 id="UNION"><a href="#UNION" class="headerlink" title=" UNION "></a><u> UNION </u></h2><p>语法：</p>
<p>适用于从多个不同的表中挑选不同的列</p>
<blockquote>
<p>UNION 中的每个查询必须包含相同的列、表达式或聚集函数（不过，</p>
<p>各个列不需要以相同的次序列出）</p>
</blockquote>
<blockquote>
<p>UNION 从查询结果集中自动去除了重复的行；换句话说，它的行为与一</p>
<p>条 SELECT 语句中使用多个 WHERE 子句条件一样。</p>
<p>这是 UNION 的默认行为，如果愿意也可以改变它。事实上，如果想返回</p>
<p>所有的匹配行，可使用 UNION ALL 而不是 UNION</p>
</blockquote>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SELECT cust_name, cust_contact, cust_email 
FROM Customers 
WHERE cust_state IN ('IL','IN','MI') 
UNION 
SELECT cust_name, cust_contact, cust_email 
FROM Customers 
WHERE cust_name = 'Fun4All';<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><blockquote>
<p>SELECT 语句的输出用 ORDER BY 子句排序。在用 UNION 组合查询时，只</p>
<p>能使用一条 ORDER BY 子句，它必须位于最后一条 SELECT 语句之后。对</p>
<p>于结果集，不存在用一种方式排序一部分，而又用另一种方式排序另一部分的情况，因此不允许使用多条 ORDER BY 子句</p>
<p>用它来排序所有 SELECT 语句返回的所有结果。</p>
</blockquote>
<h2 id="建表"><a href="#建表" class="headerlink" title="建表"></a>建表</h2><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">CREATE TABLE A
( 
 prod_id CHAR(10) NOT NULL, 
 vend_id CHAR(10) NOT NULL, 
 prod_name CHAR(254) NOT NULL, 
 prod_price DECIMAL(8,2) NOT NULL, 
 prod_desc VARCHAR(1000) NULL 
);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>要指定行列,并且后跟列的数据</p>
<p>类型</p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">CREATE TABLE Orders 
( 
 order_num INTEGER NOT NULL, 
 order_date DATETIME NOT NULL, 
 cust_id CHAR(10) NOT NULL 
);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>不要把 NULL 值与空字符串相混淆。NULL 值是没有值，不是空字符串。</p>
<p>如果指定’’（两个单引号，其间没有字符），这在 NOT NULL 列中是允</p>
<p>许的。空字符串是一个有效的值，它不是无值。NULL 值用关键字 NULL</p>
<p>而不是空字符串</p>
<p>默认值在 CREATE TABLE 语句的列定义中用关键字 DEFAULT 指定</p>
</blockquote>
<p>更新表定义，可以使用 ALTER TABLE 语句。</p>
<blockquote>
<p>使用 ALTER TABLE 更改表结构，必须给出下面的信息：</p>
<p> 在 ALTER TABLE 之后给出要更改的表名（该表必须存在，否则将</p>
<p>出错）；</p>
<p> 列出要做哪些更改</p>
</blockquote>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">ALTER TABLE Vendors 
ADD vend_phone CHAR(20);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<blockquote>
<p>更改或删除列、增加约束或增加键，这些操作也使用类似的语法（注意，</p>
<p>下面的例子并非对所有 DBMS 都有效）：</p>
<p>输入▼</p>
<p>ALTER TABLE Vendors </p>
<p>DROP COLUMN vend_phone; </p>
</blockquote>
<blockquote>
<p><u><em><strong>使用 ALTER TABLE 要极为小心，应该在进行改动前做完整的备份（表</strong></em></u></p>
<p><u><em><strong>结构和数据的备份）。数据库表的更改不能撤销，如果增加了不需要的</strong></em></u></p>
<p><u><em><strong>列，也许无法删除它们。类似地，如果删除了不应该删除的列，可能</strong></em></u></p>
<p><u><em><strong>会丢失该列中的所有数据。</strong></em></u></p>
</blockquote>
<p>删除表（删除整个表而不是其内容）非常简单，使用 DROP TABLE 语句即可：</p>
<p>DELETE  只删除表的内容不删除表本身</p>
<h2 id="重新命名"><a href="#重新命名" class="headerlink" title="重新命名"></a>重新命名</h2><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">ALTER TABLE oldname RENAME TO newname;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><blockquote>
<p><u><em><strong>视图为虚拟的表。它们包含的不是数据而是根据需要检索数据的查询。</strong></em></u></p>
<p><u><em><strong>视图提供了一种封装 SELECT 语句的层次，可用来简化数据处理，重新</strong></em></u></p>
<p><u><em><strong>格式化或保护基础数据。</strong></em></u></p>
</blockquote>
<p>用视图将联结集合起来，也就是一个子查询，相当于一个API</p>
<p>创建 视图用 CREATE VIEW 语句来创建。与 CREATE TABLE 一样，CREATE VIEW</p>
<p>删除 删除视图，可以使用 DROP 语句，其语法为 DROP VIEW viewname;。</p>
<p>覆盖（或更新）视图，必须先删除它，然后再重新创建。</p>
<p>用法：</p>
<p>建立视图</p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">CREATE VIEW ProductCustomers AS 
SELECT cust_name, cust_contact, prod_id 
FROM Customers, Orders, OrderItems 
WHERE Customers.cust_id = Orders.cust_id 
 AND OrderItems.order_num = Orders.order_num;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这条语句创建一个名为 ProductCustomers 的视图，它联结三个表，返</p>
<p>回已订购了任意产品的所有顾客的列表。</p>
<p>使用视图</p>
<p>使用时，</p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SELECT cust_name, cust_contact 
FROM ProductCustomers 
WHERE prod_id = 'RGAN01';<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>也可以用于统一格式</p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">CREATE VIEW VendorLocations AS 
SELECT RTRIM(vend_name) || ' (' || RTRIM(vend_country) || ')' 
 AS vend_title 
FROM Vendors;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>之后可用</p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SELECT * 
FROM VendorLocations;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>用于过滤也一样</p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">CREATE VIEW CustomerEMailList AS 
SELECT cust_id, cust_name, cust_email 
FROM Customers 
WHERE cust_email IS NOT NULL;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>之后</p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SELECT * 
FROM CustomerEMailList;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>计算字段</p>
<pre class="line-numbers language-none"><code class="language-none">CREATE VIEW OrderItemsExpanded AS 
SELECT order_num, 
 prod_id, 
 quantity,
 item_price, 
 quantity*item_price AS expanded_price 
FROM OrderItems;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>之后</p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SELECT * 
FROM OrderItemsExpanded 
WHERE order_num = 20008;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<h2 id="存储（不会）"><a href="#存储（不会）" class="headerlink" title="存储（不会）"></a>存储（<u><em><strong>不会</strong></em></u>）</h2><blockquote>
<p>可以创建存储过程。简单来说，存储过程就是为以后使用而保存的一条</p>
<p>或多条 SQL 语句。可将其视为批文件，虽然它们的作用不仅限于批处理</p>
<p> 通过把处理封装在一个易用的单元中，可以简化复杂的操作（如前面</p>
<p>例子所述）。</p>
<p> 由于不要求反复建立一系列处理步骤，因而保证了数据的一致性。如</p>
<p>果所有开发人员和应用程序都使用同一存储过程，则所使用的代码都</p>
<p>是相同的。</p>
</blockquote>
<blockquote>
<p>EXECUTE AddNewProduct( ‘JTS01’, </p>
<p>‘Stuffed Eiffel Tower’, </p>
<p>6.49, </p>
<p>‘Plush stuffed toy with the text La </p>
<p>➥Tour Eiffel in red white and blue’ ); </p>
</blockquote>
<h2 id="管理事务处理（不会深入学习的时候再看）"><a href="#管理事务处理（不会深入学习的时候再看）" class="headerlink" title="管理事务处理（不会深入学习的时候再看）"></a>管理事务处理（不会深入学习的时候再看）</h2><blockquote>
<p>使用事务处理（transaction processing），通过确保成批的 SQL 操作要么</p>
<p>完全执行，要么完全不执行，来维护数据库的完整性</p>
</blockquote>
<blockquote>
<p> 事务（transaction）指一组 SQL 语句；</p>
<p> 回退（rollback）指撤销指定 SQL 语句的过程；</p>
<p> 提交（commit）指将未存储的 SQL 语句结果写入数据库表；</p>
<p> 保留点（savepoint）指事务处理中设置的临时占位符（placeholder），</p>
<p>可以对它发布回退（与回退整个事务处理不同）。</p>
</blockquote>
<p><strong>事务处理用来管理 INSERT、UPDATE 和 DELETE 语句。不能回退 SELECT</strong></p>
<p><strong>语句（回退 SELECT 语句也没有必要），也不能回退 CREATE 或 DROP 操</strong></p>
<p><strong>作。事务处理中可以使用这些语句，但进行回退时，这些操作也不撤销。</strong></p>
<h2 id="游标"><a href="#游标" class="headerlink" title="游标"></a>游标</h2><blockquote>
<p>有时，需要在检索出来的行中前进或后退一行或多行，这就是游标的用</p>
<p>途所在。游标（cursor）是一个存储在 DBMS 服务器上的数据库查询，</p>
<p>它不是一条 SELECT 语句，而是被该语句检索出来的结果集。在存储了</p>
<p>游标之后，应用程序可以根据需要滚动或浏览其中的数据。</p>
</blockquote>
<p>游标的选项和特性</p>
<blockquote>
<p> 能够标记游标为只读，使数据能读取，但不能更新和删除。</p>
<p> 能控制可以执行的定向操作（向前、向后、第一、最后、绝对位置、</p>
<p>相对位置等）。</p>
<p> 能标记某些列为可编辑的，某些列为不可编辑的。</p>
<p> 规定范围，使游标对创建它的特定请求（如存储过程）或对所有请求</p>
<p>可访问。</p>
<p> 指示 DBMS 对检索出的数据（而不是指出表中活动数据）进行复制，</p>
<p>使数据在游标打开和访问期间不变化。</p>
</blockquote>
<p>游标使用</p>
<blockquote>
<p> 在使用游标前，必须声明（定义）它。这个过程实际上没有检索数据，</p>
<p>它只是定义要使用的 SELECT 语句和游标选项。</p>
<p> 一旦声明，就必须打开游标以供使用。这个过程用前面定义的 SELECT</p>
<p>语句把数据实际检索出来。</p>
<p> 对于填有数据的游标，根据需要取出（检索）各行。</p>
<p> 在结束游标使用时，必须关闭游标，可能的话，释放游标（有赖于具</p>
<p>体的 DBMS）。</p>
<p>声明游标后，可根据需要频繁地打开和关闭游标。在游标打开时，可根</p>
<p>据需要频繁地执行取操作。</p>
</blockquote>
<p>创建游标</p>
<blockquote>
<p>使用 DECLARE 语句创建游标，这条语句在不同的 DBMS 中有所不同。</p>
<p>DECLARE 命名游标，并定义相应的 SELECT 语句，根据需要带 WHERE 和</p>
<p>其他子句。为了说明，我们创建一个游标来检索没有电子邮件地址的所</p>
<p>有顾客，作为应用程序的组成部分，帮助操作人员找出空缺的电子邮件</p>
<p>地址</p>
</blockquote>
<p>语法</p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">DECLARE CustCursor CURSOR 
FOR 
SELECT * FROM Customers 
WHERE cust_email IS NULL<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>使用游标</p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">OPEN CURSOR CustCursor<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>关闭游标</p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">CLOSE CustCursor 
DEALLOCATE CURSOR CustCursor<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>



<h2 id="约束（不会捏）"><a href="#约束（不会捏）" class="headerlink" title="约束（不会捏）"></a>约束（不会捏）</h2><blockquote>
<p>DBMS 通过在数据库表上施加约束来实施引用完整性。大多数约束是在</p>
<p>表定义中定义的，如第 17 课所述，用 CREATE TABLE 或 ALTER TABLE</p>
<p>语句。</p>
</blockquote>
<p>主键</p>
<blockquote>
<p>我们在第 1 课简单提过主键。主键是一种特殊的约束，用来保证一列（或</p>
<p>一组列）中的值是唯一的，而且永不改动。换句话说，表中的一列（或</p>
<p>多个列）的值唯一标识表中的每一行。这方便了直接或交互地处理表中</p>
<p>的行。没有主键，要安全地 UPDATE 或 DELETE 特定行而不影响其他行会</p>
<p>非常困难。</p>
<p>表中任意列只要满足以下条件，都可以用于主键。</p>
<p> 任意两行的主键值都不相同。</p>
<p> 每行都具有一个主键值（即列中不允许 NULL 值）。</p>
<p> 包含主键值的列从不修改或更新。（大多数 DBMS 不允许这么做，但</p>
<p>如果你使用的 DBMS 允许这样做，好吧，千万别！）</p>
<p> 主键值不能重用。如果从表中删除某一行，其主键值不分配给新行。</p>
<p>一种定义主键的方法是创建它，如下所示</p>
</blockquote>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">CREATE TABLE Vendors 
( 
 vend_id CHAR(10) NOT NULL PRIMARY KEY, 
 vend_name CHAR(50) NOT NULL, 
 vend_address CHAR(50) NULL, 
 vend_city CHAR(50) NULL, 
 vend_state CHAR(5) NULL, 
 vend_zip CHAR(10) NULL, 
 vend_country CHAR(50) NULL 
);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在此例子中，给表的 vend_id 列定义添加关键字 PRIMARY KEY，使其成</p>
<p>为主键。</p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">ALTER TABLE Vendors 
ADD CONSTRAINT PRIMARY KEY (vend_id);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>



<p>这里定义相同的列为主键，但使用的是 CONSTRAINT 语法。此语法也可</p>
<p>以用于 CREATE TABLE 和 ALTER TABLE 语句</p>
<h3 id="外键"><a href="#外键" class="headerlink" title="外键"></a>外键</h3><p>外键是表中的一列，其值必须列在另一表的主键中。外键是保证引用完</p>
<p>整性的极其重要部分。我们举个例子来理解外键</p>
<blockquote>
<p>如第 6 课所述，除帮助保证引用完整性外，外键还有另一个重要作用。</p>
<p>在定义外键后，DBMS 不允许删除在另一个表中具有关联行的行。例</p>
<p>如，不能删除关联订单的顾客。删除该顾客的唯一方法是首先删除相</p>
<p>关的订单（这表示还要删除相关的订单项）。由于需要一系列的删除，</p>
<p>因而利用外键可以防止意外删除数据。</p>
<p>有的 DBMS 支持称为级联删除（cascading delete）的特性。如果启用，</p>
<p>该特性在从一个表中删除行时删除所有相关的数据。例如，如果启用</p>
<p>级联删除并且从 Customers 表中删除某个顾客，则任何关联的订单行</p>
<p>也会被自动删除。</p>
</blockquote>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">CREATE TABLE Orders 
( 
 order_num INTEGER NOT NULL PRIMARY KEY, 
 order_date DATETIME NOT NULL, 
cust_id CHAR(10) NOT NULL REFERENCES 
➥Customers(cust_id) 
);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">CREATE [ UNIQUE | FULLTEXT ] INDEX index_name ON table_name (inex_col_name,... ) ; UNIQUE 代表的是一个唯一的索引，不可重复
SHOW INDEX FROM table_name ;
iDROP INDEX index_name ON table_name ;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-none"><code class="language-none">
触发器

&gt; 触发器是特殊的存储过程，它在特定的数据库活动发生时自动执行。触发
&gt;
&gt; 器可以与特定表上的 INSERT、UPDATE 和 DELETE 操作（或组合）相关联。
&gt;
&gt; 与存储过程不一样（存储过程只是简单的存储 SQL 语句），触发器与单
&gt;
&gt; 个的表相关联。与 Orders 表上的 INSERT 操作相关联的触发器只在
&gt;
&gt; Orders 表中插入行时执行。类似地，Customers 表上的 INSERT 和
&gt;
&gt; UPDATE 操作的触发器只在表上出现这些操作时执行。

&gt; 触发器内的代码具有以下数据的访问权：
&gt;
&gt;  INSERT 操作中的所有新数据；
&gt;
&gt;  UPDATE 操作中的所有新数据和旧数据；
&gt;
&gt;  DELETE 操作中删除的数据。
&gt;
&gt; 根据所使用的 DBMS的不同，触发器可在特定操作执行之前或之后执行。
&gt;
&gt; 下面是触发器的一些常见用途。
&gt;
&gt;  保证数据一致。例如，在 INSERT 或 UPDATE 操作中将所有州名转换
&gt;
&gt; 为大写。
&gt;
&gt;  基于某个表的变动在其他表上执行活动。例如，每当更新或删除一行
&gt;
&gt; 时将审计跟踪记录写入某个日志表。

```mysql
CREATE TRIGGER customer_state 
ON Customers 
FOR INSERT, UPDATE 
AS 
UPDATE Customers 
SET cust_state = Upper(cust_state) 
WHERE Customers.cust_id = inserted.cust_id;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="case-来进行多条件判断-不要忘记END"><a href="#case-来进行多条件判断-不要忘记END" class="headerlink" title="case 来进行多条件判断 不要忘记END"></a>case 来进行多条件判断 不要忘记END</h2><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">CASE WHEN XXX条件 THEN 满足的结果 ELSE 不满足结果 END<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>多行耦合</p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">CASE WHEN XXX条件1 THEN Y1
	 WHEN XXX 条件2 THEN  Y2
	 WHEN XXX 条件3 THEN Y3 ELSE Y4 END 
	 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><blockquote>
<p>一组操作的集合，不可分割，这些操作要么同时成功，要么同时失败，mysql默认提交方式是自动提交的，所以要改为手动提交才行</p>
</blockquote>
<p>方式1</p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">select @@autocommit; 查看提交方式，返回为1则为自动提交，否则为手动提交
set @@autocommit = 0 ; 设置为手动提交

commit 提交

rollback 回滚
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>方式二<br>事务操作</p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">start transaction 或者 begin 开启事务
commit 提交
rollback 回滚 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>事务特点</p>
<ul>
<li><p><strong>原子性</strong> 一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。</p>
</li>
<li><p><strong>一致性</strong> 在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。</p>
</li>
<li><p><strong>隔离性</strong> 数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。</p>
</li>
<li><p><strong>持久性</strong> 事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</p>
</li>
</ul>
<h3 id="并发事务问题"><a href="#并发事务问题" class="headerlink" title="并发事务问题"></a>并发事务问题</h3><ul>
<li>脏读 一个事务读到另一个事务还没有提交的数据</li>
<li>不可重复读，一个事务先后读取一条重复记录，但两次读取的数据不同，成为不可重复读</li>
<li>幻读 一个事务按照条件查询时，没有对应的数据行但是在插入数据时，这行数据已经存在了，出现了幻影<br>事务隔离级别<br><img src="/2023/08/02/58/1.png"><br>可以手动设置系统的隔离级别</li>
</ul>
<h2 id="引擎"><a href="#引擎" class="headerlink" title="引擎"></a>引擎</h2><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">CREATE TABLE 表名(

字段1 字段1类型 [ COMMENT 字段1注释 ] ,

......

字段n 字段n类型 [COMMENT 字段n注释 ]

) ENGINE = INNODB [ COMMENT 表注释 ] ;
show engines;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>InnoDB特点<br>支持事务，行级锁，外键约束</p>
<h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><blockquote>
<p>全局锁：锁定数据库中的所有表。<br>表级锁：每次操作锁住整张表。<br>行级锁：每次操作锁住对应的行数据。</p>
</blockquote>
<h2 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h2><blockquote>
<p>　1）、length()：mysql里面的length()函数是一个用来获取字符串长度的内置函数。<br>　　2）、char_length()：在mysql内置函数里面查看字符串长度的还有一个函数是char_length()。<br>　　3）、这两个函数的区别是：<br>　　　　a）、length()： 单位是字节，utf8编码下,一个汉字三个字节，一个数字或字母一个字节。gbk编码下,一个汉字两个字节，一个数字或字母一个字节。<br>　　　　b）、char_length()：单位为字符，不管汉字还是数字或者是字母都算是一个字符。</p>
</blockquote>
<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">^：表示一个字符串或行的开头

[a-z]：表示一个字符范围，匹配从 a 到 z 的任何字符。

[0-9]：表示一个字符范围，匹配从 0 到 9 的任何字符。

[a-zA-Z]：这个变量匹配从 a 到 z 或 A 到 Z 的任何字符。请注意，你可以在方括号内指定的字符范围的数量没有限制，您可以添加想要匹配的其他字符或范围。

[^a-z]：这个变量匹配不在 a 到 z 范围内的任何字符。请注意，字符 ^ 用来否定字符范围，它在方括号内的含义与它的方括号外表示开始的含义不同。

[a-z]*：表示一个字符范围，匹配从 a 到 z 的任何字符 0 次或多次。

[a-z]+：表示一个字符范围，匹配从 a 到 z 的任何字符 1 次或多次。

.：匹配任意一个字符。

\.：表示句点字符。请注意，反斜杠用于转义句点字符，因为句点字符在正则表达式中具有特殊含义。还要注意，在许多语言中，你需要转义反斜杠本身，因此需要使用\\.。

$：表示一个字符串或行的结尾。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h2><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">//导包
import com.mysql.jdbc.Driver;  
  
import javax.swing.plaf.nimbus.State;  
import java.sql.*;  
public class Name {  
public static void main(String[] args) throws Exception {  
//注册驱动程序  
Class.forName("com.mysql.jdbc.Driver");  
//获取连接  
String url = "jdbc:mysql://localhost:3306/t";  
String username = "root";  
String password = "hutao1224";  
Connection conn = DriverManager.getConnection(url,username,password);  
//获取执行sql语句的对象  
String sql = "insert into employees (name)value ('Amy');";  
Statement stmt = conn.createStatement();  
//执行sql语句  
int count = stmt.executeUpdate(sql);  
//处理结果  
System.out.println(count);  
//释放资源  
stmt.close();  
conn.close();
}  
  
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>防止sql注入使用</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">
 <span class="token annotation punctuation">@Test</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testPreparedStatement</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span>  <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
    <span class="token comment">//2. 获取连接：如果连接的是本机mysql并且端口是默认的 3306 可以简化书写</span>
    <span class="token class-name">String</span> url <span class="token operator">=</span> <span class="token string">"jdbc:mysql:///db1?useSSL=false"</span><span class="token punctuation">;</span>
    <span class="token class-name">String</span> username <span class="token operator">=</span> <span class="token string">"root"</span><span class="token punctuation">;</span>
    <span class="token class-name">String</span> password <span class="token operator">=</span> <span class="token string">"1234"</span><span class="token punctuation">;</span>
    <span class="token class-name">Connection</span> conn <span class="token operator">=</span> <span class="token class-name">DriverManager</span><span class="token punctuation">.</span><span class="token function">getConnection</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span> username<span class="token punctuation">,</span> password<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 接收用户输入 用户名和密码</span>
    <span class="token class-name">String</span> name <span class="token operator">=</span> <span class="token string">"zhangsan"</span><span class="token punctuation">;</span>
    <span class="token class-name">String</span> pwd <span class="token operator">=</span> <span class="token string">"' or '1' = '1"</span><span class="token punctuation">;</span>

    <span class="token comment">// 定义sql</span>
    <span class="token class-name">String</span> sql <span class="token operator">=</span> <span class="token string">"select * from tb_user where username = ? and password = ?"</span><span class="token punctuation">;</span>
    <span class="token comment">// 获取pstmt对象</span>
    <span class="token class-name">PreparedStatement</span> pstmt <span class="token operator">=</span> conn<span class="token punctuation">.</span><span class="token function">prepareStatement</span><span class="token punctuation">(</span>sql<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 设置？的值</span>
    pstmt<span class="token punctuation">.</span><span class="token function">setString</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//?的位置和参数</span>
    pstmt<span class="token punctuation">.</span><span class="token function">setString</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span>pwd<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 执行sql</span>
    <span class="token class-name">ResultSet</span> rs <span class="token operator">=</span> pstmt<span class="token punctuation">.</span><span class="token function">executeQuery</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 不需要传递sql语句了</span>
    <span class="token comment">// 判断登录是否成功</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>rs<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"登录成功~"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"登录失败~"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//7. 释放资源</span>
    rs<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    pstmt<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    conn<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="变量的使用"><a href="#变量的使用" class="headerlink" title="变量的使用"></a>变量的使用</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">占位符？只能用来取代sql语句中的常变量，而不能取代列名或者表名
select <span class="token operator">?</span> from <span class="token operator">?</span> where  <span class="token operator">?</span>   前两个<span class="token operator">?</span>不成立，只能用 <span class="token string">"+variable+"</span> 的方式<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><h3 id="面试常问"><a href="#面试常问" class="headerlink" title="面试常问"></a>面试常问</h3><ul>
<li>一致性哈希：整个哈希值的空间被视为一个环形，每个节点或数据都被映射到整个环上，当需要查找某个键时，会沿着环查找第一个匹配的节点。</li>
<li>数据结构：<ul>
<li>SkipList跳表，ZSet中如果保存到键值对数量&lt;128 &amp;&amp; 每个元素的长度小于64B就使用ziplist，否则则使用skiplist<ul>
<li>数据按照升序排序存储</li>
<li>节点可能包含多个指针，指针跨度不同</li>
</ul>
</li>
<li>SortedSet是有序集合，底层存储的每个数据都包含element和score两个值，score是得分，element是字符串值，会根据element和score值排序，形成有序集合，基于SkipList实现的</li>
<li>Redis如何判断KEY是否过期呢？<ul>
<li><strong>答</strong>：在Redis中会有两个Dict，也就是HashTable，其中一个记录KEY-VALUE键值对，另一个记录KEY和过期时间。要判断一个KEY是否过期，只需要到记录过期时间的Dict中根据KEY查询即可。</li>
</ul>
</li>
</ul>
</li>
<li>集群问题：<ol>
<li>Sentinel是哨兵：监控节点状态并自动实现故障转移 <img src="/2023/08/02/58/%E5%93%A8%E5%85%B5%E5%8E%9F%E7%90%86.png" alt="|400"><ul>
<li>哨兵的作用：状态监控，故障转移，状态通知</li>
<li>主观下线是某一个sentinel节点发现某个节点没在规定时间内响应，客观下线是指的是有一半以上的sentinel都认为下线了才行</li>
<li>选举新的master: </li>
<li>选举规则：判断优先级，判断offset值，越高越优先，判断id，越小越优先<ol>
<li>故障检测：sentinel检测主节点和从节点的在线情况，如果有半数以上的sentinel认为主节点故障，就会开始选举</li>
<li>sentinel选举出一个leader节点，每个sentinel都有资格，sentinel确定master下线之后就会请求其他sentinel同意自己成为leader，票数大于一半的sentinel即可成为leader,如果没有选出，就重复直到选出</li>
<li>选举根据 数据复制的偏移量更大(数据最新)，运行id更小(运行时间更长 )，节点的优先级进行选举</li>
<li>通知所有的从节点设置新的主节点，并且进行复制</li>
<li>通知客户端重新连接主节点</li>
</ol>
</li>
<li>主从复制：<ul>
<li>全量同步，当slave第一次连接到master或者slave断开太久了，repl_baklog(复制积压缓冲区)的offset已经被覆盖了，同步过程中收到的读写命令都会先执行然后记录在repl_baklog中，逐个发送给slave <img src="/2023/08/02/58/%E5%85%A8%E9%87%8F%E5%90%8C%E6%AD%A5.png" alt="|550"><ol>
<li>从节点保存主节点信息，与主节点建立连接，主节点判断是否是第一次请求，是就与从节点同步版本信息</li>
<li>主节点fork一个子进程保存当前所有的数据，2.发送数据快照3.之后主节点每次执行其他的操作都会同步给从节点<ul>
<li><p>**<code>Replication Id</code>**：简称<code>replid</code>，是数据集的标记，replid一致则是同一数据集。每个<code>master</code>都有唯一的<code>replid</code>，<code>slave</code>则会继承<code>master</code>节点的<code>replid</code></p>
</li>
<li><p>**<code>offset</code>**：偏移量，随着记录在<code>repl_baklog</code>中的数据增多而逐渐增大。<code>slave</code>完成同步时也会记录当前同步的<code>offset</code>。如果<code>slave</code>的<code>offset</code>小于<code>master</code>的<code>offset</code>，说明<code>slave</code>数据落后于<code>master</code>，需要更新。</p>
</li>
</ul>
</li>
</ol>
</li>
<li>增量同步：<img src="/2023/08/02/58/%E5%A2%9E%E9%87%8F%E5%90%8C%E6%AD%A5.png" alt="|750"><ul>
<li>根据offset来进行同步</li>
<li>具体的比较是通过<code>repl_baklog</code>，记录Redis处理过的命令及<code>offset</code>，包括master当前的<code>offset</code>，和slave已经拷贝到的<code>offset</code>发送的是命令： <img src="/2023/08/02/58/%E7%8E%AF%E5%BD%A2%E6%95%B0%E7%BB%84.png"></li>
</ul>
</li>
</ul>
</li>
<li>防止脑裂问题：设置主节点最少需要的从节点数，小于这个数量主节点就会禁止写数据，设置主从复制和同步的最大延迟，如果时间超过这个延迟就会禁止写数据。同时可以用主观下线和客观下线，当出现网络分区时，有部分的节点仍然能够连接上主节点，于是就不会出现重新选举主节点。</li>
<li>offset复制偏移量：主从各自维护自己的offset，子节点把自己的offset上报，master保存offset ，部分复制使用二者的偏移量来同步缺失的数据</li>
</ul>
</li>
<li>分片集群：<img src="/2023/08/02/58/%E5%88%86%E7%89%87%E9%9B%86%E7%BE%A4.png"><ul>
<li>每个master保存不同的数据，然后每个master都可以有多个slave节点，之后master之间通过ping来检测彼此之间的健康状态，客户端请求可以访问集群任意节点，最终都会被转发到数据所在的节点</li>
<li>故障转移：每个master转移到自己的slave即可</li>
<li>为什么插槽的数量是16384,16384是2的14次方，是一个平衡性、行呢个和兼容性之间取得折衷的结果</li>
<li>如何将同一类数据固定的保存在同一个Redis实例？<ul>
<li>Redis计算key的插槽值时会判断key中是否包含<code>{}</code>，如果有则基于<code>{}</code>内的字符计算插槽</li>
<li>所以只要用{key} 作为前缀即可把相同的类型的数据计算的插槽一定相同</li>
</ul>
</li>
</ul>
</li>
<li>常见的缓存有几种：<ul>
<li>旁路缓存：使用应用程序来保证缓存和数据库的一致性<ol>
<li>先写DB然后直接删除cache<ul>
<li>为何删除？ 1.如果db频繁更改，导致cache中的数据很少被访问，删除可以节省服务端的资源 2. 更新cache更容易造成缓存不一致的现象</li>
<li>为何不能先删除cache? 因为 如果有两个请求同时访问，请求1先把cache中的数据删除了，请求二就会从db中读取数据，然后请求一再更改db，会导致请求2读到的是旧值</li>
<li>写cache的速度要比写db快很多，所以很少会造成不一致</li>
</ul>
</li>
<li>从cache中读取数据，读不到再从db中读入并返回，然后放到cache中</li>
<li>缺点：<ul>
<li>首次请求不在cache中：可以将热点数据提前放入</li>
</ul>
</li>
</ol>
</li>
<li>读写穿透：以cache为主，让cache服务操作，不需要<ul>
<li>写:先写cache,cache没有时直接写db,有的话先更新cache,之后更新db 同步更新</li>
<li>读：直接读cache,cache没有直接读db，然后放入cache.</li>
</ul>
</li>
<li>异步缓存写入：也是由cache服务来处理,但是更新时，只更新cache,由异步处理来更新db<ul>
<li>缺点：容易造成数据不一致</li>
<li>适合对数据一致性要求没那么 高的</li>
</ul>
</li>
</ul>
</li>
<li>Redis单线程模型：Redis对于每一个客户端的连接都关联一个指令队列和响应队列<ul>
<li>为何单线程性能还这么高？ <ol>
<li>使用纯内存访问，</li>
<li>单线程避免不必要的上下文切换和竞争</li>
<li>IO多路复用，对于多个IO，Redis每次处理其中一个IO然后暂停对其他的IO事件。使用一个线程来监听多个socket某个socket可读时及逆行读写<ul>
<li>实现：select(文件描述符有上限)，poll这俩只会通知用户有有Socket就绪，不确定具体的是哪个，需要轮询来找</li>
<li>epoll会通知用户的时候把哪个socket也直接写入用户空间 </li>
<li>详细介绍一下为什么I/O复用</li>
</ul>
<ol start="2">
<li>Redis是纯内存的，所以性能取决于网络延迟，I/O多路复用实现了高效的网络请求<ol>
<li>常见的IO有 阻塞，非阻塞，多路复用</li>
<li>非阻塞式IO，读到多少就都多少，写多少，不会等待满足字节要求</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>优点：避免了线程切换的消耗。</li>
</ul>
</li>
</ol>
<ul>
<li>主从复制： 主服务器执行写操作时，会将写操作同步给从服务器，从服务器只读，并执行主服务器同步过来的指令 缺点：主服务器宕机时必须手动恢复</li>
<li>哨兵模式： 监控主从服务器，提供主从节点故障转移的功能</li>
<li>切片集群：将数据分布在不同的服务器上，以此来降低系统对单主节点的依赖，从而提高 Redis 服务的读写性能。</li>
<li>脑裂问题： 由于网络问题，集群节点之间失去联系。主从数据不同步；重新平衡选举，产生两个主服务。等网络恢复，旧主节点会降级为从节点，再与新主节点进行同步复制的时候，由于会从节点会清空自己的缓冲区，所以导致之前客户端写入的数据丢失了。 解决： 当主节点发现从节点下线或者通信超时的总数量大于阈值时，那么禁止主节点进行写数据，直接把错误返回给客户端。</li>
</ul>
</li>
<li>数据相关：<ul>
<li>数据淘汰策略：<ul>
<li>如何保证Redis中的数据是热点数据？ 答案是可以使用LRU删除策略，每次删除数据时删除最近最少使用的键，同时也可以主动去更新热点数据</li>
<li>其余的各种内存淘汰机制：1.内存到达限制时返回错误，不删除，2.删除最近最少使用键，3.lru但是只删除设置了过期时间的键，4.随机删除一些 5. 随机删除一些设置了过期时间的键6. 对访问频率来进行删除<img src="/2023/08/02/58/redis%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5.png"></li>
</ul>
</li>
<li>持久化：<ul>
<li>RDB：创建数据的快照，存的是实际的数据<ul>
<li>redis建立新的子进程，父进程继续处理请求，子进程负责将内存内容写到临时文件，os的实时复写copy-on-write会使得父进程和子进程共享一个物理页面，所以会为父进程要修改的页面创建副本，所以子进程内的数据就是fork时的快照。 子进程写完文件之后，使用临时文件代替原来的快照文件，之后子进程quit, <strong>进行的是全量快照，会把整个数据全部保存</strong></li>
</ul>
</li>
<li>AOF：<ul>
<li>重写：AOF重写会调用一个子进程，由子进程去进行重写，会读取数据库中的键值对为每一个键值对生成一个或多个写命令，这些写命令足以恢复这个键值对的状态。然后把他们写入一个新的AOF文件中，同时Redis会维护一个AOF缓冲区，把重写期间进行的数据库写操作记录到缓冲区中，重写完毕之后会把新的AOF文件发给主进程，然后退出，主进程把缓冲区中的写命令写入其中并使用新的AOF文件替换旧的AOF文件</li>
</ul>
</li>
</ul>
</li>
<li>注意：实现原理是操作系统会为进程<ul>
<li>AOF：记录操作命令而不是副本。<ol>
<li>fork,子进程向临时文件中写入重建数据库状态的命令</li>
<li>父进程接收到请求后，把写命令写入到原来的aof文件中，然后缓存起来这些命令</li>
<li>子进程搞完之后，通知父进程，父进程把缓存起来的命令写入临时文件</li>
<li>使用临时文件替代老文件,注意不会读取老文件</li>
</ol>
</li>
<li>混合持久化：两者结合，惰性删除：只有在访问这个键的时候才检查是否过期</li>
</ul>
<ol>
<li>读写分离问题：读占比较大时可以把一部分的流量摊到从节点，只对主节点进行写服务。</li>
</ol>
</li>
<li>过期策略：惰性删除和定时删除，Redis使用了两种结合的方式：当某个key被访问时，会定期检查是否过期，如果过期就删除，同时会定期对一部分key进行检查，如果过期就删除<ul>
<li>周期删除的模式：<ol>
<li>SLOW模式：通过定时任务定期抽样部分带有TTL的key，判断是否过期。如果过期key比例较高会多次抽象</li>
<li>FAST模式：Redis每次处理NIO事件之前，都会抽样部分带有TTL的key，判断是否过程，因此频率较高。如果时间充足并且过期key比例过高，也会多次抽样。</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="缓存问题"><a href="#缓存问题" class="headerlink" title="缓存问题"></a>缓存问题</h2><ul>
<li><strong>缓存问题</strong>:<ul>
<li>缓存雪崩：<strong>大量缓存</strong> 在同一时间失效或者Redis宕机导致后面的请求都直接落到了db<ul>
<li>修改key的TTL，设置随机TTL<ol>
<li>将缓存失效时间打散，在失效时间基础上加一个随机值</li>
<li>设置缓存不过期</li>
</ol>
</li>
<li>搭建Redis的集群，哨兵模式，集群模式<ul>
<li>给业务限流，nginx和spring cloud gateway</li>
</ul>
</li>
<li>使用多级缓存，Guava和Caffeine + Redis， 前面这俩是缓存在服务中的JVM中的，分布式项目中不能跨服务，但是请求速度是最快的，因为是本地的缓存</li>
<li>给缓存业务添加降级限流策略</li>
</ul>
</li>
<li><strong>缓存击穿</strong>：热点key过期，大量的请求直接给数据库压力<ul>
<li>互斥锁方案，保证同一时间只能有一个业务线程请求业务缓存</li>
<li>不给热点数据设置过期时间，由异步更新缓存，或者在热点数据要过期的时候，提前通知前台线程更新缓存或者重新设置过期时间，保证高可用，数据不会是绝对一致的</li>
</ul>
</li>
<li>缓存穿透：访问的数据不在缓存中，每次都直接查询数据库，给数据库很大压力 ，解决方案是使用布隆过滤器<ul>
<li>非法请求的限制，当有大量恶意请求访问不存在的数据时，在API入口要判断请求参数是否合理</li>
<li>设置空值或者默认值</li>
<li>使用<strong>布隆过滤器快速判断数据是否存在，避免通过查询数据库来判断数据是否存在</strong>：</li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/94433082">布隆过滤器</a>对一个数据用多个哈希函数来映射，当查询时，如果多个哈希函数的映射后任何一个索引都为0，则一定不存在，如果所有的映射后的位置都是1时，则可能存在集合中。使用的是位图<img src="/2023/08/02/58/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8.png"></li>
</ul>
</li>
<li>数据一致性<ul>
<li><strong>双写一致问题：</strong><ul>
<li>保证一致性<br>  1. 写使用的<strong>延迟双删</strong>，删两次缓存，等数据库修改完之后再删除一次缓存，用于解决数据库主从一致性问题，与缓存同步为u管。<br>  2. Cache Aside 旁路缓存策略<br>      - 写策略：先更新数据库再删除缓存中的数据<br>      - 读策略：如果命中了缓存，直接返回，否则从数据库中读入数据并写入缓存，返回给用户<br>  3. Read/Write Through 读穿/写穿策略: 应用程序只与缓存交互，由缓存组件和数据库交互，<br>      - 读为名周直接查数据库然后写入缓存<br>      - 写未命中，缓存存在直接写缓存，然后由缓存组件去更新数据库。缓存不存在则直接更新数据库<br>  4. Write Back（写回）策略<ul>
<li>使用读锁(共享锁)和写锁(排他锁)</li>
</ul>
</li>
<li>允许短暂不一致：<ul>
<li>使用消息队列，先修改数据库，数据库修改完之后向MQ发送消息，由cahe服务接受消息来对缓存进行更新</li>
<li>取决于mq的可靠性</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>延时队列： 把当前要做的事情推迟一段时间再做，如下单未付款取消<ul>
<li>可以使用 Zset来纯理，Score属性来存储延迟执行的时间</li>
<li>zadd score1 value1;</li>
<li>大key  value的值很大</li>
</ul>
</li>
<li>分布式问题：<ol>
<li>分布式锁：setnx 实际使用应该使用 set key value nx ex time 因为这个可以直接在原子性指定时间</li>
<li>Reddsion来续锁：使用lua脚本，来保证原子性<ol>
<li>一个线程获得锁，然后在事务中调用了另一个事务，另一个事务也同样对相同的锁加锁，会发生什么？<ul>
<li>如果是直接使用Redis，会阻塞，然后等锁过期后，被调用的函数可以执行，被调用的函数执行之后会释放锁，返回到第一个函数执行，第一个函数执行之后就会重复释放这个锁，无法保证原子性了。</li>
<li>如果使用Redssion，Redssion的RLock数据结构实现了可重入锁：<ul>
<li>key，status持有还是释放 ，UUID标识线程 ， 持有时间(最长的存活时间)</li>
<li>Redis中存的value字段为锁的次数</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
</ul>
<pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">{</span>
  <span class="token property">"myLock"</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token property">"status"</span><span class="token operator">:</span> <span class="token string">"LOCKED"</span><span class="token punctuation">,</span>
    <span class="token property">"owner"</span><span class="token operator">:</span> <span class="token string">"some-unique-uuid"</span><span class="token punctuation">,</span>
    <span class="token property">"hold_count"</span><span class="token operator">:</span> <span class="token number">2</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>			<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre><code>        - 这个问题中就会直接判断出是同一个线程的调用，所以只会给锁的持有技术+1，不会阻塞
</code></pre>
<ul>
<li><p>multi开始事务，discard取消事务redis的事务在出错时，只会回滚出错的命令</p>
</li>
<li><p>使用watch key 来对某一个key加上乐观锁</p>
</li>
<li><p>Redis 与 Memcached&nbsp;<strong>区别</strong>：</p>
<ol>
<li>Redis支持的数据类型更丰富：Sting Hash List Set Zset， M只支持key-value数据类型</li>
<li>Redis支持数据的持久化，可以将内存中的数据保存在磁盘中。</li>
<li>Redis原生支持集群模式</li>
<li>Redis支持发布订阅模型，LUa吉奥本，事务等</li>
</ol>
</li>
<li><p>数据类型</p>
<ul>
<li>String 类型的应用场景：SDS，可以存任何类型，直接存在二进制buf数组里</li>
<li>List 实现是：</li>
<li>Hash 类型：缓存对象、购物车等。</li>
<li>Set 类型：聚合计算（并集、交集、差集）场景，比如点赞、共同关注、抽奖活动等。</li>
<li>Zset 类型：排序场景，比如排行榜、电话和姓名排序等。</li>
<li>BitMap（2.2 版新增）：二值状态统计的场景，比如签到、判断用户登陆状态、连续签到用户总数等；</li>
<li>HyperLogLog（2.8 版新增）：海量数据基数统计的场景，比如百万级网页 UV 计数等；</li>
<li>GEO（3.2 版新增）：存储地理位置信息的场景，比如滴滴叫车；</li>
<li>Stream（5.0 版新增）：消息队列，相比于基于 List 类型实现的消息队列，有这两个特有的特性：自动生成全局唯一消息ID，支持以消费组形式消费数据。</li>
</ul>
</li>
<li><h3 id="Redis在执行命令的时候是单线程，但是也使用了多线程的来处理网络IO操作"><a href="#Redis在执行命令的时候是单线程，但是也使用了多线程的来处理网络IO操作" class="headerlink" title="Redis在执行命令的时候是单线程，但是也使用了多线程的来处理网络IO操作"></a>Redis在执行命令的时候是单线程，但是也使用了多线程的来处理网络IO操作</h3><ul>
<li>不是，Redis会启动后台： 三个线程各自有自己的任务队列,<ol>
<li>处理关闭文件</li>
<li>处理AOF刷盘</li>
<li>异步释放Redis内存，也就是lazyfree线程</li>
<li>主线程，负责执行命令</li>
<li>三个I/O线程来分担网络I/O压力</li>
</ol>
</li>
<li>这些任务的操作都是很耗时的，如果把这些任务都放在主线程来处理，那么 Redis 主线程就很容易发生阻塞，这样就无法处理后续的请求了。</li>
</ul>
</li>
<li><p>过期删除和内存淘汰： Redis使用懒惰性删除和定期删除。 惰性删除时指不主动删除过期键，每次反问key时检查是否过期，如果过期，则删除。 优点是：减少对系统资源的使用，缺点是：不能及时释放内存</p>
<ul>
<li>定期删除：每过一段时间，从数据库中取出一定数量的key来进行检查，删除其中的过期key，如果过期key超过一定比例，重复执行定期删除</li>
<li>当 Redis 运行在主从模式下时，<strong>从库不会进行过期扫描，从库对过期的处理是被动的</strong>。也就是即使从库中的 key 过期了，如果有客户端访问从库时，依然可以得到 key 对应的值，像未过期的键值对一样返回。</li>
<li>从库的过期键处理依靠主服务器控制，<strong>主库在 key 到期时，会在 AOF 文件里增加一条 del 指令，同步到所有的从库</strong>，从库通过执行这条 del 指令来删除过期的 key。REmote DIctionary Server(Redis) 是一个由 Salvatore Sanfilippo 写的 key-value 存储系统，是跨平台的非关系型数据库，非关系型数据库，</li>
</ul>
</li>
<li><p>内存淘汰： 随机淘汰，LRU最近最少使用，根据最后一次访问的时间 , LFU最近最不常使用，根据访问次数来淘汰</p>
</li>
<li><p>Lua :Redis 在执行 Lua 脚本时，可以以原子性的方式执行</p>
</li>
<li><p>Lua脚本使用</p>
<ol>
<li>EVAL执行脚本<code> EVAL script numkeys key [key …] arg [arg …]</code></li>
<li>SCRIPT LOAD script.lua 把脚本加载到redis-serve中，返会一个&nbsp;SHA1校验和，之后无论是哪个客户端都可以使用这个校验和来运行脚本。</li>
<li>EVALSHA sha1校验和  numkeys key [key …] arg [arg …]</li>
<li>SCRIPT EXISTS sha1来检验这个脚本是否还在</li>
<li>SCRIPT FLUSH刷新所有已经保存的脚本</li>
<li>redis-cli -a 密码 –eval lua脚本内容</li>
</ol>
</li>
<li><p>对于基本数据类型的操作</p>
<ol>
<li>string <ul>
<li>redis中的string可以包含任何数据，包括jpg和序列化的对象，因为string是byte [] 数组</li>
<li>setrange key number string 从number开始的下标处替换string,从0开始</li>
<li>mset 设置多个</li>
<li>xxnx not exit 不存在的话在设置</li>
<li>getrange key begin end</li>
<li>incryby key 增量 修改数据</li>
<li>append key 加</li>
<li>strlen 获取长度</li>
</ul>
</li>
<li>hash: string类型的 field 和 value的映射表,占用内存更少，方便取整个对象<ul>
<li>hset/hsetnx key field1 value1</li>
<li>hmget 获取多个fields</li>
<li>hexists key field 测试field是否存在</li>
<li>hlen key 有多少field</li>
<li>hkeys key 获取所有的field</li>
<li>hvals 获取所有的value</li>
<li>hgetall == hvals + hkeys</li>
</ul>
</li>
<li>list 底层是链表，可当作queue使用，有序，可重复，key为链表的名字<ul>
<li>lpush 头部添加 rpush尾部添加,linsert key</li>
<li>lset 重新设定指定位置的数据 </li>
<li>lrem key count value 从头开始删除count个和value一样值的数据， count &gt; 0 从头开始,count &lt; 0从尾部开始，count == 0 删除所有的</li>
<li>ltrim 只保留给定范围的数据</li>
<li>lpop/rpop</li>
<li>rpoplpush key1 key2 将key1的尾部移除并加入key2的头部，原子操作</li>
<li>lindex下标访问</li>
<li>llen获取长度</li>
</ul>
</li>
<li>set<ul>
<li>便于求集合的交并差,无序集合，不可重复</li>
<li>sadd key value</li>
<li>srem key value</li>
<li>spop key 随机删除并返回一个元素</li>
<li>sdiff 求交集 一个key1 多个key2 , key3，也就是在其他key中与其他key不同元素</li>
<li>sdiffstore 将diff的结果保存到另一个key中</li>
<li>sinter(store) 交集(存储)</li>
<li>sunion(store) 并集</li>
<li>smove 将key1 中的删除添加给第二个</li>
<li>scard 统计元素个数</li>
<li>sismember测试是否为key的元素</li>
<li>srandmember随机返回不删除</li>
</ul>
</li>
<li>sorted sets<ul>
<li>有序，不可重复，会关联一个double类型score来进行排序,是skip list 和 hash table的混合，score越小的越在前面</li>
<li>zadd key score value</li>
<li>zrem</li>
<li>zincrby key score value 给这个元素的score添加</li>
<li>zrank 按照从小到大排序返回某个member的排名</li>
<li>zrerank反向排序</li>
<li>zcount 返回给定区间score内的数量</li>
<li>zcarf 返回元素数量</li>
<li>zscore 返回score</li>
</ul>
</li>
</ol>
<ul>
<li>常用指令：keys ， del , expire,move转移把当前数据库中的数据转移到其他数据中,persist移除给定key的过期时间，randomkey随机返回一个key,rename,type</li>
<li>ping,echo,select(0~15),dbsize返回当前数据库中所有的key数量,info获取服务器统计信息</li>
<li>monitor实时转存收到的请求</li>
<li>flushdb删除所选择的数据库的所有key</li>
<li>fushall 删除所有数据库的所有key</li>
</ul>
</li>
</ul>
<h3 id="Redis-脚本命令"><a href="#Redis-脚本命令" class="headerlink" title="Redis 脚本命令"></a>Redis 脚本命令</h3><h3 id="dockercompose快速搭建一主二从一哨兵的redis集群"><a href="#dockercompose快速搭建一主二从一哨兵的redis集群" class="headerlink" title="dockercompose快速搭建一主二从一哨兵的redis集群"></a>dockercompose快速搭建一主二从一哨兵的redis集群</h3><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token property">version</span><span class="token punctuation">:</span> <span class="token string">'3'</span>
<span class="token property">services</span><span class="token punctuation">:</span>
  <span class="token property">redis-master</span><span class="token punctuation">:</span> # 主节点
    <span class="token property">image</span><span class="token punctuation">:</span> <span class="token property">redis</span><span class="token punctuation">:</span>latest
    <span class="token property">command</span><span class="token punctuation">:</span> redis-server --appendonly yes --requirepass bronya # 设置密码
    <span class="token property">volumes</span><span class="token punctuation">:</span>
      - ./data/<span class="token property">master</span><span class="token punctuation">:</span>/data
    <span class="token property">ports</span><span class="token punctuation">:</span>
      - <span class="token string">"6379:6379"</span>
    <span class="token property">networks</span><span class="token punctuation">:</span>
      - redis-network

  <span class="token property">redis-slave1</span><span class="token punctuation">:</span>
    <span class="token property">image</span><span class="token punctuation">:</span> <span class="token property">redis</span><span class="token punctuation">:</span>latest
    <span class="token property">command</span><span class="token punctuation">:</span> redis-server --slaveof redis-master 6379 --appendonly yes --masterauth bronya
    <span class="token property">depends_on</span><span class="token punctuation">:</span>
      - redis-master
    <span class="token property">volumes</span><span class="token punctuation">:</span>
      - ./data/<span class="token property">slave1</span><span class="token punctuation">:</span>/data
    <span class="token property">networks</span><span class="token punctuation">:</span>
      - redis-network

  <span class="token property">redis-slave2</span><span class="token punctuation">:</span>
    <span class="token property">image</span><span class="token punctuation">:</span> <span class="token property">redis</span><span class="token punctuation">:</span>latest
    <span class="token property">command</span><span class="token punctuation">:</span> redis-server --slaveof redis-master 6379 --appendonly yes --masterauth bronya
    <span class="token property">depends_on</span><span class="token punctuation">:</span>
      - redis-master
    <span class="token property">volumes</span><span class="token punctuation">:</span>
      - ./data/<span class="token property">slave2</span><span class="token punctuation">:</span>/data
    <span class="token property">networks</span><span class="token punctuation">:</span>
      - redis-network

  <span class="token property">redis-sentinel</span><span class="token punctuation">:</span>
    <span class="token property">image</span><span class="token punctuation">:</span> <span class="token property">redis</span><span class="token punctuation">:</span>latest
    <span class="token property">command</span><span class="token punctuation">:</span> redis-sentinel /etc/redis/sentinel.conf
    <span class="token property">depends_on</span><span class="token punctuation">:</span>
      - redis-master
    <span class="token property">volumes</span><span class="token punctuation">:</span>
      - ./sentinel.<span class="token property">conf</span><span class="token punctuation">:</span>/etc/redis/sentinel.conf
    <span class="token property">networks</span><span class="token punctuation">:</span>
      - redis-network

<span class="token property">networks</span><span class="token punctuation">:</span>
  <span class="token property">redis-network</span><span class="token punctuation">:</span>
    <span class="token property">driver</span><span class="token punctuation">:</span> bridge<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>下表列出了 redis 脚本常用命令：</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>命令及描述</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td><a target="_blank" rel="noopener" href="https://www.runoob.com/redis/scripting-eval.html">EVAL script numkeys key [key …] arg [arg …]</a>  <br>执行 Lua 脚本。</td>
</tr>
<tr>
<td>2</td>
<td><a target="_blank" rel="noopener" href="https://www.runoob.com/redis/scripting-evalsha.html">EVALSHA sha1 numkeys key [key …] arg [arg …]</a>  <br>执行 Lua 脚本。</td>
</tr>
<tr>
<td>3</td>
<td><a target="_blank" rel="noopener" href="https://www.runoob.com/redis/scripting-script-exists.html">SCRIPT EXISTS script [script …]</a>  <br>查看指定的脚本是否已经被保存在缓存当中。</td>
</tr>
<tr>
<td>4</td>
<td><a target="_blank" rel="noopener" href="https://www.runoob.com/redis/scripting-script-flush.html">SCRIPT FLUSH</a>  <br>从脚本缓存中移除所有脚本。</td>
</tr>
<tr>
<td>5</td>
<td><a target="_blank" rel="noopener" href="https://www.runoob.com/redis/scripting-script-kill.html">SCRIPT KILL</a>  <br>杀死当前正在运行的 Lua 脚本。</td>
</tr>
<tr>
<td>6</td>
<td><a target="_blank" rel="noopener" href="https://www.runoob.com/redis/scripting-script-load.html">SCRIPT LOAD script</a>  <br>将脚本 script 添加到脚本缓存中，但并不立即执行这个脚本。</td>
</tr>
</tbody></table>
<ul>
<li>选择数据库和登录<br>如果你想在Redis服务器启动时指定要使用的数据库和密码，可以通过命令行参数进行设置，例如：</li>
</ul>
<p><code>redis-server --port 6379 --requirepass your_password --db 3</code><br>redis默认有0-15个数据库，直接选择即可</p>
<p>info 来获得服务器和数据库信息</p>
<h2 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h2><p>是一种源代码可用的文档数据库，以序列化的 JSON 格式存储数据。MongoDB 将数据存储在外部存储器中，但在企业版中包含内存存储引擎。<br>常用于应对高并发、海量数据存储、数据库的高可扩展性<br>例如：社交场景保存用户信息，通过地理位置索引来实现附近的人<br>游戏场景存储用户信息，方便高效<br>日志</p>
<h4 id="基本概念："><a href="#基本概念：" class="headerlink" title="基本概念："></a>基本概念：</h4><ol>
<li>文档：数据存储的基本单位</li>
<li>索引：<ul>
<li>单字段索引：索引建立的顺序无所谓，MongoDB会可以从头/尾开始遍历</li>
<li>复合索引：建立在多个字段之上的索引,顺序很重要</li>
<li>多键索引：如果一个字段是数组，对数组建立的索引就是多键索引，相当于会对数组的每个值都建立单字段索引，举例：给Tags建立索引，搜索时只需要tags数组即可筛选出带有tags的所有文档</li>
<li>哈希索引：按照数据的哈希值进行索引，用在哈希分片集群上</li>
<li>文本索引：不建议使用，性能低下</li>
<li>地理位置索引：</li>
<li>唯一索引：确保索引字段不会存储重复值</li>
<li>TTL索引：提供一个过期机制，允许为每一个文档设置一个过期时间，当文档达到过期时间就会被删除，示例代码：`    @Indexed(expireAfterSeconds = 60 * 60 * 24 * 30)private Date createdAt;<ul>
<li>TTL索引只能用于单字段</li>
<li><code>_id</code> 不支持TTL索引</li>
<li>不能在上限集合(上限集合（Capped Collections）是一种特殊类型的集合，它有固定的大小。当集合达到其最大大小时，MongoDB会自动覆盖最旧的文档。)中删除文档</li>
</ul>
</li>
<li>覆盖索引查询：<ol>
<li>所有查询字段都要求是索引的一部分</li>
<li>结果中返回的所有字段都在同一个索引中</li>
<li>查询中没有字段为null</li>
</ol>
</li>
</ul>
</li>
<li>集合：集合是动态的，可以把不同类型的文档归为一个集合<ul>
<li>盖子集合: 有上限的集合，用于日志，不支持crud,当超过上限时，会从最老的文档开始删除<ul>
<li><code>db.createCollection("users.actions",{capped:true,size:16384,max:100})</code></li>
</ul>
</li>
<li>TTL集合: MongoDB也允许在特定的时间后废弃文档数据，有时候叫做生存时间time-to-live (TTL）集合这个功能实际上是通过一个特殊的索引实现的 创建TTL索引的方式如下：<ul>
<li><code>db.reviews.createIndex({time_field:1},{expireAfterSeconds:3600})</code></li>
<li>time_field字段会定期检查时间戳，与当前时间比较，如果时间差大于设置的时间，文档会被自动删除，单位是s</li>
</ul>
</li>
</ul>
</li>
<li>文档-&gt;集合-&gt;数据库-&gt;MongoDB</li>
<li>mongosh是一个js解释器，可以使用js标准库或者运行函数</li>
<li>使用js语法，db变量代表当前选用的数据库</li>
</ol>
<ul>
<li>CRUD:<ul>
<li>查询可以使用正则表达式</li>
<li>建立数据库直接use一个新的数据库即可</li>
<li>变量 = {…},之后db.集合.insertOne(变量)或者insertMany()</li>
<li>db.集合.find()或者findOne()</li>
<li>updateOne()</li>
<li>db.集合.deleteOne/Many()</li>
<li>db.dropDatabase()删除当前数据库</li>
<li>db.collection.drop() 删除指定集合</li>
<li>db.col.update({‘title’:’MongoDB 教程’},{$set:{‘title’:’MongoDB’}}) 对应的变量名({ “nMatched” : 1, “nUpserted” : 0, “nModified” : 1 },{multi:true}) 设置multi : true可以修改选定的所有文档</li>
<li>想显式创建集合：db.createCollection(xxx),通过size字段可以预分配空间的字节大小</li>
</ul>
</li>
<li>创建索引:db.products.createIndex({slug: 1}, {unique: true})<ul>
<li>1代表是升序，unique是指定索引的选项，指定了索引是唯一的，slug一般用于存储URL</li>
</ul>
</li>
<li>聚合管道： 类似stream流和channel管道，可以执行一系列的handler,最后返回结果 <img src="/2023/08/02/58/%E8%81%9A%E5%90%88%E7%AE%A1%E9%81%93.png"><ol>
<li><img src="/2023/08/02/58/SQL%E5%AF%B9%E6%AF%94%E8%81%9A%E5%90%88.png"></li>
</ol>
</li>
</ul>
<h2 id="Mybatis面试"><a href="#Mybatis面试" class="headerlink" title="Mybatis面试"></a>Mybatis面试</h2><ul>
<li>mybatis执行流程：<ul>
<li>读取配置文件</li>
<li>构建会话工厂：会话工厂全局一个，生产sqlSession</li>
<li>创建会话：项目与数据库的会话，包含了执行sql语句的所有方法，每次操作一个会话，有多个</li>
<li>Executor执行器</li>
<li>返回结果</li>
</ul>
</li>
<li>延迟加载：懒加载，旨在需要使用数据的时候才进行实际的SQL查询<ul>
<li>比如我们在关联查询中，我们会自动的把关联的用户数据也查询出来了，但是我们并不需要用户的信息，所以我们可以使用延迟加载，只有在我们使用用户信息的时候才会把结果查询出来</li>
</ul>
</li>
<li>缓存：本地缓存<ul>
<li>一级缓存：sqlsession ，实现方式是PerpertualCache,当Session进行flush或者close时会刷新缓存</li>
<li>二级缓存：mapper级别的</li>
</ul>
</li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/database/" rel="tag"># database</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/07/04/56/" rel="prev" title="Tools">
      <i class="fa fa-chevron-left"></i> Tools
    </a></div>
      <div class="post-nav-item">
    <a href="/2023/08/27/25/" rel="next" title="Java基础">
      Java基础 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="nav-number">1.</span> <span class="nav-text">数据库</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Mysql%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97"><span class="nav-number">1.1.</span> <span class="nav-text">Mysql面试指南</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#InnoDB%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E9%BB%98%E8%AE%A4%E7%9A%84%E5%BC%95%E6%93%8E"><span class="nav-number">1.1.1.</span> <span class="nav-text">InnoDB为什么是默认的引擎</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8B-%E6%A0%91"><span class="nav-number">1.1.2.</span> <span class="nav-text">索引为什么使用B+树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E5%9B%9E%E6%BB%9A%E7%9A%84"><span class="nav-number">1.1.3.</span> <span class="nav-text">如何进行回滚的</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%85%A2%E6%9F%A5%E8%AF%A2%E5%A6%82%E4%BD%95%E8%80%83%E8%99%91%E4%BC%98%E5%8C%96"><span class="nav-number">1.1.4.</span> <span class="nav-text">慢查询如何考虑优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E7%9A%84CAP"><span class="nav-number">1.1.5.</span> <span class="nav-text">数据库中的CAP</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%8E%E4%B9%88%E5%AF%B9plan%E8%BF%9B%E8%A1%8C%E4%BC%98%E5%8C%96"><span class="nav-number">1.1.6.</span> <span class="nav-text">怎么对plan进行优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8BMySQL%E7%9A%84%E7%B4%A2%E5%BC%95"><span class="nav-number">1.1.7.</span> <span class="nav-text">介绍一下MySQL的索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#B-%E6%A0%91%E7%9A%84%E7%89%B9%E5%BE%81%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88-MySQL-%E8%A6%81%E4%BD%BF%E7%94%A8-B-%E6%A0%91"><span class="nav-number">1.1.8.</span> <span class="nav-text">B+树的特征，为什么 MySQL 要使用 B+树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#InooDB%E8%AF%A6%E8%A7%A3"><span class="nav-number">1.1.9.</span> <span class="nav-text">InooDB详解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%EF%BC%9A"><span class="nav-number">1.1.10.</span> <span class="nav-text">索引：</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%9E%E8%A1%A8%E9%97%AE%E9%A2%98"><span class="nav-number">1.1.10.1.</span> <span class="nav-text">回表问题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%87%E4%BB%A4%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="nav-number">1.1.11.</span> <span class="nav-text">指令执行过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MySql%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96"><span class="nav-number">1.1.12.</span> <span class="nav-text">MySql查询优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Buffer-Pool-%E7%BC%93%E5%86%B2%E6%B1%A0"><span class="nav-number">1.1.13.</span> <span class="nav-text">Buffer Pool 缓冲池</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">1.2.</span> <span class="nav-text">基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.2.1.</span> <span class="nav-text">模式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#schema-%E5%92%8C-database-%E5%8C%BA%E5%88%AB"><span class="nav-number">1.3.</span> <span class="nav-text">schema 和 database 区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%8C%83%E5%BC%8F"><span class="nav-number">1.4.</span> <span class="nav-text">范式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ACID"><span class="nav-number">1.5.</span> <span class="nav-text">ACID</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#E-R%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.6.</span> <span class="nav-text">E-R模型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%87%AA%E8%81%94%E7%BB%93%EF%BC%8C%E5%8F%98%E9%87%8F%E4%B8%8D%E4%BC%9A%EF%BC%8C%E8%A1%A5%E4%B8%80%E8%A1%A5%E5%8E%BB"><span class="nav-number">1.7.</span> <span class="nav-text">自联结，变量不会，补一补去</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SQL%E8%AF%AD%E5%8F%A5"><span class="nav-number">1.8.</span> <span class="nav-text">SQL语句</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#DDL-Data-Definition-Language-%E6%95%B0%E6%8D%AE%E5%AE%9A%E4%B9%89%E8%AF%AD%E8%A8%80%EF%BC%89%E7%94%A8%E4%BA%8E%E6%93%8D%E4%BD%9C%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%AF%B9%E8%B1%A1%E6%9C%AC%E8%BA%AB%EF%BC%8C%E8%BF%99%E7%A7%8D%E5%AF%B9%E8%B1%A1%E5%8C%85%E6%8B%AC%E6%95%B0%E6%8D%AE%E5%BA%93-%E8%A1%A8%E5%AF%B9%E8%B1%A1%EF%BC%8C%E5%8F%8A%E8%A7%86%E5%9B%BE%E5%AF%B9%E8%B1%A1%EF%BC%8C%E8%A1%A8%E5%A4%B4"><span class="nav-number">1.8.1.</span> <span class="nav-text">DDL (Data Definition Language 数据定义语言）用于操作对象及对象本身，这种对象包括数据库,表对象，及视图对象，表头</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DML-%EF%BC%88Data-Manipulation-Language-%E6%95%B0%E6%8D%AE%E6%93%8D%E6%8E%A7%E8%AF%AD%E8%A8%80-%E7%94%A8%E4%BA%8E%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AF%B9%E8%B1%A1%E5%AF%B9%E8%B1%A1%E4%B8%AD%E5%8C%85%E5%90%AB%E7%9A%84%E6%95%B0%E6%8D%AE"><span class="nav-number">1.8.2.</span> <span class="nav-text">DML （Data Manipulation Language 数据操控语言) 用于操作数据库对象对象中包含的数据</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8F%92%E5%85%A5"><span class="nav-number">1.8.2.1.</span> <span class="nav-text">插入</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9B%B4%E6%96%B0%E4%B8%8E%E5%88%A0%E9%99%A4"><span class="nav-number">1.9.</span> <span class="nav-text">更新与删除</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9B%B4%E6%96%B0%EF%BC%9AUPDATE-%E6%B3%A8%E6%84%8F%E8%A6%81%E7%94%A8WHERE-%E5%90%A6%E5%88%99%E4%BC%9A%E5%87%BA%E4%BA%8B"><span class="nav-number">1.9.1.</span> <span class="nav-text">更新：UPDATE 注意要用WHERE 否则会出事</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE"><span class="nav-number">1.9.1.1.</span> <span class="nav-text">删除数据</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DQL-Data-Query-Language-%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2%E8%AF%AD%E8%A8%80-%E7%94%A8%E4%BA%8E%E6%9F%A5%E8%AF%A2%E6%95%B0%E6%8D%AE"><span class="nav-number">1.9.2.</span> <span class="nav-text">DQL (Data Query Language 数据查询语言 )用于查询数据</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#SELECT"><span class="nav-number">1.9.2.1.</span> <span class="nav-text">SELECT</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DCL-%EF%BC%88Data-Control-Language-%E6%95%B0%E6%8D%AE%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5%EF%BC%89-%E7%94%A8%E4%BA%8E%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%9D%83%E9%99%90"><span class="nav-number">1.9.3.</span> <span class="nav-text">DCL （Data Control Language 数据控制语句） 用于操作数据库对象的权限</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0-%E9%85%8D%E5%90%88SELECT-%E4%BD%BF%E7%94%A8"><span class="nav-number">1.10.</span> <span class="nav-text">函数 配合SELECT 使用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0"><span class="nav-number">1.10.1.</span> <span class="nav-text">字符串函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E5%80%BC%E5%87%BD%E6%95%B0"><span class="nav-number">1.10.2.</span> <span class="nav-text">数值函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%A5%E6%9C%9F%E5%87%BD%E6%95%B0"><span class="nav-number">1.10.3.</span> <span class="nav-text">日期函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%81%E7%A8%8B%E5%87%BD%E6%95%B0"><span class="nav-number">1.10.4.</span> <span class="nav-text">流程函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%A6%E6%9D%9F-%E4%BD%9C%E7%94%A8%E5%9F%9F%E8%A1%A8%E4%B8%AD%E5%AD%97%E6%AE%B5%E4%B8%8A%E7%9A%84%E8%A7%84%E5%88%99%EF%BC%8C%E7%94%A8%E4%BA%8E%E9%99%90%E5%88%B6%E5%AD%98%E5%82%A8%E5%9C%A8%E8%A1%A8%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE"><span class="nav-number">1.11.</span> <span class="nav-text">约束 作用域表中字段上的规则，用于限制存储在表中的数据</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2"><span class="nav-number">1.12.</span> <span class="nav-text">多表查询</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%90%E6%9F%A5%E8%AF%A2%EF%BC%9A"><span class="nav-number">1.12.1.</span> <span class="nav-text">子查询：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%81%94%E7%BB%93%E8%A1%A8"><span class="nav-number">1.13.</span> <span class="nav-text">联结表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%81%94%E7%BB%93%E4%BD%BF%E7%94%A8%E6%9D%A1%E4%BB%B6"><span class="nav-number">1.14.</span> <span class="nav-text">联结使用条件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#join%E5%8C%BA%E5%88%AB"><span class="nav-number">1.14.1.</span> <span class="nav-text">join区别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B5%B7%E5%88%AB%E5%90%8D"><span class="nav-number">1.15.</span> <span class="nav-text">起别名</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#UNION"><span class="nav-number">1.16.</span> <span class="nav-text"> UNION </span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%92%E5%BA%8F"><span class="nav-number">1.16.1.</span> <span class="nav-text">排序</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BB%BA%E8%A1%A8"><span class="nav-number">1.17.</span> <span class="nav-text">建表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%87%8D%E6%96%B0%E5%91%BD%E5%90%8D"><span class="nav-number">1.18.</span> <span class="nav-text">重新命名</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A7%86%E5%9B%BE"><span class="nav-number">1.19.</span> <span class="nav-text">视图</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%EF%BC%88%E4%B8%8D%E4%BC%9A%EF%BC%89"><span class="nav-number">1.20.</span> <span class="nav-text">存储（不会）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%A1%E7%90%86%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%EF%BC%88%E4%B8%8D%E4%BC%9A%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0%E7%9A%84%E6%97%B6%E5%80%99%E5%86%8D%E7%9C%8B%EF%BC%89"><span class="nav-number">1.21.</span> <span class="nav-text">管理事务处理（不会深入学习的时候再看）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B8%B8%E6%A0%87"><span class="nav-number">1.22.</span> <span class="nav-text">游标</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%A6%E6%9D%9F%EF%BC%88%E4%B8%8D%E4%BC%9A%E6%8D%8F%EF%BC%89"><span class="nav-number">1.23.</span> <span class="nav-text">约束（不会捏）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%96%E9%94%AE"><span class="nav-number">1.23.1.</span> <span class="nav-text">外键</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95"><span class="nav-number">1.23.2.</span> <span class="nav-text">索引</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#case-%E6%9D%A5%E8%BF%9B%E8%A1%8C%E5%A4%9A%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD-%E4%B8%8D%E8%A6%81%E5%BF%98%E8%AE%B0END"><span class="nav-number">1.24.</span> <span class="nav-text">case 来进行多条件判断 不要忘记END</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1"><span class="nav-number">1.25.</span> <span class="nav-text">事务</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E4%BA%8B%E5%8A%A1%E9%97%AE%E9%A2%98"><span class="nav-number">1.25.1.</span> <span class="nav-text">并发事务问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%95%E6%93%8E"><span class="nav-number">1.26.</span> <span class="nav-text">引擎</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%81"><span class="nav-number">1.26.1.</span> <span class="nav-text">锁</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0"><span class="nav-number">1.27.</span> <span class="nav-text">常用函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">1.28.</span> <span class="nav-text">正则表达式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JDBC"><span class="nav-number">1.29.</span> <span class="nav-text">JDBC</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%98%E9%87%8F%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">1.29.1.</span> <span class="nav-text">变量的使用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis"><span class="nav-number">1.30.</span> <span class="nav-text">Redis</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%A2%E8%AF%95%E5%B8%B8%E9%97%AE"><span class="nav-number">1.30.1.</span> <span class="nav-text">面试常问</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98"><span class="nav-number">1.31.</span> <span class="nav-text">缓存问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis%E5%9C%A8%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4%E7%9A%84%E6%97%B6%E5%80%99%E6%98%AF%E5%8D%95%E7%BA%BF%E7%A8%8B%EF%BC%8C%E4%BD%86%E6%98%AF%E4%B9%9F%E4%BD%BF%E7%94%A8%E4%BA%86%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%9D%A5%E5%A4%84%E7%90%86%E7%BD%91%E7%BB%9CIO%E6%93%8D%E4%BD%9C"><span class="nav-number">1.31.1.</span> <span class="nav-text">Redis在执行命令的时候是单线程，但是也使用了多线程的来处理网络IO操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis-%E8%84%9A%E6%9C%AC%E5%91%BD%E4%BB%A4"><span class="nav-number">1.31.2.</span> <span class="nav-text">Redis 脚本命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#dockercompose%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%BB%E4%BA%8C%E4%BB%8E%E4%B8%80%E5%93%A8%E5%85%B5%E7%9A%84redis%E9%9B%86%E7%BE%A4"><span class="nav-number">1.31.3.</span> <span class="nav-text">dockercompose快速搭建一主二从一哨兵的redis集群</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MongoDB"><span class="nav-number">1.32.</span> <span class="nav-text">MongoDB</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%EF%BC%9A"><span class="nav-number">1.32.0.1.</span> <span class="nav-text">基本概念：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Mybatis%E9%9D%A2%E8%AF%95"><span class="nav-number">1.33.</span> <span class="nav-text">Mybatis面试</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">QingQiu</p>
  <div class="site-description" itemprop="description">个人网站，学习记录，面试记录和经验总结、互联网中一块属于自己的小窝</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">57</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">26</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Zuofw/zuofw-rpc" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Zuofw&#x2F;zuofw-rpc" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2022 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">QingQiu</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="站点总字数">468k</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  















  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
