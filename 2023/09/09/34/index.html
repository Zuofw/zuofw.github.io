<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"zuofw.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="JAVA 快写最短路与具体的路径记录问题TreeMapTreeMap&lt;Integer, Integer&gt; map &#x3D; new TreeMap&lt;&gt;(); map.getOrDefault(key,0) 获得这个数，如果为空,返回默认值，可以自己设定 k &#x3D; map.higherKey(k); 获得下一个顺序的键 把toCharArray向右移动一位 a &#x3D; (&#39; &#39;+ re.">
<meta property="og:type" content="article">
<meta property="og:title" content="学算法">
<meta property="og:url" content="https://zuofw.github.io/2023/09/09/34/index.html">
<meta property="og:site_name" content="QingQiu&#39;Blog">
<meta property="og:description" content="JAVA 快写最短路与具体的路径记录问题TreeMapTreeMap&lt;Integer, Integer&gt; map &#x3D; new TreeMap&lt;&gt;(); map.getOrDefault(key,0) 获得这个数，如果为空,返回默认值，可以自己设定 k &#x3D; map.higherKey(k); 获得下一个顺序的键 把toCharArray向右移动一位 a &#x3D; (&#39; &#39;+ re.">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="file:///D:/typora%E7%94%A8%E5%9B%BE/Screenshots/image-20230511171657614.png?lastModify=1694256669">
<meta property="og:image" content="file:///D:/typora%E7%94%A8%E5%9B%BE/Screenshots/image-20230519193254443.png?lastModify=1694256669">
<meta property="og:image" content="file:///D:/typora%E7%94%A8%E5%9B%BE/Screenshots/image-20230521084412853.png?lastModify=1694256669">
<meta property="og:image" content="file:///D:/typora%E7%94%A8%E5%9B%BE/Screenshots/image-20230524164849922.png?lastModify=1694256669">
<meta property="article:published_time" content="2023-09-09T12:35:34.000Z">
<meta property="article:modified_time" content="2024-10-11T08:20:12.649Z">
<meta property="article:author" content="QingQiu">
<meta property="article:tag" content="算法，数据结构">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="file:///D:/typora%E7%94%A8%E5%9B%BE/Screenshots/image-20230511171657614.png?lastModify=1694256669">

<link rel="canonical" href="https://zuofw.github.io/2023/09/09/34/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>学算法 | QingQiu'Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>


<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">QingQiu'Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">清秋的博客</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-fa fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-fa fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-fa fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-fa fa-archive"></i>归档</a>

  </li>
        <li class="menu-item menu-item-github">

    <a href="https://github.com/Zuofw" rel="noopener" target="_blank"><i class="fa fa-fw fa-fab fa-github"></i>Github</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zuofw.github.io/2023/09/09/34/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="QingQiu">
      <meta itemprop="description" content="个人网站，学习记录，面试记录和经验总结、互联网中一块属于自己的小窝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="QingQiu'Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          学算法
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-09-09 20:35:34" itemprop="dateCreated datePublished" datetime="2023-09-09T20:35:34+08:00">2023-09-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-10-11 16:20:12" itemprop="dateModified" datetime="2024-10-11T16:20:12+08:00">2024-10-11</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>54k</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="JAVA-快写"><a href="#JAVA-快写" class="headerlink" title="JAVA 快写"></a>JAVA 快写</h2><h2 id="最短路与具体的路径记录问题"><a href="#最短路与具体的路径记录问题" class="headerlink" title="最短路与具体的路径记录问题"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-edges-in-shortest-paths/description/">最短路与具体的路径记录问题</a></h2><h2 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">TreeMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
map<span class="token punctuation">.</span><span class="token function">getOrDefault</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span> 获得这个数，如果为空<span class="token punctuation">,</span>返回默认值，可以自己设定
k <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">higherKey</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span> 获得下一个顺序的键<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h2 id="把toCharArray向右移动一位"><a href="#把toCharArray向右移动一位" class="headerlink" title="把toCharArray向右移动一位"></a>把toCharArray向右移动一位</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"> a <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token char">' '</span><span class="token operator">+</span> re<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="a-z-之间偏移量确认"><a href="#a-z-之间偏移量确认" class="headerlink" title="a ~ z 之间偏移量确认"></a>a ~ z 之间偏移量确认</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token char">'a'</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> offset <span class="token operator">-</span> <span class="token char">'a'</span><span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">26</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="看到唯一解，且是难以做的图形题，可以考虑转化为方程"><a href="#看到唯一解，且是难以做的图形题，可以考虑转化为方程" class="headerlink" title="看到唯一解，且是难以做的图形题，可以考虑转化为方程"></a>看到唯一解，且是难以做的图形题，可以考虑转化为方程</h2><p><a target="_blank" rel="noopener" href="https://www.lanqiao.cn/problems/17160/learning/?contest_id=179">https://www.lanqiao.cn/problems/17160/learning/?contest_id=179</a></p>
<h3 id="卡特兰数问题-：h-n-x3D-C-2n-n-−C-2n-n−1-n-x3D-0-1-2-…-组合数C不解释了；-C是组合数"><a href="#卡特兰数问题-：h-n-x3D-C-2n-n-−C-2n-n−1-n-x3D-0-1-2-…-组合数C不解释了；-C是组合数" class="headerlink" title="卡特兰数问题 ：h[n]=C[2n,n]−C [2n,n−1] (n=0,1,2,…)&nbsp;组合数C不解释了； C是组合数"></a>卡特兰数问题 ：h[n]=C[2n,n]−C [2n,n−1] (n=0,1,2,…)&nbsp;组合数C不解释了； C是组合数</h3><ol>
<li>出栈顺序问题 假设有N个数字依次入栈：1,2,3,…,n，试问有多少种出栈顺序？这里为表述简便，下文用+1表示一个元素入栈，用-1表示一个元素出栈</li>
<li>问题描述：有n对()括号，试问可以组成多少种合法正确的括号序列？</li>
</ol>
<h2 id="树是无向边"><a href="#树是无向边" class="headerlink" title="树是无向边"></a>树是无向边</h2><h2 id="Java日期"><a href="#Java日期" class="headerlink" title="Java日期"></a>Java日期</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">LocalDate</span> d1 <span class="token operator">=</span> <span class="token class-name">LocalDate</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span><span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>time<span class="token punctuation">.</span>format<span class="token punctuation">.</span></span>DateTimeFormatter</span><span class="token punctuation">.</span><span class="token constant">BASIC_ISO_DATE</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		s <span class="token operator">=</span> reader<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token class-name">LocalDate</span> d2 <span class="token operator">=</span> <span class="token class-name">LocalDate</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span><span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>time<span class="token punctuation">.</span>format<span class="token punctuation">.</span></span>DateTimeFormatter</span><span class="token punctuation">.</span><span class="token constant">BASIC_ISO_DATE</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">long</span> diff <span class="token operator">=</span> <span class="token class-name">ChronoUnit</span><span class="token punctuation">.</span><span class="token constant">DAYS</span><span class="token punctuation">.</span><span class="token function">between</span><span class="token punctuation">(</span>d1<span class="token punctuation">,</span> d2<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">abs</span><span class="token punctuation">(</span>diff<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">BufferedWriter</span> writer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedWriter</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">OutputStreamWriter</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
writer<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 才会写<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h2 id="JAVA更快更强的读入和写-https-www-luogu-com-cn-problem-P2367"><a href="#JAVA更快更强的读入和写-https-www-luogu-com-cn-problem-P2367" class="headerlink" title="JAVA更快更强的读入和写 https://www.luogu.com.cn/problem/P2367"></a>JAVA更快更强的读入和写 <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P2367">https://www.luogu.com.cn/problem/P2367</a></h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"> <span class="token class-name">StreamTokenizer</span> reader <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StreamTokenizer</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

reader<span class="token punctuation">.</span><span class="token function">nextToken</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
n <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> reader<span class="token punctuation">.</span>nval<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="取余数的小技巧"><a href="#取余数的小技巧" class="headerlink" title="取余数的小技巧"></a>取余数的小技巧</h2><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token punctuation">(</span>x + n<span class="token punctuation">)</span> % n 可以保证不会出现负数<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>先思考再做题，前几个题大概率时模拟题，所以别急着用算法</p>
<h2 id="常用算法"><a href="#常用算法" class="headerlink" title="常用算法"></a>常用算法</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">next_permutation</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>a<span class="token operator">+</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span> 对数组的前n个数进行全排列，并存储在这个数组中
<span class="token keyword">char</span> a<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span>
<span class="token function">puts</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> 可以直接输出一行，如果不是最后一行还会输出换行符
求 q<span class="token operator">^</span><span class="token number">0</span> <span class="token operator">+</span> q<span class="token operator">^</span><span class="token number">1</span> <span class="token operator">+</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token operator">+</span> q<span class="token operator">^</span>n
<span class="token keyword">long</span> <span class="token keyword">long</span> t <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token keyword">while</span><span class="token punctuation">(</span>n<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">//秦九zhao算法</span>
    t <span class="token operator">=</span> <span class="token punctuation">(</span>t <span class="token operator">*</span>q <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span>mod<span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>整数划分</strong><a target="_blank" rel="noopener" href="https://ac.nowcoder.com/acm/problem/252724">https://ac.nowcoder.com/acm/problem/252724</a></p>
<p>accumulate 求和</p>
<p>快乐的模板：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits/stdc++.h&gt;  
#define ll long long   
#define pii pair&lt;int,int&gt;  
using namespace std;  
void solve(){  
 &nbsp; &nbsp;return ;  
}  
int main(){  
 &nbsp; &nbsp;ios::sync_with_stdio(false);  
 &nbsp; &nbsp;cin.tie(nullptr);  
 &nbsp; &nbsp;int T;  
 &nbsp; &nbsp;cin &gt;&gt; T;  
 &nbsp; &nbsp;while (T--) solve();  
 &nbsp; &nbsp;return 0;  
}  
​```


## 小TIPS：

做题思路：

1. 从小数据，小范围推大范围
    
2. 划分，以及反证，如果要求全部满足一个性质，那么只要有部分不满足我们已经推出来的条件即可不满足所有性质
    

&gt; 1. 数组和字符串比较字典序是可以直接用大于号小于号比较的
&gt;     
&gt; 2. 字典序是指在ASCII码中出现的顺序所以 也就是 a b c 0 1 2 3 ABC 等z
&gt;     
&gt; 3. vector &lt;&gt; 可以直接赋值
&gt;     

## 牛顿迭代法：

求平方根

例子： f(x)=m,可转化为 g(x)=f(x)-m=0;

迭代公式：_x_n+1 = _x_n − _g_ (_x_n)/ _g_ ′ (_x_n)

例题：[力扣（LeetCode）官网 - 全球极客挚爱的技术成长平台](https://leetcode.cn/problems/sqrtx/submissions/431189596/)
```c++
//f (x) = x2 − a = 0  
int mySqrt(int a) {  
long x = a;  
while (x * x &gt; a) {  
x = (x + a / x) / 2;  
}  
return x;  
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="stl和一些内置函数"><a href="#stl和一些内置函数" class="headerlink" title="stl和一些内置函数"></a>stl和一些内置函数</h3><p>accumulate(num.begin(),num.end(),0); //第三个参数是初始化要返回的东西 </p>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="快速排序模板-根据数来分治"><a href="#快速排序模板-根据数来分治" class="headerlink" title="快速排序模板 根据数来分治"></a>快速排序模板 根据数来分治</h3><p>先找数字中的中位数，然后递归<br><strong>注意：</strong> while中先递归的左边，那么最后递归的时候就要以j来为界限，递归的顺序无所谓</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void quick_sort(int q[], int l, int r)
{
    if (l &gt;= r) return;
    int x = q[rand()% (r-l+1)+l]; // 随机取
    int i = l - 1, j = r + 1; 
    while (i &lt; j) {
        do i++; while (
        q[i] &lt; x);
        do j--; while (q[j] &gt; x);
        if (i &lt; j) swap(q[i], q[j]);    //如果i与j没有相遇，就交换一下
    }

    quick_sort(q, l, j);    //递归处理左右两边
    quick_sort(q, j + 1, r);
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="归并排序模板-分治-根据中间两个数为分界线"><a href="#归并排序模板-分治-根据中间两个数为分界线" class="headerlink" title="归并排序模板 分治 根据中间两个数为分界线"></a>归并排序模板 分治 根据中间两个数为分界线</h3><ol>
<li><p>确定分界点， mid=(l+r)/2</p>
</li>
<li><p>递归排序 left，right</p>
</li>
<li><p>归并 合二为一</p>
</li>
</ol>
<p>模板</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">
void msort(int a[], int l, int r) {  
    if (l &gt;= r) return;  
    //确定分界  
    int mid = l + r &gt;&gt; 1;  
    //递归  
    msort(a, l, mid); msort(a, mid + 1, r);  
    //归并  
    int k = 0, i = l, j = mid + 1;  
      
    while (i &lt;=mid &amp;&amp; j &lt;= r) {//左右比较，小的放在辅助数组里，直到有一个指针到达边界  
        if (a[i] &lt;= a[j]) tmp[k++] = a[i++];  
        else tmp[k++] = a[j++];  
    }  
    //这里继续把另一个没到边界的指针赋值给辅助数组  
    while (i &lt;= mid) tmp[k++] = a[i++];  
    while (j &lt;= r)tmp[k++] = a[j++];  
    //最后把辅助数组的元素还回去  
    for (int i = l, j = 0; i &lt;= r; i++, j++) a[i] = tmp[j];  
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="二分法-二分要保证有解"><a href="#二分法-二分要保证有解" class="headerlink" title="二分法 二分要保证有解"></a>二分法 二分要保证有解</h2><h3 id="整数二分"><a href="#整数二分" class="headerlink" title="整数二分"></a>整数二分</h3><p>一分为二，一边满足性质，一半不满足，可以来用来寻找性质的边界</p>
<p>两种模板：一种去检查满足的一半，另一种去检查不满足性质的的一半</p>
<p>考虑边界是否会包括进去</p>
<ol>
<li><p>先写出 mid=r+l&gt;&gt;1</p>
</li>
<li><p>二分要检查的性质</p>
</li>
<li><p>画图考虑，直线图</p>
</li>
<li><p>思考mid是否会包含</p>
</li>
<li><p>考虑不存在条件时</p>
</li>
</ol>
<h2 id="l-x3D-mid-1-时-输出的是-L-r-x3D-mid-1-时-输出的是r"><a href="#l-x3D-mid-1-时-输出的是-L-r-x3D-mid-1-时-输出的是r" class="headerlink" title="l = mid + 1 时,输出的是 L , r = mid -1 时 输出的是r"></a>l = mid + 1 时,输出的是 L , r = mid -1 时 输出的是r</h2><p>注意死循环，男左女右，查找从右侧往左的时候mid 要 + 1，否则不+1</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">l + (r - l + 1 &gt;&gt; 1); 
​<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">更好的二分模板
<span class="token keyword">while</span><span class="token punctuation">(</span>l<span class="token operator">&lt;=</span>r<span class="token punctuation">)</span><span class="token punctuation">{</span>
	mid <span class="token operator">=</span> <span class="token punctuation">(</span>l <span class="token operator">+</span> r<span class="token punctuation">)</span> <span class="token operator">&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>mid <span class="token operator">&lt;</span> r<span class="token punctuation">)</span> r <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token keyword">else</span>  mid <span class="token operator">=</span> l <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="浮点数二分-不要处理边界"><a href="#浮点数二分-不要处理边界" class="headerlink" title="浮点数二分 不要处理边界"></a>浮点数二分 不要处理边界</h3><p>思路：通过mid来判断，答案落在缩小的区间内，只要近似值</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">bool check(double x) {/* ... */} // 检查x是否满足某种性质  
  
double bsearch_3(double l, double r)  
{  
    const double eps = 1e-6;   // eps 表示精度，取决于题目对精度的要求  
    while (r - l &gt; eps)  
    {  
        double mid = (l + r) / 2;  
        if (check(mid)) r = mid;  
        else l = mid;  
    }  
    //或者直接不管精度，直接循环几百次  
    return l;  
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="高精度"><a href="#高精度" class="headerlink" title="高精度"></a>高精度</h2><h3 id="加法：-注意要把A设为位数更大的那一个，因为最后的位数取决于位数大的那一个，使用vector容器可以更方便的进行计算和进位和确定位数"><a href="#加法：-注意要把A设为位数更大的那一个，因为最后的位数取决于位数大的那一个，使用vector容器可以更方便的进行计算和进位和确定位数" class="headerlink" title="加法： 注意要把A设为位数更大的那一个，因为最后的位数取决于位数大的那一个，使用vector容器可以更方便的进行计算和进位和确定位数"></a>加法： 注意要把A设为位数更大的那一个，因为最后的位数取决于位数大的那一个，使用vector容器可以更方便的进行计算和进位和确定位数</h3><ol>
<li><p>逆序存数的每一位</p>
</li>
<li><p>从低位开始计算，之后计算进位</p>
</li>
<li><p>加完之后检查最后一位是否还有进位</p>
</li>
<li><p>返回数字</p>
</li>
</ol>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">vector&lt;int&gt; add(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B)  
{  
    if (A.size() &lt; B.size()) return add(B, A);  
  
    vector&lt;int&gt; C;  
    int t = 0;  
    for (int i = 0; i &lt; A.size(); i ++ )  
    {  
        t += A[i];  
        if (i &lt; B.size()) t += B[i];  
        C.push_back(t % 10);  
        t /= 10;  
    }  
  
    if (t) C.push_back(1);  
    return C;  
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="减法"><a href="#减法" class="headerlink" title="减法"></a>减法</h3><p>和加法基本一致，只要变进位为借位即可</p>
<p>// C = A - B, 满足A &gt;= B, A &gt;= 0, B &gt;= 0  </p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">vector&lt;int&gt; sub(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B)  
{  
    vector&lt;int&gt; C;  
    for (int i = 0, t = 0; i &lt; A.size(); i ++ )  
    {  
        t = A[i] - t;  
        if (i &lt; B.size()) t -= B[i];  
        C.push_back((t + 10) % 10);  
        if (t &lt; 0) t = 1;  
        else t = 0;  
    }  
  
    while (C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back();  
    return C;  
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="乘法"><a href="#乘法" class="headerlink" title="乘法"></a>乘法</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">vector&lt;int&gt; mul(vector&lt;int&gt;&amp;A,int b){  
 &nbsp; vector&lt;int&gt;C;  
 &nbsp; int t=0;  
 &nbsp; for(int i=0;i&lt;A.size()||t;i++){//出现进位  
 &nbsp; &nbsp; &nbsp;if(i&lt;A.size()) t+=A[i]*b;  
 &nbsp; &nbsp; &nbsp;C.push_back(t%10);  
 &nbsp; &nbsp; &nbsp;t/=10;  
 &nbsp; }  
 &nbsp; while(C.size()&gt;1&amp;&amp;C.back()==0) C.pop_back();  
 &nbsp; //去除前导零  
 &nbsp; return C;  
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">### 除法

vector&lt;int&gt; div(vector&lt;int&gt;&amp;A,int b){  
 &nbsp; vector&lt;int&gt;C;  
 &nbsp; int t=0;  
 &nbsp; for(int i=0;i&lt;A.size();i++){  
 &nbsp; &nbsp; &nbsp;t=t*10+A[i];  
 &nbsp; &nbsp; &nbsp;C.push_back(t/b);  
 &nbsp; &nbsp; &nbsp;t %= b;  
 &nbsp; }  
 &nbsp; //这里是清除前置零，不是后置零
 &nbsp; reverse(C.begin(),C.end());  
 &nbsp; while(C.size()&gt;1&amp;&amp;C.back()==0) C.pop_back();  
 &nbsp; return C;  
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="前缀和和差分"><a href="#前缀和和差分" class="headerlink" title="前缀和和差分"></a>前缀和和差分</h2><p><strong>构造差分可以用一个空数组，一直执行插入操作即可</strong></p>
<p>前缀和一般初始化为0到n但是只用1到n</p>
<p>二维</p>
<p>S[i, j] = 第i行j列格子左上部分所有元素的和<br>以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：<br>S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]</p>
<p>二维差分： 差分的前缀和就是原数组</p>
<p>给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：<br>S[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c//注意是x2+1,y2+1不是x2,y2</p>
<h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int x;  
int * p1 = &amp;x; // 指针可以被修改，值也可以被修改  
const int * p2 = &amp;x; // 指针可以被修改，值不可以被修改（const int）  
int * const p3 = &amp;x; // 指针不可以被修改（* const），值可以被修改  
const int * const p4 = &amp;x; // 指针不可以被修改，值也不可以被修改

for (int i = 0, j = 0; i &lt; n; i ++ )  
{  
    while (j &lt; i &amp;&amp; check(i, j)) j ++ ;  
  
    // 具体问题的逻辑  
}  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>常见问题分类：<br>    (1) 对于一个序列，用两个指针维护一段区间<br>    (2) 对于两个序列，维护某种次序，比如归并排序中合并两个有序序列的操作</p>
<h3 id="Floyd判圈法-龟兔赛跑法-用于判断链表有无环和求出环的长度"><a href="#Floyd判圈法-龟兔赛跑法-用于判断链表有无环和求出环的长度" class="headerlink" title="Floyd判圈法 龟兔赛跑法 用于判断链表有无环和求出环的长度"></a>Floyd判圈法 龟兔赛跑法 用于判断链表有无环和求出环的长度</h3><p>两个指针fast slow 都从起始位置出发，fast 一次走2步，slow一次走1步，如果能相遇，则存在环</p>
<p>计算环的长度</p>
<p>让其中一个指针停在环的起点不动，另一个一步一步向前走并记录步数，再次相遇时步数即为环的长度。</p>
<p>寻找环的起点</p>
<p>其中一个指针在环的起点不动，另一个放到起点，两个指针同时一步一步移动，则两指针将会在循环节的起点相遇。</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/linked-list-cycle-ii/description/">142. 环形链表 II - 力扣（Leetcode）</a></p>
<p>/**  </p>
<ul>
<li>Definition for singly-linked list.  </li>
<li>struct ListNode {  </li>
<li><pre><code>int val;  
</code></pre>
</li>
<li><pre><code>ListNode *next;  
</code></pre>
</li>
<li><pre><code>ListNode(int x) : val(x), next(NULL) {}  
</code></pre>
</li>
<li>};<br> */<br>class Solution {<br>public:<br> ListNode *detectCycle(ListNode *head) {<br>ListNode *fast=head,*slow=head;<br>   do{<br>   if(!fast||!fast-&gt;next) return NULL;//如果能到达末尾，则不存在环<br>   fast=fast-&gt;next-&gt;next;<br>   slow=slow-&gt;next;<br>   }while(fast!=slow);<br>   fast=head;<br>   while(fast!=slow){<br>   fast=fast-&gt;next;<br>   slow=slow-&gt;next;<br>   }<br>   return slow;<br> }<br>};</li>
</ul>
<h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><p>思路：</p>
<p>n的第k位是什么？ n&gt;&gt;k&amp;1 右移k位与1与得到是0就是0，反之就是1</p>
<ol>
<li><p>先把要判断的位置移到最左边</p>
</li>
<li><p>判断</p>
</li>
</ol>
<h3 id="lowbit"><a href="#lowbit" class="headerlink" title="lowbit"></a>lowbit</h3><p>解释：cpp的负数使用的补码表示的所以，-x就等于 ~x+1 反码+1</p>
<p>用法：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/93795692">树状数组</a>和求1的个数</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">

<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Scanner</span></span><span class="token punctuation">;</span>
<span class="token comment">// 1:无需package</span>
<span class="token comment">// 2: 类名必须Main, 不可修改</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>
    <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token class-name">N</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token number">1e5</span> <span class="token operator">+</span> <span class="token number">10</span><span class="token punctuation">;</span>
    <span class="token keyword">static</span> <span class="token keyword">long</span><span class="token punctuation">[</span><span class="token punctuation">]</span> tree <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">long</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">static</span> <span class="token keyword">int</span> n <span class="token punctuation">;</span>
    <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">lowbit</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    	<span class="token keyword">return</span> x <span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token operator">-</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">update</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token punctuation">,</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> pos <span class="token operator">=</span> i <span class="token punctuation">;</span> pos <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> pos <span class="token operator">+=</span> <span class="token function">lowbit</span><span class="token punctuation">(</span>pos<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    		tree<span class="token punctuation">[</span>pos<span class="token punctuation">]</span> <span class="token operator">+=</span> x<span class="token punctuation">;</span>
    	<span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">static</span> <span class="token keyword">long</span> <span class="token function">query</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    	<span class="token keyword">long</span> sum <span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
    	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> pos <span class="token operator">=</span> x<span class="token punctuation">;</span> pos <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">;</span> pos<span class="token operator">-=</span><span class="token function">lowbit</span><span class="token punctuation">(</span>pos<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    		sum <span class="token operator">+=</span>tree<span class="token punctuation">[</span>pos<span class="token punctuation">]</span><span class="token punctuation">;</span>
    	<span class="token punctuation">}</span>
    	<span class="token keyword">return</span> sum<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">static</span> <span class="token keyword">long</span> <span class="token function">ask</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span><span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    	<span class="token keyword">return</span> <span class="token function">query</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token function">query</span><span class="token punctuation">(</span>a<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Scanner</span> scan <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Scanner</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span>
        n <span class="token operator">=</span> scan<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> m <span class="token operator">=</span>scan<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        	<span class="token keyword">int</span> x <span class="token operator">=</span> scan<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        	<span class="token function">update</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>m<span class="token operator">--</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        	<span class="token keyword">int</span> k <span class="token operator">=</span> scan<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        	<span class="token keyword">int</span> a <span class="token operator">=</span> scan<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        	<span class="token keyword">int</span> b <span class="token operator">=</span> scan<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        	<span class="token keyword">if</span><span class="token punctuation">(</span>k <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        		<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token function">ask</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        	<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        		<span class="token function">update</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
        	<span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        scan<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="树状数组：对差分和前缀和的利用："><a href="#树状数组：对差分和前缀和的利用：" class="headerlink" title="树状数组：对差分和前缀和的利用："></a>树状数组：对差分和前缀和的利用：</h1><h3 id="使用情况："><a href="#使用情况：" class="headerlink" title="使用情况："></a>使用情况：</h3><ol>
<li><p>数组不变求区间和</p>
</li>
<li><p>多次修改某个区间，求区间和</p>
</li>
<li><p>将某个区间变为同一个数求区间和</p>
</li>
<li><p>多次修改区间，寻找定点值</p>
</li>
</ol>
<h2 id="模板："><a href="#模板：" class="headerlink" title="模板："></a>模板：</h2><p>说明：lowbit()奇妙用法…..</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define low
```bit(x) (-x)&amp;x  
///或者 int lowbit(int x) {return -x&amp;x;}  
int tree[length];//树状数组，长度和原数组相等  
//区间修改  
void update(int x,int val)  
{  
    while(x){  
        tree[x]+=val;  
        x+=lowbit(x);  
    }  
}  
//区间求和  
int sum(int l,int r){  
    int ans=0;  
    while(r){  
        ans+=tree[r];  
        r-=lowbit(r);  
    }  
    l--;//  
    while(l){  
        ans-=tree[l];  
        l-=lowbit(l);  
    }  
    return ans;  
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="使用方式："><a href="#使用方式：" class="headerlink" title="使用方式："></a>使用方式：</h2><ol>
<li><p>正常的顶点修改，区间求和直接用</p>
</li>
<li><p><strong>区间修改，求单独一个数</strong> <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3368">P3368 【模板】树状数组 2 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>
<ul>
<li><p>树状数组是保存的每一个下标为位置的前缀和</p>
</li>
<li><p>想要求指定位置的数值需要用到差分,差分的前缀和就是每一个位置的数据大小</p>
</li>
<li><p>修改时只需要修改 update(l,val),update(r+1,-val)</p>
</li>
<li><p>初始化时，要插入的是差分</p>
  <pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;  
#include &lt;algorithm&gt;  
#define ll long long  
#define lowbit(x) (x&amp;(-x))  
using namespace std;  
const int mx = 10e5 + 5;  
int t[mx], m, n;  
int add(int x, int k) {  
	while (x &lt;= n) {  
		t[x] += k;  
		x += lowbit(x);  
	}  
}  
int query(int x){  
	ll ans=0;  
	while(x){  
		ans+=t[x];  
		x-=lowbit(x);  
	}  
	return ans;  
}  
//用差分来的前缀和来表示每一位置上的数字，  
//第一个数字之后，每次把差分加入，再求前缀和就能得到每一个位置上的数字是多少了  
//修改时只需要修改x和y+1两个位置的差分，但是我们用的tree是前缀和，所以依然要用把和lowbit有关的都修改 了   
int main() {  
	cin &gt;&gt; n &gt;&gt; m;  
	int cf=0;   
	for (int i = 1; i &lt;= n; i++) {  
		int num;  
		scanf("%d", &amp;num);  
		add(i,num-cf);  
		cf=num;  
	}  
	  
	for (int i = 1; i &lt;= m; i++) {  
		int ch, x, y,k;  
		scanf("%d", &amp;ch);  
		if (ch == 1){  
			scanf("%d %d %d", &amp;x, &amp;y, &amp;k);  
			add(x,k);  
			add(y+1,-k);  
		}  
		else {  
			int s;  
			scanf("%d", &amp;s);  
			printf("%d\n", query(s));  
		}  
	}  
	return 0;  
}  
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
</li>
<li><p>用指定数据替换某个数据，然后求和 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/range-sum-query-mutable/submissions/429237767/">307. 区域和检索 - 数组可修改 - 力扣（Leetcode）</a></p>
<ul>
<li><p>更换数据也是用到了差分，新的数据-原数据==要更新的val</p>
</li>
<li><p>然后更新之后，原数组指定位置也要更新，方便下次修改同一位置</p>
</li>
<li><p>其他正常食用即可</p>
  <pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class NumArray {  
    int []t;  
    int n;  
    int []nums;  
    int lowbit(int x){return x&amp;(-x);}  
    public NumArray(int[] nums) {  
        this.nums=nums;  
        n=nums.length;  
        t=new int[n+1];  
        int i=1;  
        for (int num:nums  
             ) {  
            add(i++,num);  
        }  
    }  
    void add(int index,int val){  
        while(index&lt;=n){  
            t[index]+=val;  
            index+=lowbit(index);  
        }  
    }  
    public void update(int index, int val) {  
        add(index+1,val-nums[index]);  
        nums[index]=val;  
    }  
      
    public int sumRange(int left, int right) {  
        int ans=0;  
        right++;  
        while(right&gt;0){  
            ans+=t[right];  
            right-=lowbit(right);  
        }  
  
        while(left&gt;0){  
            ans-=t[left];  
            left-=lowbit(left);  
        }  
        return ans;  
    }  
}  
  
/**  
 * Your NumArray object will be instantiated and called as such:  
 * NumArray obj = new NumArray(nums);  
 * obj.update(index,val);  
 * int param_2 = obj.sumRange(left,right);  
 */<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
</li>
</ol>
<p>求1的个数</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;algorithm&gt;  
#include &lt;vector&gt;  
#include &lt;iostream&gt;  
#define lowbit(x) (-x)&amp;x  
using namespace std;  
int main(){  
 &nbsp; &nbsp;int n,ans=0;  
 &nbsp; &nbsp;cin&gt;&gt;n;  
 &nbsp; &nbsp;while(n){  
 &nbsp; &nbsp; &nbsp; &nbsp;ans++;  
 &nbsp; &nbsp; &nbsp; &nbsp;n-=lowbit(n);  
 &nbsp;  }  
 &nbsp; &nbsp;cout&lt;&lt;ans&lt;&lt;endl;  
 &nbsp; &nbsp;return 0;  
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="离散化"><a href="#离散化" class="headerlink" title="离散化"></a>离散化</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">unique 返回的是下下标
vector&lt;int&gt; alls; // 存储所有待离散化的值  
sort(alls.begin(), alls.end()); // 将所有值排序  
alls.erase(unique(alls.begin(), alls.end()), alls.end()); &nbsp; // 去掉重复元素  
//配合erase 即可把放在后面的重复元素删除  
/*  
该函数的作用是“去除”容器或者数组中相邻元素的重复出现的元素  
(1) 这里的去除并非真正意义的erase，而是将重复的元素放到容器的末尾，返回值是去重之后的尾地址。   
(2) unique针对的是相邻元素，所以对于顺序顺序错乱的数组成员，或者容器成员，需要先进行排序，可以调用std::sort()函数  
// 二分求出x对应的离散化的值*/  
int find(int x) // 找到第一个大于等于x的位置  
{  
 &nbsp; &nbsp;int l = 0, r = alls.size() - 1;  
 &nbsp; &nbsp;while (l &lt; r)  
 &nbsp;  {  
 &nbsp; &nbsp; &nbsp; &nbsp;int mid = l + r &gt;&gt; 1;  
 &nbsp; &nbsp; &nbsp; &nbsp;if (alls[mid] &gt;= x) r = mid;  
 &nbsp; &nbsp; &nbsp; &nbsp;else l = mid + 1;  
 &nbsp;  }  
 &nbsp; &nbsp;return r + 1; // 映射到1, 2, ...n  
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="区间和并"><a href="#区间和并" class="headerlink" title="区间和并"></a>区间和并</h2><p>每次维护一个右端点</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">// 将所有存在交集的区间合并  
void merge(vector&lt;PII&gt; &amp;segs)  
{  
    vector&lt;PII&gt; res;  
  
    sort(segs.begin(), segs.end());//根据first进行排序，默认的就是这样的不需要进行自定义  
  
    int st = -2e9, ed = -2e9;  
    for (auto seg : segs)  
        if (ed &lt; seg.first)  
        {  
            //当起点的值大于右端点的时候，一段区间结束，可以继续下一段区间了  
            if (st != -2e9) res.push_back({st, ed});  
            st = seg.first, ed = seg.second;  
        }  g
        else ed = max(ed, seg.second);//如果左没大于右端点，那么右端点每次更新完为最大值  
  
    if (st != -2e9) res.push_back({st, ed});  
    segs = res;  
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="数组模拟链表"><a href="#数组模拟链表" class="headerlink" title="数组模拟链表"></a>数组模拟链表</h2><h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">
int head,e[N],ne[N],idx;  
void init(){  
    head=-1;  
    idx=0;  
}  
//头插  
//head 也是指针,e[idx] 新节点  
void add_head(int x){  
    e[idx]=x;//插入数据  
    ne[idx]=head;//idx 当前的位置的指针指向head指向的位置 -1  
    head=idx;//head 指针指向idx   
    idx++;  
}  
//插入任意位置  
void insert_linkedlist(int k,int x){  
    e[idx]=x;//建立新节点  
    ne[idx]=ne[k];//新节点指向k的下一个节点  
    ne[k]=ne[idx]; //k指向idx这个结点  
    idx++;  
}  
void delete_linkedlist(int k){  
    ne[k]=ne[ne[k]];  
}  
int main(){  
    int k,x,m;  
    char op;  
    cin&gt;&gt;m;  
    init();  
    while(m--){  
        cin&gt;&gt;op;  
        if(op=='h'){  
            cin&gt;&gt;x;  
            add_head(x);  
        }  
        else if(op=='d'){  
            cin&gt;&gt;k;  
            delete_linkedlist(k-1);  
        }  
        else {  
            cin&gt;&gt;k&gt;&gt;x;  
            insert_linkedlist(k-1,x);  
        }  
    }  
    for(int i=head;i!=-1;i=ne[i]){cout&lt;&lt;e[i]&lt;&lt;' ';}  
    return 0;  
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">// e[]表示节点的值，l[]表示节点的左指针，r[]表示节点的右指针，idx表示当前用到了哪个节点  
int e[N], l[N], r[N], idx;  
  
// 初始化  
void init()  
{  
    //0是左端点，1是右端点  
    r[0] = 1, l[1] = 0;  
    idx = 2;  
}  
  
// 在节点a的右边插入一个数x  
void insert(int a, int x)  
{  
    e[idx] = x;  
    l[idx] = a, r[idx] = r[a];  
    l[r[a]] = idx, r[a] = idx ++ ;  
}  
  
// 删除节点a  
void remove(int a)  
{  
    l[r[a]] = l[a];  
    r[l[a]] = r[a];  
}  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">// tt表示栈顶  
int stk[N], tt = 0;  
  
// 向栈顶插入一个数  
stk[ ++ tt] = x;  
  
// 从栈顶弹出一个数  
tt -- ;  
  
// 栈顶的值  
stk[tt];  
  
// 判断栈是否为空，如果 tt &gt; 0，则表示不为空  
if (tt &gt; 0)  
{  
  
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h2><p>注意这个题目要的是结果的下标不是具体的数据</p>
<p>用栈暴力模拟一遍，然后再考虑哪些元素没有用处，就可以排除</p>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P5788">P5788 【模板】单调栈 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;  
#include &lt;cstdio&gt;  
#define ll long long   
using namespace std;  
const ll N=3*1000000+1;  
ll stk[N],a[N],ans[N];  
int tt=0;  
int main(){  
    int n;  
    cin&gt;&gt;n;  
    for(int i=1;i&lt;=n;i++){  
        scanf("%lld",&amp;a[i]);  
    }  
    for(int i=n;i&gt;0;i--){  
        while(tt!=0&amp;&amp;a[i]&gt;=a[stk[tt]]) tt--;  
        ans[i]= tt==0?0:stk[tt];  
        stk[++tt]=i;  
    }  
    for(int i=1;i&lt;=n;i++)printf("%lld ",ans[i]);  
    return 0;  
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">// hh 表示队头，tt表示队尾  
int q[N], hh = 0, tt = -1;  
  
// 向队尾插入一个数  
q[ ++ tt] = x;  
  
// 从队头弹出一个数  
hh ++ ;  
  
// 队头的值  
q[hh];  
  
// 判断队列是否为空，如果 hh &lt;= tt，则表示不为空  
if (hh &lt;= tt)  
{  
  
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h1 id="单调队列-（好东西）"><a href="#单调队列-（好东西）" class="headerlink" title="单调队列 （好东西）"></a>单调队列 （好东西）</h1><p><strong>几个点：</strong></p>
<ul>
<li><p>初始化时，hh=0,tt=-1 使得队列为空</p>
</li>
<li><p>比较的是队尾元素与当前元素</p>
</li>
<li><p>注意队列长度为0时不要输出</p>
</li>
</ul>
<p>常见模型：找出滑动窗口中的最大值/最小值  </p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int hh = 0, tt = -1;  
for (int i = 0; i &lt; n; i ++ )  
{  
    while (hh &lt;= tt &amp;&amp; check_out(q[hh])) hh ++ ;  // 判断队头是否滑出窗口  
    while (hh &lt;= tt &amp;&amp; check(q[tt], i)) tt -- ;  
    q[ ++ tt] = i;  
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>例题</p>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1886">P1886 滑动窗口 /【模板】单调队列 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;  
#include &lt;cstdio&gt;  
#define ll long long   
using namespace std;  
const int N=1000000+2;  
int n,k,a[N],q[N],ans,hh,tt;  
  
int main(){  
    cin&gt;&gt;n&gt;&gt;k;  
    for(int i=0;i&lt;n;i++){  
        scanf("%d",&amp;a[i]);  
    }  
    //队列存的是下标  
    //最小值  
    hh=0;tt=-1;//目的是让队列初始化为空  
    for(int i=0;i&lt;n;i++){  
        //判断队列是否为空  
        if(hh&lt;=tt&amp;&amp;i-k+1&gt;q[hh]) hh++;  
        //目的是把最小的元素放在队头  
        while(hh&lt;=tt&amp;&amp;a[q[tt]]&gt;=a[i]) tt--;//从队尾删除，因为经过我们的处理，已经是严格单调递增的了，所以如果第一个都大于这个元素的话，那么后面几个都大于，所以要删除  
        q[++tt]=i;  
        if(i&gt;=k-1)  
        printf("%d ",a[q[hh]]);  
    }  
    cout&lt;&lt;endl;  
    //最大值  
      hh=0;tt=-1;  
    for(int i=0;i&lt;n;i++){  
        //判断队列是否为空  
        if(hh&lt;=tt&amp;&amp;i-k+1&gt;q[hh]) hh++;  
        //目的是把最大的元素放在队头  
        while(hh&lt;=tt&amp;&amp;a[q[tt]]&lt;=a[i]) tt--;  
        q[++tt]=i;  
        if(i&gt;=k-1)  
        printf("%d ",a[q[hh]]);  
    }  
      
    return 0;  
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h2><p>对称的 ,以j这个点为中点的前后缀是相同的，所以可以直接变成next[ j ]<br><img src="file://D:/typora%E7%94%A8%E5%9B%BE/Screenshots/image-20230511171657614.png?lastModify=1694256669" alt="image-20230511171657614"></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">s从1开始，p从0开始

// s[]是长文本，p[]是模式串，n是s的长度，m是p的长度  
求模式串的Next数组：ne[1]=0  ,一开始就错了肯定从零开始
for (int i = 2, j = 0; i &lt;= m; i ++ )  
{  
    while (j &amp;&amp; p[i] != p[j + 1]) j = ne[j];  
    if (p[i] == p[j + 1]) j ++ ;  
    ne[i] = j;  
}  
  
// 匹配  
for (int i = 1, j = 0; i &lt;= n; i ++ )  
{  
    while (j &amp;&amp; s[i] != p[j + 1]) j = ne[j];  
    if (s[i] == p[j + 1]) j ++ ;  
    if (j == m)  
    {  
        j = ne[j];  
        // 匹配成功后的逻辑  
    }  
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>例题</strong></p>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3375">P3375 【模板】KMP字符串匹配 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">
#include &lt;iostream&gt;  
#include &lt;cstring&gt;  
#define N 1000010  
using namespace std;  
char s[N],p[N];  
int ls,lp,ne[N];  
int main(){  
    cin&gt;&gt;s+1&gt;&gt;p+1;  
    ls=strlen(s+1);  
    lp=strlen(p+1);  
    for(int i=2,j=0;i&lt;=lp;i++){  
        while(j&amp;&amp;p[i]!=p[j+1]) j=ne[j];  
        if(p[j+1]==p[i]) j++;  
        ne[i]=j;  
    }  
     for(int i=1,j=0;i&lt;=ls;i++){  
        while(j&amp;&amp;s[i]!=p[j+1]) j=ne[j];  
        if(s[i]==p[j+1]) j++;  
        if(j==lp){  
            cout&lt;&lt;i-lp+1&lt;&lt;endl;  
            j=ne[j];  
        }  
    }  
    for(int i=1;i&lt;=lp;i++){  
        cout&lt;&lt;ne[i]&lt;&lt;" ";  
    }  
    return 0;  
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="Trie树-高效存储和查找字符串"><a href="#Trie树-高效存储和查找字符串" class="headerlink" title="Trie树 高效存储和查找字符串"></a>Trie树 高效存储和查找字符串</h2><p>集合的数据结构</p>
<p>将字符串分解为一个一个单独的字符然后存储，然后查询这个字符串是否出现过，</p>
<p>出现过几次</p>
<h4 id="更全面-的映射"><a href="#更全面-的映射" class="headerlink" title="更全面 的映射"></a>更全面 的映射</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int getnum(char x){  
    if(x&gt;='A'&amp;&amp;x&lt;='Z')  
        return x-'A';  
    else if(x&gt;='a'&amp;&amp;x&lt;='z')  
        return x -'a'+26;  
    else  
        return x-'0'+52;  
} 

#include&lt;iostream&gt;  
#include &lt;algorithm&gt;  
#include &lt;cstdio&gt;  
using namespace std;  
const int N=100010;  
int son[N][26],cnt[N],idx;//子子节点的个数，只包含26个 小写字母 cnt是以这个字母为结尾的单词出现了福哦少个  
//idx 当前用到哪了  
//插入操作  
char str[N];  
void insert(char str[]){  
 &nbsp; &nbsp;int p=0;//当前的结点  
 &nbsp; &nbsp;for(int i=0;str[i];i++){  
 &nbsp; &nbsp; &nbsp; &nbsp;int u=str[i]-'a';//将26个小写字母映射为数字  
 &nbsp; &nbsp; &nbsp; &nbsp;if(!son[p][u]) son[p][u]=++idx;  
 &nbsp; &nbsp; &nbsp; &nbsp;p=son[p][u];  
 &nbsp;  }  
 &nbsp; &nbsp;cnt[p]++;  
}  
int query(char str[]){  
 &nbsp; &nbsp;int p=0;  
 &nbsp; &nbsp;for(int i=0;str[i];i++){  
 &nbsp; &nbsp; &nbsp; &nbsp;int u=str[i]-'a';  
 &nbsp; &nbsp; &nbsp; &nbsp;if(!son[p][u]) return 0;  
 &nbsp; &nbsp; &nbsp; &nbsp;p=son[p][u];  
 &nbsp;  }  
 &nbsp; &nbsp;return cnt[p];  
}  
int main(){  
 &nbsp; &nbsp;int n;  
 &nbsp; &nbsp;cin&gt;&gt;n;  
 &nbsp; &nbsp;while(n--){  
 &nbsp; &nbsp; &nbsp; char op[2];  
 &nbsp; &nbsp; &nbsp; cin&gt;&gt;op&gt;&gt;str;  
 &nbsp; &nbsp; &nbsp; if(op[0]=='i') insert(str);  
 &nbsp; &nbsp; &nbsp; else cout&lt;&lt;query(str)&lt;&lt;endl;  
 &nbsp;  }  
 &nbsp; &nbsp;return 0;  
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P8306">P8306 【模板】字典树 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;  
#include &lt;algorithm&gt;  
#include &lt;cstdio&gt;  
#include &lt;cstring&gt;  
using namespace std;  
const int N=3000005;  
int son[N][65],cnt[N],idx;//子子节点的个数，只包含26个 小写字母 cnt是以这个字母位借位的单词出现了福哦少个  
//idx 当前用到哪了  
//插入操作  
 int n,m,t;  
char str[N];  
int hashs(char x){  
    if(x&gt;='A'&amp;&amp;x&lt;='Z')  
        return x-'A';  
    else if(x&gt;='a'&amp;&amp;x&lt;='z')  
        return x-'a'+26;  
    else  
        return x-'0'+52;  
}  
void insert(char str[]){  
    int p=0;//当前的结点  
    int l=strlen(str);  
    for(int i=0;i&lt;l;i++){  
        int u=hashs(str[i]);//将26个小写字母映射为数字  
        if(!son[p][u]) son[p][u]=++idx;  
        p=son[p][u];  
        cnt[p]++;  
    }  
      
}  
int query(char str[]){  
    int p=0;//当前的结点  
    int l=strlen(str);  
    for(int i=0;i&lt;l;i++){  
        int u =hashs(str[i]);  
        if(!son[p][u]) return 0;  
        p=son[p][u];  
    }  
    return cnt[p];  
}  
int main(){  
     
    cin&gt;&gt;t;  
    while(t--){  
          for(int i=0;i&lt;=idx;i++){  
            for(int j=0;j&lt;=122;j++){  
                son[i][j]=0;  
            }  
          }  
          for(int i=0;i&lt;=idx;i++)  
            cnt[i]=0;  
        idx=0;  
       scanf("%d%d",&amp;n,&amp;m);  
        while(n--){  
            scanf("%s",str);  
            insert(str);  
        }  
        while(m--){  
             scanf("%s",str);  
            printf("%d\n",query(str));  
        }  
    }  
    return 0;  
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><p>用法：</p>
<h3 id="某些点或者数据是否处于一个连通块中"><a href="#某些点或者数据是否处于一个连通块中" class="headerlink" title="某些点或者数据是否处于一个连通块中"></a>某些点或者数据是否处于一个连通块中</h3><ol>
<li><p>将两个集合合并</p>
</li>
<li><p>询问两个元素是否在一个集合中</p>
</li>
</ol>
<p>基本原理：每个集合用一个树来表示，树根的编号就是整个集合的编号，</p>
<p>每一个结点表示他的父节点p[x] 表示x的父节点</p>
<ul>
<li><p>判断树根: if（p[x]==x）</p>
</li>
<li><p>如何集合的编号： while(p[x]!=x) x=p[x];</p>
</li>
<li><p>如何合并两个集合直接让其中一个的根节点的父节点为另一个集合的根节点就行</p>
</li>
<li><p>如何优化，查询一次后，将将所经过的路径的父节点全都修改为根节点</p>
</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;  
#include &lt;algorithm&gt;  
#include &lt;cstdio&gt;  
#include &lt;cstring&gt;  
using namespace std;  
const int N=10010;  
int p[N];  
//初始每个点都是一个单独的集合  
void init(int n){  
    for(int i=1;i&lt;=n;i++){  
        p[i]=i;  
    }  
}  
int find(int x){  
    if(p[x]!=x) p[x]=find(p[x]);  
    return p[x];  
}  
  
int main(){  
    int n,m;  
    cin&gt;&gt;n&gt;&gt;m;  
    init(n);  
    char op[2];  
    while(m--){  
        int a,b;  
        cin&gt;&gt;op&gt;&gt;a&gt;&gt;b;  
        //合并两个集合,路径压缩  
        if(op[0]=='i') p[find(a)]=find(b);//让a的父节点等于b的父节点，即可合并  
        else {  
            //查询  
            if(find(a)==find(b)) cout&lt;&lt;"yes"&lt;&lt;endl;  
            else cout&lt;&lt;"no"&lt;&lt;endl;  
        }  
    }  
    return 0;  
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3367">P3367 【模板】并查集 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>
<p>维护点的数量：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;  
#include &lt;algorithm&gt;  
#include &lt;cstdio&gt;  
#include &lt;cstring&gt;  
using namespace std;  
const int N=10010;  
int p[N],sizes[N];//每个集合中点的数量  
//初始每个点都是一个单独的集合  
void init(int n){  
    for(int i=1;i&lt;=n;i++){  
        p[i]=i;  
        sizes[i]=1;  
    }  
}  
int find(int x){  
    if(p[x]!=x) p[x]=find(p[x]);  
    return p[x];  
}  
  
int main(){  
    int n,m;  
    cin&gt;&gt;n&gt;&gt;m;  
    init(n);  
    int op;  
    while(m--){  
        int a,b;  
        cin&gt;&gt;op;  
        //合并两个集合,路径压缩  
        if(op==1){  
            cin&gt;&gt;a&gt;&gt;b;  
            if(find(a)==find(b)) continue;  
            sizes[find(b)]+=sizes[find(a)];  
            p[find(a)]=find(b);//让a的父节点等于b的父节点，即可合并  
      
        }  
        else if(op==2){  
            //查询  
            cin&gt;&gt;a&gt;&gt;b;  
            if(find(a)==find(b)) cout&lt;&lt;"Y"&lt;&lt;endl;  
            else cout&lt;&lt;"N"&lt;&lt;endl;  
        }  
        else {  
            //询问某个集合中点的数量  
            cin&gt;&gt;n;  
            cout&lt;&lt;sizes[find(a)]&lt;&lt;endl;  
        }  
    }  
    return 0;  
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="堆-只能保证堆顶是最值，保证不了左右两边的大小关系"><a href="#堆-只能保证堆顶是最值，保证不了左右两边的大小关系" class="headerlink" title="堆 只能保证堆顶是最值，保证不了左右两边的大小关系"></a>堆 只能保证堆顶是最值，保证不了左右两边的大小关系</h2><p>操作：down 和up 把元素向下或向上走，使用的是一维数组，x的左儿子2x,右儿子2x+1</p>
<p>size 表示数组的最后一个位置</p>
<ol>
<li><p>插入一个元素： heap[++size]=x up(size)</p>
</li>
<li><p>求最小值 heap[1]</p>
</li>
<li><p>删除最小值 数组尾部好删除，所以用最后一个元素覆盖数组的头，然后执行down，</p>
<p> 再删除尾部，head[k]=heap[size];size–; down(k)||up(k)</p>
</li>
<li><p>修改 heap[k]=k; down(k)||up(k);</p>
</li>
</ol>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">// h[N]存储堆中的值, h[1]是堆顶，x的左儿子是2x, 右儿子是2x + 1  
// ph[k]存储第k个插入的点在堆中的位置  
// hp[k]存储堆中下标是k的点是第几个插入的  
int h[N], ph[N], hp[N], size;  
  
// 交换两个点，及其映射关系  
void heap_swap(int a, int b)  
{  
    swap(ph[hp[a]],ph[hp[b]]);  
    swap(hp[a], hp[b]);  
    swap(h[a], h[b]);  
}  
  
void down(int u)  
{  
    int t = u;  
    //查找到三个结点中的最小值  
    if (u * 2 &lt;= size &amp;&amp; h[u * 2] &lt; h[t]) t = u * 2;  
    if (u * 2 + 1 &lt;= size &amp;&amp; h[u * 2 + 1] &lt; h[t]) t = u * 2 + 1;  
    if (u != t)  
    {  
        heap_swap(u, t);  
        down(t);  
    }  
}  
  
void up(int u)  
{  
    while (u / 2 &amp;&amp; h[u] &lt; h[u / 2])//父节点存在且当前结点小于父节点   
    {  
        heap_swap(u, u / 2);  
        u &gt;&gt;= 1;//下一个父节点  
    }  
}  
  
// O(n)建堆  
for (int i = n / 2; i; i -- ) down(i);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3378">P3378 【模板】堆 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits/stdc++.h&gt;  
using namespace std;  
const int N=1000001;  
int h[N],s;  
void down(int u){  
    int t=u;  
    if(u*2&lt;=s&amp;&amp;h[u*2]&lt;h[t]) t=u*2;  
    if(u*2+1&lt;=s&amp;&amp;h[u*2+1]&lt;h[t]) t=u*2+1;  
    if(u!=t){  
        swap(h[u],h[t]);  
        down(t);  
    }  
}  
void up(int u){  
    while(u/2&amp;&amp;h[u]&lt;h[u/2]){  
        swap(h[u],h[u/2]);  
        u&gt;&gt;=1;  
    }  
}  
int main(){  
    int n,op;  
    cin&gt;&gt;n;  
    for(int i=n/2;i;i--){  
        down(i);  
    }  
    while(n--){  
        scanf("%d",&amp;op);  
        if(op==1) {  
            int x;  
            scanf("%d",&amp;x);  
            h[++s]=x;  
            up(s);  
        }  
        else if(op==2){  
            printf("%d\n",h[1]);  
        }  
        else {  
            //最后一个换到第一个  
            swap(h[1],h[s]);  
            s--;//删除最后一个  
            down(1);  
        }  
    }  
  
}
			<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h2><p>删除的话打个标记<br>(1) 拉链法 </p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int h[N], e[N], ne[N], idx;  
  
// 向哈希表中插入一个数  
void insert(int x)  
{  
    int k = (x % N + N) % N;  
    e[idx] = x;  
    ne[idx] = h[k];  
    h[k] = idx ++ ;  
}  
  
// 在哈希表中查询某个数是否存在  
bool find(int x)  
{  
    int k = (x % N + N) % N;  
    for (int i = h[k]; i != -1; i = ne[i])  
        if (e[i] == x)  
            return true;  
  
    return false;  
}  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>开放寻址法，遇到冲突的话直接往后找没用的节点</p>
<p>数组要开比原来数据范围大2~3倍</p>
<p>//只要开一个h数组就可以了，不需要e和ne了，找一个不在数据范围内的数据来表示当前位置为空<br>(2) 开放寻址法  </p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">   int h[N];  
const int null =xxx;  
   // 如果x在哈希表中，返回x的下标；如果x不在哈希表中，返回x应该插入的位置  
   int find(int x)  
   {  
       int t = (x % N + N) % N;  
       while (h[t] != null &amp;&amp; h[t] != x)  
       {  
           t ++ ;  
           if (t == N) t = 0;  
       }  
       return t;  
   }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="字符串哈希"><a href="#字符串哈希" class="headerlink" title="字符串哈希"></a>字符串哈希</h3><p>快速判断两个字符串是否相等</p>
<p>核心思想：将字符串看成P进制数，P的经验值是131或13331，取这两个值的冲突概率低<br>小技巧：取模的数用2^64，这样直接用unsigned long long存储，溢出的结果就是取模的结果  </p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">typedef unsigned long long ULL;  
ULL h[N], p[N]; // h[k]存储字符串前k个字母的哈希值, p[k]存储 P^k mod 2^64  
  
// 初始化  
p[0] = 1;  
for (int i = 1; i &lt;= n; i ++ )  
{  
    h[i] = h[i - 1] * P + str[i];  
    p[i] = p[i - 1] * P;//P存储的是每一位的基数值  
}  
  
// 计算子串 str[l ~ r] 的哈希值  
ULL get(int l, int r)  
{  
    return h[r] - h[l - 1] * p[r - l + 1];  
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="STL常用"><a href="#STL常用" class="headerlink" title="STL常用"></a>STL常用</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">vector, 变长数组，倍增的思想 &nbsp;优化思路：减少申请空间的次数  
 &nbsp; &nbsp;size() &nbsp;返回元素个数  
 &nbsp; &nbsp;empty() &nbsp;返回是否为空  
 &nbsp; &nbsp;clear() &nbsp;清空  
 &nbsp; &nbsp;front()/back()  
 &nbsp; &nbsp;push_back()/pop_back()  
 &nbsp; &nbsp;begin()/end()  
 &nbsp;  []  
 &nbsp; &nbsp;支持比较运算，按字典序  
 &nbsp; &nbsp;vector&lt;int&gt; a(1,2),b(3,4);  
printf(a&lt;b) == 0  
​  
pair&lt;int, int&gt;  
 &nbsp; &nbsp;first, 第一个元素  
 &nbsp; &nbsp;second, 第二个元素  
 &nbsp; &nbsp;支持比较运算，以first为第一关键字，以second为第二关键字（字典序）  
​  
string，字符串  
 &nbsp; &nbsp;size()/length() &nbsp;返回字符串长度  
 &nbsp; &nbsp;empty()  
 &nbsp; &nbsp;clear()  
 &nbsp; &nbsp;substr(起始下标，(子串长度)) &nbsp;返回子串  
 &nbsp; &nbsp;c_str() &nbsp;返回字符串所在字符数组的起始地址  
​  
queue, 队列  
 &nbsp; &nbsp;size()  
 &nbsp; &nbsp;empty()  
 &nbsp; &nbsp;push() &nbsp;向队尾插入一个元素  
 &nbsp; &nbsp;front() &nbsp;返回队头元素  
 &nbsp; &nbsp;back() &nbsp;返回队尾元素  
 &nbsp; &nbsp;pop() &nbsp;弹出队头元素  
​  
priority_queue, 优先队列，默认是大根堆  
 &nbsp; &nbsp;size()  
 &nbsp; &nbsp;empty()  
 &nbsp; &nbsp;push() &nbsp;插入一个元素  
 &nbsp; &nbsp;top() &nbsp;返回堆顶元素  
 &nbsp; &nbsp;pop() &nbsp;弹出堆顶元素  
 &nbsp; &nbsp;定义成小根堆的方式：priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; q;  
​  
stack, 栈  
 &nbsp; &nbsp;size()  
 &nbsp; &nbsp;empty()  
 &nbsp; &nbsp;push() &nbsp;向栈顶插入一个元素  
 &nbsp; &nbsp;top() &nbsp;返回栈顶元素  
 &nbsp; &nbsp;pop() &nbsp;弹出栈顶元素  
​  
deque, 双端队列  
 &nbsp; &nbsp;size()  
 &nbsp; &nbsp;empty()  
 &nbsp; &nbsp;clear()  
 &nbsp; &nbsp;front()/back()  
 &nbsp; &nbsp;push_back()/pop_back()  
 &nbsp; &nbsp;push_front()/pop_front()  
 &nbsp; &nbsp;begin()/end()  
 &nbsp;  []  
​  
set, map, multiset, multimap, 基于平衡二叉树（红黑树），动态维护有序序列  
 &nbsp; &nbsp;size()  
 &nbsp; &nbsp;empty()  
 &nbsp; &nbsp;clear()  
 &nbsp; &nbsp;begin()/end()  
 &nbsp; &nbsp;++, -- 返回前驱和后继，时间复杂度 O(logn)  
​  
 &nbsp; &nbsp;set/multiset  
 &nbsp; &nbsp; &nbsp; &nbsp;insert() &nbsp;插入一个数  
 &nbsp; &nbsp; &nbsp; &nbsp;find() &nbsp;查找一个数  
 &nbsp; &nbsp; &nbsp; &nbsp;count() &nbsp;返回某一个数的个数  
 &nbsp; &nbsp; &nbsp; &nbsp;erase()  
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  (1) 输入是一个数x，删除所有x &nbsp; O(k + logn)  
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  (2) 输入一个迭代器，删除这个迭代器  
 &nbsp; &nbsp; &nbsp; &nbsp;lower_bound()/upper_bound()  
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;lower_bound(x) &nbsp;返回大于等于x的最小的数的迭代器  
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;upper_bound(x) &nbsp;返回大于x的最小的数的迭代器  
 &nbsp; &nbsp;map/multimap  
 &nbsp; &nbsp; &nbsp; &nbsp;insert() &nbsp;插入的数是一个pair  
 &nbsp; &nbsp; &nbsp; &nbsp;erase() &nbsp;输入的参数是pair或者迭代器  
 &nbsp; &nbsp; &nbsp; &nbsp;find()  
 &nbsp; &nbsp; &nbsp;  [] &nbsp;注意multimap不支持此操作。 时间复杂度是 O(logn)  
 &nbsp; &nbsp; &nbsp; &nbsp;lower_bound()/upper_bound()  
​  
unordered_set, unordered_map, unordered_multiset, unordered_multimap, 哈希表  
 &nbsp; &nbsp;和上面类似，增删改查的时间复杂度是 O(1)  
 &nbsp; &nbsp;不支持 lower_bound()/upper_bound()， 迭代器的++，--  
​  
bitset, 圧位 省空间 &nbsp; &nbsp;  
 &nbsp; &nbsp;bitset&lt;10000&gt; s; &nbsp;//&lt; &gt;里面是个数, 可以用来替代bool 数组  
    //以下操作都支持  
    ~, &amp;, |, ^  
 &nbsp; &nbsp;&gt;&gt;, &lt;&lt;  
 &nbsp; &nbsp;==, !=  
 &nbsp;  []  
​  
 &nbsp; &nbsp;count() &nbsp;返回有多少个1  
​  
 &nbsp; &nbsp;any() &nbsp;判断是否至少有一个1  
 &nbsp; &nbsp;none() &nbsp;判断是否全为0  
​  
 &nbsp; &nbsp;set() &nbsp;把所有位置成1  
 &nbsp; &nbsp;set(k, v) &nbsp;将第k位变成v  
 &nbsp; &nbsp;reset() &nbsp;把所有位变成0  
 &nbsp; &nbsp;flip() &nbsp;等价于~  
 &nbsp; &nbsp;flip(k) 把第k位取反  
​<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="图论背思路"><a href="#图论背思路" class="headerlink" title="图论背思路"></a>图论背思路</h2><h2 id="BFS和DFS"><a href="#BFS和DFS" class="headerlink" title="BFS和DFS"></a>BFS和DFS</h2><h3 id="非常完美的一道dfs-并查集-https-www-luogu-com-cn-problem-P1127"><a href="#非常完美的一道dfs-并查集-https-www-luogu-com-cn-problem-P1127" class="headerlink" title="非常完美的一道dfs + 并查集 https://www.luogu.com.cn/problem/P1127"></a>非常完美的一道dfs + 并查集 <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1127">https://www.luogu.com.cn/problem/P1127</a></h3><p><u>还原现场很重要</u> </p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span> start<span class="token punctuation">,</span><span class="token keyword">int</span> num<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>num <span class="token operator">==</span> n<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
		<span class="token comment">//开始搜索</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			<span class="token comment">//找start这个开头的string</span>
			<span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token char">'a'</span> <span class="token operator">==</span> start <span class="token operator">&amp;&amp;</span> st<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
				<span class="token comment">//标记</span>
				st<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
				ans<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">dfs</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token char">'a'</span><span class="token punctuation">,</span>num<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
				<span class="token comment">//还原现场</span>
				st<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
				ans<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>ans<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			
		<span class="token punctuation">}</span>
		<span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="DFS-回溯的时候记得回复现场"><a href="#DFS-回溯的时候记得回复现场" class="headerlink" title="DFS 回溯的时候记得回复现场"></a>DFS 回溯的时候记得回复现场</h3><h3 id="邻接矩阵：-p-a-b-a-gt-b-适合稠密图"><a href="#邻接矩阵：-p-a-b-a-gt-b-适合稠密图" class="headerlink" title="邻接矩阵： p[ a] [ b ] a -> b 适合稠密图"></a>邻接矩阵： p[ a] [ b ] a -&gt; b 适合稠密图</h3><h3 id="邻接表：-稀疏图"><a href="#邻接表：-稀疏图" class="headerlink" title="邻接表： 稀疏图"></a>邻接表： 稀疏图</h3><p>和哈希表思路一样</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">// 对于每个点k，开一个单链表，存储k所有可以走到的点。h[k]存储这个单链表的头结点  
int h[N], e[N], ne[N], idx; //e是终点end  
  
// 添加一条边a-&gt;b  
void add(int a, int b)  
{  
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;  
}   
// 初始化  
idx = 0;  
memset(h, -1, sizeof h);  
//遍历图  
for(int i = h[t] ; i != -1 ; i = ne[i] )

## 另一种使用结构体的邻接表存法

int idx=0,n;  
int h[N] , dis[N] , vis[N];  
struct Edge{  
    int ne,to,dis;  
}ed[N];  
//添加， 从 1 开始  
void add(int a,int b ,int c){  
    ed[++idx].ne = h[a];  
    ed[idx].to = b;  
    ed[idx].dis = c;  
    h[a] = idx;  
}
//遍历图  
for(int i = h[t] ; i ; i = ed[i].ne)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="BFS-可用于解决权值相等的最短路径问题"><a href="#BFS-可用于解决权值相等的最短路径问题" class="headerlink" title="BFS 可用于解决权值相等的最短路径问题"></a>BFS 可用于解决权值相等的最短路径问题</h3><h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><p>必须是又向无环</p>
<p>排完后，所有的起点都在终点之前</p>
<ol>
<li><p>统计每一个节点的入度和出度</p>
</li>
<li><p>每一次将入读相同的点放入queue</p>
</li>
<li><p>枚举队头的出边，删掉 出边,这条边的终点的入度-1</p>
</li>
<li><p>如果某个点的入度为0 放入队列</p>
</li>
</ol>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">bool topsort()  
{  
    int hh = 0, tt = -1;  
  
    // d[i] 存储点i的入度  
    for (int i = 1; i &lt;= n; i ++ )  
        if (!d[i])  
            q[ ++ tt] = i;//把每个入度为0的点加入队列  
  
    while (hh &lt;= tt)  
    {  
        int t = q[hh ++ ];//取出队头  
		//从队头开始找路径  
        for (int i = h[t]; i != -1; i = ne[i])  
        {  
            int j = e[i];  
            if (-- d[j] == 0)  
                q[ ++ tt] = j;  
        }  
    }  
  
    // 如果所有点都入队了，说明存在拓扑序列；否则不存在拓扑序列。  
    return tt == n - 1;  
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="最短路问题："><a href="#最短路问题：" class="headerlink" title="最短路问题："></a>最短路问题：</h2><h2 id="分层最短路-，适用于乘车路线和免费次数。"><a href="#分层最短路-，适用于乘车路线和免费次数。" class="headerlink" title="_分层最短路_，适用于乘车路线和免费次数。"></a>_分层最短路_，适用于乘车路线和免费次数。</h2><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P4568#submit">飞机路线</a></p>
<h3 id="单源最短路-一个点-x2F-到其他所有点的最短路"><a href="#单源最短路-一个点-x2F-到其他所有点的最短路" class="headerlink" title="单源最短路 一个点./.到其他所有点的最短路"></a>单源最短路 一个点./.到其他所有点的最短路</h3><ul>
<li><p>所有边的权都是正数</p>
<ol>
<li>朴素Dijkstra O(n^2) n为点的数量 稠密图 边很多 外部迭代n-1 次 <pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int g[N][N];  // 存储每条边  权值  
int dist[N];  // 存储1号点到每个点的最短距离  
bool st[N];   // 存储每个点的最短路是否已经确定  
  
// 求1号点到n号点的最短路，如果不存在则返回-1  
int dijkstra()  
{  
    memset(dist, 0x3f, sizeof dist);  
    dist[1] = 0;  
  
    for (int i = 0; i &lt; n - 1; i ++ )//迭代n-1 次，因为上来选中了一个点  
    {  
        int t = -1;     // 在还未确定最短路的点中，寻找距离最小的点  
        for (int j = 1; j &lt;= n; j ++ )  
            if (!st[j] &amp;&amp; (t == -1 || dist[t] &gt; dist[j]))  
                t = j;  
  
        // 用t更新其他点的距离  
        for (int j = 1; j &lt;= n; j ++ )  
            dist[j] = min(dist[j], dist[t] + g[t][j]);  
  
        st[t] = true;  
    }  
  
    if (dist[n] == 0x3f3f3f3f) return -1;  
    return dist[n];  
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li>堆优化版的 O(mlogn) 稀疏图  <pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">typedef pair&lt;int, int&gt; PII;  
  
int n;      // 点的数量  
int h[N], w[N], e[N], ne[N], idx;       // 邻接表存储所有边  
int dist[N];        // 存储所有点到1号点的距离  
bool st[N];     // 存储每个点的最短距离是否已确定  
  
// 求1号点到n号点的最短距离，如果不存在，则返回-1  
int dijkstra()  
{  
    memset(dist, 0x3f, sizeof dist);  
    dist[1] = 0;  
    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;  
    heap.push({0, 1});      // first存储距离，second存储节点编号  
  
    while (heap.size())  
    {  
        auto t = heap.top();  
        heap.pop();  
  
        int ver = t.second, distance = t.first;  
  
        if (st[ver]) continue;  
        st[ver] = true;  
  
        for (int i = h[ver]; i != -1; i = ne[i])  
        {  
            int j = e[i];  
            if (dist[j] &gt; distance + w[i])  
            {  
                dist[j] = distance + w[i];  
                heap.push({dist[j], j});  
            }  
        }  
    }  
  
    if (dist[n] == 0x3f3f3f3f) return -1;  
    return dist[n];  
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ol>
</li>
<li><p>存在负权边</p>
<ol>
<li><p>Bellman -Ford O(nm) <strong>奇妙的存图方式</strong> 无负权回路 经过路径有次数限制的话只能用这个了，外面限制的是经过i的点的个数，然后每次遍历边即可。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int n, m;       // n表示点数，m表示边数  
int dist[N];        // dist[x]存储1到x的最短路距离  
  
struct Edge     // 边，a表示出点，b表示入点，w表示边的权重  
{  
    int a, b, w;  
}edges[M];  
  
// 求1到n的最短路距离，如果无法从1走到n，则返回-1。  
int bellman_ford()  
{  
    memset(dist, 0x3f, sizeof dist);  
    dist[1] = 0;  
	//不需要进行收录顶点  
    // 如果第n次迭代仍然会松弛三角不等式，就说明存在一条长度是n+1的最短路径，由抽屉原理，路径中至少存在两个相同的点，说明图中存在负权回路。  
    for (int i = 0; i &lt; n; i ++ )//这个n是指的是最多不经过 多少次经过同一条边  
    {  
        for (int j = 0; j &lt; m; j ++ )  
        {  
            int a = edges[j].a, b = edges[j].b, w = edges[j].w;  
            if (dist[b] &gt; dist[a] + w)  
                dist[b] = dist[a] + w;  
        }  
    }  
  
    if (dist[n] &gt; 0x3f3f3f3f / 2) return -1;  
    return dist[n];  
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><p>SPFA 一般： O（m) 最坏O（nm） 不存在负权环才能使用 99%都没有负环比较好用</p>
<p> 优化思路：只有更新过点才对后面的点更新有影响</p>
<p> 要从 1 开始存比较好 ，e 是end 也就是一条边的终点</p>
 <pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int n;      // 总点数  
int h[N], w[N], e[N], ne[N], idx;       // 邻接表存储所有边  
int dist[N];        // 存储每个点到1号点的最短距离  
bool st[N];     // 存储每个点是否在队列中  
  
  
// 求x号点到n号点的最短路距离，如果从1号点无法走到n号点则返回-1  
int spfa(int x)  
{  
    memset(dist, 0x3f, sizeof dist);//初始化要根据题目来  
      
    dist[x] = 0;  
/*或者  
for(int i = 1 ; i &lt;= n ; i ++){  
        dis[i] = INT_MAX;  
    }*/	  
    queue&lt;int&gt; q;  
    q.push(x);  
  
    while (q.size())//不为空，即为还有更新的点  
    {  
        auto t = q.front();  
        q.pop();  
  
        st[t] = false;//这里不要忘记  
       //遍历所以能到达的顶点，进行更新  
        for (int i = h[t]; i != -1; i = ne[i])  
        {  
            int j = e[i];  
            if (dist[j] &gt; dist[t] + w[i])  
            {  
                dist[j] = dist[t] + w[i];  
                if (!st[j])     // 如果队列中已存在j，则不需要将j重复插入  
                {  
                    q.push(j);//这里是j  
                    st[j] = true;//这里是j  
                }  
            }  
        }  
    }  
  
    if (dist[n] == 0x3f3f3f3f) return -1;  
    return dist[n];  
}  
//初始化和存图  
void add(int a, int b , int c){  
    w[idx] = c;  
    ne[idx] = h[a];   
    en[idx] =  b;    
    h[a] = idx++;  
}  
void init(){  
    idx = 1;  
    memset(h , -1 ,sizeof h);  
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="模板题："><a href="#模板题：" class="headerlink" title="模板题："></a>模板题：</h4><p> <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3371">P3371 【模板】单源最短路径（弱化版） - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>
</li>
</ol>
</li>
</ul>
<h2 id="x3D-x3D-判断有无负环-用cnt-来记录当前最短路的边数"><a href="#x3D-x3D-判断有无负环-用cnt-来记录当前最短路的边数" class="headerlink" title="==判断有无负环 用cnt 来记录当前最短路的边数"></a>==<strong>判断有无负环 用cnt 来记录当前最短路的边数</strong></h2><p>例题： <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3385">负环路</a></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int n;      // 总点数  
int h[N], w[N], e[N], ne[N], idx;       // 邻接表存储所有边  
int dist[N], cnt[N];        // dist[x]存储1号点到x的最短距离，cnt[x]存储1到x的最短路中经过的点数  
bool st[N];     // 存储每个点是否在队列中  
  
// 如果存在负环，则返回true，否则返回false。  
bool spfa()  
{  
    // 不需要初始化dist数组  
    // 原理：如果某条最短路径上有n个点（除了自己），那么加上自己之后一共有n+1个点，由抽屉原理一定有两个点相同，所以存在环。  
  
    queue&lt;int&gt; q;  
    for (int i = 1; i &lt;= n; i ++ )  
    {  
        q.push(i);  
        st[i] = true;  
    }  
  
    while (q.size())  
    {  
        auto t = q.front();  
        q.pop();  
  
        st[t] = false;  
  
        for (int i = h[t]; i != -1; i = ne[i])  
        {  
            int j = e[i];  
            if (dist[j] &gt; dist[t] + w[i])  
            {  
                dist[j] = dist[t] + w[i];  
                cnt[j] = cnt[t] + 1;  
                if (cnt[j] &gt;= n) return true;       // 如果从1号点到x的最短路中包含至少n个点（不包括自己），则说明存在环  
                if (!st[j])  
                {  
                    q.push(j);  
                    st[j] = true;  
                }  
            }  
        }  
    }  
  
    return false;  
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="多源汇最短路-起点终点都不确定"><a href="#多源汇最短路-起点终点都不确定" class="headerlink" title="多源汇最短路 起点终点都不确定"></a>多源汇最短路 起点终点都不确定</h3><p>Floyd O(n^3)</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">初始化：  
 &nbsp; &nbsp;for (int i = 1; i &lt;= n; i ++ )  
 &nbsp; &nbsp; &nbsp; &nbsp;for (int j = 1; j &lt;= n; j ++ )  
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if (i == j) d[i][j] = 0;  
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;else d[i][j] = INF;  
​  
// 算法结束后，d[a][b]表示a到b的最短距离  
void floyd()  
{  
 &nbsp; &nbsp;for (int k = 1; k &lt;= n; k ++ )  
 &nbsp; &nbsp; &nbsp; &nbsp;for (int i = 1; i &lt;= n; i ++ )  
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;for (int j = 1; j &lt;= n; j ++ )  
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;d[i][j] = min(d[i][j], d[i][k] + d[k][j]);// i经过k 点到达j   
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><h3 id="普利姆算法-Prim-思路和Dijsktra算法相似-外部迭代-n-次，因为没有提前选中一个点"><a href="#普利姆算法-Prim-思路和Dijsktra算法相似-外部迭代-n-次，因为没有提前选中一个点" class="headerlink" title="普利姆算法 Prim 思路和Dijsktra算法相似 外部迭代 n 次，因为没有提前选中一个点"></a>普利姆算法 Prim 思路和Dijsktra算法相似 外部迭代 n 次，因为没有提前选中一个点</h3><h3 id="迭代n次因为没有提前选中一个点-枚举所有点"><a href="#迭代n次因为没有提前选中一个点-枚举所有点" class="headerlink" title="迭代n次因为没有提前选中一个点 枚举所有点"></a>迭代n次因为没有提前选中一个点 枚举所有点</h3><ol>
<li><p>朴素Prim算法 稠密图 每次找到未收录的距离最近的点，收录并进行更新其他点到<strong>集合</strong>的距离</p>
</li>
<li><p>找这个点是否与集合内部相连</p>
</li>
<li><p>某个点到这个集合的距离为某个点到这个集合当中的点的距离最短的边</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int n; &nbsp; &nbsp; &nbsp;// n表示点数  
int g[N][N]; &nbsp; &nbsp; &nbsp; &nbsp;// 邻接矩阵，存储所有边  
int dist[N]; &nbsp; &nbsp; &nbsp; &nbsp;// 存储其他点到当前最小生成树的距离  
bool st[N]; &nbsp; &nbsp; // 存储每个点是否已经在生成树中  
​  
​  
// 如果图不连通，则返回INF(值是0x3f3f3f3f), 否则返回最小生成树的树边权重之和  
int prim()  
{  
 &nbsp; &nbsp;memset(dist, 0x3f, sizeof dist);  
​  
 &nbsp; &nbsp;int res = 0;  
 &nbsp; &nbsp;for (int i = 0; i &lt; n; i ++ )  
 &nbsp;  {  
 &nbsp; &nbsp; &nbsp; &nbsp;int t = -1;  
 &nbsp; &nbsp; &nbsp; &nbsp;for (int j = 1; j &lt;= n; j ++ )  
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if (!st[j] &amp;&amp; (t == -1 || dist[t] &gt; dist[j]))  
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;t = j;  
​  
 &nbsp; &nbsp; &nbsp; &nbsp;if (i &amp;&amp; dist[t] == INF) return INF;  
​  
 &nbsp; &nbsp; &nbsp; &nbsp;if (i) res += dist[t];  
 &nbsp; &nbsp; &nbsp; &nbsp;st[t] = true;  
​  
 &nbsp; &nbsp; &nbsp; &nbsp;for (int j = 1; j &lt;= n; j ++ ) dist[j] = min(dist[j], g[t][j]);  
 &nbsp; &nbsp; &nbsp; &nbsp;//不是相加  
 &nbsp;  }  
​  
 &nbsp; &nbsp;return res;  
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>堆优化版的Prim 稀疏图 不常用</p>
</li>
</ol>
<h3 id="克鲁斯卡尔算法-Kruskal-先对边进行排序-稀疏图-可以用并查集-枚举所有边"><a href="#克鲁斯卡尔算法-Kruskal-先对边进行排序-稀疏图-可以用并查集-枚举所有边" class="headerlink" title="克鲁斯卡尔算法 Kruskal 先对边进行排序 稀疏图 可以用并查集 枚举所有边"></a>克鲁斯卡尔算法 Kruskal 先对边进行排序 稀疏图 可以用并查集 枚举所有边</h3><p>java版本:</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">bronya</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token operator">*</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>math<span class="token punctuation">.</span></span><span class="token class-name">BigInteger</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token operator">*</span></span><span class="token punctuation">;</span>


<span class="token keyword">class</span> <span class="token class-name">Edge</span> <span class="token punctuation">{</span>
	<span class="token keyword">int</span> a <span class="token punctuation">,</span> b <span class="token punctuation">,</span> w<span class="token punctuation">;</span>
	<span class="token keyword">public</span> <span class="token class-name">Edge</span><span class="token punctuation">(</span><span class="token keyword">int</span> a <span class="token punctuation">,</span> <span class="token keyword">int</span> b <span class="token punctuation">,</span> <span class="token keyword">int</span> w<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">this</span><span class="token punctuation">.</span>a <span class="token operator">=</span> a<span class="token punctuation">;</span>
		<span class="token keyword">this</span><span class="token punctuation">.</span>b <span class="token operator">=</span> b<span class="token punctuation">;</span>
		<span class="token keyword">this</span><span class="token punctuation">.</span>w <span class="token operator">=</span> w<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span><span class="token punctuation">{</span>

	<span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token class-name">N</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token number">2</span> <span class="token operator">*</span> <span class="token number">1e5</span> <span class="token operator">+</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">static</span> <span class="token keyword">int</span> n <span class="token punctuation">,</span> m <span class="token punctuation">;</span>
	<span class="token keyword">static</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token keyword">static</span> <span class="token class-name">Edge</span><span class="token punctuation">[</span><span class="token punctuation">]</span> ed <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Edge</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token keyword">static</span> <span class="token keyword">long</span> ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>x <span class="token operator">!=</span> p<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">)</span> p<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>p<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span> p<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">check</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n <span class="token punctuation">;</span>  i <span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			p<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>ed<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>m<span class="token punctuation">,</span><span class="token punctuation">(</span>e1<span class="token punctuation">,</span>e2<span class="token punctuation">)</span><span class="token operator">-&gt;</span>e1<span class="token punctuation">.</span>w <span class="token operator">-</span> e2<span class="token punctuation">.</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">int</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
		<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m <span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			<span class="token keyword">int</span> a <span class="token operator">=</span> ed<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>a<span class="token punctuation">;</span>
			<span class="token keyword">int</span> b <span class="token operator">=</span> ed<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>b<span class="token punctuation">;</span>
			<span class="token keyword">int</span> w <span class="token operator">=</span> ed<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>w<span class="token punctuation">;</span>
			a <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
			b <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">if</span><span class="token punctuation">(</span>a <span class="token operator">!=</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
				p<span class="token punctuation">[</span>a<span class="token punctuation">]</span> <span class="token operator">=</span> b<span class="token punctuation">;</span>
				ans <span class="token operator">+=</span> w<span class="token punctuation">;</span>
				cnt <span class="token operator">++</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>cnt <span class="token operator">&lt;</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
		<span class="token keyword">else</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">{</span>
		<span class="token class-name">BufferedReader</span> re <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> s <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		n <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		m <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span>  i <span class="token operator">&lt;</span> m <span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			s <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">int</span> w <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			ed<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Edge</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> w<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">boolean</span> f <span class="token operator">=</span> <span class="token function">check</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>ans<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">else</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"orz"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3366">P3366 【模板】最小生成树 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>
<ol>
<li><p>所有边按权重从小到大排序</p>
</li>
<li><p>枚举每条边a,b权重c if a,b不连通， 将这条边加入集合中</p>
</li>
</ol>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int n, m;       // n是点数，m是边数  
int p[N];       // 并查集的父节点数组  
  
struct Edge     // 存储边  
{  
    int a, b, w;  
  
    bool operator&lt; (const Edge &amp;W)const // 重载了 &lt;   
    {  
        return w &lt; W.w;  
    }  
}edges[M];  
  
int find(int x)     // 并查集核心操作  
{  
    if (p[x] != x) p[x] = find(p[x]);  
    return p[x];  
}  
  
int kruskal()  
{  
    sort(edges, edges + m);  
  
    for (int i = 1; i &lt;= n; i ++ ) p[i] = i;    // 初始化并查集  
  
    int res = 0, cnt = 0;  
    for (int i = 0; i &lt; m; i ++ )  
    {  
        int a = edges[i].a, b = edges[i].b, w = edges[i].w;  
  
        a = find(a), b = find(b);  
        if (a != b)     // 如果两个连通块不连通，则将这两个连通块合并  
        {  
            p[a] = b;  
            res += w;  
            cnt ++ ;  
        }  
    }  
  
    if (cnt &lt; n - 1) return INF;  
    return res;  
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="二分图-当且仅当图中没有奇数环"><a href="#二分图-当且仅当图中没有奇数环" class="headerlink" title="二分图 当且仅当图中没有奇数环"></a>二分图 当且仅当图中没有奇数环</h2><h3 id="染色法-O-n-m-判断是否是二分图"><a href="#染色法-O-n-m-判断是否是二分图" class="headerlink" title="染色法 O(n+m) 判断是否是二分图"></a>染色法 O(n+m) 判断是否是二分图</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int n;      // n表示点数  
int h[N], e[M], ne[M], idx;     // 邻接表存储图  
int color[N];       // 表示每个点的颜色，-1表示未染色，0表示白色，1表示黑色  
  
// 参数：u表示当前节点，c表示当前点的颜色  
bool dfs(int u, int c)  
{  
    color[u] = c;  
    for (int i = h[u]; i != -1; i = ne[i])  
    {  
        int j = e[i];  
        if (color[j] == -1)//未染色  
        {  
            if (!dfs(j, !c)) return false;//比如两种颜色， 0，1表示，那么这里就可以用 3- c,也就是用另一种颜色去染色  
        }  
        else if (color[j] == c) return false;  
    }  
  
    return true;  
}  
  
bool check()  
{  
    memset(color, -1, sizeof color);  
    bool flag = true;  
    //枚举所有点，去染色  
    for (int i = 1; i &lt;= n; i ++ )  
        if (color[i] == -1)  
            if (!dfs(i, 0))  
            {  
                flag = false;  
                break;  
            }  
    return flag;  
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="匈牙利算法-O-mn-实际运行时间一般小于这个值-稠密图不适合用邻接表，推荐使用临界矩阵"><a href="#匈牙利算法-O-mn-实际运行时间一般小于这个值-稠密图不适合用邻接表，推荐使用临界矩阵" class="headerlink" title="匈牙利算法 O(mn) 实际运行时间一般小于这个值 稠密图不适合用邻接表，推荐使用临界矩阵"></a>匈牙利算法 O(mn) 实际运行时间一般小于这个值 稠密图不适合用邻接表，推荐使用临界矩阵</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int n1, n2; &nbsp; &nbsp; // n1表示第一个集合中的点数，n2表示第二个集合中的点数  
int h[N], e[M], ne[M], idx; &nbsp; &nbsp; // 邻接表存储所有边，匈牙利算法中只会用到从第一个集合指向第二个集合的边，所以这里只用存一个方向的边  
int match[N]; &nbsp; &nbsp; &nbsp; // 存储第二个集合中的每个点当前匹配的第一个集合中的点是哪个  
bool st[N]; &nbsp; &nbsp; // 表示第二个集合中的每个点是否已经被遍历过  
​  
bool find(int x)  
{  
 &nbsp; &nbsp;for (int i = h[x]; i != -1; i = ne[i])  
 &nbsp;  {  
 &nbsp; &nbsp; &nbsp; &nbsp;int j = e[i];  
 &nbsp; &nbsp; &nbsp; &nbsp;if (!st[j])  
 &nbsp; &nbsp; &nbsp;  {  
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;st[j] = true;  
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if (match[j] == 0 || find(match[j]))//第二个集合的点未匹配，或者是可以为已经 匹配的第一个集合中的点找到别的集合二中的点  
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  {  
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;match[j] = x;  
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return true;  
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  }  
 &nbsp; &nbsp; &nbsp;  }  
 &nbsp;  }  
​  
 &nbsp; &nbsp;return false;  
}  
​  
// 求最大匹配数，依次枚举第一个集合中的每个点能否匹配第二个集合中的点  
int res = 0;  
for (int i = 1; i &lt;= n1; i ++ )  
{  
 &nbsp; &nbsp;memset(st, false, sizeof st);  
 &nbsp; &nbsp;if (find(i)) res ++ ;  
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>例题：<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3386">P3386 【模板】二分图最大匹配 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></strong></p>
<h2 id="邻接表的写法-稠密图会超时"><a href="#邻接表的写法-稠密图会超时" class="headerlink" title="邻接表的写法(稠密图会超时)"></a>邻接表的写法(稠密图会超时)</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits/stdc++.h&gt;  
using namespace std;  
const int N  = 505;  
int n1,n2,ed;//需要两个集合  
int h[N] , ne[N] , e[N] , idx;  
int match[N] ;  
bool vis[N];  
void init(){  
    memset(h,-1,sizeof h);  
    idx = 0;  
}  
void add(int a, int b){  
    e[idx] = b ;  
    ne[idx] = h[a];  
    h[a] = idx++;  
}  
bool find(int x){  
    for (int i = h[x] ; i != -1 ; i =ne[i]){  
        int j = e[i];  
        if(!vis[j]){  
            vis[j] = true;  
            if(match[j] == 0 || find(match[j])){  
                //如果终边的点未匹配，或者是可以为以匹配的起点找到另一个终点  
                match[j] = x;  
                return true;  
            }  
        }  
    }  
    return false;  
}  
int main(){  
    ios::sync_with_stdio(false);  
    cin.tie(nullptr);  
    cin &gt;&gt; n1 &gt;&gt; n2 &gt;&gt;ed;  
    init();  
    int u ,v;  
    for (int i = 1 ; i &lt;= ed ; i++){  
        cin &gt;&gt; u &gt;&gt; v;  
        if(v &lt;= n2){  
            add(u , v);  
        }  
         
    }  
    int ans = 0;  
    for (int i = 1 ; i &lt;= n1 ; i++){  
        memset(vis, false ,sizeof vis);  
        if(find(i)) ans++;  
    }  
    cout &lt;&lt; ans &lt;&lt;endl ;  
    return 0;  
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="邻接矩阵的写法："><a href="#邻接矩阵的写法：" class="headerlink" title="邻接矩阵的写法："></a>邻接矩阵的写法：</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits/stdc++.h&gt;  
using namespace std;  
const int N  = 505;  
int n1,n2,ed;//需要两个集合  
bool a[N][N];  
int match[N];  
bool vis[N];  
bool find(int x){  
    //枚举终边  
    for (int i = 1 ; i &lt;= n2 ; i ++){  
        if(!vis[i] &amp;&amp; a[x][i]){  
            vis[i] = true;  
            if(match[i] == 0 || find(match[i])){  
                //如果终边的点未匹配，或者是可以为以匹配的起点找到另一个终点  
                match[i] = x;  
                return true;  
            }  
        }  
    }  
    return false;  
}  
int main(){  
    ios::sync_with_stdio(false);  
    cin.tie(nullptr);  
    cin &gt;&gt; n1 &gt;&gt; n2 &gt;&gt;ed;  
    int u ,v;  
    for (int i = 1 ; i &lt;= ed ; i++){  
        cin &gt;&gt; u &gt;&gt; v;  
        if(v &lt;= n2){  
            a[u][v] = 1;  
        }  
         
    }  
    int ans = 0;  
    for (int i = 1 ; i &lt;= n1 ; i++){  
        ans+=find(i); // 这里不一样哦  
        memset(vis, false ,sizeof vis);  
    }  
    cout &lt;&lt; ans &lt;&lt;endl ;  
    return 0;  
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="数学知识"><a href="#数学知识" class="headerlink" title="数学知识"></a>数学知识</h2><blockquote>
<p>[!NOTE]</p>
<h2 id="当看见-0-的个数时考虑将结果分成-2-，-5-的个数-并且，末尾的0的个数一定是由5的个数决定的"><a href="#当看见-0-的个数时考虑将结果分成-2-，-5-的个数-并且，末尾的0的个数一定是由5的个数决定的" class="headerlink" title="当看见 0 的个数时考虑将结果分成 2 ， 5 的个数,并且，末尾的0的个数一定是由5的个数决定的"></a>当看见 0 的个数时考虑将结果分成 2 ， 5 的个数,并且，末尾的0的个数一定是由5的个数决定的</h2></blockquote>
<p><a target="_blank" rel="noopener" href="https://ac.nowcoder.com/acm/contest/57683/E">E-Kevin喜欢零(困难版本)_牛客小白月赛73 (nowcoder.com)</a></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits/stdc++.h&gt;  
​  
void solve() {#include &lt;bits/stdc++.h&gt;  
​  
void solve() {  
 &nbsp; &nbsp;int n, k;  
 &nbsp; &nbsp;std::cin &gt;&gt; n &gt;&gt; k;  
​  
 &nbsp; &nbsp;int64_t ans = 0;  
 &nbsp; &nbsp;std::unordered_map&lt;int, std::vector&lt;int&gt;&gt; tp, fp;  
 &nbsp; &nbsp;//tp 记录5的个数，fp记录2的个数  
 &nbsp; &nbsp;//两个是互补的  
 &nbsp; &nbsp;tp[0].push_back(0);  
 &nbsp; &nbsp;fp[0].push_back(0);  
​  
 &nbsp; &nbsp;for (int i = 0, t = 0, f = 0; i &lt; n; i++) {  
 &nbsp; &nbsp; &nbsp; &nbsp;int x;  
 &nbsp; &nbsp; &nbsp; &nbsp;std::cin &gt;&gt; x;  
 &nbsp; &nbsp; &nbsp; &nbsp;for (; x &amp;&amp; x % 2 == 0; x /= 2, t++) {  
 &nbsp; &nbsp; &nbsp;  }  
 &nbsp; &nbsp; &nbsp; &nbsp;for (; x &amp;&amp; x % 5 == 0; x /= 5, f++) {  
 &nbsp; &nbsp; &nbsp;  }  
 &nbsp; &nbsp; &nbsp; &nbsp;ans += std::max(  
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//需要 2^k &nbsp; * 5^k 即可满足 10^k 所以是动态规划  
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//每次计算出当前数据含有的2 和  5 的数量 和仍然需要 k  - 当前数量 &nbsp; 这一行的去更新  
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//因为同一个状态有可能对应多个数据， 所以只要找到第一个满足能凑出另一个2或者5的即可   
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//map不能使用upper_bound 但是 内部的vector 是可以使用的  
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;std::upper_bound(tp[t - k].begin(), tp[t - k].end(), f - k) - tp[t - k].begin(),  
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;std::upper_bound(fp[f - k].begin(), fp[f - k].end(), t - k) - fp[f - k].begin()  
 &nbsp; &nbsp; &nbsp;  );  
 &nbsp; &nbsp; &nbsp; &nbsp;tp[t].push_back(f);  
 &nbsp; &nbsp; &nbsp; &nbsp;fp[f].push_back(t);  
 &nbsp;  }  
​  
 &nbsp; &nbsp;std::cout &lt;&lt; ans &lt;&lt; "\n";  
}  
​  
int main() {  
 &nbsp; &nbsp;std::ios::sync_with_stdio(false);  
 &nbsp; &nbsp;std::cin.tie(nullptr);  
​  
 &nbsp; &nbsp;int t;  
 &nbsp; &nbsp;std::cin &gt;&gt; t;  
​  
 &nbsp; &nbsp;while (t--) {  
 &nbsp; &nbsp; &nbsp; &nbsp;solve();  
 &nbsp;  }  
​  
 &nbsp; &nbsp;return 0;  
}  
​  
 &nbsp; &nbsp;int n, k;  
 &nbsp; &nbsp;std::cin &gt;&gt; n &gt;&gt; k;  
​  
 &nbsp; &nbsp;int64_t ans = 0;  
 &nbsp; &nbsp;std::unordered_map&lt;int, std::vector&lt;int&gt;&gt; tp, fp;  
 &nbsp; &nbsp;//tp 记录5的个数，fp记录2的个数  
 &nbsp; &nbsp;//两个是互补的  
 &nbsp; &nbsp;tp[0].push_back(0);  
 &nbsp; &nbsp;fp[0].push_back(0);  
​  
 &nbsp; &nbsp;for (int i = 0, t = 0, f = 0; i &lt; n; i++) {  
 &nbsp; &nbsp; &nbsp; &nbsp;int x;  
 &nbsp; &nbsp; &nbsp; &nbsp;std::cin &gt;&gt; x;  
 &nbsp; &nbsp; &nbsp; &nbsp;for (; x &amp;&amp; x % 2 == 0; x /= 2, t++) {  
 &nbsp; &nbsp; &nbsp;  }  
 &nbsp; &nbsp; &nbsp; &nbsp;for (; x &amp;&amp; x % 5 == 0; x /= 5, f++) {  
 &nbsp; &nbsp; &nbsp;  }  
 &nbsp; &nbsp; &nbsp; &nbsp;ans += std::max(  
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//需要 2^k &nbsp; * 5^k 即可满足 10^k 所以是动态规划  
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//每次计算出当前数据含有的2 和  5 的数量 和仍然需要 k  - 当前数量 &nbsp; 这一行的去更新  
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//因为同一个状态有可能对应多个数据， 所以只要找到第一个满足能凑出另一个2或者5的即可   
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;std::upper_bound(tp[t - k].begin(), tp[t - k].end(), f - k) - tp[t - k].begin(),  
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;std::upper_bound(fp[f - k].begin(), fp[f - k].end(), t - k) - fp[f - k].begin()  
 &nbsp; &nbsp; &nbsp;  );  
 &nbsp; &nbsp; &nbsp; &nbsp;tp[t].push_back(f);  
 &nbsp; &nbsp; &nbsp; &nbsp;fp[f].push_back(t);  
 &nbsp;  }  
​  
 &nbsp; &nbsp;std::cout &lt;&lt; ans &lt;&lt; "\n";  
}  
​  
int main() {  
 &nbsp; &nbsp;std::ios::sync_with_stdio(false);  
 &nbsp; &nbsp;std::cin.tie(nullptr);  
​  
 &nbsp; &nbsp;int t;  
 &nbsp; &nbsp;std::cin &gt;&gt; t;  
​  
 &nbsp; &nbsp;while (t--) {  
 &nbsp; &nbsp; &nbsp; &nbsp;solve();  
 &nbsp;  }  
​  
 &nbsp; &nbsp;return 0;  
}  
​
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="数论"><a href="#数论" class="headerlink" title="数论"></a>数论</h1><ol>
<li><p>质数</p>
<ul>
<li><p>试除法判定质数，只枚举 d*d&lt;=n 即可`</p>
  <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token operator">/</span>i<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  
<span class="token comment">//不要担心	数据超过int  </span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>试除法分解质因子，质因数 ,求约数</p>
<ul>
<li>从小到大枚举所有的约数,n中最多只存在一个大于风雨根号n的质因子</li>
</ul>
</li>
</ul>
</li>
</ol>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">            <span class="token keyword">void</span> <span class="token function">divide</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span>  
            <span class="token punctuation">{</span>  
                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> x <span class="token operator">/</span> i<span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span>  
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">%</span> i <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>  
                    <span class="token punctuation">{</span>  
                        <span class="token keyword">int</span> s <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  
                        <span class="token keyword">while</span> <span class="token punctuation">(</span>x <span class="token operator">%</span> i <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> x <span class="token operator">/=</span> i<span class="token punctuation">,</span> s <span class="token operator">++</span> <span class="token punctuation">;</span>  
                        cout <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> <span class="token char">' '</span> <span class="token operator">&lt;&lt;</span> s <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>  
                    <span class="token punctuation">}</span>  
                <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span> cout <span class="token operator">&lt;&lt;</span> x <span class="token operator">&lt;&lt;</span> <span class="token char">' '</span> <span class="token operator">&lt;&lt;</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>  
                cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>  
            <span class="token punctuation">}</span>
            
```            

# 埃氏筛法： 枚举所有数据，然后把每个数的倍数筛去，留下的就是质数 <span class="token operator">*</span><span class="token operator">*</span>思想比较好<span class="token operator">*</span><span class="token operator">*</span> 思想太好了
``` cpp
	   <span class="token keyword">void</span> <span class="token function">get_primes</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>  
        	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  
        		<span class="token keyword">if</span><span class="token punctuation">(</span>st<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>  
                <span class="token comment">//删除所有质数的倍数  </span>
        		primes<span class="token punctuation">[</span>cnt<span class="token operator">++</span><span class="token punctuation">]</span><span class="token operator">=</span>i<span class="token punctuation">;</span>  
        		<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span>i<span class="token operator">+</span>i<span class="token punctuation">;</span>j<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>j<span class="token operator">+=</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>  
        			st<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span><span class="token boolean">true</span><span class="token punctuation">;</span>  
        		<span class="token punctuation">}</span>  
        	<span class="token punctuation">}</span>	  
        <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="线性筛法：-如果质数，把这个数加入集合中-最常用"><a href="#线性筛法：-如果质数，把这个数加入集合中-最常用" class="headerlink" title="线性筛法： 如果质数，把这个数加入集合中 最常用"></a><strong>线性筛法： 如果质数，把这个数加入集合中</strong> 最常用</h3> <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> primes<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span> cnt<span class="token punctuation">;</span>     <span class="token comment">// primes[]存储所有素数  </span>
<span class="token keyword">bool</span> st<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>         <span class="token comment">// st[x]存储x是否被筛掉  </span>
  
<span class="token keyword">void</span> <span class="token function">get_primes</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span>  
<span class="token punctuation">{</span>  
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span>  
    <span class="token punctuation">{</span>  
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>st<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> primes<span class="token punctuation">[</span>cnt <span class="token operator">++</span> <span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>  
        <span class="token comment">//枚举已有的质数，删除它的倍数  </span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> primes<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> n <span class="token operator">/</span> i<span class="token punctuation">;</span> j <span class="token operator">++</span> <span class="token punctuation">)</span>  
        <span class="token punctuation">{</span>  
            st<span class="token punctuation">[</span>primes<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">*</span> i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>  
            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">%</span> primes<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>  
        <span class="token punctuation">}</span>  
    <span class="token punctuation">}</span>  
<span class="token punctuation">}</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol start="2">
<li><p>约数</p>
<ul>
<li><p>试除法求所有约数</p>
<ul>
<li>只枚举较小的约数，较大的约数可以直接算出</li>
</ul>
</li>
</ul>
</li>
</ol>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>  
	vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> ans<span class="token punctuation">;</span>  
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token operator">/</span>i<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  
		<span class="token keyword">if</span><span class="token punctuation">(</span>n<span class="token operator">%</span>i<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  
			<span class="token comment">//从小到大枚举所有约数，并把n/i 得到的约数加入即可  </span>
			ans<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>  
			<span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">!=</span>n<span class="token operator">/</span>i<span class="token punctuation">)</span> ans<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>n<span class="token operator">/</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>  
		<span class="token punctuation">}</span>  
	<span class="token punctuation">}</span>  
	<span class="token function">sort</span><span class="token punctuation">(</span>ans<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>ans<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
	<span class="token keyword">return</span> ans<span class="token punctuation">;</span>  
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>约数个数,约数之和<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">        如果 N <span class="token operator">=</span> p1<span class="token operator">^</span>c1 <span class="token operator">*</span> p2<span class="token operator">^</span>c2 <span class="token operator">*</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token operator">*</span>pk<span class="token operator">^</span>ck  
        约数个数： <span class="token punctuation">(</span>c1 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>c2 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token operator">*</span> <span class="token punctuation">(</span>ck <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>  
        约数之和： <span class="token punctuation">(</span>p1<span class="token operator">^</span><span class="token number">0</span> <span class="token operator">+</span> p1<span class="token operator">^</span><span class="token number">1</span> <span class="token operator">+</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token operator">+</span> p1<span class="token operator">^</span>c1<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token operator">*</span> <span class="token punctuation">(</span>pk<span class="token operator">^</span><span class="token number">0</span> <span class="token operator">+</span> pk<span class="token operator">^</span><span class="token number">1</span> <span class="token operator">+</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token operator">+</span> pk<span class="token operator">^</span>ck
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;bits/stdc++.h&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
<span class="token keyword">typedef</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">long</span> ULL<span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> mod  <span class="token operator">=</span> <span class="token number">1e9</span> <span class="token operator">+</span> <span class="token number">7</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> n <span class="token punctuation">;</span>
    cin <span class="token operator">&gt;&gt;</span> n<span class="token punctuation">;</span>
    unordered_map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span><span class="token keyword">int</span><span class="token operator">&gt;</span> primes<span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>n<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> x<span class="token punctuation">;</span>
        <span class="token function">scanf</span> <span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> x <span class="token operator">/</span> i <span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">while</span><span class="token punctuation">(</span>x <span class="token operator">%</span> i <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                primes<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">++</span><span class="token punctuation">;</span>
                x <span class="token operator">/=</span> i<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span>  primes<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    ULL cnts <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span>res <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> <span class="token punctuation">[</span>prime<span class="token punctuation">,</span>cnt<span class="token punctuation">]</span><span class="token operator">:</span>primes<span class="token punctuation">)</span>  <span class="token punctuation">{</span>
        cnts <span class="token operator">=</span> <span class="token punctuation">(</span>cnts <span class="token operator">*</span> <span class="token punctuation">(</span>cnt <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">%</span> mod<span class="token punctuation">;</span>
        <span class="token comment">//求和</span>
        ULL t <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>cnt<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token comment">//秦九zhao算法</span>
            t <span class="token operator">=</span> <span class="token punctuation">(</span>t <span class="token operator">*</span>prime <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span>mod<span class="token punctuation">;</span>
        <span class="token punctuation">}</span> 
        res <span class="token operator">=</span> res <span class="token operator">*</span> t <span class="token operator">%</span> mod<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    cout <span class="token operator">&lt;&lt;</span> cnts <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> res<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
<ol start="3">
<li><p>欧几里得算法，辗转相除法，求最大公约数</p>
<ul>
<li>GCD(a,b) = =GCD(a.amodb)<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">        <span class="token keyword">int</span> <span class="token function">gcd</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span>  
        <span class="token punctuation">{</span>  
            <span class="token keyword">return</span> b <span class="token operator">?</span> <span class="token function">gcd</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> a <span class="token operator">%</span> b<span class="token punctuation">)</span> <span class="token operator">:</span> a<span class="token punctuation">;</span>  
        <span class="token punctuation">}</span>
        
```     
    <span class="token operator">-</span> LCM 最小公倍数 将两个数相乘再除以最大公因数即可得到最小公倍数
    ```cpp
        <span class="token keyword">int</span> <span class="token function">lcm</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span><span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">{</span>  
        	<span class="token keyword">return</span> a<span class="token operator">*</span>b<span class="token operator">/</span><span class="token function">gcd</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>  
        <span class="token punctuation">}</span>
        <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li>求ax+by=gcd(a,b)<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">        <span class="token keyword">int</span> <span class="token function">xGCD</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>x<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>y<span class="token punctuation">)</span> <span class="token punctuation">{</span>  
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>b<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//b = 0 时  </span>
                x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> y <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  
                <span class="token keyword">return</span> a<span class="token punctuation">;</span>  
            <span class="token punctuation">}</span>  
            <span class="token keyword">int</span> x1<span class="token punctuation">,</span> y10<span class="token punctuation">,</span> gcd <span class="token operator">=</span> <span class="token function">xGCD</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> a <span class="token operator">%</span> b<span class="token punctuation">,</span> x1<span class="token punctuation">,</span> y1<span class="token punctuation">)</span><span class="token punctuation">;</span>  
            x <span class="token operator">=</span> y1<span class="token punctuation">,</span> y <span class="token operator">=</span> x1 <span class="token operator">-</span> <span class="token punctuation">(</span>a <span class="token operator">/</span> b<span class="token punctuation">)</span> <span class="token operator">*</span> y1<span class="token punctuation">;</span>  
            <span class="token keyword">return</span> gcd<span class="token punctuation">;</span>  
        <span class="token punctuation">}</span>
        
```     
### 欧拉函数：小于x的整数中与x互质的数的个数<span class="token punctuation">]</span>
        
求出单个数的欧拉函数  
<span class="token function">f</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token operator">=</span> `n <span class="token operator">*</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">/</span> p1<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">/</span> p2a<span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>`
```cpp
        <span class="token keyword">int</span> <span class="token function">phi</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">{</span>  
        	<span class="token keyword">int</span> res<span class="token operator">=</span>x<span class="token punctuation">;</span>  
        	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>x<span class="token operator">/</span>i<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  
        		<span class="token keyword">if</span><span class="token punctuation">(</span>x<span class="token operator">%</span>i<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  
        			res<span class="token operator">=</span>res<span class="token operator">/</span>i<span class="token operator">*</span><span class="token punctuation">(</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
        			<span class="token keyword">while</span><span class="token punctuation">(</span>x<span class="token operator">%</span>i<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> x<span class="token operator">/=</span>i<span class="token punctuation">;</span>  
        		<span class="token punctuation">}</span>  
        	<span class="token punctuation">}</span>  
        	<span class="token keyword">if</span><span class="token punctuation">(</span>x<span class="token operator">&gt;</span><span class="token number">1</span><span class="token punctuation">)</span> res<span class="token operator">=</span>res<span class="token operator">/</span>x<span class="token operator">*</span><span class="token punctuation">(</span>x<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
        	<span class="token keyword">return</span> res<span class="token punctuation">;</span>  
        <span class="token punctuation">}</span>
        <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
</li>
</ol>
<p>筛法：求出1-n每个数的欧拉函数，在线性筛法的模板中加上三行</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> primes<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span> cnt<span class="token punctuation">;</span>     <span class="token comment">// primes[]存储所有素数  </span>
<span class="token keyword">int</span> euler<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>           <span class="token comment">// 存储每个数的欧拉函数  </span>
<span class="token keyword">bool</span> st<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>         <span class="token comment">// st[x]存储x是否被筛掉  </span>
  
  
<span class="token keyword">void</span> <span class="token function">get_eulers</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span>  
<span class="token punctuation">{</span>  
    euler<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span>  
    <span class="token punctuation">{</span>  
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>st<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>  
        <span class="token punctuation">{</span>  
            primes<span class="token punctuation">[</span>cnt <span class="token operator">++</span> <span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>  
            euler<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>  
        <span class="token punctuation">}</span>  
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> primes<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> n <span class="token operator">/</span> i<span class="token punctuation">;</span> j <span class="token operator">++</span> <span class="token punctuation">)</span>  
        <span class="token punctuation">{</span>  
            <span class="token keyword">int</span> t <span class="token operator">=</span> primes<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">*</span> i<span class="token punctuation">;</span>  
            st<span class="token punctuation">[</span>t<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>  
            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">%</span> primes<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>  
            <span class="token punctuation">{</span>  
                euler<span class="token punctuation">[</span>t<span class="token punctuation">]</span> <span class="token operator">=</span> euler<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">*</span> primes<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>  
                <span class="token keyword">break</span><span class="token punctuation">;</span>  
            <span class="token punctuation">}</span>  
            euler<span class="token punctuation">[</span>t<span class="token punctuation">]</span> <span class="token operator">=</span> euler<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token punctuation">(</span>primes<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
        <span class="token punctuation">}</span>  
    <span class="token punctuation">}</span>  
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="欧拉定理"><a href="#欧拉定理" class="headerlink" title="欧拉定理"></a>欧拉定理</h3><p>a ^f(n) % n = 1<br>a和n互质</p>
<h3 id="快速幂："><a href="#快速幂：" class="headerlink" title="快速幂："></a>快速幂：</h3>  <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">        把指数转为<span class="token number">2</span>进制就可以看出来有哪些含有了
        
        预处理时每一个结果都是前一个的平方再mod
        
        求 m<span class="token operator">^</span>k mod p，时间复杂度 <span class="token function">O</span><span class="token punctuation">(</span>logk<span class="token punctuation">)</span>。  
        ​  
        <span class="token keyword">int</span> <span class="token function">qmi</span><span class="token punctuation">(</span><span class="token keyword">int</span> m<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">,</span> <span class="token keyword">int</span> p<span class="token punctuation">)</span>  
        <span class="token punctuation">{</span>  
            <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">%</span> p<span class="token punctuation">,</span> t <span class="token operator">=</span> m<span class="token punctuation">;</span>  
            <span class="token keyword">while</span> <span class="token punctuation">(</span>k<span class="token punctuation">)</span>  
            <span class="token punctuation">{</span>  
                <span class="token keyword">if</span> <span class="token punctuation">(</span>k<span class="token operator">&amp;</span><span class="token number">1</span><span class="token punctuation">)</span> res <span class="token operator">=</span> res <span class="token operator">*</span> t <span class="token operator">%</span> p<span class="token punctuation">;</span>  
                t <span class="token operator">=</span> t <span class="token operator">*</span> t <span class="token operator">%</span> p<span class="token punctuation">;</span>  
                k <span class="token operator">&gt;&gt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>  
            <span class="token punctuation">}</span>  
            <span class="token keyword">return</span> res<span class="token punctuation">;</span>  
        <span class="token punctuation">}</span>
        
    
```      
### 快速幂求逆元
```cpp
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;bits/stdc++.h&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
<span class="token keyword">typedef</span> <span class="token keyword">long</span> <span class="token keyword">long</span> LL<span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">quick_mi</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span><span class="token keyword">int</span> b<span class="token punctuation">,</span><span class="token keyword">int</span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">%</span> p<span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>b<span class="token operator">&amp;</span><span class="token number">1</span><span class="token punctuation">)</span> res <span class="token operator">=</span> <span class="token punctuation">(</span>LL<span class="token punctuation">)</span> res<span class="token operator">*</span>a <span class="token operator">%</span>p<span class="token punctuation">;</span>
        b <span class="token operator">&gt;&gt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        a <span class="token operator">=</span> <span class="token punctuation">(</span>LL<span class="token punctuation">)</span> a <span class="token operator">*</span> a <span class="token operator">%</span> p<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> res<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> n<span class="token punctuation">;</span>
    <span class="token function">scanf</span> <span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>n<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> a<span class="token punctuation">,</span>p<span class="token punctuation">;</span>
        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d%d"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>a<span class="token punctuation">,</span><span class="token operator">&amp;</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>a <span class="token operator">%</span> p<span class="token punctuation">)</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span><span class="token function">quick_mi</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>p<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">,</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span> <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"impossible"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="扩展欧几里得算法-不会"><a href="#扩展欧几里得算法-不会" class="headerlink" title="扩展欧几里得算法(不会)"></a>扩展欧几里得算法(不会)</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">    <span class="token comment">// 求x, y，使得ax + by = gcd(a, b)  </span>
    <span class="token keyword">int</span> <span class="token function">exgcd</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>x<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>y<span class="token punctuation">)</span>  
    <span class="token punctuation">{</span>  
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>b<span class="token punctuation">)</span>  
        <span class="token punctuation">{</span>  
            x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> y <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  
            <span class="token keyword">return</span> a<span class="token punctuation">;</span>  
        <span class="token punctuation">}</span>  
        <span class="token keyword">int</span> d <span class="token operator">=</span> <span class="token function">exgcd</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> a <span class="token operator">%</span> b<span class="token punctuation">,</span> y<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>  
        y <span class="token operator">-=</span> <span class="token punctuation">(</span>a<span class="token operator">/</span>b<span class="token punctuation">)</span> <span class="token operator">*</span> x<span class="token punctuation">;</span>  
        <span class="token keyword">return</span> d<span class="token punctuation">;</span>  
    <span class="token punctuation">}</span>
```  
#### 高斯消元求解方程组的解
 ```cpp
	 <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;bits/stdc++.h&gt;</span>  </span>
    <span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>  
    <span class="token keyword">const</span> <span class="token keyword">int</span> N<span class="token operator">=</span><span class="token number">100</span><span class="token punctuation">;</span>  
    <span class="token keyword">int</span> n<span class="token punctuation">;</span>  
    <span class="token keyword">const</span> <span class="token keyword">double</span> eps<span class="token operator">=</span><span class="token number">1e-6</span><span class="token punctuation">;</span>  
    <span class="token keyword">double</span> a<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>  
    <span class="token comment">// a[N][N]是增广矩阵  </span>
    <span class="token comment">// a[N][N]是增广矩阵  </span>
    <span class="token keyword">int</span> <span class="token function">gauss</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  
    <span class="token punctuation">{</span>  
        <span class="token keyword">int</span> c<span class="token punctuation">,</span> r<span class="token punctuation">;</span>  
        <span class="token keyword">for</span> <span class="token punctuation">(</span>c <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> r <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> c <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> c <span class="token operator">++</span> <span class="token punctuation">)</span>  
        <span class="token punctuation">{</span>  
            <span class="token keyword">int</span> t <span class="token operator">=</span> r<span class="token punctuation">;</span>  
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> r<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span>   <span class="token comment">// 找到绝对值最大的行  </span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">fabs</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token function">fabs</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  
                    t <span class="token operator">=</span> i<span class="token punctuation">;</span>  
    ​  
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">fabs</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> eps<span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>  
    ​  
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> c<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token function">swap</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// 将绝对值最大的行换到最顶端  </span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n<span class="token punctuation">;</span> i <span class="token operator">&gt;=</span> c<span class="token punctuation">;</span> i <span class="token operator">--</span> <span class="token punctuation">)</span> a<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">/=</span> a<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">;</span>      <span class="token comment">// 将当前行的首位变成1  </span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> r <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span>       <span class="token comment">// 用当前行将下面所有的列消成0  </span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">fabs</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> eps<span class="token punctuation">)</span>  
                    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> n<span class="token punctuation">;</span> j <span class="token operator">&gt;=</span> c<span class="token punctuation">;</span> j <span class="token operator">--</span> <span class="token punctuation">)</span>  
                        a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">-=</span> a<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">*</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">;</span>  
    ​  
            r <span class="token operator">++</span> <span class="token punctuation">;</span>  
        <span class="token punctuation">}</span>  
    ​  
        <span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token operator">&lt;</span> n<span class="token punctuation">)</span>  
        <span class="token punctuation">{</span>  
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> r<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span>  
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">fabs</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> eps<span class="token punctuation">)</span>  
                    <span class="token keyword">return</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">// 无解  </span>
            <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 有无穷多组解  </span>
        <span class="token punctuation">}</span>  
    ​  
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">--</span> <span class="token punctuation">)</span>  
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j <span class="token operator">++</span> <span class="token punctuation">)</span>  
                a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">-=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">*</span> a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>  
    ​  
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 有唯一解  </span>
    <span class="token punctuation">}</span>  
    <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  
        cin<span class="token operator">&gt;&gt;</span>n<span class="token punctuation">;</span>  
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>  
            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  
                cin<span class="token operator">&gt;&gt;</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>  
            <span class="token punctuation">}</span>  
    ​  
    <span class="token keyword">int</span> t<span class="token operator">=</span><span class="token function">gauss</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
        <span class="token keyword">if</span><span class="token punctuation">(</span>t<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  
            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  
                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%.2lf "</span><span class="token punctuation">,</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
            <span class="token punctuation">}</span>  
        <span class="token punctuation">}</span>  
        <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>t<span class="token operator">==</span><span class="token number">2</span><span class="token punctuation">)</span> cout<span class="token operator">&lt;&lt;</span><span class="token string">"无解"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>  
        <span class="token keyword">else</span> cout<span class="token operator">&lt;&lt;</span><span class="token string">"有无数组解"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>  
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  
    <span class="token punctuation">}</span>
    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="递推求组合数，dp法-适合询问次数-gt-10w"><a href="#递推求组合数，dp法-适合询问次数-gt-10w" class="headerlink" title="递推求组合数，dp法 适合询问次数>10w"></a>递推求组合数，dp法 适合询问次数&gt;10w</h3> <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// c[a][b] 表示从a个苹果中选b个的方案数  </span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span>  
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> i<span class="token punctuation">;</span> j <span class="token operator">++</span> <span class="token punctuation">)</span>  
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>j<span class="token punctuation">)</span> c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  
        <span class="token keyword">else</span> c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>c<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> c<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">%</span> mod<span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="通过预处理逆元的方式求组合数-询问1w"><a href="#通过预处理逆元的方式求组合数-询问1w" class="headerlink" title="通过预处理逆元的方式求组合数 询问1w"></a>通过预处理逆元的方式求组合数 询问1w</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">    首先预处理出所有阶乘取模的余数fact<span class="token punctuation">[</span>N<span class="token punctuation">]</span>，以及所有阶乘取模的逆元infact<span class="token punctuation">[</span>N<span class="token punctuation">]</span>  
    如果取模的数是质数，可以用费马小定理求逆元  
    <span class="token keyword">int</span> <span class="token function">qmi</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">,</span> <span class="token keyword">int</span> p<span class="token punctuation">)</span>    <span class="token comment">// 快速幂模板  </span>
    <span class="token punctuation">{</span>  
        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  
        <span class="token keyword">while</span> <span class="token punctuation">(</span>k<span class="token punctuation">)</span>  
        <span class="token punctuation">{</span>  
            <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">)</span> res <span class="token operator">=</span> <span class="token punctuation">(</span>LL<span class="token punctuation">)</span>res <span class="token operator">*</span> a <span class="token operator">%</span> p<span class="token punctuation">;</span>  
            a <span class="token operator">=</span> <span class="token punctuation">(</span>LL<span class="token punctuation">)</span>a <span class="token operator">*</span> a <span class="token operator">%</span> p<span class="token punctuation">;</span>  
            k <span class="token operator">&gt;&gt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>  
        <span class="token punctuation">}</span>  
        <span class="token keyword">return</span> res<span class="token punctuation">;</span>  
    <span class="token punctuation">}</span>  
    ​  
    <span class="token comment">// 预处理阶乘的余数和阶乘逆元的余数  </span>
    fact<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> infact<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span>  
    <span class="token punctuation">{</span>  
        fact<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>LL<span class="token punctuation">)</span>fact<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">*</span> i <span class="token operator">%</span> mod<span class="token punctuation">;</span>  
        infact<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>LL<span class="token punctuation">)</span>infact<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token function">qmi</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> mod <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">,</span> mod<span class="token punctuation">)</span> <span class="token operator">%</span> mod<span class="token punctuation">;</span>  
    <span class="token punctuation">}</span>  
    ​
```    
### Lucas定理求组合数 <span class="token number">20</span>次询问以下
    
<span class="token operator">!</span><span class="token punctuation">[</span>image<span class="token operator">-</span><span class="token number">20230519193526425</span><span class="token punctuation">]</span><span class="token punctuation">(</span>file<span class="token operator">:</span><span class="token comment">//D:/typora%E7%94%A8%E5%9B%BE/Screenshots/image-20230519193526425.png?lastModify=1694256669)    </span>
```cpp
      <span class="token comment">//若p是质数，则对于任意整数 1 &lt;= m &lt;= n，有：  </span>
      <span class="token comment">//  C(n, m) = C(n % p, m % p) * C(n / p, m / p) (mod p)  </span>
    ​  
    <span class="token keyword">int</span> <span class="token function">qmi</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">,</span> <span class="token keyword">int</span> p<span class="token punctuation">)</span>  <span class="token comment">// 快速幂模板  </span>
    <span class="token punctuation">{</span>  
        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">%</span> p<span class="token punctuation">;</span>  
        <span class="token keyword">while</span> <span class="token punctuation">(</span>k<span class="token punctuation">)</span>  
        <span class="token punctuation">{</span>  
            <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">)</span> res <span class="token operator">=</span> <span class="token punctuation">(</span>LL<span class="token punctuation">)</span>res <span class="token operator">*</span> a <span class="token operator">%</span> p<span class="token punctuation">;</span>  
            a <span class="token operator">=</span> <span class="token punctuation">(</span>LL<span class="token punctuation">)</span>a <span class="token operator">*</span> a <span class="token operator">%</span> p<span class="token punctuation">;</span>  
            k <span class="token operator">&gt;&gt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>  
        <span class="token punctuation">}</span>  
        <span class="token keyword">return</span> res<span class="token punctuation">;</span>  
    <span class="token punctuation">}</span>  
    ​  
    <span class="token keyword">int</span> <span class="token function">C</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">,</span> <span class="token keyword">int</span> p<span class="token punctuation">)</span>  <span class="token comment">// 通过定理求组合数C(a, b)  </span>
    <span class="token punctuation">{</span>  
        <span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">&lt;</span> b<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  
    ​  
        LL x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> y <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">// x是分子，y是分母  </span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> a<span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> b<span class="token punctuation">;</span> i <span class="token operator">--</span><span class="token punctuation">,</span> j <span class="token operator">++</span> <span class="token punctuation">)</span>  
        <span class="token punctuation">{</span>  
            x <span class="token operator">=</span> <span class="token punctuation">(</span>LL<span class="token punctuation">)</span>x <span class="token operator">*</span> i <span class="token operator">%</span> p<span class="token punctuation">;</span>  
            y <span class="token operator">=</span> <span class="token punctuation">(</span>LL<span class="token punctuation">)</span> y <span class="token operator">*</span> j <span class="token operator">%</span> p<span class="token punctuation">;</span>  
        <span class="token punctuation">}</span>  
    ​  
        <span class="token keyword">return</span> x <span class="token operator">*</span> <span class="token punctuation">(</span>LL<span class="token punctuation">)</span><span class="token function">qmi</span><span class="token punctuation">(</span>y<span class="token punctuation">,</span> p <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">,</span> p<span class="token punctuation">)</span> <span class="token operator">%</span> p<span class="token punctuation">;</span>  
    <span class="token punctuation">}</span>  
    ​  
    <span class="token keyword">int</span> <span class="token function">lucas</span><span class="token punctuation">(</span>LL a<span class="token punctuation">,</span> LL b<span class="token punctuation">,</span> <span class="token keyword">int</span> p<span class="token punctuation">)</span>  
    <span class="token punctuation">{</span>  
        <span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">&lt;</span> p <span class="token operator">&amp;&amp;</span> b <span class="token operator">&lt;</span> p<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token function">C</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>  
        <span class="token keyword">return</span> <span class="token punctuation">(</span>LL<span class="token punctuation">)</span><span class="token function">C</span><span class="token punctuation">(</span>a <span class="token operator">%</span> p<span class="token punctuation">,</span> b <span class="token operator">%</span> p<span class="token punctuation">,</span> p<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token function">lucas</span><span class="token punctuation">(</span>a <span class="token operator">/</span> p<span class="token punctuation">,</span> b <span class="token operator">/</span> p<span class="token punctuation">,</span> p<span class="token punctuation">)</span> <span class="token operator">%</span> p<span class="token punctuation">;</span>  
    <span class="token punctuation">}</span>
    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="file://D:/typora%E7%94%A8%E5%9B%BE/Screenshots/image-20230519193254443.png?lastModify=1694256669" alt="image-20230519193254443"></p>
<h3 id="逆元："><a href="#逆元：" class="headerlink" title="逆元："></a>逆元：</h3><p>可以在快速幂中求出</p>
<p>也就是a的p-2次方的</p>
<blockquote>
<p>在模为素数p的情况下，有费马小定理 a^(p-1)=1（mod p） 那么a^(p-2)=a^-1(mod p) 也就是说a的逆元为a^(p-2)</p>
</blockquote>
<h4 id="分解质因数法求组合数"><a href="#分解质因数法求组合数" class="headerlink" title="分解质因数法求组合数"></a>分解质因数法求组合数</h4><p> &nbsp; </p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">    当我们需要求出组合数的真实值，而非对某个数的余数时，分解质因数的方式比较好用：  
        <span class="token number">1.</span> 筛法求出范围内的所有质数  
        <span class="token number">2.</span> 通过 <span class="token function">C</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token operator">=</span> a<span class="token operator">!</span> <span class="token operator">/</span> b<span class="token operator">!</span> <span class="token operator">/</span> <span class="token punctuation">(</span>a <span class="token operator">-</span> b<span class="token punctuation">)</span><span class="token operator">!</span> 这个公式求出每个质因子的次数。 n<span class="token operator">!</span> 中p的次数是 n <span class="token operator">/</span> p <span class="token operator">+</span> n <span class="token operator">/</span> p<span class="token operator">^</span><span class="token number">2</span> <span class="token operator">+</span> n <span class="token operator">/</span> p<span class="token operator">^</span><span class="token number">3</span> <span class="token operator">+</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  
        <span class="token number">3.</span> 用高精度乘法将所有质因子相乘  
      
    <span class="token keyword">int</span> primes<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span> cnt<span class="token punctuation">;</span>     <span class="token comment">// 存储所有质数  </span>
    <span class="token keyword">int</span> sum<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>     <span class="token comment">// 存储每个质数的次数  </span>
    <span class="token keyword">bool</span> st<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>     <span class="token comment">// 存储每个数是否已被筛掉</span>

    <span class="token keyword">void</span> <span class="token function">get_primes</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span>      <span class="token comment">// 线性筛法求素数  </span>
•        <span class="token punctuation">{</span>  
•            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span>  
•            <span class="token punctuation">{</span>  
•                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>st<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> primes<span class="token punctuation">[</span>cnt <span class="token operator">++</span> <span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>  
•                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> primes<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> n <span class="token operator">/</span> i<span class="token punctuation">;</span> j <span class="token operator">++</span> <span class="token punctuation">)</span>  
•                <span class="token punctuation">{</span>  
•                    st<span class="token punctuation">[</span>primes<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">*</span> i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>  
•                    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">%</span> primes<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>  
•                <span class="token punctuation">}</span>  
•            <span class="token punctuation">}</span>  
•        <span class="token punctuation">}</span>  
​  
​  
•          
•        <span class="token keyword">int</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> p<span class="token punctuation">)</span>       <span class="token comment">// 求n！中的次数  </span>
•        <span class="token punctuation">{</span>  
•            <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  
•            <span class="token keyword">while</span> <span class="token punctuation">(</span>n<span class="token punctuation">)</span>  
•            <span class="token punctuation">{</span>  
•                res <span class="token operator">+=</span> n <span class="token operator">/</span> p<span class="token punctuation">;</span>  
•                n <span class="token operator">/=</span> p<span class="token punctuation">;</span>  
•            <span class="token punctuation">}</span>  
•            <span class="token keyword">return</span> res<span class="token punctuation">;</span>  
•        <span class="token punctuation">}</span>  
​  
​  
•          
•        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">mul</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span>       <span class="token comment">// 高精度乘低精度模板  </span>
•        <span class="token punctuation">{</span>  
•            vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> c<span class="token punctuation">;</span>  
•            <span class="token keyword">int</span> t <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  
•            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> a<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span>  
•            <span class="token punctuation">{</span>  
•                t <span class="token operator">+=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">*</span> b<span class="token punctuation">;</span>  
•                c<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>t <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
•                t <span class="token operator">/=</span> <span class="token number">10</span><span class="token punctuation">;</span>  
•            <span class="token punctuation">}</span>  
•          
•            <span class="token keyword">while</span> <span class="token punctuation">(</span>t<span class="token punctuation">)</span>  
•            <span class="token punctuation">{</span>  
•                c<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>t <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
•                t <span class="token operator">/=</span> <span class="token number">10</span><span class="token punctuation">;</span>  
•            <span class="token punctuation">}</span>  
•          
•            <span class="token keyword">return</span> c<span class="token punctuation">;</span>  
•        <span class="token punctuation">}</span>  
•        

    <span class="token function">get_primes</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 预处理范围内的所有质数  </span>
      
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> cnt<span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span>     <span class="token comment">// 求每个质因数的次数  </span>
    <span class="token punctuation">{</span>  
        <span class="token keyword">int</span> p <span class="token operator">=</span> primes<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>  
        sum<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">get</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> p<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token function">get</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> p<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token function">get</span><span class="token punctuation">(</span>a <span class="token operator">-</span> b<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token punctuation">}</span>  
      
    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> res<span class="token punctuation">;</span>  
    res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
      
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> cnt<span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span>     <span class="token comment">// 用高精度乘法将所有质因子相乘  </span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> sum<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> j <span class="token operator">++</span> <span class="token punctuation">)</span>  
            res <span class="token operator">=</span> <span class="token function">mul</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> primes<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p>
<h2 id="动态规划DP"><a href="#动态规划DP" class="headerlink" title="动态规划DP"></a>动态规划DP</h2><p>思路：</p>
<ol>
<li><p>状态表示：需要几维的动态规划</p>
<ul>
<li><p>集合 所有选法</p>
<ol>
<li><p>所有选法</p>
</li>
<li><p>条件</p>
<ul>
<li><p>只从前i个物品中选择</p>
</li>
<li><p>总体积&lt;=j</p>
</li>
</ul>
</li>
</ol>
</li>
<li><p>属性 最大值？最小值?……</p>
</li>
</ul>
</li>
<li><p>状态计算：怎么得到结果</p>
</li>
</ol>
<h3 id="01背包-每个物品只能用一次"><a href="#01背包-每个物品只能用一次" class="headerlink" title="01背包 每个物品只能用一次"></a>01背包 每个物品只能用一次</h3><p>一维优化;</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">///f[N][N] 表示前i个物品，j的容量下的最大值  </span>
进行压缩，因为每次更新i是时只用到了i<span class="token operator">-</span><span class="token number">1</span> 这个位置的数据，所以可以使用滚动数组，实现每次i<span class="token operator">-</span><span class="token number">1</span>到i的更新<span class="token punctuation">;</span>  
所以编成  f<span class="token punctuation">[</span>N<span class="token punctuation">]</span> 表示j的背包容量下的最大值<span class="token punctuation">;</span>  
j<span class="token operator">=</span><span class="token number">0</span>的结果都为<span class="token number">0</span> 所以可以跳过<span class="token punctuation">;</span>i<span class="token operator">=</span><span class="token number">0</span>的结果也都为<span class="token number">0</span><span class="token punctuation">,</span>同时，如果当前的背包容量不足以把当前物品装入也不需要进行更新了，所以小于当前背包容量的就不要考虑了<span class="token punctuation">;</span>  
不能更新也就是f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>f<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> 所以可以直接去掉，变为  f<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>f<span class="token punctuation">[</span>j<span class="token punctuation">]</span>  
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//遍览物品  </span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span>m<span class="token punctuation">;</span>j<span class="token operator">&gt;=</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>j<span class="token operator">--</span><span class="token punctuation">)</span><span class="token comment">//m为最大背包容量  </span>
        f<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span><span class="token function">max</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>f<span class="token punctuation">[</span>j<span class="token operator">-</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">+</span>w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="多状态dp"><a href="#多状态dp" class="headerlink" title="多状态dp"></a>多状态dp</h2><p>示例：<br><a target="_blank" rel="noopener" href="https://www.lanqiao.cn/problems/2223/learning/?subject_code=2&amp;group_code=4&amp;match_num=13&amp;match_flow=2&amp;origin=cup">魔法背包</a><br><a target="_blank" rel="noopener" href="https://www.lanqiao.cn/problems/2224/learning/?subject_code=2&amp;group_code=4&amp;match_num=13&amp;match_flow=2&amp;origin=cup">修路</a><br><a target="_blank" rel="noopener" href="https://www.lanqiao.cn/problems/3542/learning/?subject_code=2&amp;group_code=4&amp;match_num=14&amp;match_flow=1&amp;origin=cup">魔法阵</a><br>存在多个状态，其中每一个状态内的转移是正常转移的，而状态之间是需要满足条件进行转移的。</p>
<h3 id="完全背包-每件物品有无限个"><a href="#完全背包-每件物品有无限个" class="headerlink" title="完全背包 每件物品有无限个"></a>完全背包 每件物品有无限个</h3><p>01背包：从f[i-1]转过来 f[i,h]=max(f[i-1,j],f[i-1,j-v]+w[i]) //优化后:f[j]=max(f[j],f[v-v[i]]+w[i])</p>
<p>完全背包：从f[i]转移 f[i,j]=max(f[i-1,j],f[i,j-v[i]]+w[i])</p>
<p>每次更新：k是每个物品可以有多少个，i是前i个物品，j是当前背包容量</p>
<p>f[i][j]=max(f[i][j],f[i-j][j-v[i]*k]+w[i]*k</p>
<p>优化思路：</p>
<p><img src="file://D:/typora%E7%94%A8%E5%9B%BE/Screenshots/image-20230521084412853.png?lastModify=1694256669" alt="image-20230521084412853"></p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">​  
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span> <span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> m <span class="token punctuation">;</span> j <span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// for (int k = 0 ; k * v[i] &lt;= j ; k ++) {</span>
            <span class="token comment">//     f[i][j] = max(f[i][j],f[i - 1][j - k *v[i]] + k * w[i]);</span>
            <span class="token comment">// }</span>
            <span class="token comment">//f[i][j] = max(f[i-1][j],f[i-1][j-v]+w,f[i-1][j-2v] + 2w , ......)</span>
            <span class="token comment">//f[i][j-v] = max(        ,f[i-1][j-v],f[i-1][j-2v]+2w,....)</span>
            <span class="token comment">//错位相减</span>
            <span class="token comment">// f[i][j] - f[i][j-v] = w</span>
            <span class="token comment">// f[i][j] = f[i][j-v] + w</span>
            <span class="token comment">//所以 </span>
            <span class="token comment">//f[i][j] = max(f[i-1][j],f[i][j-v] + w)</span>
            <span class="token comment">//根据递推，每一个max后面那个数都等于上一个的f[i][j-v] + w</span>
            <span class="token comment">//前提是要大于v[i]等式才成立</span>
            f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> f<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//前一个转移</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">&gt;=</span> v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">+</span>w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

一维优化：删去一维

<span class="token comment">//f[i][j]=f[i-1][j];  f[i]==f[i-1] 直接删去  </span>
​  
<span class="token comment">//if(j&gt;=v[i]){ 只有当前背包容量大于当前的物品时才能装入，采用从v[i]遍历背包容量  </span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>  
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>j<span class="token operator">&lt;=</span>m<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>  
    <span class="token comment">//f[i,j]=max(f[i-1,j],f[i,j-v[i]]+w[i])  </span>
        f<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span><span class="token function">max</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>f<span class="token punctuation">[</span>j<span class="token operator">-</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">+</span>w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
<span class="token comment">//}  </span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>01和完全背包区别：</p>
<p>背包容量的遍历不同</p>
<p>01:</p>
<p> for(int j=m;j&gt;=v[i];j–)//m为最大背包容量<br>        f[j]=max(f[j],f[j-v[i]+w[i]]);</p>
<p>完全：</p>
<p>for(int j=v[i],j&lt;=m;j++)<br>        f[j]=max(f[j],f[j-v[i]]+w[i]);</p>
<h3 id="多重背包问题-优化"><a href="#多重背包问题-优化" class="headerlink" title="多重背包问题 优化"></a>多重背包问题 优化</h3><p>每个物品有个数限制，但不是无限</p>
<ol>
<li><p>状态表示：f[ i ] [ j ]</p>
<ul>
<li><p>集合</p>
</li>
<li><p>属性</p>
</li>
</ul>
</li>
<li><p>状态计算：</p>
<p> f[i][j]=max(f[i-1][j-v[i]*k]+w[i]*k)  k有范围</p>
<p> 优化：将数量打包，比如打包成1个物品一起，2个物品一起……</p>
<p> 之后用01背包做即可</p>
</li>
</ol>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;bits/stdc++.h&gt;</span>  </span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>  
<span class="token keyword">const</span> <span class="token keyword">int</span> N <span class="token operator">=</span> <span class="token number">1001</span><span class="token punctuation">;</span>  
<span class="token keyword">int</span> f<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span>v<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span>w<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>  
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  
    <span class="token keyword">int</span> n<span class="token punctuation">,</span>m<span class="token punctuation">,</span>cnt<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>  
    cin<span class="token operator">&gt;&gt;</span>n<span class="token operator">&gt;&gt;</span>m<span class="token punctuation">;</span>  
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  
        <span class="token keyword">int</span> a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>s<span class="token punctuation">;</span><span class="token comment">//容量，价值  </span>
        cin<span class="token operator">&gt;&gt;</span>a<span class="token operator">&gt;&gt;</span>b<span class="token operator">&gt;&gt;</span>s<span class="token punctuation">;</span>  
        <span class="token keyword">int</span> k<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//用来打包  </span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>k<span class="token operator">&lt;=</span>s<span class="token punctuation">)</span><span class="token punctuation">{</span>  
            cnt<span class="token operator">++</span><span class="token punctuation">;</span>  
            v<span class="token punctuation">[</span>cnt<span class="token punctuation">]</span><span class="token operator">=</span>a<span class="token operator">*</span>k<span class="token punctuation">;</span>  
            w<span class="token punctuation">[</span>cnt<span class="token punctuation">]</span><span class="token operator">=</span>b<span class="token operator">*</span>k<span class="token punctuation">;</span>  
            s<span class="token operator">-=</span>k<span class="token punctuation">;</span>  
            k<span class="token operator">*=</span><span class="token number">2</span><span class="token punctuation">;</span>  
        <span class="token punctuation">}</span>  
        <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token operator">&gt;</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  
            cnt<span class="token operator">++</span><span class="token punctuation">;</span>  
            v<span class="token punctuation">[</span>cnt<span class="token punctuation">]</span><span class="token operator">=</span>a<span class="token operator">*</span>s<span class="token punctuation">;</span>  
            w<span class="token punctuation">[</span>cnt<span class="token punctuation">]</span><span class="token operator">=</span>b<span class="token operator">*</span>s<span class="token punctuation">;</span>  
        <span class="token punctuation">}</span>  
    <span class="token punctuation">}</span>  
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>cnt<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span>m<span class="token punctuation">;</span>j<span class="token operator">&gt;=</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>j<span class="token operator">--</span><span class="token punctuation">)</span>  
        f<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span><span class="token function">max</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>f<span class="token punctuation">[</span>j<span class="token operator">-</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">+</span>w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token punctuation">}</span>  
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="分组背包问题"><a href="#分组背包问题" class="headerlink" title="分组背包问题"></a>分组背包问题</h3><h2 id="线性DP"><a href="#线性DP" class="headerlink" title="线性DP"></a>线性DP</h2><p>递归方程有线性关系，具有求的先后顺序</p>
<p>具体有各种子序列</p>
<p>建议看leetcode101 里面的比较好</p>
<h1 id="数位统计DP"><a href="#数位统计DP" class="headerlink" title="数位统计DP"></a>数位统计DP</h1><p>给出两个数字 a, b</p>
<p>统计a到b 中每一位 的0~9的出现次数</p>
<p>思路：分情况讨论 + 前缀和思想</p>
<p><img src="file://D:/typora%E7%94%A8%E5%9B%BE/Screenshots/image-20230524164849922.png?lastModify=1694256669" alt="image-20230524164849922"></p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">include <span class="token operator">&lt;</span>iostream<span class="token operator">&gt;</span>  
<span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">include</span> <span class="token string">&lt;cmath&gt;</span>  </span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>  
  
<span class="token keyword">int</span> <span class="token function">dgt</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token comment">// 计算整数n有多少位  </span>
<span class="token punctuation">{</span>  
    <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  
    <span class="token keyword">while</span> <span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token operator">++</span> res<span class="token punctuation">,</span> n <span class="token operator">/=</span> <span class="token number">10</span><span class="token punctuation">;</span>  
    <span class="token keyword">return</span> res<span class="token punctuation">;</span>  
<span class="token punctuation">}</span>  
  
<span class="token keyword">int</span> <span class="token function">cnt</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token comment">// 计算从1到n的整数中数字i出现多少次   </span>
<span class="token punctuation">{</span>  
    <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> d <span class="token operator">=</span> <span class="token function">dgt</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> d<span class="token punctuation">;</span> j <span class="token operator">++</span><span class="token punctuation">)</span> <span class="token comment">// 从右到左第j位上数字i出现多少次，所有位上的次数加起来就是i出现的总次数  </span>
    <span class="token punctuation">{</span>  
        <span class="token comment">// l和r是第j位左边和右边的整数 (视频中的abc和efg); dj是第j位的数字  </span>
        <span class="token keyword">int</span> p <span class="token operator">=</span> <span class="token function">pow</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> l <span class="token operator">=</span> n <span class="token operator">/</span> p <span class="token operator">/</span> <span class="token number">10</span><span class="token punctuation">,</span> r <span class="token operator">=</span> n <span class="token operator">%</span> p<span class="token punctuation">,</span> dj <span class="token operator">=</span> n <span class="token operator">/</span> p <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">;</span>  
        <span class="token comment">// 计算第j位左边的整数小于l (视频中xxx = 000 ~ abc - 1)的情况  </span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>i<span class="token punctuation">)</span> res <span class="token operator">+=</span> l <span class="token operator">*</span> p<span class="token punctuation">;</span>   
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>i <span class="token operator">&amp;&amp;</span> l<span class="token punctuation">)</span> res <span class="token operator">+=</span> <span class="token punctuation">(</span>l <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> p<span class="token punctuation">;</span> <span class="token comment">// 如果i = 0, 左边高位不能全为0(视频中xxx = 001 ~ abc - 1)，并且&amp;&amp;l表示这时i也不能在最高位出现。  </span>
        <span class="token comment">// 计算第j位左边的整数等于l (视频中xxx = abc)的情况  </span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token punctuation">(</span>dj <span class="token operator">&gt;</span> i<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>i <span class="token operator">||</span> l<span class="token punctuation">)</span> <span class="token punctuation">)</span> res <span class="token operator">+=</span> p<span class="token punctuation">;</span>  <span class="token comment">//(i || l)表示i=0时，i不能出现在最高位（即l不能为0），因为这种数是不存在的  </span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token punctuation">(</span>dj <span class="token operator">==</span> i<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>i <span class="token operator">||</span> l<span class="token punctuation">)</span> <span class="token punctuation">)</span> res <span class="token operator">+=</span> r <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">//(i || l)表示i=0时，i不能出现在最高位（即l不能为0），因为这种数是不存在的  </span>
    <span class="token punctuation">}</span>  
    <span class="token keyword">return</span> res<span class="token punctuation">;</span>  
<span class="token punctuation">}</span>  
  
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  
<span class="token punctuation">{</span>  
    <span class="token keyword">int</span> a<span class="token punctuation">,</span> b<span class="token punctuation">;</span>  
    <span class="token keyword">while</span> <span class="token punctuation">(</span>cin <span class="token operator">&gt;&gt;</span> a <span class="token operator">&gt;&gt;</span> b <span class="token punctuation">,</span> a<span class="token punctuation">)</span>  
    <span class="token punctuation">{</span>  
        <span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">&gt;</span> b<span class="token punctuation">)</span> <span class="token function">swap</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>  
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">9</span><span class="token punctuation">;</span> <span class="token operator">++</span> i<span class="token punctuation">)</span> cout <span class="token operator">&lt;&lt;</span> <span class="token function">cnt</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> i<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token function">cnt</span><span class="token punctuation">(</span>a <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token char">' '</span><span class="token punctuation">;</span>  
        cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>  
    <span class="token punctuation">}</span>  
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="数位DP-重要"><a href="#数位DP-重要" class="headerlink" title="数位DP(重要)"></a>数位DP(重要)</h1><p>DP时间复杂度：状态个数*转移个数</p>
<p>相当于往空里填数字</p>
<p><strong>知识点1：</strong>mask集合</p>
<blockquote>
<p>集合和数字的替换，使用二进制转化集合来实现某些数字不选择</p>
<p>例： 10011 从高到低依次代表者 4 3 2 1 0 这几个数字选不选，1表示选择，那么，</p>
<p>集合mask &gt;&gt; d &amp; 1 d为这个数字，进行这样的运算就可以判断mask 对应的d数字这个位置上是1还是0</p>
<p>同理 mask|(1&lt;&lt;d) 将1移位到mask上 代表d这个数字的位置，进行或运算，即可将d加入集合中</p>
</blockquote>
<h2 id="模板：-1"><a href="#模板：-1" class="headerlink" title="模板："></a>模板：</h2><p>将问题转化为填数字受限问题：</p>
<blockquote>
<p>递归中的变量：</p>
<p>i 当前下标 当 i == 最大长度时，根据是否满足条件返回 0 或 1</p>
<p>mask 集合 代表着一种状态的记录，比如某位填了哪些数字，或者截止到上一位已经积累的某个要求满足条件的数据是多少，这个一般是变化的</p>
<p>is_limit 前一个位置是否收到原来的数字的限制：123 第一个填1 了后面一定受限，同时如果前面受限了，那么后面所有的都受限</p>
<p>is_num 前一个位置是否填数字，如果前一个没填数字，那么这一位无法填0了，如果填了可以填任意数字，当0对题目没影响时，可以不用这个东西</p>
</blockquote>
<p><strong>模板公式：</strong></p>
<ol>
<li><p>求出最大长度和memo，记忆数组，并初始化为-1 memo数组的一维是长度，二维是能包含所有枚举的最大长度，具体问题具体分析</p>
</li>
<li><p>递归函数</p>
<ul>
<li><p>结束递归条件<code>i == m 返回是否满足 满足为1 满足为0</code></p>
</li>
<li><p>记忆化剪枝：当is_limit 和 is_num 只有一个为真时，后面的数字也是可以任意填的，所以可以剪枝</p>
</li>
<li><p><code>!is_limit &amp;&amp; is_num &amp;&amp; memo[i][mask] != -1 return memo[i][mask]</code></p>
</li>
<li><p>设出res = 0 即为我们要求的答案</p>
</li>
<li><p>(可能不存在这种情况)这一位不填数字：<code>res = (i+1 , mask不改变, false , false)</code></p>
</li>
<li><p>求出这一位数字可以填写的上下界：根据is_limit来求 <code>up = is_limit ? s[i] - '0' : 9</code></p>
</li>
<li><p>枚举这一位数字，进行递归 (条件判断不一定需要)</p>
</li>
<li><p><code>for (int d = 初始 ; d &lt;= up ; d++) if(当前这个数字没使用) 把这个数字加入mask</code></p>
</li>
<li><p>循环内：<code>res = (i+1 , mask 的改变 , is_limit &amp;&amp; d == up , is_num的变化)</code></p>
</li>
<li><p>当is_limit 和 is_num 只有一个为真时将答案加入memo中 <code>if(!is_limit &amp;&amp; is_num) memo[i][mask] = res</code></p>
</li>
<li><p>返回res</p>
</li>
</ul>
</li>
</ol>
<p><strong>例题：</strong></p>
<ol>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/numbers-with-repeated-digits/description/">1012. 至少有 1 位重复的数字 - 力扣（Leetcode）</a></li>
</ol>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>  
<span class="token keyword">public</span><span class="token operator">:</span>  
    <span class="token keyword">int</span> <span class="token function">numDupDigitsAtMostN</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>  
        <span class="token comment">//将n转化为字符串，方便枚举每一位置上的数字  </span>
        <span class="token keyword">auto</span> s <span class="token operator">=</span><span class="token function">to_string</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//使用auto 防止爆int  </span>
        <span class="token comment">//记忆化数组，当dp到相同的情况时直接可以使用以前的的出来的  </span>
        <span class="token comment">//第一维为长度  </span>
        <span class="token comment">//第二位代表可以选择的数字有哪些  </span>
        <span class="token comment">//这题从高到低每一位代表着 9876543210 所以需要移动到第11位，才能出现10个数字都选择的情况  </span>
        <span class="token keyword">int</span> m <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>memo<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  
        <span class="token function">memset</span><span class="token punctuation">(</span>memo<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token punctuation">,</span><span class="token keyword">sizeof</span> memo<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//-1表示没有计算过这种情况  </span>
        <span class="token comment">//递归函数  </span>
        function<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span><span class="token keyword">int</span><span class="token punctuation">,</span><span class="token keyword">bool</span><span class="token punctuation">,</span><span class="token keyword">bool</span><span class="token punctuation">)</span><span class="token operator">&gt;</span> f <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token punctuation">,</span><span class="token keyword">int</span> mask<span class="token punctuation">,</span> <span class="token keyword">bool</span> is_limit <span class="token punctuation">,</span> <span class="token keyword">bool</span> is_num<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token keyword">int</span> <span class="token punctuation">{</span>  
            <span class="token comment">//i 下标  </span>
            <span class="token comment">//mask 是记录当前已经选择数字的集合  </span>
            <span class="token comment">//is_limit 代表当前位置是否受到n这个数字的制约，比如不能超过某个数字  </span>
            <span class="token comment">//is_num 代表前一位是否填数字了，这个是用来判断0是否可填的，如果0可不可填都无所谓就可以不使用这个了  </span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> m<span class="token punctuation">)</span> <span class="token comment">//如果dp到了最后一个位置了，要返回是否得到合法数字了  </span>
                 <span class="token keyword">return</span> is_num<span class="token punctuation">;</span><span class="token comment">//合法数字一定为true，因为长度到了前一个一定要填数字的  </span>
            <span class="token comment">//如果没收到限制或者没收到前一个的填数字的限制，后面可以任意填了，所以必定会有很小重复性的，所以可以直接返回  </span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>is_limit <span class="token operator">&amp;&amp;</span> is_num <span class="token operator">&amp;&amp;</span>memo<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>mask<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> memo<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>mask<span class="token punctuation">]</span><span class="token punctuation">;</span>  
            <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>is_num<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//前一个数字没填，这个数字当然也可以不填  </span>
                res <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span> <span class="token punctuation">,</span> mask <span class="token punctuation">,</span> <span class="token boolean">false</span> <span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
                <span class="token comment">//继续递归  </span>
            <span class="token punctuation">}</span>  
            <span class="token comment">//如果当前数字没收到限制，那么当然可以继续任意填  </span>
            <span class="token comment">//如果收到限制了，那么最多只能填当前这一位置上的数字  </span>
            <span class="token keyword">int</span> up <span class="token operator">=</span> is_limit <span class="token operator">?</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token char">'0'</span> <span class="token operator">:</span> <span class="token number">9</span><span class="token punctuation">;</span>  
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> d <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">-</span> is_num <span class="token punctuation">;</span> d <span class="token operator">&lt;=</span> up <span class="token punctuation">;</span> <span class="token operator">++</span>d<span class="token punctuation">)</span>  
                <span class="token comment">//枚举可以填入的数据，前一位没填数字 ，那么这一位只能从1开始，否则可以从0开始，那么可以填0，如果没被限制，那么要小心是否是第一位了，所以从1开始  </span>
                <span class="token comment">//当d == up 时，  </span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>mask <span class="token operator">&gt;&gt;</span> d <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">// d 不在 mask 中  </span>
                <span class="token comment">//d != up 时，所有的后面的位置都不会受限  </span>
                <span class="token comment">//d == up 时，如果前一位已经受限了，那么后面还会接着受限  </span>
                    res <span class="token operator">+=</span> <span class="token function">f</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> mask <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> d<span class="token punctuation">)</span><span class="token punctuation">,</span> is_limit <span class="token operator">&amp;&amp;</span> d <span class="token operator">==</span> up<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     
              
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>is_limit <span class="token operator">&amp;&amp;</span> is_num<span class="token punctuation">)</span>  
            <span class="token comment">//如果没收到限制或者没收到前一个的填数字的限制，后面可以任意填了  </span>
                memo<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>mask<span class="token punctuation">]</span> <span class="token operator">=</span> res<span class="token punctuation">;</span>  
            <span class="token keyword">return</span> res<span class="token punctuation">;</span>  
        <span class="token punctuation">}</span><span class="token punctuation">;</span>  
        <span class="token keyword">return</span> n <span class="token operator">-</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token number">0</span> <span class="token punctuation">,</span> <span class="token number">0</span> <span class="token punctuation">,</span> <span class="token boolean">true</span> <span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//第一个数字肯定受限了  </span>
    <span class="token punctuation">}</span>  
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token number">2.</span> <span class="token punctuation">[</span><span class="token number">6396.</span> 统计整数数目 <span class="token operator">-</span> 力扣（Leetcode）<span class="token punctuation">]</span><span class="token punctuation">(</span>https<span class="token operator">:</span><span class="token comment">//leetcode.cn/problems/count-of-integers/description/) 一种变形，好好理解</span>
    <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>  
    <span class="token keyword">public</span><span class="token operator">:</span>  
        <span class="token keyword">const</span> <span class="token keyword">int</span> mod <span class="token operator">=</span> <span class="token number">1e9</span> <span class="token operator">+</span> <span class="token number">7</span><span class="token punctuation">;</span>  
        <span class="token keyword">int</span> <span class="token function">cmp</span><span class="token punctuation">(</span>string s <span class="token punctuation">,</span> <span class="token keyword">int</span> min_sum <span class="token punctuation">,</span> <span class="token keyword">int</span> max_sum<span class="token punctuation">)</span><span class="token punctuation">{</span>  
            <span class="token comment">//memo数组最大有 n个9 或者是被迫的这个最大数字 记得 + 1  </span>
            <span class="token keyword">int</span> n <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">,</span> memo<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token function">min</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token operator">*</span>n<span class="token punctuation">,</span>max_sum<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  
            <span class="token function">memset</span><span class="token punctuation">(</span>memo <span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token punctuation">,</span> <span class="token keyword">sizeof</span> memo<span class="token punctuation">)</span><span class="token punctuation">;</span>  
            <span class="token comment">//因为0无影响，所以is_num可以不要了  </span>
            <span class="token comment">//sum 就是mask  </span>
            function <span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token punctuation">,</span><span class="token keyword">int</span> <span class="token punctuation">,</span><span class="token keyword">bool</span><span class="token punctuation">)</span><span class="token operator">&gt;</span> f <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token punctuation">,</span> <span class="token keyword">int</span> sum <span class="token punctuation">,</span> <span class="token keyword">bool</span> is_limit<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token keyword">int</span> <span class="token punctuation">{</span>  
            <span class="token comment">//1.非法情况  </span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>sum <span class="token operator">&gt;</span> max_sum<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//结束递归，sum是一直增加的，后面无法减小的  </span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> n<span class="token punctuation">)</span> <span class="token keyword">return</span> sum <span class="token operator">&gt;=</span> min_sum<span class="token punctuation">;</span><span class="token comment">//结束递归的时候如果数字合法且满足  </span>
            <span class="token comment">//少了一个is_num,只要后面不受限制，那么，后面一定重复  </span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>is_limit <span class="token operator">&amp;&amp;</span> memo<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>sum<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> memo<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>sum<span class="token punctuation">]</span><span class="token punctuation">;</span>  
            <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span> <span class="token comment">//计算所要的答案，也就是计数  </span>
            <span class="token keyword">int</span> up <span class="token operator">=</span> is_limit <span class="token operator">?</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token char">'0'</span> <span class="token operator">:</span> <span class="token number">9</span><span class="token punctuation">;</span><span class="token comment">//上界  </span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> d <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span> d <span class="token operator">&lt;=</span> up <span class="token punctuation">;</span> d<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//枚举位置上的数字  </span>
                <span class="token comment">//d == up的时候，如果前面受限了，后面继续受限，如果前面没受限，那么后面也不受限  </span>
                res <span class="token operator">=</span> <span class="token punctuation">(</span>res <span class="token operator">+</span> <span class="token function">f</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span> <span class="token punctuation">,</span> sum <span class="token operator">+</span> d  <span class="token punctuation">,</span> is_limit <span class="token operator">&amp;&amp;</span> d <span class="token operator">==</span> up<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">%</span> mod<span class="token punctuation">;</span>  
            <span class="token punctuation">}</span>  
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>is_limit<span class="token punctuation">)</span> memo<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>sum<span class="token punctuation">]</span> <span class="token operator">=</span> res <span class="token punctuation">;</span>  <span class="token comment">//与上面保持一致  </span>
            <span class="token keyword">return</span> res <span class="token punctuation">;</span><span class="token comment">//返回答案  </span>
            <span class="token punctuation">}</span><span class="token punctuation">;</span>  
            <span class="token keyword">return</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token number">0</span> <span class="token punctuation">,</span> <span class="token number">0</span> <span class="token punctuation">,</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//初始状态下，一定受限  </span>
        <span class="token punctuation">}</span>  
        <span class="token keyword">int</span> <span class="token function">count</span><span class="token punctuation">(</span>string num1<span class="token punctuation">,</span> string num2<span class="token punctuation">,</span> <span class="token keyword">int</span> min_sum<span class="token punctuation">,</span> <span class="token keyword">int</span> max_sum<span class="token punctuation">)</span> <span class="token punctuation">{</span>  
            <span class="token comment">//转化：  </span>
            <span class="token comment">/*  
                计算 &lt;= num2 的合法数字a和 &lt;= num2 的合法数字b 答案就等于 a - b  
                可以直接计算 &lt;= num1 的合法数字，最后单独判定 num1是否合法  
                套模板： mask 在这里指的是各位数字之和  
                递归结束条件：  
                sum &gt; max_sum 直接返回0 ，不成立，因为sum不能减小，所以继续递归下去也没有用  
                递归到就结束的时候，如果 sum &gt;= min_sum 那么就是满足的，可以直接返回1了  
                前导零对和没有影响，所以isnum可以不用  
                最后：取模运算  
                (a+b)mod m = ((a mod m) + (b mod m )) mod m  
                (a*b)mode m = ((a mod m) * (b mod m )) mod m  
            */</span>  
            <span class="token keyword">int</span> ans <span class="token operator">=</span> <span class="token function">cmp</span><span class="token punctuation">(</span>num2 <span class="token punctuation">,</span> min_sum <span class="token punctuation">,</span>max_sum<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token function">cmp</span><span class="token punctuation">(</span>num1 <span class="token punctuation">,</span> min_sum <span class="token punctuation">,</span>max_sum<span class="token punctuation">)</span><span class="token punctuation">;</span>  
            <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  
            <span class="token comment">//最后一个num1单独判断，因为上面计算的是 num1 &lt; x &lt;= num2的，和前缀和一样  </span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> c <span class="token operator">:</span> num1<span class="token punctuation">)</span> sum <span class="token operator">+=</span> c <span class="token operator">-</span> <span class="token char">'0'</span><span class="token punctuation">;</span>  
            ans <span class="token operator">+=</span> min_sum <span class="token operator">&lt;=</span> sum <span class="token operator">&amp;&amp;</span> sum <span class="token operator">&lt;=</span> max_sum <span class="token punctuation">;</span>  
            <span class="token keyword">return</span> ans <span class="token operator">%</span> mod<span class="token punctuation">;</span>  
        <span class="token punctuation">}</span>  
    <span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="状压DP-状态压缩-动态规划-利用二进制把状态记录成二进制数"><a href="#状压DP-状态压缩-动态规划-利用二进制把状态记录成二进制数" class="headerlink" title="状压DP 状态压缩+动态规划 利用二进制把状态记录成二进制数"></a>状压DP 状态压缩+动态规划 利用二进制把状态记录成二进制数</h2><p>291 91</p>
<pre class="line-numbers language-css" data-language="css"><code class="language-css"><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="树形DP-各层选择取最大值"><a href="#树形DP-各层选择取最大值" class="headerlink" title="树形DP 各层选择取最大值"></a>树形DP 各层选择取最大值</h2><p>将状态分为当前节点选择和不选择</p>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/287/">285. 没有上司的舞会 - AcWing题库</a></p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;bits/stdc++.h&gt;</span>  </span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>  
<span class="token keyword">const</span> <span class="token keyword">int</span> N <span class="token operator">=</span> <span class="token number">6010</span><span class="token punctuation">;</span>  
<span class="token keyword">int</span> happy<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>  
<span class="token keyword">int</span> n<span class="token punctuation">;</span>  
<span class="token keyword">int</span> e<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token comment">/*e存的是编号1*/</span> <span class="token punctuation">,</span> ne<span class="token punctuation">[</span>N<span class="token punctuation">]</span> <span class="token punctuation">,</span> idx <span class="token punctuation">,</span>h<span class="token punctuation">[</span>N<span class="token punctuation">]</span> <span class="token punctuation">,</span> dp<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>  
<span class="token keyword">bool</span> fa<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>  
<span class="token comment">/*  
    状态定义：dp[i][1] dp[i][0] 当前节点选不选  
    状态转移 ： dp[i][0] = sum(子树)   子树有可以分为选与不选  取最大值  
                dp[i][1] = sum(下一层子树不选)    
    属性： 最大值  
   
*/</span>  
<span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  
    idx <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  
    <span class="token function">memset</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token punctuation">,</span> <span class="token keyword">sizeof</span> h<span class="token punctuation">)</span><span class="token punctuation">;</span>  
<span class="token punctuation">}</span>  
<span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">{</span>  
    e<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> b<span class="token punctuation">;</span>  
    ne<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> h<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">;</span>  
    h<span class="token punctuation">[</span>a<span class="token punctuation">]</span> <span class="token operator">=</span> idx<span class="token operator">++</span><span class="token punctuation">;</span>  
<span class="token punctuation">}</span>  
<span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span> u<span class="token punctuation">)</span><span class="token punctuation">{</span>  
        <span class="token comment">//如果当前的节点要选择的话，要初始化数据  </span>
        dp<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> happy<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">;</span>  
        <span class="token comment">//遍历u的子树  </span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> h<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token punctuation">;</span> i <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token punctuation">;</span> i <span class="token operator">=</span> ne<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  
            <span class="token keyword">int</span> j <span class="token operator">=</span> e<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>  
            <span class="token comment">//递归到最低层，实现一层层的求和  </span>
            <span class="token function">dfs</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>  
            <span class="token comment">//当前不选，则是子树的最大值  </span>
            dp<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token punctuation">,</span> dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
            <span class="token comment">//当前选择，那么就是下一层子树不选  </span>
            dp<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+=</span> dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  
        <span class="token punctuation">}</span>  
<span class="token punctuation">}</span>  
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  
    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span> <span class="token punctuation">,</span><span class="token operator">&amp;</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  
        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>happy<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token punctuation">}</span>  
    <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token operator">-</span><span class="token number">1</span> <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  
        <span class="token keyword">int</span> a <span class="token punctuation">,</span> b <span class="token punctuation">;</span>  
        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d%d"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>a<span class="token punctuation">,</span><span class="token operator">&amp;</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>  
        fa<span class="token punctuation">[</span>a<span class="token punctuation">]</span> <span class="token operator">=</span><span class="token boolean">true</span><span class="token punctuation">;</span>  
        <span class="token function">add</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token punctuation">}</span>  
    <span class="token keyword">int</span> root <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  
    <span class="token keyword">while</span><span class="token punctuation">(</span>fa<span class="token punctuation">[</span>root<span class="token punctuation">]</span><span class="token punctuation">)</span> root<span class="token operator">++</span><span class="token punctuation">;</span>  
    <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span><span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>root<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>dp<span class="token punctuation">[</span>root<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="状态机："><a href="#状态机：" class="headerlink" title="状态机："></a>状态机：</h2><blockquote>
<p>通过表示出状态的转换方式即可自动得到答案</p>
</blockquote>
<h2 id="DP行-x2F-列问题"><a href="#DP行-x2F-列问题" class="headerlink" title="DP行/列问题"></a>DP行/列问题</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-strictly-increasing-cells-in-a-matrix/">6456. 矩阵中严格递增的单元格数 - 力扣（Leetcode）</a></p>
<h3 id="例题：股票买卖问题"><a href="#例题：股票买卖问题" class="headerlink" title="例题：股票买卖问题"></a>例题：股票买卖问题</h3><p><strong>含有冷却时间需要用四个状态，正常两个即可，具体问题具体分析</strong></p>
<ol>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/description/">714. 买卖股票的最佳时机含手续费 - 力扣（Leetcode）</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/solutions/2283535/zhuang-tai-ji-dp-by-hardcore-dubinsky348-1qew/">309. 最佳买卖股票时机含冷冻期 - 力扣（Leetcode）</a></p>
</li>
</ol>
<h2 id="通过stoi-和隔板法实现枚举每一个数字的任意子子串"><a href="#通过stoi-和隔板法实现枚举每一个数字的任意子子串" class="headerlink" title="通过stoi 和隔板法实现枚举每一个数字的任意子子串"></a>通过stoi 和隔板法实现枚举每一个数字的任意子子串</h2><p>stoi substr to_string 的妙用</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-the-punishment-number-of-an-integer/">6441. 求一个整数的惩罚数 - 力扣（LeetCode）</a></p>
<h2 id="子列和-x2F-字串问题："><a href="#子列和-x2F-字串问题：" class="headerlink" title="子列和/字串问题："></a>子列和/字串问题：</h2><ol>
<li><p>求任意子列的乘积最大 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-strength-of-a-group/">6393. 一个小组的最大实力值 - 力扣（Leetcode）</a></p>
</li>
<li><p>一个字符串匹配另一个字典求最大匹配长度问题：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/extra-characters-in-a-string/">6394. 字符串中的额外字符 - 力扣（Leetcode）</a></p>
</li>
<li><p>反转01得到相等字符串问题：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-cost-to-make-all-characters-equal/">6455. 使所有字符相等的最小成本 - 力扣（Leetcode）</a></p>
</li>
</ol>
<h1 id="暴力枚举法"><a href="#暴力枚举法" class="headerlink" title="暴力枚举法"></a>暴力枚举法</h1><p>使用于组合的数量少，但是需要找到最合适的组合的题目<br>例题<br><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-moves-to-spread-stones-over-grid/submissions/">3*3</a></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E7%AE%97%E6%B3%95%EF%BC%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag"># 算法，数据结构</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/08/27/25/" rel="prev" title="Java基础">
      <i class="fa fa-chevron-left"></i> Java基础
    </a></div>
      <div class="post-nav-item">
    <a href="/2023/09/17/02/" rel="next" title="ssm-practice">
      ssm-practice <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#JAVA-%E5%BF%AB%E5%86%99"><span class="nav-number">1.</span> <span class="nav-text">JAVA 快写</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%80%E7%9F%AD%E8%B7%AF%E4%B8%8E%E5%85%B7%E4%BD%93%E7%9A%84%E8%B7%AF%E5%BE%84%E8%AE%B0%E5%BD%95%E9%97%AE%E9%A2%98"><span class="nav-number">2.</span> <span class="nav-text">最短路与具体的路径记录问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TreeMap"><span class="nav-number">3.</span> <span class="nav-text">TreeMap</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8A%8AtoCharArray%E5%90%91%E5%8F%B3%E7%A7%BB%E5%8A%A8%E4%B8%80%E4%BD%8D"><span class="nav-number">4.</span> <span class="nav-text">把toCharArray向右移动一位</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#a-z-%E4%B9%8B%E9%97%B4%E5%81%8F%E7%A7%BB%E9%87%8F%E7%A1%AE%E8%AE%A4"><span class="nav-number">5.</span> <span class="nav-text">a ~ z 之间偏移量确认</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9C%8B%E5%88%B0%E5%94%AF%E4%B8%80%E8%A7%A3%EF%BC%8C%E4%B8%94%E6%98%AF%E9%9A%BE%E4%BB%A5%E5%81%9A%E7%9A%84%E5%9B%BE%E5%BD%A2%E9%A2%98%EF%BC%8C%E5%8F%AF%E4%BB%A5%E8%80%83%E8%99%91%E8%BD%AC%E5%8C%96%E4%B8%BA%E6%96%B9%E7%A8%8B"><span class="nav-number">6.</span> <span class="nav-text">看到唯一解，且是难以做的图形题，可以考虑转化为方程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%A1%E7%89%B9%E5%85%B0%E6%95%B0%E9%97%AE%E9%A2%98-%EF%BC%9Ah-n-x3D-C-2n-n-%E2%88%92C-2n-n%E2%88%921-n-x3D-0-1-2-%E2%80%A6-%E7%BB%84%E5%90%88%E6%95%B0C%E4%B8%8D%E8%A7%A3%E9%87%8A%E4%BA%86%EF%BC%9B-C%E6%98%AF%E7%BB%84%E5%90%88%E6%95%B0"><span class="nav-number">6.1.</span> <span class="nav-text">卡特兰数问题 ：h[n]&#x3D;C[2n,n]−C [2n,n−1] (n&#x3D;0,1,2,…) 组合数C不解释了； C是组合数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%91%E6%98%AF%E6%97%A0%E5%90%91%E8%BE%B9"><span class="nav-number">7.</span> <span class="nav-text">树是无向边</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java%E6%97%A5%E6%9C%9F"><span class="nav-number">8.</span> <span class="nav-text">Java日期</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JAVA%E6%9B%B4%E5%BF%AB%E6%9B%B4%E5%BC%BA%E7%9A%84%E8%AF%BB%E5%85%A5%E5%92%8C%E5%86%99-https-www-luogu-com-cn-problem-P2367"><span class="nav-number">9.</span> <span class="nav-text">JAVA更快更强的读入和写 https:&#x2F;&#x2F;www.luogu.com.cn&#x2F;problem&#x2F;P2367</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%96%E4%BD%99%E6%95%B0%E7%9A%84%E5%B0%8F%E6%8A%80%E5%B7%A7"><span class="nav-number">10.</span> <span class="nav-text">取余数的小技巧</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95"><span class="nav-number">11.</span> <span class="nav-text">常用算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#stl%E5%92%8C%E4%B8%80%E4%BA%9B%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0"><span class="nav-number">11.1.</span> <span class="nav-text">stl和一些内置函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%92%E5%BA%8F"><span class="nav-number">12.</span> <span class="nav-text">排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E6%A8%A1%E6%9D%BF-%E6%A0%B9%E6%8D%AE%E6%95%B0%E6%9D%A5%E5%88%86%E6%B2%BB"><span class="nav-number">12.1.</span> <span class="nav-text">快速排序模板 根据数来分治</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E6%A8%A1%E6%9D%BF-%E5%88%86%E6%B2%BB-%E6%A0%B9%E6%8D%AE%E4%B8%AD%E9%97%B4%E4%B8%A4%E4%B8%AA%E6%95%B0%E4%B8%BA%E5%88%86%E7%95%8C%E7%BA%BF"><span class="nav-number">12.2.</span> <span class="nav-text">归并排序模板 分治 根据中间两个数为分界线</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%88%86%E6%B3%95-%E4%BA%8C%E5%88%86%E8%A6%81%E4%BF%9D%E8%AF%81%E6%9C%89%E8%A7%A3"><span class="nav-number">13.</span> <span class="nav-text">二分法 二分要保证有解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B4%E6%95%B0%E4%BA%8C%E5%88%86"><span class="nav-number">13.1.</span> <span class="nav-text">整数二分</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#l-x3D-mid-1-%E6%97%B6-%E8%BE%93%E5%87%BA%E7%9A%84%E6%98%AF-L-r-x3D-mid-1-%E6%97%B6-%E8%BE%93%E5%87%BA%E7%9A%84%E6%98%AFr"><span class="nav-number">14.</span> <span class="nav-text">l &#x3D; mid + 1 时,输出的是 L , r &#x3D; mid -1 时 输出的是r</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%AE%E7%82%B9%E6%95%B0%E4%BA%8C%E5%88%86-%E4%B8%8D%E8%A6%81%E5%A4%84%E7%90%86%E8%BE%B9%E7%95%8C"><span class="nav-number">14.1.</span> <span class="nav-text">浮点数二分 不要处理边界</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%AB%98%E7%B2%BE%E5%BA%A6"><span class="nav-number">15.</span> <span class="nav-text">高精度</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A0%E6%B3%95%EF%BC%9A-%E6%B3%A8%E6%84%8F%E8%A6%81%E6%8A%8AA%E8%AE%BE%E4%B8%BA%E4%BD%8D%E6%95%B0%E6%9B%B4%E5%A4%A7%E7%9A%84%E9%82%A3%E4%B8%80%E4%B8%AA%EF%BC%8C%E5%9B%A0%E4%B8%BA%E6%9C%80%E5%90%8E%E7%9A%84%E4%BD%8D%E6%95%B0%E5%8F%96%E5%86%B3%E4%BA%8E%E4%BD%8D%E6%95%B0%E5%A4%A7%E7%9A%84%E9%82%A3%E4%B8%80%E4%B8%AA%EF%BC%8C%E4%BD%BF%E7%94%A8vector%E5%AE%B9%E5%99%A8%E5%8F%AF%E4%BB%A5%E6%9B%B4%E6%96%B9%E4%BE%BF%E7%9A%84%E8%BF%9B%E8%A1%8C%E8%AE%A1%E7%AE%97%E5%92%8C%E8%BF%9B%E4%BD%8D%E5%92%8C%E7%A1%AE%E5%AE%9A%E4%BD%8D%E6%95%B0"><span class="nav-number">15.1.</span> <span class="nav-text">加法： 注意要把A设为位数更大的那一个，因为最后的位数取决于位数大的那一个，使用vector容器可以更方便的进行计算和进位和确定位数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%8F%E6%B3%95"><span class="nav-number">15.2.</span> <span class="nav-text">减法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B9%98%E6%B3%95"><span class="nav-number">15.3.</span> <span class="nav-text">乘法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%8D%E7%BC%80%E5%92%8C%E5%92%8C%E5%B7%AE%E5%88%86"><span class="nav-number">16.</span> <span class="nav-text">前缀和和差分</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%8C%E6%8C%87%E9%92%88"><span class="nav-number">17.</span> <span class="nav-text">双指针</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Floyd%E5%88%A4%E5%9C%88%E6%B3%95-%E9%BE%9F%E5%85%94%E8%B5%9B%E8%B7%91%E6%B3%95-%E7%94%A8%E4%BA%8E%E5%88%A4%E6%96%AD%E9%93%BE%E8%A1%A8%E6%9C%89%E6%97%A0%E7%8E%AF%E5%92%8C%E6%B1%82%E5%87%BA%E7%8E%AF%E7%9A%84%E9%95%BF%E5%BA%A6"><span class="nav-number">17.1.</span> <span class="nav-text">Floyd判圈法 龟兔赛跑法 用于判断链表有无环和求出环的长度</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97"><span class="nav-number">18.</span> <span class="nav-text">位运算</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#lowbit"><span class="nav-number">18.1.</span> <span class="nav-text">lowbit</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%EF%BC%9A%E5%AF%B9%E5%B7%AE%E5%88%86%E5%92%8C%E5%89%8D%E7%BC%80%E5%92%8C%E7%9A%84%E5%88%A9%E7%94%A8%EF%BC%9A"><span class="nav-number"></span> <span class="nav-text">树状数组：对差分和前缀和的利用：</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%83%85%E5%86%B5%EF%BC%9A"><span class="nav-number">0.1.</span> <span class="nav-text">使用情况：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF%EF%BC%9A"><span class="nav-number">1.</span> <span class="nav-text">模板：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F%EF%BC%9A"><span class="nav-number">2.</span> <span class="nav-text">使用方式：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A6%BB%E6%95%A3%E5%8C%96"><span class="nav-number">3.</span> <span class="nav-text">离散化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8C%BA%E9%97%B4%E5%92%8C%E5%B9%B6"><span class="nav-number">4.</span> <span class="nav-text">区间和并</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E6%A8%A1%E6%8B%9F%E9%93%BE%E8%A1%A8"><span class="nav-number">5.</span> <span class="nav-text">数组模拟链表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E9%93%BE%E8%A1%A8"><span class="nav-number">5.1.</span> <span class="nav-text">单链表</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%8C%E9%93%BE%E8%A1%A8"><span class="nav-number">6.</span> <span class="nav-text">双链表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%88"><span class="nav-number">7.</span> <span class="nav-text">栈</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%95%E8%B0%83%E6%A0%88"><span class="nav-number">8.</span> <span class="nav-text">单调栈</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%98%9F%E5%88%97"><span class="nav-number">9.</span> <span class="nav-text">队列</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97-%EF%BC%88%E5%A5%BD%E4%B8%9C%E8%A5%BF%EF%BC%89"><span class="nav-number"></span> <span class="nav-text">单调队列 （好东西）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#KMP"><span class="nav-number">1.</span> <span class="nav-text">KMP</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Trie%E6%A0%91-%E9%AB%98%E6%95%88%E5%AD%98%E5%82%A8%E5%92%8C%E6%9F%A5%E6%89%BE%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">2.</span> <span class="nav-text">Trie树 高效存储和查找字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9B%B4%E5%85%A8%E9%9D%A2-%E7%9A%84%E6%98%A0%E5%B0%84"><span class="nav-number">2.0.1.</span> <span class="nav-text">更全面 的映射</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="nav-number">3.</span> <span class="nav-text">并查集</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%90%E4%BA%9B%E7%82%B9%E6%88%96%E8%80%85%E6%95%B0%E6%8D%AE%E6%98%AF%E5%90%A6%E5%A4%84%E4%BA%8E%E4%B8%80%E4%B8%AA%E8%BF%9E%E9%80%9A%E5%9D%97%E4%B8%AD"><span class="nav-number">3.1.</span> <span class="nav-text">某些点或者数据是否处于一个连通块中</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A0%86-%E5%8F%AA%E8%83%BD%E4%BF%9D%E8%AF%81%E5%A0%86%E9%A1%B6%E6%98%AF%E6%9C%80%E5%80%BC%EF%BC%8C%E4%BF%9D%E8%AF%81%E4%B8%8D%E4%BA%86%E5%B7%A6%E5%8F%B3%E4%B8%A4%E8%BE%B9%E7%9A%84%E5%A4%A7%E5%B0%8F%E5%85%B3%E7%B3%BB"><span class="nav-number">4.</span> <span class="nav-text">堆 只能保证堆顶是最值，保证不了左右两边的大小关系</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HashTable"><span class="nav-number">5.</span> <span class="nav-text">HashTable</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C"><span class="nav-number">5.1.</span> <span class="nav-text">字符串哈希</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#STL%E5%B8%B8%E7%94%A8"><span class="nav-number">6.</span> <span class="nav-text">STL常用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%BE%E8%AE%BA%E8%83%8C%E6%80%9D%E8%B7%AF"><span class="nav-number">7.</span> <span class="nav-text">图论背思路</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BFS%E5%92%8CDFS"><span class="nav-number">8.</span> <span class="nav-text">BFS和DFS</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%9E%E5%B8%B8%E5%AE%8C%E7%BE%8E%E7%9A%84%E4%B8%80%E9%81%93dfs-%E5%B9%B6%E6%9F%A5%E9%9B%86-https-www-luogu-com-cn-problem-P1127"><span class="nav-number">8.1.</span> <span class="nav-text">非常完美的一道dfs + 并查集 https:&#x2F;&#x2F;www.luogu.com.cn&#x2F;problem&#x2F;P1127</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DFS-%E5%9B%9E%E6%BA%AF%E7%9A%84%E6%97%B6%E5%80%99%E8%AE%B0%E5%BE%97%E5%9B%9E%E5%A4%8D%E7%8E%B0%E5%9C%BA"><span class="nav-number">8.2.</span> <span class="nav-text">DFS 回溯的时候记得回复现场</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%EF%BC%9A-p-a-b-a-gt-b-%E9%80%82%E5%90%88%E7%A8%A0%E5%AF%86%E5%9B%BE"><span class="nav-number">8.3.</span> <span class="nav-text">邻接矩阵： p[ a] [ b ] a -&gt; b 适合稠密图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%82%BB%E6%8E%A5%E8%A1%A8%EF%BC%9A-%E7%A8%80%E7%96%8F%E5%9B%BE"><span class="nav-number">8.4.</span> <span class="nav-text">邻接表： 稀疏图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BFS-%E5%8F%AF%E7%94%A8%E4%BA%8E%E8%A7%A3%E5%86%B3%E6%9D%83%E5%80%BC%E7%9B%B8%E7%AD%89%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98"><span class="nav-number">8.5.</span> <span class="nav-text">BFS 可用于解决权值相等的最短路径问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="nav-number">9.</span> <span class="nav-text">拓扑排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%80%E7%9F%AD%E8%B7%AF%E9%97%AE%E9%A2%98%EF%BC%9A"><span class="nav-number">10.</span> <span class="nav-text">最短路问题：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E5%B1%82%E6%9C%80%E7%9F%AD%E8%B7%AF-%EF%BC%8C%E9%80%82%E7%94%A8%E4%BA%8E%E4%B9%98%E8%BD%A6%E8%B7%AF%E7%BA%BF%E5%92%8C%E5%85%8D%E8%B4%B9%E6%AC%A1%E6%95%B0%E3%80%82"><span class="nav-number">11.</span> <span class="nav-text">_分层最短路_，适用于乘车路线和免费次数。</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF-%E4%B8%80%E4%B8%AA%E7%82%B9-x2F-%E5%88%B0%E5%85%B6%E4%BB%96%E6%89%80%E6%9C%89%E7%82%B9%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF"><span class="nav-number">11.1.</span> <span class="nav-text">单源最短路 一个点.&#x2F;.到其他所有点的最短路</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF%E9%A2%98%EF%BC%9A"><span class="nav-number">11.1.1.</span> <span class="nav-text">模板题：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#x3D-x3D-%E5%88%A4%E6%96%AD%E6%9C%89%E6%97%A0%E8%B4%9F%E7%8E%AF-%E7%94%A8cnt-%E6%9D%A5%E8%AE%B0%E5%BD%95%E5%BD%93%E5%89%8D%E6%9C%80%E7%9F%AD%E8%B7%AF%E7%9A%84%E8%BE%B9%E6%95%B0"><span class="nav-number">12.</span> <span class="nav-text">&#x3D;&#x3D;判断有无负环 用cnt 来记录当前最短路的边数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E6%BA%90%E6%B1%87%E6%9C%80%E7%9F%AD%E8%B7%AF-%E8%B5%B7%E7%82%B9%E7%BB%88%E7%82%B9%E9%83%BD%E4%B8%8D%E7%A1%AE%E5%AE%9A"><span class="nav-number">12.1.</span> <span class="nav-text">多源汇最短路 起点终点都不确定</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="nav-number">13.</span> <span class="nav-text">最小生成树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%99%AE%E5%88%A9%E5%A7%86%E7%AE%97%E6%B3%95-Prim-%E6%80%9D%E8%B7%AF%E5%92%8CDijsktra%E7%AE%97%E6%B3%95%E7%9B%B8%E4%BC%BC-%E5%A4%96%E9%83%A8%E8%BF%AD%E4%BB%A3-n-%E6%AC%A1%EF%BC%8C%E5%9B%A0%E4%B8%BA%E6%B2%A1%E6%9C%89%E6%8F%90%E5%89%8D%E9%80%89%E4%B8%AD%E4%B8%80%E4%B8%AA%E7%82%B9"><span class="nav-number">13.1.</span> <span class="nav-text">普利姆算法 Prim 思路和Dijsktra算法相似 外部迭代 n 次，因为没有提前选中一个点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3n%E6%AC%A1%E5%9B%A0%E4%B8%BA%E6%B2%A1%E6%9C%89%E6%8F%90%E5%89%8D%E9%80%89%E4%B8%AD%E4%B8%80%E4%B8%AA%E7%82%B9-%E6%9E%9A%E4%B8%BE%E6%89%80%E6%9C%89%E7%82%B9"><span class="nav-number">13.2.</span> <span class="nav-text">迭代n次因为没有提前选中一个点 枚举所有点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%8B%E9%B2%81%E6%96%AF%E5%8D%A1%E5%B0%94%E7%AE%97%E6%B3%95-Kruskal-%E5%85%88%E5%AF%B9%E8%BE%B9%E8%BF%9B%E8%A1%8C%E6%8E%92%E5%BA%8F-%E7%A8%80%E7%96%8F%E5%9B%BE-%E5%8F%AF%E4%BB%A5%E7%94%A8%E5%B9%B6%E6%9F%A5%E9%9B%86-%E6%9E%9A%E4%B8%BE%E6%89%80%E6%9C%89%E8%BE%B9"><span class="nav-number">13.3.</span> <span class="nav-text">克鲁斯卡尔算法 Kruskal 先对边进行排序 稀疏图 可以用并查集 枚举所有边</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%88%86%E5%9B%BE-%E5%BD%93%E4%B8%94%E4%BB%85%E5%BD%93%E5%9B%BE%E4%B8%AD%E6%B2%A1%E6%9C%89%E5%A5%87%E6%95%B0%E7%8E%AF"><span class="nav-number">14.</span> <span class="nav-text">二分图 当且仅当图中没有奇数环</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%93%E8%89%B2%E6%B3%95-O-n-m-%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E6%98%AF%E4%BA%8C%E5%88%86%E5%9B%BE"><span class="nav-number">14.1.</span> <span class="nav-text">染色法 O(n+m) 判断是否是二分图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95-O-mn-%E5%AE%9E%E9%99%85%E8%BF%90%E8%A1%8C%E6%97%B6%E9%97%B4%E4%B8%80%E8%88%AC%E5%B0%8F%E4%BA%8E%E8%BF%99%E4%B8%AA%E5%80%BC-%E7%A8%A0%E5%AF%86%E5%9B%BE%E4%B8%8D%E9%80%82%E5%90%88%E7%94%A8%E9%82%BB%E6%8E%A5%E8%A1%A8%EF%BC%8C%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8%E4%B8%B4%E7%95%8C%E7%9F%A9%E9%98%B5"><span class="nav-number">14.2.</span> <span class="nav-text">匈牙利算法 O(mn) 实际运行时间一般小于这个值 稠密图不适合用邻接表，推荐使用临界矩阵</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%82%BB%E6%8E%A5%E8%A1%A8%E7%9A%84%E5%86%99%E6%B3%95-%E7%A8%A0%E5%AF%86%E5%9B%BE%E4%BC%9A%E8%B6%85%E6%97%B6"><span class="nav-number">15.</span> <span class="nav-text">邻接表的写法(稠密图会超时)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E7%9A%84%E5%86%99%E6%B3%95%EF%BC%9A"><span class="nav-number">16.</span> <span class="nav-text">邻接矩阵的写法：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86"><span class="nav-number">17.</span> <span class="nav-text">数学知识</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BD%93%E7%9C%8B%E8%A7%81-0-%E7%9A%84%E4%B8%AA%E6%95%B0%E6%97%B6%E8%80%83%E8%99%91%E5%B0%86%E7%BB%93%E6%9E%9C%E5%88%86%E6%88%90-2-%EF%BC%8C-5-%E7%9A%84%E4%B8%AA%E6%95%B0-%E5%B9%B6%E4%B8%94%EF%BC%8C%E6%9C%AB%E5%B0%BE%E7%9A%840%E7%9A%84%E4%B8%AA%E6%95%B0%E4%B8%80%E5%AE%9A%E6%98%AF%E7%94%B15%E7%9A%84%E4%B8%AA%E6%95%B0%E5%86%B3%E5%AE%9A%E7%9A%84"><span class="nav-number">18.</span> <span class="nav-text">当看见 0 的个数时考虑将结果分成 2 ， 5 的个数,并且，末尾的0的个数一定是由5的个数决定的</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E8%AE%BA"><span class="nav-number"></span> <span class="nav-text">数论</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E6%80%A7%E7%AD%9B%E6%B3%95%EF%BC%9A-%E5%A6%82%E6%9E%9C%E8%B4%A8%E6%95%B0%EF%BC%8C%E6%8A%8A%E8%BF%99%E4%B8%AA%E6%95%B0%E5%8A%A0%E5%85%A5%E9%9B%86%E5%90%88%E4%B8%AD-%E6%9C%80%E5%B8%B8%E7%94%A8"><span class="nav-number">0.1.</span> <span class="nav-text">线性筛法： 如果质数，把这个数加入集合中 最常用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AC%A7%E6%8B%89%E5%AE%9A%E7%90%86"><span class="nav-number">0.2.</span> <span class="nav-text">欧拉定理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BF%AB%E9%80%9F%E5%B9%82%EF%BC%9A"><span class="nav-number">0.3.</span> <span class="nav-text">快速幂：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95-%E4%B8%8D%E4%BC%9A"><span class="nav-number">0.4.</span> <span class="nav-text">扩展欧几里得算法(不会)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%92%E6%8E%A8%E6%B1%82%E7%BB%84%E5%90%88%E6%95%B0%EF%BC%8Cdp%E6%B3%95-%E9%80%82%E5%90%88%E8%AF%A2%E9%97%AE%E6%AC%A1%E6%95%B0-gt-10w"><span class="nav-number">0.5.</span> <span class="nav-text">递推求组合数，dp法 适合询问次数&gt;10w</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%9A%E8%BF%87%E9%A2%84%E5%A4%84%E7%90%86%E9%80%86%E5%85%83%E7%9A%84%E6%96%B9%E5%BC%8F%E6%B1%82%E7%BB%84%E5%90%88%E6%95%B0-%E8%AF%A2%E9%97%AE1w"><span class="nav-number">0.5.1.</span> <span class="nav-text">通过预处理逆元的方式求组合数 询问1w</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%86%E5%85%83%EF%BC%9A"><span class="nav-number">0.6.</span> <span class="nav-text">逆元：</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E8%A7%A3%E8%B4%A8%E5%9B%A0%E6%95%B0%E6%B3%95%E6%B1%82%E7%BB%84%E5%90%88%E6%95%B0"><span class="nav-number">0.6.1.</span> <span class="nav-text">分解质因数法求组合数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92DP"><span class="nav-number">1.</span> <span class="nav-text">动态规划DP</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#01%E8%83%8C%E5%8C%85-%E6%AF%8F%E4%B8%AA%E7%89%A9%E5%93%81%E5%8F%AA%E8%83%BD%E7%94%A8%E4%B8%80%E6%AC%A1"><span class="nav-number">1.1.</span> <span class="nav-text">01背包 每个物品只能用一次</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E7%8A%B6%E6%80%81dp"><span class="nav-number">2.</span> <span class="nav-text">多状态dp</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85-%E6%AF%8F%E4%BB%B6%E7%89%A9%E5%93%81%E6%9C%89%E6%97%A0%E9%99%90%E4%B8%AA"><span class="nav-number">2.1.</span> <span class="nav-text">完全背包 每件物品有无限个</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98-%E4%BC%98%E5%8C%96"><span class="nav-number">2.2.</span> <span class="nav-text">多重背包问题 优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E7%BB%84%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="nav-number">2.3.</span> <span class="nav-text">分组背包问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E6%80%A7DP"><span class="nav-number">3.</span> <span class="nav-text">线性DP</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E4%BD%8D%E7%BB%9F%E8%AE%A1DP"><span class="nav-number"></span> <span class="nav-text">数位统计DP</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E4%BD%8DDP-%E9%87%8D%E8%A6%81"><span class="nav-number"></span> <span class="nav-text">数位DP(重要)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF%EF%BC%9A-1"><span class="nav-number">1.</span> <span class="nav-text">模板：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%8A%B6%E5%8E%8BDP-%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E5%88%A9%E7%94%A8%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%8A%8A%E7%8A%B6%E6%80%81%E8%AE%B0%E5%BD%95%E6%88%90%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0"><span class="nav-number">2.</span> <span class="nav-text">状压DP 状态压缩+动态规划 利用二进制把状态记录成二进制数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%91%E5%BD%A2DP-%E5%90%84%E5%B1%82%E9%80%89%E6%8B%A9%E5%8F%96%E6%9C%80%E5%A4%A7%E5%80%BC"><span class="nav-number">3.</span> <span class="nav-text">树形DP 各层选择取最大值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%8A%B6%E6%80%81%E6%9C%BA%EF%BC%9A"><span class="nav-number">4.</span> <span class="nav-text">状态机：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DP%E8%A1%8C-x2F-%E5%88%97%E9%97%AE%E9%A2%98"><span class="nav-number">5.</span> <span class="nav-text">DP行&#x2F;列问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BE%8B%E9%A2%98%EF%BC%9A%E8%82%A1%E7%A5%A8%E4%B9%B0%E5%8D%96%E9%97%AE%E9%A2%98"><span class="nav-number">5.1.</span> <span class="nav-text">例题：股票买卖问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%9A%E8%BF%87stoi-%E5%92%8C%E9%9A%94%E6%9D%BF%E6%B3%95%E5%AE%9E%E7%8E%B0%E6%9E%9A%E4%B8%BE%E6%AF%8F%E4%B8%80%E4%B8%AA%E6%95%B0%E5%AD%97%E7%9A%84%E4%BB%BB%E6%84%8F%E5%AD%90%E5%AD%90%E4%B8%B2"><span class="nav-number">6.</span> <span class="nav-text">通过stoi 和隔板法实现枚举每一个数字的任意子子串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%90%E5%88%97%E5%92%8C-x2F-%E5%AD%97%E4%B8%B2%E9%97%AE%E9%A2%98%EF%BC%9A"><span class="nav-number">7.</span> <span class="nav-text">子列和&#x2F;字串问题：</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9A%B4%E5%8A%9B%E6%9E%9A%E4%B8%BE%E6%B3%95"><span class="nav-number"></span> <span class="nav-text">暴力枚举法</span></a></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">QingQiu</p>
  <div class="site-description" itemprop="description">个人网站，学习记录，面试记录和经验总结、互联网中一块属于自己的小窝</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">57</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">26</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Zuofw/zuofw-rpc" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Zuofw&#x2F;zuofw-rpc" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2022 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">QingQiu</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="站点总字数">470k</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  















  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
