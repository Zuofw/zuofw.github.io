<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="学算法, 博客，学习，成长">
    <meta name="description" content="学算法先思考再做题，前几个题大概率时模拟题，所以别急着用算法
丢人必做题:整数划分https://ac.nowcoder.com/acm/problem/252724
accumulate 求和
快乐的模板：
#include &amp;lt;bi">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>学算法 | QingQiu&#39;Blog</title>
    <link rel="icon" type="image/x-icon, image/vnd.microsoft.icon" href="/favicon.ico">
    


    <!-- bg-cover style     -->



<link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.min.css">
<link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
<link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
<link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
<link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
<link rel="stylesheet" type="text/css" href="/css/matery.css">
<link rel="stylesheet" type="text/css" href="/css/my.css">
<link rel="stylesheet" type="text/css" href="/css/dark.css" media="none" onload="if(media!='all')media='all'">




    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
    <link rel="stylesheet" href="/css/post.css">




    
        <link rel="stylesheet" type="text/css" href="/css/reward.css">
    



    <script src="/libs/jquery/jquery-3.6.0.min.js"></script>

<style type="text/css" lang="css">
    #loading-container{
        position: fixed;
        top: 0;
        left: 0;
        min-height: 100vh;
        width: 100vw;
        z-index: 9999;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        background: #FFF;
        text-align: center;
        /* loader页面消失采用渐隐的方式*/
        -webkit-transition: opacity 1s ease;
        -moz-transition: opacity 1s ease;
        -o-transition: opacity 1s ease;
        transition: opacity 1s ease;
    }
    .loading-image{
        width: 120px;
        height: 50px;
        transform: translate(-50%);
    }

    .loading-image div:nth-child(2) {
        -webkit-animation: pacman-balls 1s linear 0s infinite;
        animation: pacman-balls 1s linear 0s infinite
    }

    .loading-image div:nth-child(3) {
        -webkit-animation: pacman-balls 1s linear .33s infinite;
        animation: pacman-balls 1s linear .33s infinite
    }

    .loading-image div:nth-child(4) {
        -webkit-animation: pacman-balls 1s linear .66s infinite;
        animation: pacman-balls 1s linear .66s infinite
    }

    .loading-image div:nth-child(5) {
        -webkit-animation: pacman-balls 1s linear .99s infinite;
        animation: pacman-balls 1s linear .99s infinite
    }

   .loading-image div:first-of-type {
        width: 0;
        height: 0;
        border: 25px solid #49b1f5;
        border-right-color: transparent;
        border-radius: 25px;
        -webkit-animation: rotate_pacman_half_up .5s 0s infinite;
        animation: rotate_pacman_half_up .5s 0s infinite;
    }
    .loading-image div:nth-child(2) {
        width: 0;
        height: 0;
        border: 25px solid #49b1f5;
        border-right-color: transparent;
        border-radius: 25px;
        -webkit-animation: rotate_pacman_half_down .5s 0s infinite;
        animation: rotate_pacman_half_down .5s 0s infinite;
        margin-top: -50px;
    }
    @-webkit-keyframes rotate_pacman_half_up {0% {transform: rotate(270deg)}50% {transform: rotate(1turn)}to {transform: rotate(270deg)}}

    @keyframes rotate_pacman_half_up {0% {transform: rotate(270deg)}50% {transform: rotate(1turn)}to {transform: rotate(270deg)}}

    @-webkit-keyframes rotate_pacman_half_down {0% {transform: rotate(90deg)}50% {transform: rotate(0deg)}to {transform: rotate(90deg)}}

    @keyframes rotate_pacman_half_down {0% {transform: rotate(90deg)}50% {transform: rotate(0deg)}to {transform: rotate(90deg)}}

    @-webkit-keyframes pacman-balls {75% {opacity: .7}to {transform: translate(-100px, -6.25px)}}

    @keyframes pacman-balls {75% {opacity: .7}to {transform: translate(-100px, -6.25px)}}


    .loading-image div:nth-child(3),
    .loading-image div:nth-child(4),
    .loading-image div:nth-child(5),
    .loading-image div:nth-child(6){
        background-color: #49b1f5;
        width: 15px;
        height: 15px;
        border-radius: 100%;
        margin: 2px;
        width: 10px;
        height: 10px;
        position: absolute;
        transform: translateY(-6.25px);
        top: 25px;
        left: 100px;
    }
    .loading-text{
        margin-bottom: 20vh;
        text-align: center;
        color: #2c3e50;
        font-size: 2rem;
        box-sizing: border-box;
        padding: 0 10px;
        text-shadow: 0 2px 10px rgba(0,0,0,0.2);
    }
    @media only screen and (max-width: 500px) {
         .loading-text{
            font-size: 1.5rem;
         }
    }
    .fadeout {
        opacity: 0;
        filter: alpha(opacity=0);
    }
    /* logo出现动画 */
    @-webkit-keyframes fadeInDown{0%{opacity:0;-webkit-transform:translate3d(0,-100%,0);transform:translate3d(0,-100%,0)}100%{opacity:1;-webkit-transform:none;transform:none}}
    @keyframes fadeInDown{0%{opacity:0;-webkit-transform:translate3d(0,-100%,0);}}
 </style>
 <script>
(function () {
    const loaded = function(){
       setTimeout(function(){
            const loader = document.getElementById("loading-container");
            loader.className="fadeout" ;//使用渐隐的方法淡出loading page
            // document.getElementById("body-wrap").style.display="flex";
            setTimeout(function(){
                loader.style.display="none";
            },1000); 
        },1000);//强制显示loading page 1s  
    };
    loaded();
})()
 </script><meta name="generator" content="Hexo 6.3.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head>



 <div id="loading-container">
     <p class="loading-text">玩命加载中 . . . </p> 
     <div class="loading-image">
         <div></div>
         <div></div>
         <div></div>
         <div></div> 
         <div></div>
     </div>
 </div><body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">QingQiu&#39;Blog</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
  <li>
    <a href="javascript:;" class="waves-effect waves-light" onclick="switchNightMode()" title="深色/浅色模式" >
      <i id="sum-moon-icon" class="fas fa-sun" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">QingQiu&#39;Blog</div>
        <div class="logo-desc">
            
            个人网站，学习记录，互联网的一篇属于自己的小窝
            
        </div>
    </div>

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/blinkfox/hexo-theme-matery" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/blinkfox/hexo-theme-matery" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/20.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">学算法</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/%E7%AE%97%E6%B3%95%EF%BC%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">
                                <span class="chip bg-color">算法，数据结构</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2023-09-09
                </div>
                

                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    11.3k
                </div>
                

                

                
            </div>
        </div>
        <hr class="clearfix">

        
        <!-- 是否加载使用自带的 prismjs. -->
        <link rel="stylesheet" href="/libs/prism/prism.min.css">
        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <h1 id="学算法"><a href="#学算法" class="headerlink" title="学算法"></a>学算法</h1><p>先思考再做题，前几个题大概率时模拟题，所以别急着用算法</p>
<h1 id="丢人必做题"><a href="#丢人必做题" class="headerlink" title="丢人必做题:"></a>丢人必做题:</h1><p><strong>整数划分</strong><a target="_blank" rel="noopener" href="https://ac.nowcoder.com/acm/problem/252724">https://ac.nowcoder.com/acm/problem/252724</a></p>
<p>accumulate 求和</p>
<p>快乐的模板：</p>
<p>#include &lt;bits/stdc++.h&gt;<br>#define ll long long<br>#define pii pair&lt;int,int&gt;<br>using namespace std;<br>void solve(){<br> &nbsp; &nbsp;return ;<br>}<br>int main(){<br> &nbsp; &nbsp;ios::sync_with_stdio(false);<br> &nbsp; &nbsp;cin.tie(nullptr);<br> &nbsp; &nbsp;int T;<br> &nbsp; &nbsp;cin &gt;&gt; T;<br> &nbsp; &nbsp;while (T–) solve();<br> &nbsp; &nbsp;return 0;<br>}<br>​</p>
<h2 id="小TIPS："><a href="#小TIPS：" class="headerlink" title="小TIPS："></a>小TIPS：</h2><p>做题思路：</p>
<ol>
<li><p>从小数据，小范围推大范围</p>
</li>
<li><p>划分，以及反证，如果要求全部满足一个性质，那么只要有部分不满足我们已经推出来的条件即可不满足所有性质</p>
</li>
</ol>
<blockquote>
<ol>
<li><p>数组和字符串比较字典序是可以直接用大于号小于号比较的</p>
</li>
<li><p>字典序是指在ASCII码中出现的顺序所以 也就是 a b c 0 1 2 3 ABC 等z</p>
</li>
<li><p>vector &lt;&gt; 可以直接赋值</p>
</li>
</ol>
</blockquote>
<h2 id="牛顿迭代法："><a href="#牛顿迭代法：" class="headerlink" title="牛顿迭代法："></a>牛顿迭代法：</h2><p>求平方根</p>
<p>例子： f(x)=m,可转化为 g(x)=f(x)-m=0;</p>
<p>迭代公式：_x_n+1 = _x_n − <em>g</em> (_x_n)/ <em>g</em> ′ (_x_n)</p>
<p>例题：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sqrtx/submissions/431189596/">力扣（LeetCode）官网 - 全球极客挚爱的技术成长平台</a></p>
<p>//f (x) = x2 − a = 0<br>int mySqrt(int a) {<br>long x = a;<br>while (x * x &gt; a) {<br>x = (x + a / x) / 2;<br>}<br>return x;<br>}</p>
<h3 id="stl和一些内置函数"><a href="#stl和一些内置函数" class="headerlink" title="stl和一些内置函数"></a>stl和一些内置函数</h3><p>accumulate(num.begin(),num.end(),0); //第三个参数是初始化要返回的东西 </p>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="快速排序模板-根据数来分治"><a href="#快速排序模板-根据数来分治" class="headerlink" title="快速排序模板 根据数来分治"></a>快速排序模板 根据数来分治</h3><p>int a[100];<br>void qsort(int a[], int l, int r) {<br>    if (l &gt;= r) return;<br>    int i = l, j = r, x = a[l];<br>    while (i &lt; j) {<br>        while (i &lt; j &amp;&amp; a[j] &gt;= a[l]) j–;<br>        while (i &lt; j &amp;&amp; a[i] &lt;= a[l]) i++;<br>        x = a[i]; a[i] = a[j]; a[j] = x;<br>    }<br>    a[i] = a[l]; a[l] = x;<br>    qsort(a, l, i - 1);<br>    qsort(a, i + 1, r);<br>}</p>
<h3 id="归并排序模板-分治-根据中间两个数为分界线"><a href="#归并排序模板-分治-根据中间两个数为分界线" class="headerlink" title="归并排序模板 分治 根据中间两个数为分界线"></a>归并排序模板 分治 根据中间两个数为分界线</h3><ol>
<li><p>确定分界点， mid=(l+r)/2</p>
</li>
<li><p>递归排序 left，right</p>
</li>
<li><p>归并 合二为一</p>
</li>
</ol>
<p>模板</p>
<p>void msort(int a[], int l, int r) {<br>    if (l &gt;= r) return;<br>    //确定分界<br>    int mid = l + r &gt;&gt; 1;<br>    //递归<br>    msort(a, l, mid); msort(a, mid + 1, r);<br>    //归并<br>    int k = 0, i = l, j = mid + 1;  </p>
<pre><code>while (i &lt;=mid &amp;&amp; j &lt;= r) {//左右比较，小的放在辅助数组里，直到有一个指针到达边界  
    if (a[i] &lt;= a[j]) tmp[k++] = a[i++];  
    else tmp[k++] = a[j++];  
}  
//这里继续把另一个没到边界的指针赋值给辅助数组  
while (i &lt;= mid) tmp[k++] = a[i++];  
while (j &lt;= r)tmp[k++] = a[j++];  
//最后把辅助数组的元素还回去  
for (int i = l, j = 0; i &lt;= r; i++, j++) a[i] = tmp[j];  
</code></pre>
<p>}</p>
<h2 id="二分法-二分要保证有解"><a href="#二分法-二分要保证有解" class="headerlink" title="二分法 二分要保证有解"></a>二分法 二分要保证有解</h2><h3 id="整数二分"><a href="#整数二分" class="headerlink" title="整数二分"></a>整数二分</h3><p>一分为二，一边满足性质，一半不满足，可以来用来寻找性质的边界</p>
<p>两种模板：一种去检查满足的一半，另一种去检查不满足性质的的一半</p>
<p>考虑边界是否会包括进去</p>
<ol>
<li><p>先写出 mid=r+l&gt;&gt;1</p>
</li>
<li><p>二分要检查的性质</p>
</li>
<li><p>画图考虑，直线图</p>
</li>
<li><p>思考mid是否会包含</p>
</li>
<li><p>考虑不存在条件时</p>
</li>
</ol>
<p>bool check(int x) {/* … */} // 检查x是否满足某种性质<br>//比如左侧是不满足，右侧是满足<br>// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：<br>//去右半边<br>int bsearch_1(int l, int r)<br>{<br> &nbsp; &nbsp;while (l &lt; r)<br> &nbsp;  {<br> &nbsp; &nbsp; &nbsp; &nbsp;int mid = l + r &gt;&gt; 1;<br> &nbsp; &nbsp; &nbsp; &nbsp;if (check(mid)) r = mid; &nbsp; &nbsp;// check()判断mid是否满足性质<br> &nbsp; &nbsp; &nbsp; &nbsp;else l = mid + 1;<br> &nbsp;  }<br> &nbsp; &nbsp;return l;<br>}<br>//去二分左半边，mid要+1，因为mid有可能不在要求的<br>// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：<br>int bsearch_2(int l, int r)<br>{<br> &nbsp; &nbsp;while (l &lt; r)<br> &nbsp;  {<br> &nbsp; &nbsp; &nbsp; &nbsp;int mid = l + r + 1 &gt;&gt; 1;<br> &nbsp; &nbsp; &nbsp; &nbsp;if (check(mid)) l = mid;<br> &nbsp; &nbsp; &nbsp; &nbsp;else r = mid - 1;<br> &nbsp;  }<br> &nbsp; &nbsp;return l;<br>}<br>​</p>
<h3 id="浮点数二分-不要处理边界"><a href="#浮点数二分-不要处理边界" class="headerlink" title="浮点数二分 不要处理边界"></a>浮点数二分 不要处理边界</h3><p>思路：通过mid来判断，答案落在缩小的区间内，只要近似值</p>
<p>bool check(double x) {/* … */} // 检查x是否满足某种性质  </p>
<p>double bsearch_3(double l, double r)<br>{<br>    const double eps = 1e-6;   // eps 表示精度，取决于题目对精度的要求<br>    while (r - l &gt; eps)<br>    {<br>        double mid = (l + r) / 2;<br>        if (check(mid)) r = mid;<br>        else l = mid;<br>    }<br>    //或者直接不管精度，直接循环几百次<br>    return l;<br>}</p>
<h2 id="高精度"><a href="#高精度" class="headerlink" title="高精度"></a>高精度</h2><h3 id="加法：-注意要把A设为位数更大的那一个，因为最后的位数取决于位数大的那一个，使用vector容器可以更方便的进行计算和进位和确定位数"><a href="#加法：-注意要把A设为位数更大的那一个，因为最后的位数取决于位数大的那一个，使用vector容器可以更方便的进行计算和进位和确定位数" class="headerlink" title="加法： 注意要把A设为位数更大的那一个，因为最后的位数取决于位数大的那一个，使用vector容器可以更方便的进行计算和进位和确定位数"></a>加法： 注意要把A设为位数更大的那一个，因为最后的位数取决于位数大的那一个，使用vector容器可以更方便的进行计算和进位和确定位数</h3><ol>
<li><p>逆序存数的每一位</p>
</li>
<li><p>从低位开始计算，之后计算进位</p>
</li>
<li><p>加完之后检查最后一位是否还有进位</p>
</li>
<li><p>返回数字</p>
</li>
</ol>
<p>vector<int> add(vector<int> &amp;A, vector<int> &amp;B)<br>{<br>    if (A.size() &lt; B.size()) return add(B, A);  </int></int></int></p>
<pre><code>vector&lt;int&gt; C;  
int t = 0;  
for (int i = 0; i &lt; A.size(); i ++ )  
{  
    t += A[i];  
    if (i &lt; B.size()) t += B[i];  
    C.push_back(t % 10);  
    t /= 10;  
}  

if (t) C.push_back(1);  
return C;  
</code></pre>
<p>}</p>
<h3 id="减法"><a href="#减法" class="headerlink" title="减法"></a>减法</h3><p>和加法基本一致，只要变进位为借位即可</p>
<p>// C = A - B, 满足A &gt;= B, A &gt;= 0, B &gt;= 0<br>vector<int> sub(vector<int> &amp;A, vector<int> &amp;B)<br>{<br>    vector<int> C;<br>    for (int i = 0, t = 0; i &lt; A.size(); i ++ )<br>    {<br>        t = A[i] - t;<br>        if (i &lt; B.size()) t -= B[i];<br>        C.push_back((t + 10) % 10);<br>        if (t &lt; 0) t = 1;<br>        else t = 0;<br>    }  </int></int></int></int></p>
<pre><code>while (C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back();  
return C;  
</code></pre>
<p>}</p>
<h3 id="乘法"><a href="#乘法" class="headerlink" title="乘法"></a>乘法</h3><p>vector<int> mul(vector<int>&amp;A,int b){<br> &nbsp; vector<int>C;<br> &nbsp; int t=0;<br> &nbsp; for(int i=0;i&lt;A.size()||t;i++){//出现进位<br> &nbsp; &nbsp; &nbsp;if(i&lt;A.size()) t+=A[i]*b;<br> &nbsp; &nbsp; &nbsp;C.push_back(t%10);<br> &nbsp; &nbsp; &nbsp;t/=10;<br> &nbsp; }<br> &nbsp; while(C.size()&gt;1&amp;&amp;C.back()==0) C.pop_back();<br> &nbsp; //去除前导零<br> &nbsp; return C;<br>}</int></int></int></p>
<h3 id="除法"><a href="#除法" class="headerlink" title="除法"></a>除法</h3><p>vector<int> div(vector<int>&amp;A,int b){<br> &nbsp; vector<int>C;<br> &nbsp; int t=0;<br> &nbsp; for(int i=0;i&lt;A.size();i++){<br> &nbsp; &nbsp; &nbsp;t=t*10+A[i];<br> &nbsp; &nbsp; &nbsp;C.push_back(t/b);<br> &nbsp; &nbsp; &nbsp;t%=10;<br> &nbsp; }<br> &nbsp; reverse(C.begin(),C.end());<br> &nbsp; while(C.size()&gt;1&amp;&amp;C.back()==0) C.pop_back();<br> &nbsp; return C;<br>}</int></int></int></p>
<h2 id="前缀和和差分"><a href="#前缀和和差分" class="headerlink" title="前缀和和差分"></a>前缀和和差分</h2><p>前缀和一般初始化为0到n但是只用1到n</p>
<p>二维</p>
<p>S[i, j] = 第i行j列格子左上部分所有元素的和<br>以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：<br>S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]</p>
<p>二维差分： 差分的前缀和就是原数组</p>
<p>给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：<br>S[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c//注意是x2+1,y2+1不是x2,y2</p>
<h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><p>int x;<br>int * p1 = &amp;x; // 指针可以被修改，值也可以被修改<br>const int * p2 = &amp;x; // 指针可以被修改，值不可以被修改（const int）<br>int * const p3 = &amp;x; // 指针不可以被修改（* const），值可以被修改<br>const int * const p4 = &amp;x; // 指针不可以被修改，值也不可以被修改</p>
<p>for (int i = 0, j = 0; i &lt; n; i ++ )<br>{<br>    while (j &lt; i &amp;&amp; check(i, j)) j ++ ;  </p>
<pre><code>// 具体问题的逻辑  
</code></pre>
<p>}<br>常见问题分类：<br>    (1) 对于一个序列，用两个指针维护一段区间<br>    (2) 对于两个序列，维护某种次序，比如归并排序中合并两个有序序列的操作</p>
<h3 id="Floyd判圈法-龟兔赛跑法-用于判断链表有无环和求出环的长度"><a href="#Floyd判圈法-龟兔赛跑法-用于判断链表有无环和求出环的长度" class="headerlink" title="Floyd判圈法 龟兔赛跑法 用于判断链表有无环和求出环的长度"></a>Floyd判圈法 龟兔赛跑法 用于判断链表有无环和求出环的长度</h3><p>两个指针fast slow 都从起始位置出发，fast 一次走2步，slow一次走1步，如果能相遇，则存在环</p>
<p>计算环的长度</p>
<p>让其中一个指针停在环的起点不动，另一个一步一步向前走并记录步数，再次相遇时步数即为环的长度。</p>
<p>寻找环的起点</p>
<p>其中一个指针在环的起点不动，另一个放到起点，两个指针同时一步一步移动，则两指针将会在循环节的起点相遇。</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/linked-list-cycle-ii/description/">142. 环形链表 II - 力扣（Leetcode）</a></p>
<p>/**  </p>
<ul>
<li>Definition for singly-linked list.  </li>
<li>struct ListNode {  </li>
<li><pre><code>int val;  
</code></pre>
</li>
<li><pre><code>ListNode *next;  
</code></pre>
</li>
<li><pre><code>ListNode(int x) : val(x), next(NULL) {}  
</code></pre>
</li>
<li>};<br> */<br>class Solution {<br>public:<br> ListNode *detectCycle(ListNode *head) {<br>ListNode *fast=head,*slow=head;<br>   do{<br>   if(!fast||!fast-&gt;next) return NULL;//如果能到达末尾，则不存在环<br>   fast=fast-&gt;next-&gt;next;<br>   slow=slow-&gt;next;<br>   }while(fast!=slow);<br>   fast=head;<br>   while(fast!=slow){<br>   fast=fast-&gt;next;<br>   slow=slow-&gt;next;<br>   }<br>   return slow;<br> }<br>};</li>
</ul>
<h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><p>思路：</p>
<p>n的第k位是什么？ n&gt;&gt;k&amp;1 右移k位与1与得到是0就是0，反之就是1</p>
<ol>
<li><p>先把要判断的位置移到最左边</p>
</li>
<li><p>判断</p>
</li>
</ol>
<h3 id="lowbit"><a href="#lowbit" class="headerlink" title="lowbit"></a>lowbit</h3><p>解释：cpp的负数使用的补码表示的所以，-x就等于 ~x+1 反码+1</p>
<p>用法：树状数组和求1的个数</p>
<p>#define lowbit(x) (-x)&amp;x<br>///或者 int lowbit(int x) {return -x&amp;x;}<br>int tree[length];//树状数组，长度和原数组相等<br>//区间修改<br>void update(int x,int val)<br>{<br>    while(x&lt;n){<br>        tree[x]+=val;<br>        x+=lowbit(x);<br>    }<br>}<br>//区间求和<br>int sum(int l,int r){<br>    int ans=0;<br>    while(r){<br>        ans+=tree[r];<br>        r-=lowbit(r);<br>    }<br>    l–;//<br>    while(l){<br>        ans-=tree[l];<br>        l-=lowbit(l);<br>    }<br>    return ans;<br>}</p>
<h1 id="树状数组：对差分和前缀和的利用："><a href="#树状数组：对差分和前缀和的利用：" class="headerlink" title="树状数组：对差分和前缀和的利用："></a>树状数组：对差分和前缀和的利用：</h1><h3 id="使用情况："><a href="#使用情况：" class="headerlink" title="使用情况："></a>使用情况：</h3><ol>
<li><p>数组不变求区间和</p>
</li>
<li><p>多次修改某个区间，求区间和</p>
</li>
<li><p>将某个区间变为同一个数求区间和</p>
</li>
<li><p>多次修改区间，寻找定点值</p>
</li>
</ol>
<h2 id="模板："><a href="#模板：" class="headerlink" title="模板："></a>模板：</h2><p>说明：lowbit()奇妙用法…..</p>
<p>#define lowbit(x) (-x)&amp;x<br>///或者 int lowbit(int x) {return -x&amp;x;}<br>int tree[length];//树状数组，长度和原数组相等<br>//区间修改<br>void update(int x,int val)<br>{<br>    while(x){<br>        tree[x]+=val;<br>        x+=lowbit(x);<br>    }<br>}<br>//区间求和<br>int sum(int l,int r){<br>    int ans=0;<br>    while(r){<br>        ans+=tree[r];<br>        r-=lowbit(r);<br>    }<br>    l–;//<br>    while(l){<br>        ans-=tree[l];<br>        l-=lowbit(l);<br>    }<br>    return ans;<br>}</p>
<h2 id="使用方式："><a href="#使用方式：" class="headerlink" title="使用方式："></a>使用方式：</h2><ol>
<li><p>正常的顶点修改，区间求和直接用</p>
</li>
<li><p><strong>区间修改，求单独一个数</strong> <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3368">P3368 【模板】树状数组 2 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>
<ul>
<li><p>树状数组是保存的每一个下标为位置的前缀和</p>
</li>
<li><p>想要求指定位置的数值需要用到差分,差分的前缀和就是每一个位置的数据大小</p>
</li>
<li><p>修改时只需要修改 update(l,val),update(r+1,-val)</p>
</li>
<li><p>初始化时，要插入的是差分</p>
<p>  #include <iostream><br>  #include <algorithm><br>  #define ll long long<br>  #define lowbit(x) (x&amp;(-x))<br>  using namespace std;<br>  const int mx = 10e5 + 5;<br>  int t[mx], m, n;<br>  int add(int x, int k) {<br>  while (x &lt;= n) {<br>      t[x] += k;<br>      x += lowbit(x);<br>  }<br>  }<br>  int query(int x){<br>  ll ans=0;<br>  while(x){<br>      ans+=t[x];<br>      x-=lowbit(x);<br>  }<br>  return ans;<br>  }<br>  //用差分来的前缀和来表示每一位置上的数字，<br>  //第一个数字之后，每次把差分加入，再求前缀和就能得到每一个位置上的数字是多少了<br>  //修改时只需要修改x和y+1两个位置的差分，但是我们用的tree是前缀和，所以依然要用把和lowbit有关的都修改 了<br>  int main() {<br>  cin &gt;&gt; n &gt;&gt; m;<br>  int cf=0;<br>  for (int i = 1; i &lt;= n; i++) {<br>      int num;<br>      scanf(“%d”, &amp;num);<br>      add(i,num-cf);<br>      cf=num;<br>  }<br><br>  for (int i = 1; i &lt;= m; i++) {<br>      int ch, x, y,k;<br>      scanf(“%d”, &amp;ch);<br>      if (ch == 1){<br>          scanf(“%d %d %d”, &amp;x, &amp;y, &amp;k);<br>          add(x,k);<br>          add(y+1,-k);<br>      }<br>      else {<br>          int s;<br>          scanf(“%d”, &amp;s);<br>          printf(“%d\n”, query(s));<br>      }<br>  }<br>  return 0;<br>  }</algorithm></iostream></p>
</li>
</ul>
</li>
<li><p>用指定数据替换某个数据，然后求和 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/range-sum-query-mutable/submissions/429237767/">307. 区域和检索 - 数组可修改 - 力扣（Leetcode）</a></p>
<ul>
<li><p>更换数据也是用到了差分，新的数据-原数据==要更新的val</p>
</li>
<li><p>然后更新之后，原数组指定位置也要更新，方便下次修改同一位置</p>
</li>
<li><p>其他正常食用即可</p>
<p>  class NumArray {<br>  int []t;<br>  int n;<br>  int []nums;<br>  int lowbit(int x){return x&amp;(-x);}<br>  public NumArray(int[] nums) {<br>      this.nums=nums;<br>      n=nums.length;<br>      t=new int[n+1];<br>      int i=1;<br>      for (int num:nums<br>           ) {<br>          add(i++,num);<br>      }<br>  }<br>  void add(int index,int val){<br>      while(index&lt;=n){<br>          t[index]+=val;<br>          index+=lowbit(index);<br>      }<br>  }<br>  public void update(int index, int val) {<br>      add(index+1,val-nums[index]);<br>      nums[index]=val;<br>  }<br><br>  public int sumRange(int left, int right) {<br>      int ans=0;<br>      right++;<br>      while(right&gt;0){<br>          ans+=t[right];<br>          right-=lowbit(right);<br>      }<br><br>      while(left&gt;0){<br>          ans-=t[left];<br>          left-=lowbit(left);<br>      }<br>      return ans;<br>  }<br>  }  </p>
<p>  /**  </p>
<ul>
<li>Your NumArray object will be instantiated and called as such:  </li>
<li>NumArray obj = new NumArray(nums);  </li>
<li>obj.update(index,val);  </li>
<li>int param_2 = obj.sumRange(left,right);<br>   */</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>求1的个数</p>
<p>#include <algorithm><br>#include <vector><br>#include <iostream><br>#define lowbit(x) (-x)&amp;x<br>using namespace std;<br>int main(){<br> &nbsp; &nbsp;int n,ans=0;<br> &nbsp; &nbsp;cin&gt;&gt;n;<br> &nbsp; &nbsp;while(n){<br> &nbsp; &nbsp; &nbsp; &nbsp;ans++;<br> &nbsp; &nbsp; &nbsp; &nbsp;n-=lowbit(n);<br> &nbsp;  }<br> &nbsp; &nbsp;cout&lt;&lt;ans&lt;&lt;endl;<br> &nbsp; &nbsp;return 0;<br>}</iostream></vector></algorithm></p>
<h2 id="离散化"><a href="#离散化" class="headerlink" title="离散化"></a>离散化</h2><p>unique 返回的是下下标</p>
<p>vector<int> alls; // 存储所有待离散化的值<br>sort(alls.begin(), alls.end()); // 将所有值排序<br>alls.erase(unique(alls.begin(), alls.end()), alls.end()); &nbsp; // 去掉重复元素<br>//配合erase 即可把放在后面的重复元素删除<br>/*<br>该函数的作用是“去除”容器或者数组中相邻元素的重复出现的元素<br>(1) 这里的去除并非真正意义的erase，而是将重复的元素放到容器的末尾，返回值是去重之后的尾地址。<br>(2) unique针对的是相邻元素，所以对于顺序顺序错乱的数组成员，或者容器成员，需要先进行排序，可以调用std::sort()函数<br>// 二分求出x对应的离散化的值*/<br>int find(int x) // 找到第一个大于等于x的位置<br>{<br> &nbsp; &nbsp;int l = 0, r = alls.size() - 1;<br> &nbsp; &nbsp;while (l &lt; r)<br> &nbsp;  {<br> &nbsp; &nbsp; &nbsp; &nbsp;int mid = l + r &gt;&gt; 1;<br> &nbsp; &nbsp; &nbsp; &nbsp;if (alls[mid] &gt;= x) r = mid;<br> &nbsp; &nbsp; &nbsp; &nbsp;else l = mid + 1;<br> &nbsp;  }<br> &nbsp; &nbsp;return r + 1; // 映射到1, 2, …n<br>}</int></p>
<h2 id="区间和并"><a href="#区间和并" class="headerlink" title="区间和并"></a>区间和并</h2><p>每次维护一个右端点</p>
<p>// 将所有存在交集的区间合并<br>void merge(vector<pii> &amp;segs)<br>{<br>    vector<pii> res;  </pii></pii></p>
<pre><code>sort(segs.begin(), segs.end());//根据first进行排序，默认的就是这样的不需要进行自定义  

int st = -2e9, ed = -2e9;  
for (auto seg : segs)  
    if (ed &lt; seg.first)  
    {  
        //当起点的值大于右端点的时候，一段区间结束，可以继续下一段区间了  
        if (st != -2e9) res.push_back({st, ed});  
        st = seg.first, ed = seg.second;  
    }  
    else ed = max(ed, seg.second);//如果左没大于右端点，那么右端点每次更新完为最大值  

if (st != -2e9) res.push_back({st, ed});  
segs = res;  
</code></pre>
<p>}</p>
<h2 id="数组模拟链表"><a href="#数组模拟链表" class="headerlink" title="数组模拟链表"></a>数组模拟链表</h2><h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><p>int head,e[N],ne[N],idx;<br>void init(){<br>    head=-1;<br>    idx=0;<br>}<br>//头插<br>//head 也是指针,e[idx] 新节点<br>void add_head(int x){<br>    e[idx]=x;//插入数据<br>    ne[idx]=head;//idx 当前的位置的指针指向head指向的位置 -1<br>    head=idx;//head 指针指向idx<br>    idx++;<br>}<br>//插入任意位置<br>void insert_linkedlist(int k,int x){<br>    e[idx]=x;//建立新节点<br>    ne[idx]=ne[k];//新节点指向k的下一个节点<br>    ne[k]=ne[idx]; //k指向idx这个结点<br>    idx++;<br>}<br>void delete_linkedlist(int k){<br>    ne[k]=ne[ne[k]];<br>}<br>int main(){<br>    int k,x,m;<br>    char op;<br>    cin&gt;&gt;m;<br>    init();<br>    while(m–){<br>        cin&gt;&gt;op;<br>        if(op==’h’){<br>            cin&gt;&gt;x;<br>            add_head(x);<br>        }<br>        else if(op==’d’){<br>            cin&gt;&gt;k;<br>            delete_linkedlist(k-1);<br>        }<br>        else {<br>            cin&gt;&gt;k&gt;&gt;x;<br>            insert_linkedlist(k-1,x);<br>        }<br>    }<br>    for(int i=head;i!=-1;i=ne[i]){cout&lt;&lt;e[i]&lt;&lt;’ ‘;}<br>    return 0;<br>}</p>
<h2 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h2><p>// e[]表示节点的值，l[]表示节点的左指针，r[]表示节点的右指针，idx表示当前用到了哪个节点<br>int e[N], l[N], r[N], idx;  </p>
<p>// 初始化<br>void init()<br>{<br>    //0是左端点，1是右端点<br>    r[0] = 1, l[1] = 0;<br>    idx = 2;<br>}  </p>
<p>// 在节点a的右边插入一个数x<br>void insert(int a, int x)<br>{<br>    e[idx] = x;<br>    l[idx] = a, r[idx] = r[a];<br>    l[r[a]] = idx, r[a] = idx ++ ;<br>}  </p>
<p>// 删除节点a<br>void remove(int a)<br>{<br>    l[r[a]] = l[a];<br>    r[l[a]] = r[a];<br>}  </p>
<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>// tt表示栈顶<br>int stk[N], tt = 0;  </p>
<p>// 向栈顶插入一个数<br>stk[ ++ tt] = x;  </p>
<p>// 从栈顶弹出一个数<br>tt – ;  </p>
<p>// 栈顶的值<br>stk[tt];  </p>
<p>// 判断栈是否为空，如果 tt &gt; 0，则表示不为空<br>if (tt &gt; 0)<br>{  </p>
<p>}</p>
<h2 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h2><p>注意这个题目要的是结果的下标不是具体的数据</p>
<p>用栈暴力模拟一遍，然后再考虑哪些元素没有用处，就可以排除</p>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P5788">P5788 【模板】单调栈 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>
<p>#include<iostream><br>#include <cstdio><br>#define ll long long<br>using namespace std;<br>const ll N=3*1000000+1;<br>ll stk[N],a[N],ans[N];<br>int tt=0;<br>int main(){<br>    int n;<br>    cin&gt;&gt;n;<br>    for(int i=1;i&lt;=n;i++){<br>        scanf(“%lld”,&amp;a[i]);<br>    }<br>    for(int i=n;i&gt;0;i–){<br>        while(tt!=0&amp;&amp;a[i]&gt;=a[stk[tt]]) tt–;<br>        ans[i]= tt==0?0:stk[tt];<br>        stk[++tt]=i;<br>    }<br>    for(int i=1;i&lt;=n;i++)printf(“%lld “,ans[i]);<br>    return 0;<br>}</cstdio></iostream></p>
<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>// hh 表示队头，tt表示队尾<br>int q[N], hh = 0, tt = -1;  </p>
<p>// 向队尾插入一个数<br>q[ ++ tt] = x;  </p>
<p>// 从队头弹出一个数<br>hh ++ ;  </p>
<p>// 队头的值<br>q[hh];  </p>
<p>// 判断队列是否为空，如果 hh &lt;= tt，则表示不为空<br>if (hh &lt;= tt)<br>{  </p>
<p>}</p>
<h1 id="单调队列-（好东西）"><a href="#单调队列-（好东西）" class="headerlink" title="单调队列 （好东西）"></a>单调队列 （好东西）</h1><p><strong>几个点：</strong></p>
<ul>
<li><p>初始化时，hh=0,tt=-1 使得队列为空</p>
</li>
<li><p>比较的是队尾元素与当前元素</p>
</li>
<li><p>注意队列长度为0时不要输出</p>
</li>
</ul>
<p>常见模型：找出滑动窗口中的最大值/最小值<br>int hh = 0, tt = -1;<br>for (int i = 0; i &lt; n; i ++ )<br>{<br>    while (hh &lt;= tt &amp;&amp; check_out(q[hh])) hh ++ ;  // 判断队头是否滑出窗口<br>    while (hh &lt;= tt &amp;&amp; check(q[tt], i)) tt – ;<br>    q[ ++ tt] = i;<br>}</p>
<p>例题</p>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1886">P1886 滑动窗口 /【模板】单调队列 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>
<p>#include<iostream><br>#include <cstdio><br>#define ll long long<br>using namespace std;<br>const int N=1000000+2;<br>int n,k,a[N],q[N],ans,hh,tt;  </cstdio></iostream></p>
<p>int main(){<br>    cin&gt;&gt;n&gt;&gt;k;<br>    for(int i=0;i&lt;n;i++){<br>        scanf(“%d”,&amp;a[i]);<br>    }<br>    //队列存的是下标<br>    //最小值<br>    hh=0;tt=-1;//目的是让队列初始化为空<br>    for(int i=0;i&lt;n;i++){<br>        //判断队列是否为空<br>        if(hh&lt;=tt&amp;&amp;i-k+1&gt;q[hh]) hh++;<br>        //目的是把最小的元素放在队头<br>        while(hh&lt;=tt&amp;&amp;a[q[tt]]&gt;=a[i]) tt–;//从队尾删除，因为经过我们的处理，已经是严格单调递增的了，所以如果第一个都大于这个元素的话，那么后面几个都大于，所以要删除<br>        q[++tt]=i;<br>        if(i&gt;=k-1)<br>        printf(“%d “,a[q[hh]]);<br>    }<br>    cout&lt;&lt;endl;<br>    //最大值<br>      hh=0;tt=-1;<br>    for(int i=0;i&lt;n;i++){<br>        //判断队列是否为空<br>        if(hh&lt;=tt&amp;&amp;i-k+1&gt;q[hh]) hh++;<br>        //目的是把最大的元素放在队头<br>        while(hh&lt;=tt&amp;&amp;a[q[tt]]&lt;=a[i]) tt–;<br>        q[++tt]=i;<br>        if(i&gt;=k-1)<br>        printf(“%d “,a[q[hh]]);<br>    }  </p>
<pre><code>return 0;  
</code></pre>
<p>}</p>
<h2 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h2><p><img src="file://D:/typora%E7%94%A8%E5%9B%BE/Screenshots/image-20230511171657614.png?lastModify=1694256669" alt="image-20230511171657614"></p>
<p>s从1开始，p从0开始</p>
<p>// s[]是长文本，p[]是模式串，n是s的长度，m是p的长度<br>求模式串的Next数组：ne[1]=0<br>for (int i = 2, j = 0; i &lt;= m; i ++ )<br>{<br>    while (j &amp;&amp; p[i] != p[j + 1]) j = ne[j];<br>    if (p[i] == p[j + 1]) j ++ ;<br>    ne[i] = j;<br>}  </p>
<p>// 匹配<br>for (int i = 1, j = 0; i &lt;= n; i ++ )<br>{<br>    while (j &amp;&amp; s[i] != p[j + 1]) j = ne[j];<br>    if (s[i] == p[j + 1]) j ++ ;<br>    if (j == m)<br>    {<br>        j = ne[j];<br>        // 匹配成功后的逻辑<br>    }<br>}</p>
<p><strong>例题</strong></p>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3375">P3375 【模板】KMP字符串匹配 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>
<p>#include <iostream><br>#include <cstring><br>#define N 1000010<br>using namespace std;<br>char s[N],p[N];<br>int ls,lp,ne[N];<br>int main(){<br>    cin&gt;&gt;s+1&gt;&gt;p+1;<br>    ls=strlen(s+1);<br>    lp=strlen(p+1);<br>    for(int i=2,j=0;i&lt;=lp;i++){<br>        while(j&amp;&amp;p[i]!=p[j+1]) j=ne[j];<br>        if(p[j+1]==p[i]) j++;<br>        ne[i]=j;<br>    }<br>     for(int i=1,j=0;i&lt;=ls;i++){<br>        while(j&amp;&amp;s[i]!=p[j+1]) j=ne[j];<br>        if(s[i]==p[j+1]) j++;<br>        if(j==lp){<br>            cout&lt;&lt;i-lp+1&lt;&lt;endl;<br>            j=ne[j];<br>        }<br>    }<br>    for(int i=1;i&lt;=lp;i++){<br>        cout&lt;&lt;ne[i]&lt;&lt;” “;<br>    }<br>    return 0;<br>}</cstring></iostream></p>
<h2 id="Trie树-高效存储和查找字符串"><a href="#Trie树-高效存储和查找字符串" class="headerlink" title="Trie树 高效存储和查找字符串"></a>Trie树 高效存储和查找字符串</h2><p>集合的数据结构</p>
<p>将字符串分解为一个一个单独的字符然后存储，然后查询这个字符串是否出现过，</p>
<p>出现过几次</p>
<h4 id="更全面-的映射"><a href="#更全面-的映射" class="headerlink" title="更全面 的映射"></a>更全面 的映射</h4><p>int getnum(char x){<br>    if(x&gt;=’A’&amp;&amp;x&lt;=’Z’)<br>        return x-‘A’;<br>    else if(x&gt;=’a’&amp;&amp;x&lt;=’z’)<br>        return x-‘a’+26;<br>    else<br>        return x-‘0’+52;<br>} </p>
<p>#include<iostream><br>#include <algorithm><br>#include <cstdio><br>using namespace std;<br>const int N=100010;<br>int son[N][26],cnt[N],idx;//子子节点的个数，只包含26个 小写字母 cnt是以这个字母为结尾的单词出现了福哦少个<br>//idx 当前用到哪了<br>//插入操作<br>char str[N];<br>void insert(char str[]){<br> &nbsp; &nbsp;int p=0;//当前的结点<br> &nbsp; &nbsp;for(int i=0;str[i];i++){<br> &nbsp; &nbsp; &nbsp; &nbsp;int u=str[i]-‘a’;//将26个小写字母映射为数字<br> &nbsp; &nbsp; &nbsp; &nbsp;if(!son[p][u]) son[p][u]=++idx;<br> &nbsp; &nbsp; &nbsp; &nbsp;p=son[p][u];<br> &nbsp;  }<br> &nbsp; &nbsp;cnt[p]++;<br>}<br>int query(char str[]){<br> &nbsp; &nbsp;int p=0;<br> &nbsp; &nbsp;for(int i=0;str[i];i++){<br> &nbsp; &nbsp; &nbsp; &nbsp;int u=str[i]-‘a’;<br> &nbsp; &nbsp; &nbsp; &nbsp;if(!son[p][u]) return 0;<br> &nbsp; &nbsp; &nbsp; &nbsp;p=son[p][u];<br> &nbsp;  }<br> &nbsp; &nbsp;return cnt[p];<br>}<br>int main(){<br> &nbsp; &nbsp;int n;<br> &nbsp; &nbsp;cin&gt;&gt;n;<br> &nbsp; &nbsp;while(n–){<br> &nbsp; &nbsp; &nbsp; char op[2];<br> &nbsp; &nbsp; &nbsp; cin&gt;&gt;op&gt;&gt;str;<br> &nbsp; &nbsp; &nbsp; if(op[0]==’i’) insert(str);<br> &nbsp; &nbsp; &nbsp; else cout&lt;&lt;query(str)&lt;&lt;endl;<br> &nbsp;  }<br> &nbsp; &nbsp;return 0;<br>}</cstdio></algorithm></iostream></p>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P8306">P8306 【模板】字典树 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>
<p>#include<iostream><br>#include <algorithm><br>#include <cstdio><br>#include <cstring><br>using namespace std;<br>const int N=3000005;<br>int son[N][65],cnt[N],idx;//子子节点的个数，只包含26个 小写字母 cnt是以这个字母位借位的单词出现了福哦少个<br>//idx 当前用到哪了<br>//插入操作<br> int n,m,t;<br>char str[N];<br>int hashs(char x){<br>    if(x&gt;=’A’&amp;&amp;x&lt;=’Z’)<br>        return x-‘A’;<br>    else if(x&gt;=’a’&amp;&amp;x&lt;=’z’)<br>        return x-‘a’+26;<br>    else<br>        return x-‘0’+52;<br>}<br>void insert(char str[]){<br>    int p=0;//当前的结点<br>    int l=strlen(str);<br>    for(int i=0;i&lt;l;i++){<br>        int u=hashs(str[i]);//将26个小写字母映射为数字<br>        if(!son[p][u]) son[p][u]=++idx;<br>        p=son[p][u];<br>        cnt[p]++;<br>    }  </cstring></cstdio></algorithm></iostream></p>
<p>}<br>int query(char str[]){<br>    int p=0;//当前的结点<br>    int l=strlen(str);<br>    for(int i=0;i&lt;l;i++){<br>        int u =hashs(str[i]);<br>        if(!son[p][u]) return 0;<br>        p=son[p][u];<br>    }<br>    return cnt[p];<br>}<br>int main(){  </p>
<pre><code>cin&gt;&gt;t;  
while(t--){  
      for(int i=0;i&lt;=idx;i++){  
        for(int j=0;j&lt;=122;j++){  
            son[i][j]=0;  
        }  
      }  
      for(int i=0;i&lt;=idx;i++)  
        cnt[i]=0;  
    idx=0;  
   scanf("%d%d",&amp;n,&amp;m);  
    while(n--){  
        scanf("%s",str);  
        insert(str);  
    }  
    while(m--){  
         scanf("%s",str);  
        printf("%d\n",query(str));  
    }  
}  
return 0;  
</code></pre>
<p>}</p>
<h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><p>用法：</p>
<h3 id="某些点或者数据是否处于一个连通块中"><a href="#某些点或者数据是否处于一个连通块中" class="headerlink" title="某些点或者数据是否处于一个连通块中"></a>某些点或者数据是否处于一个连通块中</h3><ol>
<li><p>将两个集合合并</p>
</li>
<li><p>询问两个元素是否在一个集合中</p>
</li>
</ol>
<p>基本原理：每个集合用一个树来表示，树根的编号就是整个集合的编号，</p>
<p>每一个结点表示他的父节点p[x] 表示x的父节点</p>
<ul>
<li><p>判断树根: if（p[x]==x）</p>
</li>
<li><p>如何集合的编号： while(p[x]!=x) x=p[x];</p>
</li>
<li><p>如何合并两个集合直接让其中一个的根节点的父节点为另一个集合的根节点就行</p>
</li>
<li><p>如何优化，查询一次后，将将所经过的路径的父节点全都修改为根节点</p>
</li>
</ul>
<p>#include<iostream><br>#include <algorithm><br>#include <cstdio><br>#include <cstring><br>using namespace std;<br>const int N=10010;<br>int p[N];<br>//初始每个点都是一个单独的集合<br>void init(int n){<br>    for(int i=1;i&lt;=n;i++){<br>        p[i]=i;<br>    }<br>}<br>int find(int x){<br>    if(p[x]!=x) p[x]=find(p[x]);<br>    return p[x];<br>}  </cstring></cstdio></algorithm></iostream></p>
<p>int main(){<br>    int n,m;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    init(n);<br>    char op[2];<br>    while(m–){<br>        int a,b;<br>        cin&gt;&gt;op&gt;&gt;a&gt;&gt;b;<br>        //合并两个集合,路径压缩<br>        if(op[0]==’i’) p[find(a)]=find(b);//让a的父节点等于b的父节点，即可合并<br>        else {<br>            //查询<br>            if(find(a)==find(b)) cout&lt;&lt;”yes”&lt;&lt;endl;<br>            else cout&lt;&lt;”no”&lt;&lt;endl;<br>        }<br>    }<br>    return 0;<br>}</p>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3367">P3367 【模板】并查集 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>
<p>维护点的数量：</p>
<p>#include<iostream><br>#include <algorithm><br>#include <cstdio><br>#include <cstring><br>using namespace std;<br>const int N=10010;<br>int p[N],sizes[N];//每个集合中点的数量<br>//初始每个点都是一个单独的集合<br>void init(int n){<br>    for(int i=1;i&lt;=n;i++){<br>        p[i]=i;<br>        sizes[i]=1;<br>    }<br>}<br>int find(int x){<br>    if(p[x]!=x) p[x]=find(p[x]);<br>    return p[x];<br>}  </cstring></cstdio></algorithm></iostream></p>
<p>int main(){<br>    int n,m;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    init(n);<br>    int op;<br>    while(m–){<br>        int a,b;<br>        cin&gt;&gt;op;<br>        //合并两个集合,路径压缩<br>        if(op==1){<br>            cin&gt;&gt;a&gt;&gt;b;<br>            if(find(a)==find(b)) continue;<br>            sizes[find(b)]+=sizes[find(a)];<br>            p[find(a)]=find(b);//让a的父节点等于b的父节点，即可合并  </p>
<pre><code>    }  
    else if(op==2){  
        //查询  
        cin&gt;&gt;a&gt;&gt;b;  
        if(find(a)==find(b)) cout&lt;&lt;"Y"&lt;&lt;endl;  
        else cout&lt;&lt;"N"&lt;&lt;endl;  
    }  
    else {  
        //询问某个集合中点的数量  
        cin&gt;&gt;n;  
        cout&lt;&lt;sizes[find(a)]&lt;&lt;endl;  
    }  
}  
return 0;  
</code></pre>
<p>}</p>
<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>操作：down 和up 把元素向下或向上走，使用的是一维数组，x的左儿子2x,右儿子2x+1</p>
<p>size 表示数组的最后一个位置</p>
<ol>
<li><p>插入一个元素： heap[++size]=x up(size)</p>
</li>
<li><p>求最小值 heap[1]</p>
</li>
<li><p>删除最小值 数组尾部好删除，所以用最后一个元素覆盖数组的头，然后执行down，</p>
<p> 再删除尾部，head[k]=heap[size];size–; down(k)||up(k)</p>
</li>
<li><p>修改 heap[k]=k; down(k)||up(k);</p>
</li>
</ol>
<p>// h[N]存储堆中的值, h[1]是堆顶，x的左儿子是2x, 右儿子是2x + 1<br>// ph[k]存储第k个插入的点在堆中的位置<br>// hp[k]存储堆中下标是k的点是第几个插入的<br>int h[N], ph[N], hp[N], size;  </p>
<p>// 交换两个点，及其映射关系<br>void heap_swap(int a, int b)<br>{<br>    swap(ph[hp[a]],ph[hp[b]]);<br>    swap(hp[a], hp[b]);<br>    swap(h[a], h[b]);<br>}  </p>
<p>void down(int u)<br>{<br>    int t = u;<br>    //查找到三个结点中的最小值<br>    if (u * 2 &lt;= size &amp;&amp; h[u * 2] &lt; h[t]) t = u * 2;<br>    if (u * 2 + 1 &lt;= size &amp;&amp; h[u * 2 + 1] &lt; h[t]) t = u * 2 + 1;<br>    if (u != t)<br>    {<br>        heap_swap(u, t);<br>        down(t);<br>    }<br>}  </p>
<p>void up(int u)<br>{<br>    while (u / 2 &amp;&amp; h[u] &lt; h[u / 2])//父节点存在且当前结点小于父节点<br>    {<br>        heap_swap(u, u / 2);<br>        u &gt;&gt;= 1;//下一个父节点<br>    }<br>}  </p>
<p>// O(n)建堆<br>for (int i = n / 2; i; i – ) down(i);</p>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3378">P3378 【模板】堆 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>
<p>#include &lt;bits/stdc++.h&gt;<br>using namespace std;<br>const int N=1000001;<br>int h[N],s;<br>void down(int u){<br>    int t=u;<br>    if(u*2&lt;=s&amp;&amp;h[u*2]&lt;h[t]) t=u*2;<br>    if(u*2+1&lt;=s&amp;&amp;h[u*2+1]&lt;h[t]) t=u*2+1;<br>    if(u!=t){<br>        swap(h[u],h[t]);<br>        down(t);<br>    }<br>}<br>void up(int u){<br>    while(u/2&amp;&amp;h[u]&lt;h[u/2]){<br>        swap(h[u],h[u/2]);<br>        u&gt;&gt;=1;<br>    }<br>}<br>int main(){<br>    int n,op;<br>    cin&gt;&gt;n;<br>    for(int i=n/2;i;i–){<br>        down(i);<br>    }<br>    while(n–){<br>        scanf(“%d”,&amp;op);<br>        if(op==1) {<br>            int x;<br>            scanf(“%d”,&amp;x);<br>            h[++s]=x;<br>            up(s);<br>        }<br>        else if(op==2){<br>            printf(“%d\n”,h[1]);<br>        }<br>        else {<br>            //最后一个换到第一个<br>            swap(h[1],h[s]);<br>            s–;//删除最后一个<br>            down(1);<br>        }<br>    }  </p>
<p>}</p>
<h2 id="HahTable"><a href="#HahTable" class="headerlink" title="HahTable"></a>HahTable</h2><p>删除的话打个标记</p>
<p>(1) 拉链法<br>    int h[N], e[N], ne[N], idx;  </p>
<pre><code>// 向哈希表中插入一个数  
void insert(int x)  
{  
    int k = (x % N + N) % N;  
    e[idx] = x;  
    ne[idx] = h[k];  
    h[k] = idx ++ ;  
}  

// 在哈希表中查询某个数是否存在  
bool find(int x)  
{  
    int k = (x % N + N) % N;  
    for (int i = h[k]; i != -1; i = ne[i])  
        if (e[i] == x)  
            return true;  

    return false;  
}  
</code></pre>
<p>开放寻址法，遇到冲突的话直接往后找没用的节点</p>
<p>数组要开比原来数据范围大2~3倍</p>
<p>//只要开一个h数组就可以了，不需要e和ne了，找一个不在数据范围内的数据来表示当前位置为空<br>(2) 开放寻址法<br>    int h[N];<br>    const int null =xxx;<br>    // 如果x在哈希表中，返回x的下标；如果x不在哈希表中，返回x应该插入的位置<br>    int find(int x)<br>    {<br>        int t = (x % N + N) % N;<br>        while (h[t] != null &amp;&amp; h[t] != x)<br>        {<br>            t ++ ;<br>            if (t == N) t = 0;<br>        }<br>        return t;<br>    }</p>
<h3 id="字符串哈希"><a href="#字符串哈希" class="headerlink" title="字符串哈希"></a>字符串哈希</h3><p>快速判断两个字符串是否相等</p>
<p>核心思想：将字符串看成P进制数，P的经验值是131或13331，取这两个值的冲突概率低<br>小技巧：取模的数用2^64，这样直接用unsigned long long存储，溢出的结果就是取模的结果  </p>
<p>typedef unsigned long long ULL;<br>ULL h[N], p[N]; // h[k]存储字符串前k个字母的哈希值, p[k]存储 P^k mod 2^64  </p>
<p>// 初始化<br>p[0] = 1;<br>for (int i = 1; i &lt;= n; i ++ )<br>{<br>    h[i] = h[i - 1] * P + str[i];<br>    p[i] = p[i - 1] * P;//P存储的是每一位的基数值<br>}  </p>
<p>// 计算子串 str[l ~ r] 的哈希值<br>ULL get(int l, int r)<br>{<br>    return h[r] - h[l - 1] * p[r - l + 1];<br>}</p>
<h2 id="STL常用"><a href="#STL常用" class="headerlink" title="STL常用"></a>STL常用</h2><p>vector, 变长数组，倍增的思想 &nbsp;优化思路：减少申请空间的次数<br> &nbsp; &nbsp;size() &nbsp;返回元素个数<br> &nbsp; &nbsp;empty() &nbsp;返回是否为空<br> &nbsp; &nbsp;clear() &nbsp;清空<br> &nbsp; &nbsp;front()/back()<br> &nbsp; &nbsp;push_back()/pop_back()<br> &nbsp; &nbsp;begin()/end()<br> &nbsp;  []<br> &nbsp; &nbsp;支持比较运算，按字典序<br> &nbsp; &nbsp;vector<int> a(1,2),b(3,4);<br>printf(a&lt;b) == 0<br>​<br>pair&lt;int, int&gt;<br> &nbsp; &nbsp;first, 第一个元素<br> &nbsp; &nbsp;second, 第二个元素<br> &nbsp; &nbsp;支持比较运算，以first为第一关键字，以second为第二关键字（字典序）<br>​<br>string，字符串<br> &nbsp; &nbsp;size()/length() &nbsp;返回字符串长度<br> &nbsp; &nbsp;empty()<br> &nbsp; &nbsp;clear()<br> &nbsp; &nbsp;substr(起始下标，(子串长度)) &nbsp;返回子串<br> &nbsp; &nbsp;c_str() &nbsp;返回字符串所在字符数组的起始地址<br>​<br>queue, 队列<br> &nbsp; &nbsp;size()<br> &nbsp; &nbsp;empty()<br> &nbsp; &nbsp;push() &nbsp;向队尾插入一个元素<br> &nbsp; &nbsp;front() &nbsp;返回队头元素<br> &nbsp; &nbsp;back() &nbsp;返回队尾元素<br> &nbsp; &nbsp;pop() &nbsp;弹出队头元素<br>​<br>priority_queue, 优先队列，默认是大根堆<br> &nbsp; &nbsp;size()<br> &nbsp; &nbsp;empty()<br> &nbsp; &nbsp;push() &nbsp;插入一个元素<br> &nbsp; &nbsp;top() &nbsp;返回堆顶元素<br> &nbsp; &nbsp;pop() &nbsp;弹出堆顶元素<br> &nbsp; &nbsp;定义成小根堆的方式：priority_queue&lt;int, vector<int>, greater<int>&gt; q;<br>​<br>stack, 栈<br> &nbsp; &nbsp;size()<br> &nbsp; &nbsp;empty()<br> &nbsp; &nbsp;push() &nbsp;向栈顶插入一个元素<br> &nbsp; &nbsp;top() &nbsp;返回栈顶元素<br> &nbsp; &nbsp;pop() &nbsp;弹出栈顶元素<br>​<br>deque, 双端队列<br> &nbsp; &nbsp;size()<br> &nbsp; &nbsp;empty()<br> &nbsp; &nbsp;clear()<br> &nbsp; &nbsp;front()/back()<br> &nbsp; &nbsp;push_back()/pop_back()<br> &nbsp; &nbsp;push_front()/pop_front()<br> &nbsp; &nbsp;begin()/end()<br> &nbsp;  []<br>​<br>set, map, multiset, multimap, 基于平衡二叉树（红黑树），动态维护有序序列<br> &nbsp; &nbsp;size()<br> &nbsp; &nbsp;empty()<br> &nbsp; &nbsp;clear()<br> &nbsp; &nbsp;begin()/end()<br> &nbsp; &nbsp;++, – 返回前驱和后继，时间复杂度 O(logn)<br>​<br> &nbsp; &nbsp;set/multiset<br> &nbsp; &nbsp; &nbsp; &nbsp;insert() &nbsp;插入一个数<br> &nbsp; &nbsp; &nbsp; &nbsp;find() &nbsp;查找一个数<br> &nbsp; &nbsp; &nbsp; &nbsp;count() &nbsp;返回某一个数的个数<br> &nbsp; &nbsp; &nbsp; &nbsp;erase()<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  (1) 输入是一个数x，删除所有x &nbsp; O(k + logn)<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  (2) 输入一个迭代器，删除这个迭代器<br> &nbsp; &nbsp; &nbsp; &nbsp;lower_bound()/upper_bound()<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;lower_bound(x) &nbsp;返回大于等于x的最小的数的迭代器<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;upper_bound(x) &nbsp;返回大于x的最小的数的迭代器<br> &nbsp; &nbsp;map/multimap<br> &nbsp; &nbsp; &nbsp; &nbsp;insert() &nbsp;插入的数是一个pair<br> &nbsp; &nbsp; &nbsp; &nbsp;erase() &nbsp;输入的参数是pair或者迭代器<br> &nbsp; &nbsp; &nbsp; &nbsp;find()<br> &nbsp; &nbsp; &nbsp;  [] &nbsp;注意multimap不支持此操作。 时间复杂度是 O(logn)<br> &nbsp; &nbsp; &nbsp; &nbsp;lower_bound()/upper_bound()<br>​<br>unordered_set, unordered_map, unordered_multiset, unordered_multimap, 哈希表<br> &nbsp; &nbsp;和上面类似，增删改查的时间复杂度是 O(1)<br> &nbsp; &nbsp;不支持 lower_bound()/upper_bound()， 迭代器的++，–<br>​<br>bitset, 圧位 省空间 &nbsp; &nbsp;<br> &nbsp; &nbsp;bitset&lt;10000&gt; s; &nbsp;//&lt; &gt;里面是个数, 可以用来替代bool 数组<br>    //以下操作都支持<br>    <del>, &amp;, |, ^<br> &nbsp; &nbsp;&gt;&gt;, &lt;&lt;<br> &nbsp; &nbsp;==, !=<br> &nbsp;  []<br>​<br> &nbsp; &nbsp;count() &nbsp;返回有多少个1<br>​<br> &nbsp; &nbsp;any() &nbsp;判断是否至少有一个1<br> &nbsp; &nbsp;none() &nbsp;判断是否全为0<br>​<br> &nbsp; &nbsp;set() &nbsp;把所有位置成1<br> &nbsp; &nbsp;set(k, v) &nbsp;将第k位变成v<br> &nbsp; &nbsp;reset() &nbsp;把所有位变成0<br> &nbsp; &nbsp;flip() &nbsp;等价于</del><br> &nbsp; &nbsp;flip(k) 把第k位取反<br>​</int></int></int></p>
<h2 id="图论背思路"><a href="#图论背思路" class="headerlink" title="图论背思路"></a>图论背思路</h2><h2 id="BFS和DFS"><a href="#BFS和DFS" class="headerlink" title="BFS和DFS"></a>BFS和DFS</h2><h3 id="DFS-回溯的时候记得回复现场"><a href="#DFS-回溯的时候记得回复现场" class="headerlink" title="DFS 回溯的时候记得回复现场"></a>DFS 回溯的时候记得回复现场</h3><h3 id="邻接矩阵：-p-a-b-a-gt-b-适合稠密图"><a href="#邻接矩阵：-p-a-b-a-gt-b-适合稠密图" class="headerlink" title="邻接矩阵： p[ a] [ b ] a -> b 适合稠密图"></a>邻接矩阵： p[ a] [ b ] a -&gt; b 适合稠密图</h3><h3 id="邻接表：-稀疏图"><a href="#邻接表：-稀疏图" class="headerlink" title="邻接表： 稀疏图"></a>邻接表： 稀疏图</h3><p>和哈希表思路一样</p>
<p>// 对于每个点k，开一个单链表，存储k所有可以走到的点。h[k]存储这个单链表的头结点<br>int h[N], e[N], ne[N], idx; //e是终点end  </p>
<p>// 添加一条边a-&gt;b<br>void add(int a, int b)<br>{<br>    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;<br>}<br>// 初始化<br>idx = 0;<br>memset(h, -1, sizeof h);<br>//遍历图<br>for(int i = h[t] ; i != -1 ; i = ne[i] )</p>
<h2 id="另一种使用结构体的邻接表存法"><a href="#另一种使用结构体的邻接表存法" class="headerlink" title="另一种使用结构体的邻接表存法"></a>另一种使用结构体的邻接表存法</h2><p>int idx=0,n;<br>int h[N] , dis[N] , vis[N];<br>struct Edge{<br>    int ne,to,dis;<br>}ed[N];<br>//添加， 从 1 开始<br>void add(int a,int b ,int c){<br>    ed[++idx].ne = h[a];<br>    ed[idx].to = b;<br>    ed[idx].dis = c;<br>    h[a] = idx;<br>}<br>//遍历图<br>for(int i = h[t] ; i ; i = ed[i].ne)</p>
<h3 id="BFS-可用于解决权值相等的最短路径问题"><a href="#BFS-可用于解决权值相等的最短路径问题" class="headerlink" title="BFS 可用于解决权值相等的最短路径问题"></a>BFS 可用于解决权值相等的最短路径问题</h3><h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><p>必须是又向无环</p>
<p>排完后，所有的起点都在终点之前</p>
<ol>
<li><p>统计每一个节点的入度和出度</p>
</li>
<li><p>每一次将入读相同的点放入queue</p>
</li>
<li><p>枚举队头的出边，删掉 出边,这条边的终点的入度-1</p>
</li>
<li><p>如果某个点的入度为0 放入队列</p>
</li>
</ol>
<p>bool topsort()<br>{<br>    int hh = 0, tt = -1;  </p>
<pre><code>// d[i] 存储点i的入度  
for (int i = 1; i &lt;= n; i ++ )  
    if (!d[i])  
        q[ ++ tt] = i;//把每个入度为0的点加入队列  

while (hh &lt;= tt)  
{  
    int t = q[hh ++ ];//取出队头  
    //从队头开始找路径  
    for (int i = h[t]; i != -1; i = ne[i])  
    {  
        int j = e[i];  
        if (-- d[j] == 0)  
            q[ ++ tt] = j;  
    }  
}  

// 如果所有点都入队了，说明存在拓扑序列；否则不存在拓扑序列。  
return tt == n - 1;  
</code></pre>
<p>}</p>
<h2 id="最短路问题："><a href="#最短路问题：" class="headerlink" title="最短路问题："></a>最短路问题：</h2><h3 id="单源最短路-一个点到其他所有点的最短路"><a href="#单源最短路-一个点到其他所有点的最短路" class="headerlink" title="单源最短路 一个点到其他所有点的最短路"></a>单源最短路 一个点到其他所有点的最短路</h3><ul>
<li><p>所有边的权都是正数</p>
<ol>
<li><p>朴素Dijkstra O(n^2) n为点的数量 稠密图 边很多 外部迭代n-1 次</p>
<p> int g[N][N];  // 存储每条边  权值<br> int dist[N];  // 存储1号点到每个点的最短距离<br> bool st[N];   // 存储每个点的最短路是否已经确定  </p>
<p> // 求1号点到n号点的最短路，如果不存在则返回-1<br> int dijkstra()<br> {<br> memset(dist, 0x3f, sizeof dist);<br> dist[1] = 0;<br><br> for (int i = 0; i &lt; n - 1; i ++ )//迭代n-1 次，因为上来选中了一个点<br> {<br>     int t = -1;     // 在还未确定最短路的点中，寻找距离最小的点<br>     for (int j = 1; j &lt;= n; j ++ )<br>         if (!st[j] &amp;&amp; (t == -1 || dist[t] &gt; dist[j]))<br>             t = j;<br><br>     // 用t更新其他点的距离<br>     for (int j = 1; j &lt;= n; j ++ )<br>         dist[j] = min(dist[j], dist[t] + g[t][j]);<br><br>     st[t] = true;<br> }<br><br> if (dist[n] == 0x3f3f3f3f) return -1;<br> return dist[n];<br> }</p>
</li>
<li><p>堆优化版的 O(mlogn) 稀疏图</p>
<p> typedef pair&lt;int, int&gt; PII;  </p>
<p> int n;      // 点的数量<br> int h[N], w[N], e[N], ne[N], idx;       // 邻接表存储所有边<br> int dist[N];        // 存储所有点到1号点的距离<br> bool st[N];     // 存储每个点的最短距离是否已确定  </p>
<p> // 求1号点到n号点的最短距离，如果不存在，则返回-1<br> int dijkstra()<br> {<br> memset(dist, 0x3f, sizeof dist);<br> dist[1] = 0;<br> priority_queue&lt;PII, vector<pii>, greater<pii>&gt; heap;<br> heap.push({0, 1});      // first存储距离，second存储节点编号<br><br> while (heap.size())<br> {<br>     auto t = heap.top();<br>     heap.pop();<br><br>     int ver = t.second, distance = t.first;<br><br>     if (st[ver]) continue;<br>     st[ver] = true;<br><br>     for (int i = h[ver]; i != -1; i = ne[i])<br>     {<br>         int j = e[i];<br>         if (dist[j] &gt; distance + w[i])<br>         {<br>             dist[j] = distance + w[i];<br>             heap.push({dist[j], j});<br>         }<br>     }<br> }<br><br> if (dist[n] == 0x3f3f3f3f) return -1;<br> return dist[n];<br> }</pii></pii></p>
</li>
</ol>
</li>
<li><p>存在负权边</p>
<ol>
<li><p>Bellman -Ford O(nm) <strong>奇妙的存图方式</strong> 无负权回路 经过路径有次数限制的话只能用这个了</p>
<p> int n, m;       // n表示点数，m表示边数<br> int dist[N];        // dist[x]存储1到x的最短路距离  </p>
<p> struct Edge     // 边，a表示出点，b表示入点，w表示边的权重<br> {<br> int a, b, w;<br> }edges[M];  </p>
<p> // 求1到n的最短路距离，如果无法从1走到n，则返回-1。<br> int bellman_ford()<br> {<br> memset(dist, 0x3f, sizeof dist);<br> dist[1] = 0;<br> //不需要进行收录顶点<br> // 如果第n次迭代仍然会松弛三角不等式，就说明存在一条长度是n+1的最短路径，由抽屉原理，路径中至少存在两个相同的点，说明图中存在负权回路。<br> for (int i = 0; i &lt; n; i ++ )//这个n是指的是最多不经过 多少次经过同一条边<br> {<br>     for (int j = 0; j &lt; m; j ++ )<br>     {<br>         int a = edges[j].a, b = edges[j].b, w = edges[j].w;<br>         if (dist[b] &gt; dist[a] + w)<br>             dist[b] = dist[a] + w;<br>     }<br> }<br><br> if (dist[n] &gt; 0x3f3f3f3f / 2) return -1;<br> return dist[n];<br> }</p>
</li>
<li><p>SPFA 一般： O（m) 最坏O（nm） 不存在负权环才能使用 99%都没有负环比较好用</p>
<p> 优化思路：只有更新过点才对后面的点更新有影响</p>
<p> 要从 1 开始存比较好 ，e 是end 也就是一条边的终点</p>
<p> int n;      // 总点数<br> int h[N], w[N], e[N], ne[N], idx;       // 邻接表存储所有边<br> int dist[N];        // 存储每个点到1号点的最短距离<br> bool st[N];     // 存储每个点是否在队列中  </p>
<p> // 求x号点到n号点的最短路距离，如果从1号点无法走到n号点则返回-1<br> int spfa(int x)<br> {<br> memset(dist, 0x3f, sizeof dist);//初始化要根据题目来<br><br> dist[x] = 0;<br> /*或者<br> for(int i = 1 ; i &lt;= n ; i ++){<br>     dis[i] = INT_MAX;<br> }*/	<br> queue<int> q;<br> q.push(x);<br> st[x] = true;<br><br> while (q.size())//不为空，即为还有更新的点<br> {<br>     auto t = q.front();<br>     q.pop();<br><br>     st[t] = false;//这里不要忘记<br>    //遍历所以能到达的顶点，进行更新<br>     for (int i = h[t]; i != -1; i = ne[i])<br>     {<br>         int j = e[i];<br>         if (dist[j] &gt; dist[t] + w[i])<br>         {<br>             dist[j] = dist[t] + w[i];<br>             if (!st[j])     // 如果队列中已存在j，则不需要将j重复插入<br>             {<br>                 q.push(j);//这里是j<br>                 st[j] = true;//这里是j<br>             }<br>         }<br>     }<br> }<br><br> if (dist[n] == 0x3f3f3f3f) return -1;<br> return dist[n];<br> }<br> //初始化和存图<br> void add(int a, int b , int c){<br> w[idx] = c;<br> ne[idx] = h[a];<br> en[idx] =  b;<br> h[a] = idx++;<br> }<br> void init(){<br> idx = 1;<br> memset(h , -1 ,sizeof h);<br> }</int></p>
<h4 id="模板题："><a href="#模板题：" class="headerlink" title="模板题："></a>模板题：</h4><p> <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3371">P3371 【模板】单源最短路径（弱化版） - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>
<h2 id="判断有无负环-用cnt-来记录当前最短路的边数"><a href="#判断有无负环-用cnt-来记录当前最短路的边数" class="headerlink" title="判断有无负环 用cnt 来记录当前最短路的边数"></a><em><strong>判断有无负环 用cnt 来记录当前最短路的边数</strong></em></h2><p> int n;      // 总点数<br> int h[N], w[N], e[N], ne[N], idx;       // 邻接表存储所有边<br> int dist[N], cnt[N];        // dist[x]存储1号点到x的最短距离，cnt[x]存储1到x的最短路中经过的点数<br> bool st[N];     // 存储每个点是否在队列中  </p>
<p> // 如果存在负环，则返回true，否则返回false。<br> bool spfa()<br> {<br> // 不需要初始化dist数组<br> // 原理：如果某条最短路径上有n个点（除了自己），那么加上自己之后一共有n+1个点，由抽屉原理一定有两个点相同，所以存在环。<br><br> queue<int> q;<br> for (int i = 1; i &lt;= n; i ++ )<br> {<br>     q.push(i);<br>     st[i] = true;<br> }<br><br> while (q.size())<br> {<br>     auto t = q.front();<br>     q.pop();<br><br>     st[t] = false;<br><br>     for (int i = h[t]; i != -1; i = ne[i])<br>     {<br>         int j = e[i];<br>         if (dist[j] &gt; dist[t] + w[i])<br>         {<br>             dist[j] = dist[t] + w[i];<br>             cnt[j] = cnt[t] + 1;<br>             if (cnt[j] &gt;= n) return true;       // 如果从1号点到x的最短路中包含至少n个点（不包括自己），则说明存在环<br>             if (!st[j])<br>             {<br>                 q.push(j);<br>                 st[j] = true;<br>             }<br>         }<br>     }<br> }<br><br> return false;<br> }</int></p>
</li>
</ol>
</li>
</ul>
<h3 id="多源汇最短路-起点终点都不确定"><a href="#多源汇最短路-起点终点都不确定" class="headerlink" title="多源汇最短路 起点终点都不确定"></a>多源汇最短路 起点终点都不确定</h3><p>Floyd O(n^3)</p>
<p>初始化：<br> &nbsp; &nbsp;for (int i = 1; i &lt;= n; i ++ )<br> &nbsp; &nbsp; &nbsp; &nbsp;for (int j = 1; j &lt;= n; j ++ )<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if (i == j) d[i][j] = 0;<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;else d[i][j] = INF;<br>​<br>// 算法结束后，d[a][b]表示a到b的最短距离<br>void floyd()<br>{<br> &nbsp; &nbsp;for (int k = 1; k &lt;= n; k ++ )<br> &nbsp; &nbsp; &nbsp; &nbsp;for (int i = 1; i &lt;= n; i ++ )<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;for (int j = 1; j &lt;= n; j ++ )<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;d[i][j] = min(d[i][j], d[i][k] + d[k][j]);// i经过k 点到达j<br>}</p>
<h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><h3 id="普利姆算法-Prim-思路和Dijsktra算法相似-外部迭代-n-次，因为没有提前选中一个点"><a href="#普利姆算法-Prim-思路和Dijsktra算法相似-外部迭代-n-次，因为没有提前选中一个点" class="headerlink" title="普利姆算法 Prim 思路和Dijsktra算法相似 外部迭代 n 次，因为没有提前选中一个点"></a>普利姆算法 Prim 思路和Dijsktra算法相似 外部迭代 n 次，因为没有提前选中一个点</h3><h3 id="迭代n次因为没有提前选中一个点-枚举所有点"><a href="#迭代n次因为没有提前选中一个点-枚举所有点" class="headerlink" title="迭代n次因为没有提前选中一个点 枚举所有点"></a>迭代n次因为没有提前选中一个点 枚举所有点</h3><ol>
<li><p>朴素Prim算法 稠密图 每次找到未收录的距离最近的点，收录并进行更新其他点到<strong>集合</strong>的距离</p>
</li>
<li><p>找这个点是否与集合内部相连</p>
</li>
<li><p>某个点到这个集合的距离为某个点到这个集合当中的点的距离最短的边</p>
<p> int n; &nbsp; &nbsp; &nbsp;// n表示点数<br> int g[N][N]; &nbsp; &nbsp; &nbsp; &nbsp;// 邻接矩阵，存储所有边<br> int dist[N]; &nbsp; &nbsp; &nbsp; &nbsp;// 存储其他点到当前最小生成树的距离<br> bool st[N]; &nbsp; &nbsp; // 存储每个点是否已经在生成树中<br> ​<br> ​<br> // 如果图不连通，则返回INF(值是0x3f3f3f3f), 否则返回最小生成树的树边权重之和<br> int prim()<br> {<br>  &nbsp; &nbsp;memset(dist, 0x3f, sizeof dist);<br> ​<br>  &nbsp; &nbsp;int res = 0;<br>  &nbsp; &nbsp;for (int i = 0; i &lt; n; i ++ )<br>  &nbsp;  {<br>  &nbsp; &nbsp; &nbsp; &nbsp;int t = -1;<br>  &nbsp; &nbsp; &nbsp; &nbsp;for (int j = 1; j &lt;= n; j ++ )<br>  &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if (!st[j] &amp;&amp; (t == -1 || dist[t] &gt; dist[j]))<br>  &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;t = j;<br> ​<br>  &nbsp; &nbsp; &nbsp; &nbsp;if (i &amp;&amp; dist[t] == INF) return INF;<br> ​<br>  &nbsp; &nbsp; &nbsp; &nbsp;if (i) res += dist[t];<br>  &nbsp; &nbsp; &nbsp; &nbsp;st[t] = true;<br> ​<br>  &nbsp; &nbsp; &nbsp; &nbsp;for (int j = 1; j &lt;= n; j ++ ) dist[j] = min(dist[j], g[t][j]);<br>  &nbsp; &nbsp; &nbsp; &nbsp;//不是相加<br>  &nbsp;  }<br> ​<br>  &nbsp; &nbsp;return res;<br> }</p>
</li>
<li><p>堆优化版的Prim 稀疏图 不常用</p>
</li>
</ol>
<h3 id="克鲁斯卡尔算法-Kruskal-先对边进行排序-稀疏图-可以用并查集-枚举所有边"><a href="#克鲁斯卡尔算法-Kruskal-先对边进行排序-稀疏图-可以用并查集-枚举所有边" class="headerlink" title="克鲁斯卡尔算法 Kruskal 先对边进行排序 稀疏图 可以用并查集 枚举所有边"></a>克鲁斯卡尔算法 Kruskal 先对边进行排序 稀疏图 可以用并查集 枚举所有边</h3><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3366">P3366 【模板】最小生成树 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>
<ol>
<li><p>所有边按权重从小到大排序</p>
</li>
<li><p>枚举每条边a,b权重c if a,b不连通， 将这条边加入集合中</p>
</li>
</ol>
<p>int n, m;       // n是点数，m是边数<br>int p[N];       // 并查集的父节点数组  </p>
<p>struct Edge     // 存储边<br>{<br>    int a, b, w;  </p>
<pre><code>bool operator&lt; (const Edge &amp;W)const // 重载了 &lt;   
{  
    return w &lt; W.w;  
}  
</code></pre>
<p>}edges[M];  </p>
<p>int find(int x)     // 并查集核心操作<br>{<br>    if (p[x] != x) p[x] = find(p[x]);<br>    return p[x];<br>}  </p>
<p>int kruskal()<br>{<br>    sort(edges, edges + m);  </p>
<pre><code>for (int i = 1; i &lt;= n; i ++ ) p[i] = i;    // 初始化并查集  

int res = 0, cnt = 0;  
for (int i = 0; i &lt; m; i ++ )  
{  
    int a = edges[i].a, b = edges[i].b, w = edges[i].w;  

    a = find(a), b = find(b);  
    if (a != b)     // 如果两个连通块不连通，则将这两个连通块合并  
    {  
        p[a] = b;  
        res += w;  
        cnt ++ ;  
    }  
}  

if (cnt &lt; n - 1) return INF;  
return res;  
</code></pre>
<p>}</p>
<h2 id="二分图-当且仅当图中没有奇数环"><a href="#二分图-当且仅当图中没有奇数环" class="headerlink" title="二分图 当且仅当图中没有奇数环"></a>二分图 当且仅当图中没有奇数环</h2><h3 id="染色法-O-n-m-判断是否是二分图"><a href="#染色法-O-n-m-判断是否是二分图" class="headerlink" title="染色法 O(n+m) 判断是否是二分图"></a>染色法 O(n+m) 判断是否是二分图</h3><p>int n;      // n表示点数<br>int h[N], e[M], ne[M], idx;     // 邻接表存储图<br>int color[N];       // 表示每个点的颜色，-1表示未染色，0表示白色，1表示黑色  </p>
<p>// 参数：u表示当前节点，c表示当前点的颜色<br>bool dfs(int u, int c)<br>{<br>    color[u] = c;<br>    for (int i = h[u]; i != -1; i = ne[i])<br>    {<br>        int j = e[i];<br>        if (color[j] == -1)//未染色<br>        {<br>            if (!dfs(j, !c)) return false;//比如两种颜色， 0，1表示，那么这里就可以用 3- c,也就是用另一种颜色去染色<br>        }<br>        else if (color[j] == c) return false;<br>    }  </p>
<pre><code>return true;  
</code></pre>
<p>}  </p>
<p>bool check()<br>{<br>    memset(color, -1, sizeof color);<br>    bool flag = true;<br>    //枚举所有点，去染色<br>    for (int i = 1; i &lt;= n; i ++ )<br>        if (color[i] == -1)<br>            if (!dfs(i, 0))<br>            {<br>                flag = false;<br>                break;<br>            }<br>    return flag;<br>}</p>
<h3 id="匈牙利算法-O-mn-实际运行时间一般小于这个值-稠密图不适合用邻接表，推荐使用临界矩阵"><a href="#匈牙利算法-O-mn-实际运行时间一般小于这个值-稠密图不适合用邻接表，推荐使用临界矩阵" class="headerlink" title="匈牙利算法 O(mn) 实际运行时间一般小于这个值 稠密图不适合用邻接表，推荐使用临界矩阵"></a>匈牙利算法 O(mn) 实际运行时间一般小于这个值 稠密图不适合用邻接表，推荐使用临界矩阵</h3><p>int n1, n2; &nbsp; &nbsp; // n1表示第一个集合中的点数，n2表示第二个集合中的点数<br>int h[N], e[M], ne[M], idx; &nbsp; &nbsp; // 邻接表存储所有边，匈牙利算法中只会用到从第一个集合指向第二个集合的边，所以这里只用存一个方向的边<br>int match[N]; &nbsp; &nbsp; &nbsp; // 存储第二个集合中的每个点当前匹配的第一个集合中的点是哪个<br>bool st[N]; &nbsp; &nbsp; // 表示第二个集合中的每个点是否已经被遍历过<br>​<br>bool find(int x)<br>{<br> &nbsp; &nbsp;for (int i = h[x]; i != -1; i = ne[i])<br> &nbsp;  {<br> &nbsp; &nbsp; &nbsp; &nbsp;int j = e[i];<br> &nbsp; &nbsp; &nbsp; &nbsp;if (!st[j])<br> &nbsp; &nbsp; &nbsp;  {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;st[j] = true;<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if (match[j] == 0 || find(match[j]))//第二个集合的点未匹配，或者是可以为已经 匹配的第一个集合中的点找到别的集合二中的点<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;match[j] = x;<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return true;<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  }<br> &nbsp; &nbsp; &nbsp;  }<br> &nbsp;  }<br>​<br> &nbsp; &nbsp;return false;<br>}<br>​<br>// 求最大匹配数，依次枚举第一个集合中的每个点能否匹配第二个集合中的点<br>int res = 0;<br>for (int i = 1; i &lt;= n1; i ++ )<br>{<br> &nbsp; &nbsp;memset(st, false, sizeof st);<br> &nbsp; &nbsp;if (find(i)) res ++ ;<br>}</p>
<p><strong>例题：<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3386">P3386 【模板】二分图最大匹配 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></strong></p>
<h2 id="邻接表的写法-稠密图会超时"><a href="#邻接表的写法-稠密图会超时" class="headerlink" title="邻接表的写法(稠密图会超时)"></a>邻接表的写法(稠密图会超时)</h2><p>#include &lt;bits/stdc++.h&gt;<br>using namespace std;<br>const int N  = 505;<br>int n1,n2,ed;//需要两个集合<br>int h[N] , ne[N] , e[N] , idx;<br>int match[N] ;<br>bool vis[N];<br>void init(){<br>    memset(h,-1,sizeof h);<br>    idx = 0;<br>}<br>void add(int a, int b){<br>    e[idx] = b ;<br>    ne[idx] = h[a];<br>    h[a] = idx++;<br>}<br>bool find(int x){<br>    for (int i = h[x] ; i != -1 ; i =ne[i]){<br>        int j = e[i];<br>        if(!vis[j]){<br>            vis[j] = true;<br>            if(match[j] == 0 || find(match[j])){<br>                //如果终边的点未匹配，或者是可以为以匹配的起点找到另一个终点<br>                match[j] = x;<br>                return true;<br>            }<br>        }<br>    }<br>    return false;<br>}<br>int main(){<br>    ios::sync_with_stdio(false);<br>    cin.tie(nullptr);<br>    cin &gt;&gt; n1 &gt;&gt; n2 &gt;&gt;ed;<br>    init();<br>    int u ,v;<br>    for (int i = 1 ; i &lt;= ed ; i++){<br>        cin &gt;&gt; u &gt;&gt; v;<br>        if(v &lt;= n2){<br>            add(u , v);<br>        }  </p>
<pre><code>}  
int ans = 0;  
for (int i = 1 ; i &lt;= n1 ; i++){  
    memset(vis, false ,sizeof vis);  
    if(find(i)) ans++;  
}  
cout &lt;&lt; ans &lt;&lt;endl ;  
return 0;  
</code></pre>
<p>}</p>
<h2 id="邻接矩阵的写法："><a href="#邻接矩阵的写法：" class="headerlink" title="邻接矩阵的写法："></a>邻接矩阵的写法：</h2><p>#include &lt;bits/stdc++.h&gt;<br>using namespace std;<br>const int N  = 505;<br>int n1,n2,ed;//需要两个集合<br>bool a[N][N];<br>int match[N];<br>bool vis[N];<br>bool find(int x){<br>    //枚举终边<br>    for (int i = 1 ; i &lt;= n2 ; i ++){<br>        if(!vis[i] &amp;&amp; a[x][i]){<br>            vis[i] = true;<br>            if(match[i] == 0 || find(match[i])){<br>                //如果终边的点未匹配，或者是可以为以匹配的起点找到另一个终点<br>                match[i] = x;<br>                return true;<br>            }<br>        }<br>    }<br>    return false;<br>}<br>int main(){<br>    ios::sync_with_stdio(false);<br>    cin.tie(nullptr);<br>    cin &gt;&gt; n1 &gt;&gt; n2 &gt;&gt;ed;<br>    int u ,v;<br>    for (int i = 1 ; i &lt;= ed ; i++){<br>        cin &gt;&gt; u &gt;&gt; v;<br>        if(v &lt;= n2){<br>            a[u][v] = 1;<br>        }  </p>
<pre><code>}  
int ans = 0;  
for (int i = 1 ; i &lt;= n1 ; i++){  
    ans+=find(i); // 这里不一样哦  
    memset(vis, false ,sizeof vis);  
}  
cout &lt;&lt; ans &lt;&lt;endl ;  
return 0;  
</code></pre>
<p>}</p>
<h2 id="数学知识"><a href="#数学知识" class="headerlink" title="数学知识"></a>数学知识</h2><h2 id="当看见-0-的个数时考虑将结果分成-2-，-5-的个数"><a href="#当看见-0-的个数时考虑将结果分成-2-，-5-的个数" class="headerlink" title="当看见 0 的个数时考虑将结果分成 2 ， 5 的个数"></a>当看见 0 的个数时考虑将结果分成 2 ， 5 的个数</h2><p><a target="_blank" rel="noopener" href="https://ac.nowcoder.com/acm/contest/57683/E">E-Kevin喜欢零(困难版本)_牛客小白月赛73 (nowcoder.com)</a></p>
<p>#include &lt;bits/stdc++.h&gt;<br>​<br>void solve() </p>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">QingQiu</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://qiuely.github.io/2023/09/09/hou-duan/xue-suan-fa/">https://qiuely.github.io/2023/09/09/hou-duan/xue-suan-fa/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">QingQiu</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/%E7%AE%97%E6%B3%95%EF%BC%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">
                                    <span class="chip bg-color">算法，数据结构</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2023/09/17/hou-duan/ssm-practice/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/11.jpg" class="responsive-img" alt="ssm-practice">
                        
                        <span class="card-title">ssm-practice</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2023-09-17
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            QingQiu
                            
                        </span>
                    </div>
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2023/09/01/qian-duan/javaweb-study/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/4.jpg" class="responsive-img" alt="JavaWeb_study">
                        
                        <span class="card-title">JavaWeb_study</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2023-09-01
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            QingQiu
                            
                        </span>
                    </div>
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>


  <!-- 是否加载使用自带的 prismjs. -->
  <script type="text/javascript" src="/libs/prism/prism.min.js"></script>


<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>



    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="503838841"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="/libs/aplayer/Meting.min.js"></script>

    

    <div class="container row center-align"
         style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2019-2023</span>
            
            <a href="/about" target="_blank">QingQiu</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            
                <span id="translate">|&nbsp;繁/简：</span><a id="translateLink" href="javascript:translatePage();">繁</a>
            
            <br>
            
                &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                        class="white-color">71.4k</span>
            
            
            
                
            
            
                <span id="busuanzi_container_site_pv">
                &nbsp;|&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;
                    <span id="busuanzi_value_site_pv" class="white-color"></span>
            </span>
            
            
                <span id="busuanzi_container_site_uv">
                &nbsp;|&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;
                    <span id="busuanzi_value_site_uv" class="white-color"></span>
            </span>
            
            <br>

            <!-- 运行天数提醒. -->
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/qiuEly" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=VmRlY2Jhb2BkYGUWJyd4NTk7" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="https://tool.gljlw.com/qq/?qq=2354796263" class="tooltipped" target="_blank" data-tooltip="QQ联系我:2354796263 " data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 白天和黑夜主题 -->
<div class="stars-con">
    <div id="stars"></div>
    <div id="stars2"></div>
    <div id="stars3"></div>  
</div>

<script>
    function switchNightMode() {
        $('<div class="Cuteen_DarkSky"><div class="Cuteen_DarkPlanet"></div></div>').appendTo($('body')),
        setTimeout(function () {
            $('body').hasClass('DarkMode') 
            ? ($('body').removeClass('DarkMode'), localStorage.setItem('isDark', '0'), $('#sum-moon-icon').removeClass("fa-sun").addClass('fa-moon')) 
            : ($('body').addClass('DarkMode'), localStorage.setItem('isDark', '1'), $('#sum-moon-icon').addClass("fa-sun").removeClass('fa-moon')),
            
            setTimeout(function () {
            $('.Cuteen_DarkSky').fadeOut(1e3, function () {
                $(this).remove()
            })
            }, 2e3)
        })
    }
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    

    
        <script type="text/javascript" src="/js/tw_cn.js"></script>
        <script type="text/javascript">
          var defaultEncoding = 2; //网站编写字体是否繁体，1-繁体，2-简体
          var translateDelay = 0; //延迟时间,若不在前, 要设定延迟翻译时间, 如100表示100ms,默认为0
          var cookieDomain = "https://qiuely.github.io"; //Cookie地址, 一定要设定, 通常为你的网址
          var msgToTraditionalChinese = "繁"; //此处可以更改为你想要显示的文字
          var msgToSimplifiedChinese = "简"; //同上，但两处均不建议更改
          var translateButtonId = "translateLink"; //默认互换id
          translateInitilization();
        </script>
    
    
    

    <!-- 雪花特效 -->
    

    <!-- 鼠标星星特效 -->
    

     
        <script src="https://ssl.captcha.qq.com/TCaptcha.js"></script>
        <script src="/libs/others/TencentCaptcha.js"></script>
        <button id="TencentCaptcha" data-appid="xxxxxxxxxx" data-cbfn="callback" type="button" hidden></button>
    

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    <!--腾讯兔小巢-->
    
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"react":{"opacity":0.7}});</script></body>

</html>
